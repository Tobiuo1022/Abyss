1..3
ok 1 - No VM crash on enormous number of combiners
ok 2 - native strings can be as large as regular strings
    1..8
    ok 1 - Multi-role mix with value constrained parameter
    ok 2 - Multis from diferent roles with value constrained parameter
    ok 3 - Multi-role mix with only where clauses different
    ok 4 - Multis from same role declaration order tiebreaker (TEST USES UNSUPPORTED FEATURES)
    ok 5 - Multis from different roles with only where clauses different
    not ok 6 - Multis from different roles declaration order tiebreaker (TEST USES UNSUPPORTED FEATURES) # TODO Wrong tiebreaker order (S12, actually)
    # Failed test 'Multis from different roles declaration order tiebreaker (TEST USES UNSUPPORTED FEATURES)'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/APPENDICES/A01-limits/misc.rakudo line 22
    ok 7 - Multis from different roles with only where clauses different (2)
    not ok 8 - Multis from different roles declaration order tiebreaker (TEST USES UNSUPPORTED FEATURES) # TODO Wrong tiebreaker order (S12, actually)
    # Failed test 'Multis from different roles declaration order tiebreaker (TEST USES UNSUPPORTED FEATURES)'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/APPENDICES/A01-limits/misc.rakudo line 22
ok 3 - role multi tiebreaking (TEST USES UNSUPPORTED FEATURES)
# FUDGED!
1..9
    1..2
        1..3
        ok 1 - returned handle is STDOUT
        ok 2 - set binary mode
        ok 3 - changed encoding
    ok 1 - STDOUT
        1..3
        ok 1 - returned handle is STDIN
        ok 2 - set binary mode
        ok 3 - changed encoding
    ok 2 - STDIN
ok 1 - .open with "-" as path uses $*IN/$*OUT
    1..3
        1..4
        ok 1 - returned handle is STDOUT
        ok 2 - $*OUT is now opened
        ok 3 - set binary mode
        ok 4 - changed encoding
    ok 1 - STDOUT
        1..4
        ok 1 - returned handle is STDIN
        ok 2 - $*IN is now opened
        ok 3 - set binary mode
        ok 4 - changed encoding
    ok 2 - STDIN
    ok 3 - can use unopened handle with path '-'.IO
ok 2 - .open with "-" as path can open closed $*IN/$*OUT
ok 3 - can .slurp from "-".IO path
    1..7
        1..64
        ok 1 - correct return value when using \("", "")
        ok 2 - correct modification when using \("", "")
        ok 3 - correct return value when using \("", "", :g)
        ok 4 - correct modification when using \("", "", :g)
        ok 5 - correct return value when using \("", "", :global)
        ok 6 - correct modification when using \("", "", :global)
        ok 7 - correct return value when using \("a", "")
        ok 8 - correct modification when using \("a", "")
        ok 9 - correct return value when using \("a", "", :g)
        ok 10 - correct modification when using \("a", "", :g)
        ok 11 - correct return value when using \("a", "", :global)
        ok 12 - correct modification when using \("a", "", :global)
        ok 13 - correct return value when using \("b", "")
        ok 14 - correct modification when using \("b", "")
        ok 15 - correct return value when using \("b", "", :g)
        ok 16 - correct modification when using \("b", "", :g)
        ok 17 - correct return value when using \("b", "", :global)
        ok 18 - correct modification when using \("b", "", :global)
        ok 19 - correct return value when using \(/<[abc]>/, "")
        ok 20 - correct modification when using \(/<[abc]>/, "")
        ok 21 - correct return value when using \(/<[abc]>/, "", :g)
        ok 22 - correct modification when using \(/<[abc]>/, "", :g)
        ok 23 - correct return value when using \(/<[abc]>/, "", :global)
        ok 24 - correct modification when using \(/<[abc]>/, "", :global)
        ok 25 - correct return value when using \(/<[abc]>/, "", :st(1))
        ok 26 - correct modification when using \(/<[abc]>/, "", :st(1))
        ok 27 - correct return value when using \(/<[abc]>/, "", :st(-> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140323317652952) ... }))
        ok 28 - correct modification when using \(/<[abc]>/, "", :st(-> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140323317652952) ... }))
        ok 29 - correct return value when using \(/<[abc]>/, "", :nd(2))
        ok 30 - correct modification when using \(/<[abc]>/, "", :nd(2))
        ok 31 - correct return value when using \(/<[abc]>/, "", :nd(-> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140323317657776) ... }))
        ok 32 - correct modification when using \(/<[abc]>/, "", :nd(-> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140323317657776) ... }))
        ok 33 - correct return value when using \(/<[abc]>/, "", :rd(3))
        ok 34 - correct modification when using \(/<[abc]>/, "", :rd(3))
        ok 35 - correct return value when using \(/<[abc]>/, "", :rd(-> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140323317658136) ... }))
        ok 36 - correct modification when using \(/<[abc]>/, "", :rd(-> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140323317658136) ... }))
        ok 37 - correct return value when using \(/<[abc]>/, "", :th(4))
        ok 38 - correct modification when using \(/<[abc]>/, "", :th(4))
        ok 39 - correct return value when using \(/<[abc]>/, "", :th(-> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140323317658496) ... }))
        ok 40 - correct modification when using \(/<[abc]>/, "", :th(-> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140323317658496) ... }))
        ok 41 - correct return value when using \(/<[abc]>/, "", :nth(5))
        ok 42 - correct modification when using \(/<[abc]>/, "", :nth(5))
        ok 43 - correct return value when using \(/<[abc]>/, "", :nth(-> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140323317658856) ... }))
        ok 44 - correct modification when using \(/<[abc]>/, "", :nth(-> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140323317658856) ... }))
        ok 45 - correct return value when using \(/<[abc]>/, "", :x(5))
        ok 46 - correct modification when using \(/<[abc]>/, "", :x(5))
        ok 47 - correct return value when using \(/<[abc]>/, "", :x(1..5))
        ok 48 - correct modification when using \(/<[abc]>/, "", :x(1..5))
        ok 49 - correct return value when using \(/<[cz]> \s+ <[xy]>/, "Z P", :ss)
        ok 50 - correct modification when using \(/<[cz]> \s+ <[xy]>/, "Z P", :ss)
        ok 51 - correct return value when using \(/<[cz]> \s+ <[xy]>/, "Z P", :global, :ss)
        ok 52 - correct modification when using \(/<[cz]> \s+ <[xy]>/, "Z P", :global, :ss)
        ok 53 - correct return value when using \("a", "Z", :ii)
        ok 54 - correct modification when using \("a", "Z", :ii)
        ok 55 - correct return value when using \("a", "Z", :global, :ii)
        ok 56 - correct modification when using \("a", "Z", :global, :ii)
        ok 57 - correct return value when using \(/<[b]+[b\x[308]]>/, "Z", :mm)
        ok 58 - correct modification when using \(/<[b]+[b\x[308]]>/, "Z", :mm)
        ok 59 - correct return value when using \(/<[b]+[b\x[308]]>/, "Z", :global, :mm)
        ok 60 - correct modification when using \(/<[b]+[b\x[308]]>/, "Z", :global, :mm)
        ok 61 - correct return value when using \(/<[b]+[b\x[308]]>/, "Z", :ii, :mm)
        ok 62 - correct modification when using \(/<[b]+[b\x[308]]>/, "Z", :ii, :mm)
        ok 63 - correct return value when using \(/<[b]+[b\x[308]]>/, "Z", :global, :ii, :mm)
        ok 64 - correct modification when using \(/<[b]+[b\x[308]]>/, "Z", :global, :ii, :mm)
    ok 1 - Cool.subst-mutate works same as on .Str
        1..68
        ok 1 - :g with Regex matcher on Str
        ok 2 - :x with Regex matcher on Str
        ok 3 - :nth(List) with Regex matcher on Str
        ok 4 - :nth(Seq) with Regex matcher on Str
        ok 5 - :nth(Range) with Regex matcher on Str
        ok 6 - :th(List) with Regex matcher on Str
        ok 7 - :th(Seq) with Regex matcher on Str
        ok 8 - :th(Range) with Regex matcher on Str
        ok 9 - :st(List) with Regex matcher on Str
        ok 10 - :st(Seq) with Regex matcher on Str
        ok 11 - :st(Range) with Regex matcher on Str
        ok 12 - :nd(List) with Regex matcher on Str
        ok 13 - :nd(Seq) with Regex matcher on Str
        ok 14 - :nd(Range) with Regex matcher on Str
        ok 15 - :rd(List) with Regex matcher on Str
        ok 16 - :rd(Seq) with Regex matcher on Str
        ok 17 - :rd(Range) with Regex matcher on Str
        ok 18 - :g with Regex matcher on Int
        ok 19 - :x with Regex matcher on Int
        ok 20 - :nth(List) with Regex matcher on Int
        ok 21 - :nth(Seq) with Regex matcher on Int
        ok 22 - :nth(Range) with Regex matcher on Int
        ok 23 - :th(List) with Regex matcher on Int
        ok 24 - :th(Seq) with Regex matcher on Int
        ok 25 - :th(Range) with Regex matcher on Int
        ok 26 - :st(List) with Regex matcher on Int
        ok 27 - :st(Seq) with Regex matcher on Int
        ok 28 - :st(Range) with Regex matcher on Int
        ok 29 - :nd(List) with Regex matcher on Int
        ok 30 - :nd(Seq) with Regex matcher on Int
        ok 31 - :nd(Range) with Regex matcher on Int
        ok 32 - :rd(List) with Regex matcher on Int
        ok 33 - :rd(Seq) with Regex matcher on Int
        ok 34 - :rd(Range) with Regex matcher on Int
        ok 35 - :g with Str matcher on Str
        ok 36 - :x with Str matcher on Str
        ok 37 - :nth(List) with Str matcher on Str
        ok 38 - :nth(Seq) with Str matcher on Str
        ok 39 - :nth(Range) with Str matcher on Str
        ok 40 - :th(List) with Str matcher on Str
        ok 41 - :th(Seq) with Str matcher on Str
        ok 42 - :th(Range) with Str matcher on Str
        ok 43 - :st(List) with Str matcher on Str
        ok 44 - :st(Seq) with Str matcher on Str
        ok 45 - :st(Range) with Str matcher on Str
        ok 46 - :nd(List) with Str matcher on Str
        ok 47 - :nd(Seq) with Str matcher on Str
        ok 48 - :nd(Range) with Str matcher on Str
        ok 49 - :rd(List) with Str matcher on Str
        ok 50 - :rd(Seq) with Str matcher on Str
        ok 51 - :rd(Range) with Str matcher on Str
        ok 52 - :g with Str matcher on Int
        ok 53 - :x with Str matcher on Int
        ok 54 - :nth(List) with Str matcher on Int
        ok 55 - :nth(Seq) with Str matcher on Int
        ok 56 - :nth(Range) with Str matcher on Int
        ok 57 - :th(List) with Str matcher on Int
        ok 58 - :th(Seq) with Str matcher on Int
        ok 59 - :th(Range) with Str matcher on Int
        ok 60 - :st(List) with Str matcher on Int
        ok 61 - :st(Seq) with Str matcher on Int
        ok 62 - :st(Range) with Str matcher on Int
        ok 63 - :nd(List) with Str matcher on Int
        ok 64 - :nd(Seq) with Str matcher on Int
        ok 65 - :nd(Range) with Str matcher on Int
        ok 66 - :rd(List) with Str matcher on Int
        ok 67 - :rd(Seq) with Str matcher on Int
        ok 68 - :rd(Range) with Str matcher on Int
    ok 2 - .subst-mutate returns a List for things .match return a List for
        1..68
        ok 1 - :g with Regex matcher on Str
        ok 2 - :x with Regex matcher on Str
        ok 3 - :nth(List) with Regex matcher on Str
        ok 4 - :nth(Seq) with Regex matcher on Str
        ok 5 - :nth(Range) with Regex matcher on Str
        ok 6 - :th(List) with Regex matcher on Str
        ok 7 - :th(Seq) with Regex matcher on Str
        ok 8 - :th(Range) with Regex matcher on Str
        ok 9 - :st(List) with Regex matcher on Str
        ok 10 - :st(Seq) with Regex matcher on Str
        ok 11 - :st(Range) with Regex matcher on Str
        ok 12 - :nd(List) with Regex matcher on Str
        ok 13 - :nd(Seq) with Regex matcher on Str
        ok 14 - :nd(Range) with Regex matcher on Str
        ok 15 - :rd(List) with Regex matcher on Str
        ok 16 - :rd(Seq) with Regex matcher on Str
        ok 17 - :rd(Range) with Regex matcher on Str
        ok 18 - :g with Regex matcher on Int
        ok 19 - :x with Regex matcher on Int
        ok 20 - :nth(List) with Regex matcher on Int
        ok 21 - :nth(Seq) with Regex matcher on Int
        ok 22 - :nth(Range) with Regex matcher on Int
        ok 23 - :th(List) with Regex matcher on Int
        ok 24 - :th(Seq) with Regex matcher on Int
        ok 25 - :th(Range) with Regex matcher on Int
        ok 26 - :st(List) with Regex matcher on Int
        ok 27 - :st(Seq) with Regex matcher on Int
        ok 28 - :st(Range) with Regex matcher on Int
        ok 29 - :nd(List) with Regex matcher on Int
        ok 30 - :nd(Seq) with Regex matcher on Int
        ok 31 - :nd(Range) with Regex matcher on Int
        ok 32 - :rd(List) with Regex matcher on Int
        ok 33 - :rd(Seq) with Regex matcher on Int
        ok 34 - :rd(Range) with Regex matcher on Int
        ok 35 - :g with Str matcher on Str
        ok 36 - :x with Str matcher on Str
        ok 37 - :nth(List) with Str matcher on Str
        ok 38 - :nth(Seq) with Str matcher on Str
        ok 39 - :nth(Range) with Str matcher on Str
        ok 40 - :th(List) with Str matcher on Str
        ok 41 - :th(Seq) with Str matcher on Str
        ok 42 - :th(Range) with Str matcher on Str
        ok 43 - :st(List) with Str matcher on Str
        ok 44 - :st(Seq) with Str matcher on Str
        ok 45 - :st(Range) with Str matcher on Str
        ok 46 - :nd(List) with Str matcher on Str
        ok 47 - :nd(Seq) with Str matcher on Str
        ok 48 - :nd(Range) with Str matcher on Str
        ok 49 - :rd(List) with Str matcher on Str
        ok 50 - :rd(Seq) with Str matcher on Str
        ok 51 - :rd(Range) with Str matcher on Str
        ok 52 - :g with Str matcher on Int
        ok 53 - :x with Str matcher on Int
        ok 54 - :nth(List) with Str matcher on Int
        ok 55 - :nth(Seq) with Str matcher on Int
        ok 56 - :nth(Range) with Str matcher on Int
        ok 57 - :th(List) with Str matcher on Int
        ok 58 - :th(Seq) with Str matcher on Int
        ok 59 - :th(Range) with Str matcher on Int
        ok 60 - :st(List) with Str matcher on Int
        ok 61 - :st(Seq) with Str matcher on Int
        ok 62 - :st(Range) with Str matcher on Int
        ok 63 - :nd(List) with Str matcher on Int
        ok 64 - :nd(Seq) with Str matcher on Int
        ok 65 - :nd(Range) with Str matcher on Int
        ok 66 - :rd(List) with Str matcher on Int
        ok 67 - :rd(Seq) with Str matcher on Int
        ok 68 - :rd(Range) with Str matcher on Int
    ok 3 - no-matches .subst-mutate: with multi-match opts = empty List
        1..14
            1..4
            ok 1 - $/ is a List…
            ok 2 - …with 3 items…
            ok 3 - …all are Match…
            ok 4 - …all have right values
        ok 1 - Int.subst-mutate: :g
            1..4
            ok 1 - $/ is a List…
            ok 2 - …with 2 items…
            ok 3 - …all are Match…
            ok 4 - …all have right values
        ok 2 - .subst-mutate: :x
            1..4
            ok 1 - $/ is a List…
            ok 2 - …with 3 items…
            ok 3 - …all are Match…
            ok 4 - …all have right values
        ok 3 - .subst-mutate: :nth
            1..4
            ok 1 - $/ is a List…
            ok 2 - …with 3 items…
            ok 3 - …all are Match…
            ok 4 - …all have right values
        ok 4 - .subst-mutate: :st
            1..4
            ok 1 - $/ is a List…
            ok 2 - …with 3 items…
            ok 3 - …all are Match…
            ok 4 - …all have right values
        ok 5 - .subst-mutate: :nd
            1..4
            ok 1 - $/ is a List…
            ok 2 - …with 3 items…
            ok 3 - …all are Match…
            ok 4 - …all have right values
        ok 6 - .subst-mutate: :rd
            1..4
            ok 1 - $/ is a List…
            ok 2 - …with 3 items…
            ok 3 - …all are Match…
            ok 4 - …all have right values
        ok 7 - .subst-mutate: :th
            1..4
            ok 1 - $/ is a List…
            ok 2 - …with 3 items…
            ok 3 - …all are Match…
            ok 4 - …all have right values
        ok 8 - Str.subst-mutate: :g
            1..4
            ok 1 - $/ is a List…
            ok 2 - …with 2 items…
            ok 3 - …all are Match…
            ok 4 - …all have right values
        ok 9 - .subst-mutate: :x
            1..4
            ok 1 - $/ is a List…
            ok 2 - …with 3 items…
            ok 3 - …all are Match…
            ok 4 - …all have right values
        ok 10 - .subst-mutate: :nth
            1..4
            ok 1 - $/ is a List…
            ok 2 - …with 3 items…
            ok 3 - …all are Match…
            ok 4 - …all have right values
        ok 11 - .subst-mutate: :st
            1..4
            ok 1 - $/ is a List…
            ok 2 - …with 3 items…
            ok 3 - …all are Match…
            ok 4 - …all have right values
        ok 12 - .subst-mutate: :nd
            1..4
            ok 1 - $/ is a List…
            ok 2 - …with 3 items…
            ok 3 - …all are Match…
            ok 4 - …all have right values
        ok 13 - .subst-mutate: :rd
            1..4
            ok 1 - $/ is a List…
            ok 2 - …with 3 items…
            ok 3 - …all are Match…
            ok 4 - …all have right values
        ok 14 - .subst-mutate: :th
    ok 4 - .subst-mutate with multi-match args set $/ to a List of matches
        1..2
        ok 1 - code dies
        ok 2 - right exception type (X::Str::Match::x)
    ok 5 - giving .subst-mutate invalid args throws
    ok 6 - Cool.subst-mutate with wrong args does not hang
        1..2
        ok 1 - Str.subst-mutate
        ok 2 - Cool.subst-mutate
    ok 7 - $/ is set when matching in a loop
ok 4 - now-deprecated subst-mutate
    1..7
    ok 1 - The object is-a 'Int'
    ok 2 - can assign integer value and return that
    ok 3 - the expected Int value was set
        1..2
        ok 1 - code dies
        ok 2 - right exception type (X::TypeCheck::Assignment)
    ok 4 - cannot assign a Str to an Int
        1..2
        ok 1 - code dies
        ok 2 - right exception type (X::Assignment::RO)
    ok 5 - cannot assign an Int to a frozen
    ok 6 - did not change integer value
    ok 7 - Pair.freeze doesn't change object identity
ok 5 - Pair.freeze
    1..2
    ok 1 - lines(Str, :count)
    ok 2 - Str.lines(:count)
ok 6 - :count arg on &lines/Str.lines
    1..5
        1..4
        ok 1 - no version pragma
        ok 2 - 6.c version pragma
        ok 3 - 6.d version pragma
        ok 4 - 6.d version pragma
    ok 1 - version as first thing
        1..4
        ok 1 - no version pragma
        ok 2 - 6.c version pragma
        ok 3 - 6.d version pragma
        ok 4 - 6.d version pragma
    ok 2 - version after comments
        1..4
        ok 1 - no version pragma
        ok 2 - 6.c version pragma
        ok 3 - 6.d version pragma
        ok 4 - 6.d version pragma
    ok 3 - version after POD
        1..3
        ok 1 - 6.c version pragma
        ok 2 - 6.d version pragma
        ok 3 - 6.d version pragma
    ok 4 - error out when trying to switch version too late
        1..4
        ok 1 - no version pragma
        ok 2 - 6.c version pragma
        ok 3 - 6.d version pragma
        ok 4 - 6.d version pragma
    ok 5 - versions without dot
ok 7 - language switching
    1..1
        1..4
        ok 1 - defaults
        ok 2 - :nl-out set to ♥
        ok 3 - :nl-out set to a string (via .new)
        ok 4 - :nl-out set via .new, then via .open, then via attribute assignment
    ok 1 - .print-nl method
ok 8 - IO::Handle.new can take a bunch of options
    1..12
    ok 1 - CALLER:: string arg
    ok 2 - CALLER:: number arg
    # You planned 12 tests, but ran 2
1..19
ok 1 - native types and where clauses do not cause spurious circularities
    1..8
    ok 1 - type
    ok 2 - :D smiley
    ok 3 - implied Any
    ok 4 - # SKIP :D/:U coerces NYI
    ok 5 - type
    ok 6 - :D smiley
    ok 7 - implied Any
    ok 8 - # SKIP :D/:U coerces NYI
ok 2 - :D DefiniteHow target (core types)
    1..3
    ok 1 - type
    ok 2 - :U smiley
    ok 3 - implied Any
ok 3 - :U DefiniteHow target (core types)
    1..4
        1..2
        ok 1 - '-> Date:D(DateTime)   {}(DateTime)' died
        ok 2 - right exception type (X::Parameter::InvalidConcreteness)
    ok 1 - type, bad source # TODO no proper concreteness check in coerces
        1..2
        ok 1 - '-> Date:D(DateTime:D) {}(DateTime)' died
        not ok 2 - right exception type (X::Parameter::InvalidConcreteness) # TODO no proper concreteness check in coerces
        # Failed test 'right exception type (X::Parameter::InvalidConcreteness)'
        # at SETTING::src/core.c/Exception.pm6 line 62
        # Expected: X::Parameter::InvalidConcreteness
        # Got:      X::TypeCheck::Binding::Parameter
        # Exception message: Type check failed in binding to parameter '<anon>'; expected Date:D(DateTime:D) but got DateTime (DateTime)
    not ok 2 - :D, bad source # TODO no proper concreteness check in coerces
    # Failed test ':D, bad source'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/APPENDICES/A04-experimental/01-misc.rakudo line 56
        1..2
        ok 1 - '-> Date:D(DateTime:U) {}(DateTime)' died
        ok 2 - right exception type (X::Parameter::InvalidConcreteness)
    ok 3 - :U, bad target # TODO no proper concreteness check in coerces
        1..2
        ok 1 - '-> Date:D() {}(DateTime)' died
        ok 2 - right exception type (X::Parameter::InvalidConcreteness)
    ok 4 - implied, bad target # TODO no proper concreteness check in coerces
ok 4 - DefiniteHow target, errors
    1..4
        1..2
        ok 1 - '-> Date:D(DateTime)   {}(Date)' died
        not ok 2 - right exception type (X::Parameter::InvalidConcreteness) # TODO no proper concreteness check in coerces
        # Failed test 'right exception type (X::Parameter::InvalidConcreteness)'
        # at SETTING::src/core.c/Exception.pm6 line 62
        # Expected: X::Parameter::InvalidConcreteness
        # Got:      X::TypeCheck::Binding::Parameter
        # Exception message: Type check failed in binding to parameter '<anon>'; expected Date:D(DateTime) but got Date (Date)
    not ok 1 - type # TODO no proper concreteness check in coerces
    # Failed test 'type'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/APPENDICES/A04-experimental/01-misc.rakudo line 70
        1..2
        ok 1 - '-> Date:D(DateTime:D) {}(Date)' died
        not ok 2 - right exception type (X::Parameter::InvalidConcreteness) # TODO no proper concreteness check in coerces
        # Failed test 'right exception type (X::Parameter::InvalidConcreteness)'
        # at SETTING::src/core.c/Exception.pm6 line 62
        # Expected: X::Parameter::InvalidConcreteness
        # Got:      X::TypeCheck::Binding::Parameter
        # Exception message: Type check failed in binding to parameter '<anon>'; expected Date:D(DateTime:D) but got Date (Date)
    not ok 2 - :D # TODO no proper concreteness check in coerces
    # Failed test ':D'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/APPENDICES/A04-experimental/01-misc.rakudo line 71
        1..2
        ok 1 - '-> Date:D(DateTime:U) {}(Date)' died
        not ok 2 - right exception type (X::Parameter::InvalidConcreteness) # TODO no proper concreteness check in coerces
        # Failed test 'right exception type (X::Parameter::InvalidConcreteness)'
        # at SETTING::src/core.c/Exception.pm6 line 62
        # Expected: X::Parameter::InvalidConcreteness
        # Got:      X::TypeCheck::Binding::Parameter
        # Exception message: Type check failed in binding to parameter '<anon>'; expected Date:D(DateTime:U) but got Date (Date)
    not ok 3 - :U # TODO no proper concreteness check in coerces
    # Failed test ':U'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/APPENDICES/A04-experimental/01-misc.rakudo line 72
        1..2
        ok 1 - '-> Date:D() {}(Date)' died
        ok 2 - right exception type (X::Parameter::InvalidConcreteness)
    ok 4 - implied # TODO no proper concreteness check in coerces
ok 5 - DefiniteHow target, errors, source is already target
    1..6
    ok 1 - from type
    ok 2 - from :D smiley
    ok 3 - # SKIP :D/:U coerces NYI
    ok 4 - from Any
    ok 5 - from Any:D
    ok 6 - from implied Any
ok 6 - :D DefiniteHow target (arbitrary types; from source)
    1..6
    ok 1 - from type
    ok 2 - from :D smiley
    ok 3 - # SKIP :D/:U coerces NYI
    ok 4 - from Any
    ok 5 - from Any:D
    ok 6 - from implied Any
ok 7 - :D DefiniteHow target (arbitrary types; from source subclass)
    1..6
    ok 1 - from type
    ok 2 - from :D smiley
    ok 3 - # SKIP :D/:U coerces NYI
    ok 4 - from Any
    ok 5 - from Any:D
    ok 6 - from implied Any
ok 8 - :D DefiniteHow target (arbitrary types; already target)
    1..6
    ok 1 - from type
    ok 2 - # SKIP :D/:U coerces NYI
    ok 3 - from :U smiley
    ok 4 - from Any
    ok 5 - from Any:U
    ok 6 - from implied Any
ok 9 - :U DefiniteHow target (arbitrary types; from source)
    1..6
    ok 1 - from type
    ok 2 - # SKIP :D/:U coerces NYI
    ok 3 - from :U smiley
    ok 4 - from Any
    ok 5 - from Any:U
    ok 6 - from implied Any
ok 10 - :U DefiniteHow target (arbitrary types; from source subclass)
    1..6
    ok 1 - from type
    ok 2 - # SKIP :D/:U coerces NYI
    ok 3 - from :U smiley
    ok 4 - from Any
    ok 5 - # SKIP :D/:U coerces NYI
    ok 6 - from implied Any
ok 11 - :U DefiniteHow target (arbitrary types; already target)
    1..2
    ok 1 - 
    ok 2 - 
ok 12 - mistyped typenames in coercers give good error
ok 13 - .IO on Date
ok 14 - .IO on DateTime
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 15 - .IO on Date:U throws
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 16 - .IO on DateTime:U throws
    1..8
        1..3
        ok 1 - returns correct type
        ok 2 - returns correct value
        ok 3 - .returns() gives correct value
    ok 1 - sub (Int --> Str())
        1..3
        ok 1 - returns correct type
        ok 2 - returns correct value
        ok 3 - .returns() gives correct value
    ok 2 - sub (Num $x --> Int(Str))
        1..3
        ok 1 - returns correct type
        ok 2 - returns correct value
        ok 3 - .returns() gives correct value
    ok 3 - sub (Int) returns Str()
        1..3
        ok 1 - returns correct type
        ok 2 - returns correct value
        ok 3 - .returns() gives correct value
    ok 4 - sub (Num) returns Int(Str)
        1..3
        ok 1 - returns correct type
        ok 2 - returns correct value
        ok 3 - .returns() gives correct value
    ok 5 - block Int --> Str()
        1..3
        ok 1 - returns correct type
        ok 2 - returns correct value
        ok 3 - .returns() gives correct value
    ok 6 - block --> Str()
        1..3
        ok 1 - returns correct type
        ok 2 - returns correct value
        ok 3 - .returns() gives correct value
    ok 7 - method (Int --> Str())
        1..2
        ok 1 - code dies
        ok 2 - right exception type (X::TypeCheck::Return)
    ok 8 - returning incorrect type throws
ok 17 - type coercions work in returns
ok 18 - Array:U.flat is identity
    1..15
    ok 1 - 
    ok 2 - 
    ok 3 - 
    ok 4 - # SKIP Clarification needed
    ok 5 - # SKIP Clarification needed
    ok 6 - # SKIP Clarification needed
    ok 7 - # SKIP Clarification needed
    ok 8 - # SKIP Clarification needed
    ok 9 - # SKIP Clarification needed
    ok 10 - # SKIP Clarification needed
    ok 11 - # SKIP Clarification needed
    ok 12 - # SKIP Clarification needed
    ok 13 - # SKIP Clarification needed
    ok 14 - # SKIP Clarification needed
    ok 15 - large `int` values do not overflow prematurely
ok 19 - tests that use unspecced $?BITS to make decisions
# FUDGED!
1..14
    1..2
    ok 1 - program did not hang
    ok 2 - STDOUT
ok 1 - no deadlock while acquiring mutex
ok 2 - Supply.merge on signals does not crash
ok 3 - Supply.merge on signals does not crash
ok 4 - Supply.merge on signals handles signal
ok 5 - dir() does not produce wrong results under concurrent load
ok 6 - no issues when piping one Proc's STDOUT to another's STDIN
ok 7 - supply inside sock does not hang
ok 8 - no serialization crashes with roles and traits
ok 9 - no crashes with giant enums in packages
ok 10 - no segfault in a `for` loop + some ops
ok 11 - no crashes with Whatever curries in topics of for/given statement modifiers
not ok 12 - collected right amount of characters (with &foo) # TODO https://github.com/rakudo/rakudo/issues/1535
# Failed test 'collected right amount of characters (with &foo)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/MISC/bug-coverage-stress.rakudo line 189
# expected: '4000'
#      got: '0'
ok 13 - collected right amount of characters (with { foo })
ok 14 - no SEGV in curries + with
# FUDGED!
1..7
    1..6
        1..2
        ok 1 - 'use v6.d; sub meow:sym<bar> {}' died
        ok 2 - right exception type (X::Syntax::Reserved)
    ok 1 - :sym<...>
        1..2
        ok 1 - 'use v6.d; sub meow:sym«bar» {}' died
        ok 2 - right exception type (X::Syntax::Reserved)
    ok 2 - :sym«...»
        1..2
        ok 1 - 'use v6.d; sub meow:foo<bar>:sym<bar> {}' died
        ok 2 - right exception type (X::Syntax::Reserved)
    ok 3 - :foo<bar>:sym<...>
        1..2
        ok 1 - 'use v6.d; sub meow:foo<bar>:sym«bar» {}' died
        ok 2 - right exception type (X::Syntax::Reserved)
    ok 4 - :foo<bar>:sym«...»
        1..2
        ok 1 - 'use v6.d; sub meow:sym<bar>:foo<bar> {}' died
        ok 2 - right exception type (X::Syntax::Reserved)
    ok 5 - :sym<...>:foo<bar>
        1..2
        ok 1 - 'use v6.d; sub meow:sym«bar»:foo<bar> {}' died
        ok 2 - right exception type (X::Syntax::Reserved)
    ok 6 - :sym«...»:foo<bar>
ok 1 - :sym<> colonpair on subroutine names is reserved
    1..5
    ok 1 - inside MAIN in 6.c language (with @*ARGS content)
    ok 2 - inside MAIN in 6.c language (without @*ARGS content)
    ok 3 - MAIN is an only sub
    ok 4 - MAIN is a multi sub
    ok 5 - no MAIN
ok 2 - $*ARGFILES is set to $*IN inside sub MAIN
    1..8
    ok 1 - `my` variable
    ok 2 - class attribute
    ok 3 - role attribute
    ok 4 - submethod param
    ok 5 - method param
    ok 6 - sub param
    ok 7 - block param
    ok 8 - native num array unset element
ok 3 - native num defaults to 0e0
ok 4 - use of `undefine` issues deprecation warning in 6.d
    1..6
    ok 1 - $() is a List
    ok 2 - $() is a containerized List
    ok 3 - @() is a List
    ok 4 - @() is NOT a containerized List
    ok 5 - %() is a Hash
    ok 6 - @() is NOT a containerized Hash
ok 5 - $()/@()/%() have no magick
    1..3
        1..14
        ok 1 - sigilless-constant
        ok 2 - $-constant
        ok 3 - sigilless-variable
        ok 4 - $-variable
        ok 5 - @-variable's holes
        ok 6 - %-variable's missing keys
        ok 7 - $ attribute
        ok 8 - @ attribute
        ok 9 - % attribute
        ok 10 - @ param in block
        ok 11 - % param in block
        ok 12 - @ param in sub
        ok 13 - % param in sub
        ok 14 - parametarized Callables are parametarized with smiley
    ok 1 - :D
        1..14
        ok 1 - sigilless-constant
        ok 2 - $-constant
        ok 3 - sigilless-variable
        ok 4 - $-variable
        ok 5 - @-variable's holes
        ok 6 - %-variable's missing keys
        ok 7 - $ attribute
        ok 8 - @ attribute
        ok 9 - % attribute
        ok 10 - # SKIP crashes https://github.com/rakudo/rakudo/issues/2298
        ok 11 - # SKIP crashes https://github.com/rakudo/rakudo/issues/2298
        ok 12 - # SKIP crashes https://github.com/rakudo/rakudo/issues/2298
        ok 13 - # SKIP crashes https://github.com/rakudo/rakudo/issues/2298
        ok 14 - parametarized Callables are parametarized with smiley
    ok 2 - :U
        1..14
        ok 1 - sigilless-constant
        ok 2 - $-constant
        ok 3 - sigilless-variable
        ok 4 - $-variable
        ok 5 - @-variable's holes
        ok 6 - %-variable's missing keys
        ok 7 - $ attribute
        ok 8 - @ attribute
        ok 9 - % attribute
        ok 10 - @ param in block
        ok 11 - % param in block
        ok 12 - @ param in sub
        ok 13 - % param in sub
        ok 14 - parametarized Callables are parametarized with smiley
    ok 3 - :_
ok 6 - smiley constraints default to type object without smiley
ok 7 - no crashes when accessing outer lexicals
# FUDGED!
1..17
ok 1 - elems
ok 2 - exists
ok 3 - nonexists fail
ok 4 - fetch
ok 5 - can retro fetch
ok 6 - retro fetch
ok 7 - retro elems
ok 8 - retro exists
ok 9 - retro nonexists
ok 10 - can push
ok 11 - push result via obj
not ok 12 - push result via array # TODO doesn't work yet due to copying of arrays
# Failed test 'push result via array'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S01-perl-5-integration/array.rakudo line 80
# expected: '9'
#      got: (Any)
not ok 13 - retro push result # TODO doesn't work yet due to copying of arrays
# Failed test 'retro push result'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S01-perl-5-integration/array.rakudo line 87
# expected: '9'
#      got: '0'
not ok 14 - retro push result # TODO doesn't work yet due to copying of arrays
# Failed test 'retro push result'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S01-perl-5-integration/array.rakudo line 88
# expected: '9'
#      got: (Any)
ok 15 - can store
not ok 16 - store result # TODO doesn't work yet due to copying of arrays
# Failed test 'store result'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S01-perl-5-integration/array.rakudo line 95
# expected: '3'
#      got: '5'
ok 17 - store result
# FUDGED!
1..3
ok 1 - # SKIP 
ok 2 - 
ok 3 - CLASS:from<Perl5>.new
# FUDGED!
1..10
not ok 1 - :context<void> sets void context # TODO 
# Failed test ':context<void> sets void context'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S01-perl-5-integration/context.rakudo line 20
# expected: '1'
#      got: '0'
ok 2 - :context<scalar> doesn't set void context
ok 3 - :context<list> doesn't set void context
not ok 4 - :context<scalar> sets scalar context # TODO 
# Failed test ':context<scalar> sets scalar context'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S01-perl-5-integration/context.rakudo line 36
# expected: '1'
#      got: '0'
ok 5 - :context<void> doesn't set scalar context
ok 6 - :context<list> doesn't set scalar context
ok 7 - :context<list> sets list context
not ok 8 - :context<scalar> doesn't set list context # TODO 
# Failed test ':context<scalar> doesn't set list context'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S01-perl-5-integration/context.rakudo line 54
# expected: '0'
#      got: '1'
not ok 9 - :context<void> doesn't set list context # TODO 
# Failed test ':context<void> doesn't set list context'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S01-perl-5-integration/context.rakudo line 56
# expected: '0'
#      got: '1'
not ok 10 - a p5 sub called in void context returns a Nil # TODO 
# Failed test 'a p5 sub called in void context returns a Nil'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S01-perl-5-integration/context.rakudo line 59
# expected: Nil
#  matcher: 'infix:<===>'
#      got: [1, 2, 3, 4]
# FUDGED!
1..2
not ok 1 - lexical inside an EVAL # TODO 
# Failed test 'lexical inside an EVAL'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S01-perl-5-integration/eval_lex.rakudo line 14
# expected: 'self is some text'
#      got: 'self is '
    1..2
        1..3
        ok 1 - STDOUT has right data
        ok 2 - STDERR is empty
        ok 3 - exitcode is correct
    ok 1 - EVAL
        1..3
        ok 1 - STDOUT has right data
        ok 2 - STDERR is empty
        ok 3 - exitcode is correct
    ok 2 - EVALFILE
ok 2 - EVAL/EVALFILE evals Buf like perl would execute source file
# FUDGED!
1..13
ok 1 - class method
ok 2 - class is shadowed in Raku
ok 3 - blessed
ok 4 - invoke method
ok 5 - invoke method with Perl arg
ok 6 - returning a coderef
ok 7 - invoking p5 coderef
ok 8 - invoke with p5 coderef
ok 9 - 
ok 10 - 
ok 11 - invoke method with callback
ok 12 - invoke Raku method from Perl
not ok 13 - modify a scalar ref # TODO doesn't work yet due to copying of arrays
# Failed test 'modify a scalar ref'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S01-perl-5-integration/method.rakudo line 135
# expected: '99'
#      got: '1'
# FUDGED!
1..6
ok 1 - 
not ok 2 - Null Bytes in the middle of a converted string # TODO NativeCall strings not yet Null safe
# Failed test 'Null Bytes in the middle of a converted string'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S01-perl-5-integration/strings.rakudo line 13
# expected: 'Yet Ano ther P erl Hacker'
#      got: 'Yet Ano'
ok 3 - utf8 in literals
ok 4 - Passing simple strings to p5 land
ok 5 - Passing strings with null bytes to p5 land
ok 6 - Passing strings with unicode to p5 land
# FUDGED!
1..110
ok 1 - unspace with numbers
ok 2 - unspace with comments
ok 3 - unspace with strings
ok 4 - unspace with strings + parens
ok 5 - (short) unspace with postfix inc
ok 6 - (short) unspace with postfix inc really postfix
ok 7 - unspace with postfix inc
ok 8 - unspace with postfix inc really postfix
ok 9 - unspace with postfix dec
ok 10 - unspace with postfix dec really postfix
ok 11 - unspace without spaces
ok 12 - unspace with newline
ok 13 - unspace with adverb
ok 14 - unspace on postfix subscript
ok 15 - unspace with postfix pre-dot hyperops
ok 16 - unspace with postfix pre- and/or post-dot hyperops
ok 17 - sanity - foo.lc
ok 18 - sanity - foo .lc
ok 19 - sanity - bar.lc
ok 20 - sanity - bar .lc
ok 21 - short unspace
ok 22 - unspace
ok 23 - unspace before arguments
ok 24 - not a unspace
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Comp)
ok 25 - unspace not allowed in identifier
ok 26 - longer dot
ok 27 - unspace with embedded comment
    1..2
    not ok 1 - code dies # TODO unspace NYI
    # Failed test 'code dies'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-lexical-conventions/unspace.rakudo line 78
    ok 2 - # SKIP Code did not die, can not check exception
not ok 28 - unspace can't hide space between  \# and opening bracket # TODO unspace NYI
# Failed test 'unspace can't hide space between  \# and opening bracket'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-lexical-conventions/unspace.rakudo line 78
ok 29 - unspace with end-of-line comment
ok 30 - unspace in colonpair
ok 31 - unspace is allowed both before and after method .
ok 32 - unspace with pod =begin/=end comment
ok 33 - unspace with pod =for comment
ok 34 - unspace with pod =comment
ok 35 - # SKIP pod and unspace
ok 36 - # SKIP =for pod NYI (in STD.pm, from Perl)
ok 37 - # SKIP pod and unspace
ok 38 - # SKIP pod and unspace
ok 39 - # SKIP =for pod NYI (in STD.pm, from Perl)
ok 40 - # SKIP =for pod NYI (in STD.pm, from Perl)
ok 41 - # SKIP =for pod NYI (in STD.pm, from Perl)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Syntax::Confused)
ok 42 - semicolon or newline required between blocks
ok 43 - comma immediately following arg block
ok 44 - comma not immediately following arg block
ok 45 - unspace then comma following arg block
ok 46 - colon immediately following arg block
ok 47 - colon not immediately following arg block
ok 48 - unspace then colon following arg block
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Syntax::Confused)
ok 49 - infix requires space when ambiguous with postfix
ok 50 - check $n
ok 51 - check $m
ok 52 - $n ++$m with infix:<++> is $n ++ $m
ok 53 - check $n
ok 54 - check $m
ok 55 - postfix requires no space w/ infix ambiguity
ok 56 - check $n
ok 57 - check $m
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Syntax::Confused)
ok 58 - postfix dot w/ infix ambiguity
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Comp)
ok 59 - postfix unspace w/ infix ambiguity
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Comp)
ok 60 - postfix unspace w/ infix ambiguity
ok 61 - check $n
ok 62 - check $m
ok 63 - unspace inside operator splits it
ok 64 - check $n
ok 65 - check $m
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Comp)
ok 66 - postfix requires no space
ok 67 - check $n
ok 68 - postfix dot
ok 69 - check $n
ok 70 - postfix unspace
ok 71 - check $n
ok 72 - postfix unspace
ok 73 - check $n
ok 74 - unspace with U+301D/U+301E comment
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Comp)
ok 75 - unspace with U+301D/U+301F is invalid
ok 76 -  .123 is equal to 0.123
ok 77 - .123 is equal to 0.123
ok 78 - unspaced postfix after method call not misparsed
ok 79 - unspace between parameter and before and after method .
ok 80 - sanity
ok 81 - unspace between method and first argument
ok 82 - unspace between method and first argument with leading space
ok 83 - unspace between first and second argument
ok 84 - unspace between first and second argument with leading space
ok 85 - two unspace in a row after . for method call
ok 86 - two unspace in a row before . for method call
ok 87 - Unspace restriction in regex does not apply to \ \#
ok 88 - bareword call with unspace
ok 89 - bareword call with degenerate unspace
ok 90 - bare longname call with unspace
ok 91 - bare longname call with degenerate unspace
ok 92 - longname array subscript with unspace
ok 93 - longname array subscript with degenerate unspace
ok 94 - longname hash subscript with unspace
ok 95 - longname hash subscript with degenerate unspace
ok 96 - longname pointy hash subscript with unspace
ok 97 - longname pointy hash subscript with degenerate unspace
ok 98 - bare longname metamethod call with unspace
ok 99 - bare longname metamethod call with degenerate unspace
ok 100 - unspace with method calls detached from sigiless terms works
ok 101 - unspace with array subscript detached from sigiless terms works
ok 102 - unspace with hash subscript detached from sigiless terms works
ok 103 - unspace with pointy hash subscript detached from sigiless terms works
ok 104 - degenerate unspace with method calls detached from sigiless terms works
ok 105 - degenerate unspace with array subscript detached from sigiless terms works
ok 106 - degenerate unspace with hash subscript detached from sigiless terms works
ok 107 - degenerate unspace with pointy hash subscript detached from sigiless terms works
ok 108 - unspace can recurse
ok 109 - unspace combined with map and a constant
ok 110 - unspace combined with map and constants
# FUDGED!
1..35
ok 1 - Basic boolean adverb works
ok 2 - Negated boolean adverb works
ok 3 - Adverb with value in parens works
ok 4 - Adverb with angle quote value works
ok 5 - ...and does the right thing with the value list
ok 6 - Adverb with postfix:<[ ]> works
ok 7 - :abcd works
ok 8 - :@a works
ok 9 - :%a works
ok 10 - :&a works
ok 11 - Basic numeric adverb works
ok 12 - Unicode numeric adverb works
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Comp)
ok 13 - Numeric adverb can't have an extra value
ok 14 - Adverb with postfix:<> makes code object
ok 15 - Adverb with $= twigil works
ok 16 - Adverb with $? twigil works
ok 17 - Adverb with $* twigil works
ok 18 - Adverb with @* twigil works
ok 19 - Adverb with %* twigil works
ok 20 - Adverb with $^ twigil works
ok 21 - Adverb with @^ twigil works
ok 22 - Adverb with %^ twigil works
ok 23 - Adverb with $: twigil works
ok 24 - Adverb with @: twigil works
ok 25 - Adverb with %: twigil works
ok 26 - Adverb with $< twigil works
not ok 27 - Adverb with @< twigil works # TODO :@<...> and :%<...> broken needs RT
# Failed test 'Adverb with @< twigil works'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-literals/adverbs.rakudo line 57
# expected: :fie((Match.new(:orig("aaaa"), :from(1), :pos(2)), Match.new(:orig("aaaa"), :from(2), :pos(3))))
#      got: :fie(Match.new(:orig("aaaa"), :from(1), :pos(3), :list((Match.new(:orig("aaaa"), :from(1), :pos(2)), Match.new(:orig("aaaa"), :from(2), :pos(3))))))
not ok 28 - Adverb with %< twigil works # TODO :@<...> and :%<...> broken needs RT
# Failed test 'Adverb with %< twigil works'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-literals/adverbs.rakudo line 58
# expected: :foe(Map.new((:fum(Match.new(:orig("aaaa"), :from(3), :pos(4))))))
#      got: :foe(Match.new(:orig("aaaa"), :from(3), :pos(4), :hash(Map.new((:fum(Match.new(:orig("aaaa"), :from(3), :pos(4))))))))
ok 29 - Adverb with $~ twigil works
ok 30 - Adverb with @~ twigil works
ok 31 - Adverb with %~ twigil works
ok 32 - Adverbs without punctuations is allowed
ok 33 - Adverbs without punctuations is allowed
ok 34 - Large numeric adverbs don't error out, and also give the correct value
ok 35 - lack of comma does not cause LTA error
# FUDGED!
1..33
ok 1 - q:to// is singular
ok 2 - here doc interpolated
ok 3 - here doc interpolating with indentation
ok 4 - q:to// is singular, also when indented
ok 5 - indentation stripped
ok 6 - q:heredoc// is singular
ok 7 - backslashes
ok 8 - indent with multiline interpolation
ok 9 - indent with multiline interpolation with spaces at the beginning
ok 10 - extra spaces after interpolation will be kept
ok 11 - interpolations without constant strings in the middle
ok 12 - interpolations at the very end
ok 13 - empty lines
ok 14 - Tabs get correctly removed
ok 15 - mixed tabs and spaces get correctly removed
ok 16 - mixing tabs and spaces even more evil-ly
ok 17 - Constant heredocs work
ok 18 - Heredoc leading and trailing empty lines
ok 19 - Completely empty heredoc
ok 20 - Heredoc one empty line
ok 21 - Heredoc two empty lines
ok 22 - Heredoc tab explosion makefile use case is usesul.
ok 23 - # SKIP RT  \#131927
ok 24 - # SKIP RT  \#131927
ok 25 - # SKIP RT  \#131927
ok 26 - # SKIP RT  \#131927
ok 27 - # SKIP RT  \#131927
ok 28 - # SKIP RT  \#131927
ok 29 - # SKIP RT  \#131927
ok 30 - # SKIP RT  \#131927
ok 31 - # SKIP RT  \#131927
ok 32 - # SKIP RT  \#131927
ok 33 - # SKIP RT  \#131927
# FUDGED!
1..24
ok 1 - list context <list>
not ok 2 - listop |<< <list> # TODO meta operators RT #124558
# Failed test 'listop |<< <list>'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-literals/listquote.rakudo line 15
# expected: 'xayaz'
#      got: ''
ok 3 - .join<abc> parses and fails
ok 4 - {...}<a b c> is hash subscript
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Syntax::Confused)
ok 5 - {...} <...> parsefail
ok 6 - (...) < 3 no parsefail
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Comp)
ok 7 - ()<3 parsefail
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Syntax::Confused)
ok 8 - :foo <1 2 3> parsefail
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Multi::NoMatch)
ok 9 - <3 is comparison, but dies at run time
ok 10 - :foo<1 2 3> is pair of list
ok 11 - Hashes with embedded newlines in the list (1)
ok 12 - Hashes with embedded newlines in the list (2)
ok 13 - Hashes with embedded newlines in the list (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Obsolete)
ok 14 - bare <> is disallowed
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Obsolete)
ok 15 - <STDIN> is disallowed
ok 16 - <a b c> produces a List
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Immutable)
ok 17 - ... which is immutable
ok 18 - <...> numeric literals stringify correctly
ok 19 - <foo ...> is a Str
ok 20 - < ... 3 ...> is an Int
ok 21 - < ... 4.5 ...> is a Rat
ok 22 - < ... 1.2e1 ...> is a Num
ok 23 - < ... -2+3i ...> is a Complex
ok 24 - function call with assignment to list
# FUDGED!
1..69
ok 1 - 1 produces a Int
ok 2 - 1 does Numeric
ok 3 - 1 does Real
ok 4 - 1.Num produces a Int
ok 5 - 1.Num does Numeric
ok 6 - 1.Num does Real
ok 7 - <1/2> Rat literal
ok 8 - <1/2> produces a Rat
ok 9 - <1/2> does Numeric
ok 10 - <1/2> does Real
ok 11 - same with hexadecimal numbers
not ok 12 - negative allowed only on numerator # TODO Unsure of what's acceptable for val()
# Failed test 'negative allowed only on numerator'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-literals/numeric.rakudo line 22
not ok 13 - negative allowed only on numerator # TODO Unsure of what's acceptable for val()
# Failed test 'negative allowed only on numerator'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-literals/numeric.rakudo line 23
ok 14 - negative Rat literal
ok 15 - negative Rat literal
ok 16 - Rat works with hexadecimal numbers
ok 17 - Rat works with binary numbers
not ok 18 - Rat works with colon radix numbers # TODO Adverbial numbers in Rat literals not supported
# Failed test 'Rat works with colon radix numbers'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-literals/numeric.rakudo line 32
# expected: '0.142857'
#      got: ':13<01>/:13<07>'
not ok 19 - Rat works with colon radix numbers # TODO Adverbial numbers in Rat literals not supported
# Failed test 'Rat works with colon radix numbers'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-literals/numeric.rakudo line 33
# expected: '0.231579'
#      got: ':12<1a>/:12<7b>'
ok 20 - <1+1i> is a Complex literal
ok 21 - <+2+2i> is a Complex literal
ok 22 - <-3+3i> is a Complex literal
ok 23 - <+4-4i> is a Complex literal
ok 24 - <-5-5i> is a Complex literal
ok 25 - 1+1i does Numeric
ok 26 - 1+1i doesn't do Real
ok 27 - 1*1i is a Str
ok 28 - <3+2i> produces correct value
ok 29 - <+3+2i> produces correct value
ok 30 - <-3+2i> produces correct value
ok 31 - <+3-2i> produces correct value
ok 32 - <-3-2i> produces correct value
ok 33 - <3.1+2.9i> produces correct value
ok 34 - +<3.2+2.8i> produces correct value
ok 35 - -<3.3+2.7i> produces correct value
ok 36 - +<3.4-2.6i> produces correct value
ok 37 - -<3.5-2.5i> produces correct value
ok 38 - <3.1e10+2.9e10i> produces correct value
ok 39 - <+3.1e+11+2.9e+11i> produces correct value
ok 40 - <-3.1e+12-2.9e+12i> produces correct value
ok 41 - <-3.1e-23-2.9e-23i> produces correct real value
ok 42 - <-3.1e-23-2.9e-23i> produces correct imaginary value
ok 43 - <3.1e-99+2.9e-99i> produces correct real value
ok 44 - <3.1e-99+2.9e-99i> produces correct imaginary value
ok 45 - <NaN+Inf\i> produces correct value
ok 46 - <NaN-Inf\i> produces correct value
ok 47 - 0--Inf\i is a Str
ok 48 - 0++Inf\i is a Str
ok 49 - 0+-Inf\i is a Str
ok 50 - 0-+Inf\i is a Str
ok 51 - --Inf-1i is a Str
ok 52 - ++Inf-1i is a Str
ok 53 - +-Inf-1i is a Str
ok 54 - -+Inf-1i is a Str
ok 55 - very long Num literals
ok 56 - parsing 0.000... with 19 decimal places lives
ok 57 - parsing 0.000... with 20 decimal places lives
ok 58 - parsing 0.000... with 63 decimal places lives
ok 59 - parsing 0.000... with 66 decimal places lives
ok 60 - parsing 0.000... with 1024 decimal places lives
ok 61 - 0e999999999999 equals zero
ok 62 - We can handle Unicode digits
ok 63 - We can handle Unicode non-digit numerics
ok 64 - We can handle vulgar fractions
ok 65 - We can multiply cuneiform :-)
ok 66 - We can write 1 in funny ways too
ok 67 - yeah, we do that too...
    1..6
    ok 1 - use negation as postfix
    ok 2 - use ~ as postfix
    ok 3 - use « » to wrap the prefix
    ok 4 - use << >> to wrap the prefix
    ok 5 - use [" "] to wrap the prefix
    ok 6 - use <<' '>> to wrap the prefix
ok 68 -  \#2094 prefix as post fix works on number literals
    ok 1 - is '123'.Numeric ok?
    ok 2 - is '123'.Int ok?
    ok 3 - is '١٢٣'.Numeric ok?
    ok 4 - is '١٢٣'.Int ok?
    ok 5 - is '۱۲۳'.Numeric ok?
    ok 6 - is '۱۲۳'.Int ok?
    ok 7 - is '߁߂߃'.Numeric ok?
    ok 8 - is '߁߂߃'.Int ok?
    ok 9 - is '१२३'.Numeric ok?
    ok 10 - is '१२३'.Int ok?
    ok 11 - is '১২৩'.Numeric ok?
    ok 12 - is '১২৩'.Int ok?
    ok 13 - is '੧੨੩'.Numeric ok?
    ok 14 - is '੧੨੩'.Int ok?
    ok 15 - is '૧૨૩'.Numeric ok?
    ok 16 - is '૧૨૩'.Int ok?
    ok 17 - is '୧୨୩'.Numeric ok?
    ok 18 - is '୧୨୩'.Int ok?
    ok 19 - is '௧௨௩'.Numeric ok?
    ok 20 - is '௧௨௩'.Int ok?
    ok 21 - is '౧౨౩'.Numeric ok?
    ok 22 - is '౧౨౩'.Int ok?
    ok 23 - is '೧೨೩'.Numeric ok?
    ok 24 - is '೧೨೩'.Int ok?
    ok 25 - is '൧൨൩'.Numeric ok?
    ok 26 - is '൧൨൩'.Int ok?
    ok 27 - is '෧෨෩'.Numeric ok?
    ok 28 - is '෧෨෩'.Int ok?
    ok 29 - is '๑๒๓'.Numeric ok?
    ok 30 - is '๑๒๓'.Int ok?
    ok 31 - is '໑໒໓'.Numeric ok?
    ok 32 - is '໑໒໓'.Int ok?
    ok 33 - is '༡༢༣'.Numeric ok?
    ok 34 - is '༡༢༣'.Int ok?
    1..34
ok 69 - check simple non-ascii numerification
# FUDGED!
1..6
ok 1 - # SKIP postcircumfix:<{ }> not defined for type Array RT  \#125130
ok 2 - # SKIP postcircumfix:<{ }> not defined for type Array RT  \#125130
ok 3 - # SKIP isn't the iterator exhausted already, since it's been used previously?
ok 4 - # SKIP isn't the iterator exhausted already, since it's been used previously?
ok 5 - # SKIP isn't the iterator exhausted already, since it's been used previously?
ok 6 - custom named paras with `-` in identifiers works
# FUDGED!
1..158
ok 1 - 0xffffffff is parsed right (covers bug on 32bit compilers)
ok 2 - got the correct int value from decimal 0
ok 3 - got the correct int value from decimal 1
ok 4 - got the correct int value from decimal 2
ok 5 - got the correct int value from decimal 3
ok 6 - 42 and 0d42 are the same
ok 7 - :10<42> and 42 are the same
ok 8 - :10<42> and 0d42 are the same
ok 9 - :10('01110') is default decimal
ok 10 - :10('0b1110') overrides default decimal
ok 11 - :10(':2<1110>') overrides default decimal
ok 12 - :10('0x20') overrides default decimal
ok 13 - :10(':16<20>') overrides default decimal
ok 14 - :10('0o255') overrides default decimal
ok 15 - :10(':8<255>') overrides default decimal
ok 16 - :10('0d37') overrides default decimal
ok 17 - :10(':10<37>') overrides default decimal
    1..5
    ok 1 - ':10(42)' died
    ok 2 - right exception type (X::Numeric::Confused)
    ok 3 - .message matches /Int/
    ok 4 - .num matches 42
    ok 5 - .base matches 10
ok 18 - :10() really wants a string, not an integer
    1..5
    ok 1 - ':12(42.2)' died
    ok 2 - right exception type (X::Numeric::Confused)
    ok 3 - .num matches 42.2
    ok 4 - .message matches /Rat/
    ok 5 - .base matches 12
ok 19 - :10() really wants a string, not a rational
    1..5
    ok 1 - ':16(6.02e23)' died
    ok 2 - right exception type (X::Numeric::Confused)
    ok 3 - .base matches 16
    ok 4 - .message matches /Num/
    ok 5 - .num matches 6.02e+23
ok 20 - :10() really wants a string, not a num
    1..4
    ok 1 - ':10([1,2,3])' died
    ok 2 - right exception type (X::Numeric::Confused)
    ok 3 - .base matches 10
    ok 4 - .message matches /Array/
ok 21 - :10() really wants a string, not an array
ok 22 - got the correct int value from hex 0
ok 23 - got the correct int value from hex 1
ok 24 - got the correct int value from hex 2
ok 25 - got the correct int value from hex 3
ok 26 - got the correct int value from hex 4
ok 27 - got the correct int value from hex 5
ok 28 - got the correct int value from hex 6
ok 29 - got the correct int value from hex 7
ok 30 - got the correct int value from hex 8
ok 31 - got the correct int value from hex 9
ok 32 - got the correct int value from hex A
ok 33 - got the correct int value from hex B
ok 34 - got the correct int value from hex C
ok 35 - got the correct int value from hex D
ok 36 - got the correct int value from hex E
ok 37 - got the correct int value from hex F
ok 38 - got the correct int value from hex a
ok 39 - got the correct int value from hex b
ok 40 - got the correct int value from hex c
ok 41 - got the correct int value from hex d
ok 42 - got the correct int value from hex e
ok 43 - got the correct int value from hex f
ok 44 - got the correct int value from hex 10
ok 45 - got the correct int value from hex 20
ok 46 - got the correct int value from hex 30
ok 47 - got the correct int value from hex 40
ok 48 - got the correct int value from hex 50
ok 49 - got the correct int value from hex 100
ok 50 - got the correct int value from hex FF
ok 51 - got the correct int value from (mixed case) hex fF
ok 52 - got the correct int value from hex 2_F_A_C_E_D
ok 53 - :16('0b1110') uses b as hex digit
ok 54 - :16('0d37') uses d as hex digit
ok 55 - :16("0d..") is hex, not decimal
ok 56 - :16('0fff') defaults to hexadecimal
ok 57 - :16('0x20') stays hexadecimal
ok 58 - :16('0o255') converts from octal
ok 59 - :16(':8<255>') converts from octal
ok 60 - :16(':2<1110>') overrides default hex
ok 61 - :16(':10<37>') overrides default hex
ok 62 - Powers outside same as powers inside
ok 63 - Zero powers inside
ok 64 - # SKIP RT  \#123862 - negative radix
ok 65 - Fractional base 16 works
ok 66 - got the correct int value from oct 0
ok 67 - got the correct int value from oct 1
ok 68 - got the correct int value from oct 2
ok 69 - got the correct int value from oct 3
ok 70 - got the correct int value from oct 4
ok 71 - got the correct int value from oct 5
ok 72 - got the correct int value from oct 6
ok 73 - got the correct int value from oct 7
ok 74 - got the correct int value from oct 10
ok 75 - got the correct int value from oct 20
ok 76 - got the correct int value from oct 30
ok 77 - got the correct int value from oct 40
ok 78 - got the correct int value from oct 50
ok 79 - got the correct int value from oct 100
ok 80 - got the correct int value from oct 77
ok 81 - got the correct int value from oct 377
ok 82 - got the correct int value from oct 400
ok 83 - got the correct int value from oct 177777
ok 84 - got the correct int value from oct 200000
ok 85 - :8(0b1110) overrides from default octal
ok 86 - :8(:2<1110>) overrides from default octal
ok 87 - :8(0x20) overrides from default octal
ok 88 - :8(:16<20>) overrides from default octal
ok 89 - :8(0o377) stays octal
ok 90 - :8(:8<377>) stays octal
ok 91 - :8(0d37) overrides from default octal
ok 92 - :8(:10<37>) overrides from default octal
ok 93 - got the correct int value from bin 0
ok 94 - got the correct int value from bin 1
ok 95 - got the correct int value from bin 10
ok 96 - got the correct int value from bin 1010
ok 97 - got the correct int value from bin 11111111111111111111111111111111
ok 98 - :2<0b1110> stays binary
ok 99 - :2<0x20> converts from hexadecimal
ok 100 - :2<0o255> converts from octal
ok 101 - :2<0d37> converts from decimal
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Syntax::Malformed)
ok 102 - Ambiguous, illegal syntax doesn't work
ok 103 - binary number to power of 2
ok 104 - multiplication and exponentiation
ok 105 - Power of two in <> works
ok 106 - # SKIP Really?!
ok 107 - List of numbers works
ok 108 - Decimal point in list works
ok 109 - Adverbial form of base 100 integer works
ok 110 - Adverbial form of base 100 fraction works
ok 111 - List of expressions works
not ok 112 - 32bit and 64bit large radix literals work # TODO This needs an RT
# Failed test '32bit and 64bit large radix literals work'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-literals/radix.rakudo line 251
# expected: '18446744073709551617 4294967297'
#      got: '1 4294967297'
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Method::NotFound)
ok 113 - 2.e123 parses as method call
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Method::NotFound)
ok 114 - 2.foo  parses as method call
ok 115 - Leading zeroes stringify correctly
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 116 - :2<2> is illegal
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 117 - :10<3a> is illegal
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Syntax::Number::RadixOutOfRange)
ok 118 - :0<...> is illegal
ok 119 - Adverbial form of base 2 works
ok 120 - Adverbial form of base 3 works
ok 121 - Adverbial form of base 4 works
ok 122 - Adverbial form of base 5 works
ok 123 - Adverbial form of base 6 works
ok 124 - Adverbial form of base 7 works
ok 125 - Adverbial form of base 8 works
ok 126 - Adverbial form of base 9 works
ok 127 - Adverbial form of base 10 works
ok 128 - Adverbial form of base 11 works
ok 129 - Adverbial form of base 12 works
ok 130 - Adverbial form of base 13 works
ok 131 - Adverbial form of base 14 works
ok 132 - Adverbial form of base 15 works
ok 133 - Adverbial form of base 16 works
ok 134 - Adverbial form of base 17 works
ok 135 - Adverbial form of base 18 works
ok 136 - Adverbial form of base 19 works
ok 137 - Adverbial form of base 20 works
ok 138 - Adverbial form of base 21 works
ok 139 - Adverbial form of base 22 works
ok 140 - Adverbial form of base 23 works
ok 141 - Adverbial form of base 24 works
ok 142 - Adverbial form of base 25 works
ok 143 - Adverbial form of base 26 works
ok 144 - Adverbial form of base 27 works
ok 145 - Adverbial form of base 28 works
ok 146 - Adverbial form of base 29 works
ok 147 - Adverbial form of base 30 works
ok 148 - Adverbial form of base 31 works
ok 149 - Adverbial form of base 32 works
ok 150 - Adverbial form of base 33 works
ok 151 - Adverbial form of base 34 works
ok 152 - Adverbial form of base 35 works
ok 153 - Adverbial form of base 36 works
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Numeric::Confused)
ok 154 - :2() is Confused
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Syntax::Malformed)
ok 155 - :2 is Malformed
ok 156 - Unicode digit radix bases work
    1..12
        1..3
        ok 1 - ':3<a11>' died
        ok 2 - right exception type (X::Str::Numeric)
        ok 3 - .pos matches 0
    ok 1 - whole part only, start
        1..3
        ok 1 - ':3<1a1>' died
        ok 2 - right exception type (X::Str::Numeric)
        ok 3 - .pos matches 1
    ok 2 - whole part only, middle
        1..3
        ok 1 - ':3<11a>' died
        ok 2 - right exception type (X::Str::Numeric)
        ok 3 - .pos matches 2
    ok 3 - whole part only, end
        1..3
        ok 1 - ':3<a11.111>' died
        ok 2 - right exception type (X::Str::Numeric)
        ok 3 - .pos matches 0
    ok 4 - with fractional part, error in whole part, start
        1..3
        ok 1 - ':3<1a1.111>' died
        ok 2 - right exception type (X::Str::Numeric)
        ok 3 - .pos matches 1
    ok 5 - with fractional part, error in whole part, middle
        1..3
        ok 1 - ':3<11a.111>' died
        ok 2 - right exception type (X::Str::Numeric)
        ok 3 - .pos matches 2
    ok 6 - with fractional part, error in whole part, end
        1..3
        ok 1 - ':3<111.a11>' died
        ok 2 - right exception type (X::Str::Numeric)
        ok 3 - .pos matches 4
    ok 7 - with fractional part, error in fractional part, start
        1..3
        ok 1 - ':3<111.1a1>' died
        ok 2 - right exception type (X::Str::Numeric)
        ok 3 - .pos matches 5
    ok 8 - with fractional part, error in fractional part, middle
        1..3
        ok 1 - ':3<111.11a>' died
        ok 2 - right exception type (X::Str::Numeric)
        ok 3 - .pos matches 6
    ok 9 - with fractional part, error in fractional part, end
        1..3
        ok 1 - ':3<a11.a11>' died
        ok 2 - right exception type (X::Str::Numeric)
        ok 3 - .pos matches 0
    ok 10 - with fractional part, error in both parts, start
        1..3
        ok 1 - ':3<1a1.1a1>' died
        ok 2 - right exception type (X::Str::Numeric)
        ok 3 - .pos matches 1
    ok 11 - with fractional part, error in both parts, middle
        1..3
        ok 1 - ':3<11a.1a1>' died
        ok 2 - right exception type (X::Str::Numeric)
        ok 3 - .pos matches 2
    ok 12 - with fractional part, error in both parts, end
ok 157 - sane errors on failures to parse rad numbers
    1..10
    ok 1 - bad digit in whole part (1)
    ok 2 - bad digit in whole part (2)
    ok 3 - bad digit in whole part (3)
    ok 4 - bad digit in fractional part (1)
    ok 5 - bad digit in fractional part (2)
    ok 6 - bad digit in fractional part (3)
    ok 7 - bad digit in both parts (1)
    ok 8 - bad digit in both part (2)
    ok 9 - bad digit in both part (3)
    ok 10 - .substr with Num arg does not hang
ok 158 - no hangs in bad digits in rad numbers / in .substr
# FUDGED!
1..31
ok 1 - version literal stringification
ok 2 - version literal stringification
ok 3 - version literal stringification
ok 4 - eqv works on version literals (+)
ok 5 - eqv works on version literals (-)
ok 6 - + makes a difference in eqv
ok 7 - version literals are value types
ok 8 - === (-)
ok 9 - smart-matching (same)
ok 10 - smart-matching (different)
ok 11 - smart-matching treats trailing 0 correctly (left)
ok 12 - smart-matching treats trailing 0 correctly (right)
ok 13 - smart-matching and plus (+1)
ok 14 - smart-matching and plus (+2)
ok 15 - + scopes to the whole version, not just the last chunk
ok 16 - * wildcard (1+)
ok 17 - * wildcard (2+)
ok 18 - * wildcard (-)
ok 19 - smart-matching and plus (-)
ok 20 - smart-matching only cares about the length of the LHS
ok 21 - ... but it can still fail
ok 22 - cmp: Same
ok 23 - cmp: Less
ok 24 - cmp: More
ok 25 - cmp isn't Stringy-based
not ok 26 - trailing zeroes are equivalent # TODO trailing zeroes fail
# Failed test 'trailing zeroes are equivalent'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-literals/version.rakudo line 30
not ok 27 - trailing zeroes are equivalent # TODO trailing zeroes fail
# Failed test 'trailing zeroes are equivalent'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-literals/version.rakudo line 31
not ok 28 - trailing zeroes are equivalent # TODO trailing zeroes fail
# Failed test 'trailing zeroes are equivalent'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-literals/version.rakudo line 32
ok 29 - can we handle empty string versions
ok 30 - can we handle empty string versions
ok 31 - can we handle a bare Whatever
# FUDGED!
1..28
ok 1 - # SKIP unimpl $?DISTRO RT  \#124624
ok 2 - # SKIP unimpl $?DISTRO RT  \#124624
ok 3 - # SKIP unimpl $?DISTRO RT  \#124624
ok 4 - # SKIP unimpl $?DISTRO RT  \#124624
ok 5 - # SKIP unimpl $?DISTRO RT  \#124624
ok 6 - # SKIP unimpl $?DISTRO RT  \#124624
ok 7 - # SKIP unimpl $?DISTRO RT  \#124624
ok 8 - # SKIP unimpl $?DISTRO RT  \#124624
ok 9 - # SKIP unimpl $?DISTRO RT  \#124624
ok 10 - # SKIP unimpl $?DISTRO RT  \#124624
ok 11 - # SKIP unimpl $?DISTRO RT  \#124624
ok 12 - # SKIP unimpl $?DISTRO RT  \#124624
ok 13 - # SKIP unimpl $?DISTRO RT  \#124624
ok 14 - # SKIP unimpl $?DISTRO RT  \#124624
ok 15 - We are running under 'macos'
ok 16 - Authority is 'Apple Inc.'
ok 17 - Version is '11.2'
not ok 18 - Signature is '' # TODO no Distro.signature yet RT #124624
# Failed test 'Signature is '''
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-magicals/DISTRO.rakudo line 46
ok 19 - Description is 'unknown'
ok 20 - Release info is '20D64'
ok 21 - Path separator is ':'
ok 22 - We can do a $*DISTRO.raku
ok 23 - We can do a $*DISTRO.gist
ok 24 - We can do a $*DISTRO.Str
ok 25 - Non-empty $*DISTRO.name
ok 26 - The object is-a 'Version'
ok 27 - The object is-a 'Blob'
ok 28 - The object is-a 'Bool'
# FUDGED!
1..42
ok 1 - # SKIP unimpl $?KERNEL RT  \#124624
ok 2 - # SKIP unimpl $?KERNEL RT  \#124624
ok 3 - # SKIP unimpl $?KERNEL RT  \#124624
ok 4 - # SKIP unimpl $?KERNEL RT  \#124624
ok 5 - # SKIP unimpl $?KERNEL RT  \#124624
ok 6 - # SKIP unimpl $?KERNEL RT  \#124624
ok 7 - # SKIP unimpl $?KERNEL RT  \#124624
ok 8 - # SKIP unimpl $?KERNEL RT  \#124624
ok 9 - # SKIP unimpl $?KERNEL RT  \#124624
ok 10 - # SKIP unimpl $?KERNEL RT  \#124624
ok 11 - # SKIP unimpl $?KERNEL RT  \#124624
ok 12 - # SKIP unimpl $?KERNEL RT  \#124624
ok 13 - # SKIP unimpl $?KERNEL RT  \#124624
ok 14 - # SKIP unimpl $?KERNEL RT  \#124624
ok 15 - # SKIP unimpl $?KERNEL RT  \#124624
ok 16 - # SKIP unimpl $?KERNEL RT  \#124624
ok 17 - We are running under 'darwin'
ok 18 - Authority is 'unknown'
ok 19 - Version is 'Darwin.Kernel.Version.20.3.0.Thu.Jan.21.00.07.06.PST.2021.root.xnu.7195.81.3.1.RELEASE_X.86._.64'
not ok 20 - Signature is '' # TODO no Kernel.signature yet RT #124624
# Failed test 'Signature is '''
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-magicals/KERNEL.rakudo line 38
not ok 21 - Description is '' # TODO no Kernel.desc yet RT #124624
# Failed test 'Description is '''
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-magicals/KERNEL.rakudo line 41
ok 22 - Release info is '20.3.0'
ok 23 - Hardware info is 'x86_64'
ok 24 - Architecture info is 'i386'
ok 25 - Number of bits is '64'
ok 26 - Hostname is 'ookurakaitonoMacBook-Pro-2.local'
ok 27 - We can do a $*KERNEL.raku
ok 28 - We can do a $*KERNEL.gist
ok 29 - We can do a $*KERNEL.Str
ok 30 - We know of the KERNEL we are running under
ok 31 - The object is-a 'Version'
ok 32 - The object is-a 'Blob'
ok 33 - The object is-a 'Int'
ok 34 - did Kernel.signals return a list
ok 35 - do we have Signals only?  and Any's of course
ok 36 - did we get an Int back
ok 37 - was the Int defined
ok 38 - no signal should come out as 0
ok 39 - also ok as string?
ok 40 - also ok as partial string?
ok 41 - also ok as Int?
ok 42 - .signal: Str:D works with un-initialized $*KERNEL.signals
# FUDGED!
1..46
ok 1 - # SKIP unimpl $?PERL RT  \#124624
ok 2 - # SKIP unimpl $?PERL RT  \#124624
ok 3 - # SKIP unimpl $?PERL RT  \#124624
ok 4 - # SKIP unimpl $?PERL RT  \#124624
ok 5 - # SKIP unimpl $?PERL RT  \#124624
ok 6 - # SKIP unimpl $?PERL RT  \#124624
ok 7 - # SKIP unimpl $?PERL RT  \#124624
ok 8 - # SKIP unimpl $?PERL RT  \#124624
ok 9 - # SKIP unimpl $?PERL RT  \#124624
ok 10 - # SKIP unimpl $?PERL RT  \#124624
ok 11 - # SKIP unimpl $?PERL RT  \#124624
ok 12 - # SKIP unimpl $?PERL RT  \#124624
ok 13 - # SKIP unimpl $?PERL RT  \#124624
ok 14 - # SKIP unimpl $?PERL RT  \#124624
ok 15 - # SKIP unimpl $?PERL RT  \#124624
ok 16 - # SKIP unimpl $?PERL RT  \#124624
ok 17 - # SKIP unimpl $?PERL RT  \#124624
ok 18 - # SKIP unimpl $?PERL RT  \#124624
ok 19 - # SKIP unimpl $?PERL RT  \#124624
ok 20 - # SKIP unimpl $?PERL RT  \#124624
ok 21 - # SKIP unimpl $?PERL RT  \#124624
ok 22 - # SKIP unimpl $?PERL RT  \#124624
ok 23 - # SKIP unimpl $?PERL RT  \#124624
ok 24 - We are running under 'Raku'
ok 25 - Authority is 'The Perl Foundation'
ok 26 - Version is '6.d'
not ok 27 - Signature is '' # TODO no Perl.signature yet RT #124624
# Failed test 'Signature is '''
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-magicals/PERL.rakudo line 46
not ok 28 - Description is '' # TODO no Perl.desc yet RT #124624
# Failed test 'Description is '''
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-magicals/PERL.rakudo line 49
ok 29 - Has compiler info
ok 30 - We can do a $*PERL.raku
ok 31 - We can do a $*PERL.gist
ok 32 - We can do a $*PERL.Str
ok 33 - The object is-a 'Version'
ok 34 - The object is-a 'Blob'
ok 35 - The object is-a 'Compiler'
ok 36 - We were compiled in 'rakudo'
ok 37 - Authority is 'The Perl Foundation'
ok 38 - Version is '2020.12.108.g.297.cba.1.a.1'
not ok 39 - Signature is '' # TODO no Perl.compiler.signature yet RT #124624
# Failed test 'Signature is '''
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-magicals/PERL.rakudo line 67
not ok 40 - Description is '' # TODO no Perl.compiler.desc yet RT #124624
# Failed test 'Description is '''
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-magicals/PERL.rakudo line 70
not ok 41 - Release is '' # TODO no Perl.compiler.release yet RT #124624
# Failed test 'Release is '''
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-magicals/PERL.rakudo line 73
not ok 42 - Codename is '' # TODO no Perl.compiler.codename yet RT #124624
# Failed test 'Codename is '''
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-magicals/PERL.rakudo line 76
ok 43 - We can do a $?PERL.compiler.raku
ok 44 - We can do a $?PERL.compiler.gist
ok 45 - The object is-a 'Version'
ok 46 - The object is-a 'Blob'
# FUDGED!
1..46
ok 1 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 2 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 3 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 4 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 5 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 6 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 7 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 8 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 9 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 10 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 11 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 12 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 13 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 14 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 15 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 16 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 17 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 18 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 19 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 20 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 21 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 22 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 23 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 24 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 25 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 26 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 27 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 28 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 29 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 30 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 31 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 32 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 33 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 34 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 35 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 36 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 37 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 38 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 39 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 40 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 41 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 42 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 43 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 44 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 45 - # SKIP $*RAKU and $?RAKU aren't implemented yet
ok 46 - # SKIP $*RAKU and $?RAKU aren't implemented yet
# FUDGED!
1..32
ok 1 - # SKIP unimpl $?VM
1..18
ok 1 - %*ENV has keys
ok 2 - %*ENV was successfully copied into another variable
ok 3 - modifying a copy of %*ENV didn't affect the environment
ok 4 - there's no env variable 'PUGS_ROCKS'
ok 5 - there's still no env variable 'PUGS_ROCKS'
ok 6 - %*ENV is rw
ok 7 - We can remove keys from %*ENV
ok 8 - exists() returns false on a not defined env var
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Undeclared)
ok 9 - %ENV not visible by default
ok 10 - # SKIP import fails, ENV not available: RT  \#122339
ok 11 - %ENV not visible by after lexical import scope
ok 12 - non-existing vars are undefined
ok 13 - non-existing vars do not exist
ok 14 - ENV members persist to child processes
ok 15 - %*ENV.gist generates something with ABC in it
ok 16 - %*ENV.raku generates something with ABC in it
ok 17 - itemizer works on %*ENV.
Welcome to Rakudo(tm) v2020.12-108-g297cba1a1.
Implementing the Raku(tm) programming language v6.d.
Built on MoarVM version 2020.12-90-g1082d8893.
ok 18 - call run($command) after setting non-strings into %*ENV does not die
# FUDGED!
1..156
ok 1 - basic variable name
ok 2 - variable name with package
ok 3 - # SKIP package variable autovivification
ok 4 - variable name with 2 deep package
ok 5 - # SKIP package variable autovivification
ok 6 - variable name with a package name partially given by a variable 
ok 7 - variable name with package name completely given by variable
ok 8 - simple variable lookup
ok 9 - # SKIP this kind of lookup NYI RT  \#125659
ok 10 - variable lookup using ::{'$foo'}
ok 11 - # SKIP this kind of lookup NYI RT  \#125659
ok 12 - variable lookup using ::<$foo>
ok 13 - # SKIP ::{ } package lookup NYI
ok 14 - # SKIP ::{ } package lookup NYI
ok 15 - # SKIP ::{ } package lookup NYI
ok 16 - # SKIP ::{ } package lookup NYI
ok 17 - A::_b() call works
ok 18 - :: is a valid PseudoStash
    1..2
    ok 1 - 'OscarMikeGolf::whiskey_tango_foxtrot()' died
    ok 2 - right exception type (Exception)
ok 19 - dies when calling non-existent sub in non-existent package
    1..2
    ok 1 - 'Test::bravo_bravo_quebec()' died
    ok 2 - right exception type (Exception)
ok 20 - dies when calling non-existent sub in existing package
    1..2
    ok 1 - 'TestA::frobnosticate(3, :foo)' died
    ok 2 - right exception type (Exception)
ok 21 - calling non-existing function in foreign class dies
ok 22 - can define and call a sub self()
ok 23 - sub named "foo" called with parentheses
ok 24 - sub whose name starts with "foo-"
ok 25 - sub whose name starts with "foo'"
ok 26 - sub named "package" called with parentheses
ok 27 - sub whose name starts with "package-"
ok 28 - sub whose name starts with "package'"
ok 29 - sub named "module" called with parentheses
ok 30 - sub whose name starts with "module-"
ok 31 - sub whose name starts with "module'"
ok 32 - sub named "class" called with parentheses
ok 33 - sub whose name starts with "class-"
ok 34 - sub whose name starts with "class'"
ok 35 - sub named "role" called with parentheses
ok 36 - sub whose name starts with "role-"
ok 37 - sub whose name starts with "role'"
ok 38 - sub named "grammar" called with parentheses
ok 39 - sub whose name starts with "grammar-"
ok 40 - sub whose name starts with "grammar'"
ok 41 - sub named "my" called with parentheses
ok 42 - sub whose name starts with "my-"
ok 43 - sub whose name starts with "my'"
ok 44 - sub named "our" called with parentheses
ok 45 - sub whose name starts with "our-"
ok 46 - sub whose name starts with "our'"
ok 47 - sub named "state" called with parentheses
ok 48 - sub whose name starts with "state-"
ok 49 - sub whose name starts with "state'"
ok 50 - sub named "let" called with parentheses
ok 51 - sub whose name starts with "let-"
ok 52 - sub whose name starts with "let'"
ok 53 - sub named "temp" called with parentheses
ok 54 - sub whose name starts with "temp-"
ok 55 - sub whose name starts with "temp'"
ok 56 - sub named "has" called with parentheses
ok 57 - sub whose name starts with "has-"
ok 58 - sub whose name starts with "has'"
ok 59 - sub named "augment" called with parentheses
ok 60 - sub whose name starts with "augment-"
ok 61 - sub whose name starts with "augment'"
ok 62 - sub named "anon" called with parentheses
ok 63 - sub whose name starts with "anon-"
ok 64 - sub whose name starts with "anon'"
ok 65 - sub named "supersede" called with parentheses
ok 66 - sub whose name starts with "supersede-"
ok 67 - sub whose name starts with "supersede'"
ok 68 - sub named "sub" called with parentheses
ok 69 - sub whose name starts with "sub-"
ok 70 - sub whose name starts with "sub'"
ok 71 - sub named "method" called with parentheses
ok 72 - sub whose name starts with "method-"
ok 73 - sub whose name starts with "method'"
ok 74 - sub named "submethod" called with parentheses
ok 75 - sub whose name starts with "submethod-"
ok 76 - sub whose name starts with "submethod'"
ok 77 - sub named "macro" called with parentheses
ok 78 - sub whose name starts with "macro-"
ok 79 - sub whose name starts with "macro'"
ok 80 - sub named "multi" called with parentheses
ok 81 - sub whose name starts with "multi-"
ok 82 - sub whose name starts with "multi'"
ok 83 - sub named "proto" called with parentheses
ok 84 - sub whose name starts with "proto-"
ok 85 - sub whose name starts with "proto'"
ok 86 - sub named "only" called with parentheses
ok 87 - sub whose name starts with "only-"
ok 88 - sub whose name starts with "only'"
ok 89 - sub named "regex" called with parentheses
ok 90 - sub whose name starts with "regex-"
ok 91 - sub whose name starts with "regex'"
ok 92 - sub named "token" called with parentheses
ok 93 - sub whose name starts with "token-"
ok 94 - sub whose name starts with "token'"
ok 95 - sub named "rule" called with parentheses
ok 96 - sub whose name starts with "rule-"
ok 97 - sub whose name starts with "rule'"
ok 98 - sub named "constant" called with parentheses
ok 99 - sub whose name starts with "constant-"
ok 100 - sub whose name starts with "constant'"
ok 101 - sub named "enum" called with parentheses
ok 102 - sub whose name starts with "enum-"
ok 103 - sub whose name starts with "enum'"
ok 104 - sub named "subset" called with parentheses
ok 105 - sub whose name starts with "subset-"
ok 106 - sub whose name starts with "subset'"
ok 107 - sub named "if" called with parentheses
ok 108 - sub whose name starts with "if-"
ok 109 - sub whose name starts with "if'"
ok 110 - sub named "unless" called with parentheses
ok 111 - sub whose name starts with "unless-"
ok 112 - sub whose name starts with "unless'"
ok 113 - sub named "while" called with parentheses
ok 114 - sub whose name starts with "while-"
ok 115 - sub whose name starts with "while'"
ok 116 - sub named "repeat" called with parentheses
ok 117 - sub whose name starts with "repeat-"
ok 118 - sub whose name starts with "repeat'"
ok 119 - sub named "for" called with parentheses
ok 120 - sub whose name starts with "for-"
ok 121 - sub whose name starts with "for'"
ok 122 - sub named "foreach" called with parentheses
ok 123 - sub whose name starts with "foreach-"
ok 124 - sub whose name starts with "foreach'"
ok 125 - sub named "loop" called with parentheses
ok 126 - sub whose name starts with "loop-"
ok 127 - sub whose name starts with "loop'"
ok 128 - sub named "given" called with parentheses
ok 129 - sub whose name starts with "given-"
ok 130 - sub whose name starts with "given'"
ok 131 - sub named "when" called with parentheses
ok 132 - sub whose name starts with "when-"
ok 133 - sub whose name starts with "when'"
ok 134 - sub named "default" called with parentheses
ok 135 - sub whose name starts with "default-"
ok 136 - sub whose name starts with "default'"
ok 137 - local terms override quoters
ok 138 - local subs override quoters
ok 139 - rule => something creates a Pair
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Undeclared::Symbols)
ok 140 - error message mentions name not recognized, no maximum recursion depth exceeded
ok 141 - class names can start with Q
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Redeclaration)
ok 142 - can *not* redefine a class in EVAL -- classes are package scoped
ok 143 - can call a class Class
    1..2
    ok 1 - 'my ::foo $x, say $x' died
    ok 2 - right exception type (Exception)
ok 144 - no Null PMC access when printing a variable typed as ::foo 
ok 145 - when enum and sub Day exported, Day(0) is enum coercer
ok 146 - can get sub using & to disamgibuate
ok 147 - when module and sub foo, bare foo is module type object
ok 148 - when module and sub foo, foo() is coercion type
ok 149 - can get sub using & to disambiguate
    1..2
    ok 1 - variable lookup
    ok 2 - literal lookup
ok 150 - can use compile-time variables in names
ok 151 - properly short name Metamodel instances
ok 152 - properly short name Metamodel instances with braces
ok 153 - properly short name Metamodel instances with colons and braces
ok 154 - properly short name Metamodel instances with braces and commas
ok 155 - properly short name Metamodel instances with colons, braces, and commas
ok 156 - properly short name Metamodel instances with nested colons, braces, and commas
# FUDGED!
1..116
ok 1 - ("42").raku returned something whose EVAL()ed stringification is unchanged
ok 2 - ("42").raku returned something whose EVAL()ed .WHAT is unchanged
ok 3 - ("4.2").raku returned something whose EVAL()ed stringification is unchanged
ok 4 - ("4.2").raku returned something whose EVAL()ed .WHAT is unchanged
ok 5 - ("4.2").raku returned something whose EVAL()ed stringification is unchanged
ok 6 - ("4.2").raku returned something whose EVAL()ed .WHAT is unchanged
ok 7 - ("1.4142135623730951").raku returned something whose EVAL()ed stringification is unchanged
ok 8 - ("1.4142135623730951").raku returned something whose EVAL()ed .WHAT is unchanged
ok 9 - ("300000").raku returned something whose EVAL()ed stringification is unchanged
ok 10 - ("300000").raku returned something whose EVAL()ed .WHAT is unchanged
ok 11 - ("Inf").raku returned something whose EVAL()ed stringification is unchanged
ok 12 - ("Inf").raku returned something whose EVAL()ed .WHAT is unchanged
ok 13 - ("-Inf").raku returned something whose EVAL()ed stringification is unchanged
ok 14 - ("-Inf").raku returned something whose EVAL()ed .WHAT is unchanged
ok 15 - ("NaN").raku returned something whose EVAL()ed stringification is unchanged
ok 16 - ("NaN").raku returned something whose EVAL()ed .WHAT is unchanged
ok 17 - ("a string").raku returned something whose EVAL()ed stringification is unchanged
ok 18 - ("a string").raku returned something whose EVAL()ed .WHAT is unchanged
ok 19 - ("").raku returned something whose EVAL()ed stringification is unchanged
ok 20 - ("").raku returned something whose EVAL()ed .WHAT is unchanged
ok 21 - ("\0").raku returned something whose EVAL()ed stringification is unchanged
ok 22 - ("\0").raku returned something whose EVAL()ed .WHAT is unchanged
ok 23 - ("\t").raku returned something whose EVAL()ed stringification is unchanged
ok 24 - ("\t").raku returned something whose EVAL()ed .WHAT is unchanged
ok 25 - ("␤").raku returned something whose EVAL()ed stringification is unchanged
ok 26 - ("␤").raku returned something whose EVAL()ed .WHAT is unchanged
ok 27 - ("␤").raku returned something whose EVAL()ed stringification is unchanged
ok 28 - ("␤").raku returned something whose EVAL()ed .WHAT is unchanged
ok 29 - ("\x[7]").raku returned something whose EVAL()ed stringification is unchanged
ok 30 - ("\x[7]").raku returned something whose EVAL()ed .WHAT is unchanged
ok 31 - ("\{").raku returned something whose EVAL()ed stringification is unchanged
ok 32 - ("\{").raku returned something whose EVAL()ed .WHAT is unchanged
ok 33 - ("}").raku returned something whose EVAL()ed stringification is unchanged
ok 34 - ("}").raku returned something whose EVAL()ed .WHAT is unchanged
ok 35 - ("\$a \@string \%with \&sigils()").raku returned something whose EVAL()ed stringification is unchanged
ok 36 - ("\$a \@string \%with \&sigils()").raku returned something whose EVAL()ed .WHAT is unchanged
ok 37 - ("שלום").raku returned something whose EVAL()ed stringification is unchanged
ok 38 - ("שלום").raku returned something whose EVAL()ed .WHAT is unchanged
ok 39 - ("True").raku returned something whose EVAL()ed stringification is unchanged
ok 40 - ("True").raku returned something whose EVAL()ed .WHAT is unchanged
ok 41 - ("False").raku returned something whose EVAL()ed stringification is unchanged
ok 42 - ("False").raku returned something whose EVAL()ed .WHAT is unchanged
ok 43 - ("").raku returned something whose EVAL()ed stringification is unchanged
ok 44 - ("").raku returned something whose EVAL()ed .WHAT is unchanged
ok 45 - ("").raku returned something whose EVAL()ed stringification is unchanged
ok 46 - ("").raku returned something whose EVAL()ed .WHAT is unchanged
ok 47 - ("").raku returned something whose EVAL()ed stringification is unchanged
ok 48 - ("").raku returned something whose EVAL()ed .WHAT is unchanged
ok 49 - ("42").raku returned something whose EVAL()ed stringification is unchanged
ok 50 - ("42").raku returned something whose EVAL()ed .WHAT is unchanged
ok 51 - ("Inf").raku returned something whose EVAL()ed stringification is unchanged
ok 52 - ("Inf").raku returned something whose EVAL()ed .WHAT is unchanged
ok 53 - ("-Inf").raku returned something whose EVAL()ed stringification is unchanged
ok 54 - ("-Inf").raku returned something whose EVAL()ed .WHAT is unchanged
ok 55 - ("NaN").raku returned something whose EVAL()ed stringification is unchanged
ok 56 - ("NaN").raku returned something whose EVAL()ed .WHAT is unchanged
ok 57 - ("string").raku returned something whose EVAL()ed stringification is unchanged
ok 58 - ("string").raku returned something whose EVAL()ed .WHAT is unchanged
ok 59 - ("").raku returned something whose EVAL()ed stringification is unchanged
ok 60 - ("").raku returned something whose EVAL()ed .WHAT is unchanged
ok 61 - ("True").raku returned something whose EVAL()ed stringification is unchanged
ok 62 - ("True").raku returned something whose EVAL()ed .WHAT is unchanged
ok 63 - ("False").raku returned something whose EVAL()ed stringification is unchanged
ok 64 - ("False").raku returned something whose EVAL()ed .WHAT is unchanged
ok 65 - ("").raku returned something whose EVAL()ed stringification is unchanged
ok 66 - ("").raku returned something whose EVAL()ed .WHAT is unchanged
ok 67 - ("a\t1").raku returned something whose EVAL()ed stringification is unchanged
ok 68 - ("a\t1").raku returned something whose EVAL()ed .WHAT is unchanged
ok 69 - ("b\t2").raku returned something whose EVAL()ed stringification is unchanged
ok 70 - ("b\t2").raku returned something whose EVAL()ed .WHAT is unchanged
ok 71 - ("").raku returned something whose EVAL()ed stringification is unchanged
ok 72 - ("").raku returned something whose EVAL()ed .WHAT is unchanged
ok 73 - ("a\t42").raku returned something whose EVAL()ed stringification is unchanged
ok 74 - ("a\t42").raku returned something whose EVAL()ed .WHAT is unchanged
ok 75 - ("a\t1␤b\t2\nc\t3").raku returned something whose EVAL()ed stringification is unchanged
ok 76 - ("a\t1␤b\t2\nc\t3").raku returned something whose EVAL()ed .WHAT is unchanged
ok 77 - ("a\t1 2 3").raku returned something whose EVAL()ed stringification is unchanged
ok 78 - ("a\t1 2 3").raku returned something whose EVAL()ed .WHAT is unchanged
ok 79 - ("a\t1 2 3␤b\t4 5 6").raku returned something whose EVAL()ed stringification is unchanged
ok 80 - ("a\t1 2 3␤b\t4 5 6").raku returned something whose EVAL()ed .WHAT is unchanged
ok 81 - ("a\t1 b\t2␤c\t3").raku returned something whose EVAL()ed stringification is unchanged
ok 82 - ("a\t1 b\t2␤c\t3").raku returned something whose EVAL()ed .WHAT is unchanged
ok 83 - ("a b c").raku returned something whose EVAL()ed stringification is unchanged
ok 84 - ("a b c").raku returned something whose EVAL()ed .WHAT is unchanged
ok 85 - basic recursive hashitem
ok 86 - .raku worked correctly on a recursive hashitem
ok 87 - mixed arrayitem/hashitem recursive structure
ok 88 - .raku worked correctly on a mixed arrayitem/hashitem recursive structure
(my \Bug_140366062991472 = Bug.new(myself => [Bug_140366062991472]))
ok 89 - survived saying a self-referencing object
(my \Location_140366062991632 = Location.new(items => Array[Item].new(Item.new(loc => Location_140366062991632))))
ok 90 - survived saying two mutually referencing objects
ok 91 - .raku on a .keys list
ok 92 - changing object changes .raku output
ok 93 - attribute value appears in .raku output
ok 94 - .raku on user-defined type roundtrips okay
ok 95 - .raku on float with many digits roundtrips okay
ok 96 - can assign list with new hash element to itself
ok 97 - can take .raku from hash element
ok 98 - hoa does not refer to hash element
ok 99 - can .raku on .HOW
ok 100 - # SKIP RT  \#67790
ok 101 - 1.0 is Rat
ok 102 - 1.0 perl'd and EVAL'd is Rat
ok 103 - .raku in .grep works - type
ok 104 - .raku in .grep works - number of elems
ok 105 - .raku in .grep works - element equality
ok 106 - .raku in .grep works - type
ok 107 - .raku in .grep works - number of elems
ok 108 - .raku in .grep works - element equality
ok 109 - 
ok 110 - 100.chr.raku - lives
ok 111 - .raku on latin character
ok 112 - 780.chr.raku - lives
ok 113 - .raku on composing character
ok 114 - .raku on string with combining char on a non-printable - lives
ok 115 - .raku on string with combining char on a non-printable - roundtrips
ok 116 - non-combining start does not need escaping
# FUDGED!
1..29
ok 1 - $! can be declared again
ok 2 - as can $/
ok 3 - S05: Raku's $/ variable may not be assigned to directly.
ok 4 - $! can be declared again if proto is used though
ok 5 - as can $/
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 6 - normal varnames can't have ! in their name
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Syntax::Confused)
ok 7 - var names can't have double colons in their adverb
    1..3
    ok 1 - 'my Int a = 10;' died
    ok 2 - right exception type (X::Syntax::Malformed)
    ok 3 - .message matches / sigilless /
ok 8 - did we throws-like X::Syntax::Malformed?
    1..3
    ok 1 - 'my Int a;' died
    ok 2 - right exception type (X::Syntax::Malformed)
    ok 3 - .message matches / sigilless /
ok 9 - did we throws-like X::Syntax::Malformed?
    1..3
    ok 1 - 'my a = 10;' died
    ok 2 - right exception type (X::Syntax::Malformed)
    ok 3 - .message matches / sigilless /
ok 10 - did we throws-like X::Syntax::Malformed?
    1..3
    ok 1 - 'my a;' died
    ok 2 - right exception type (X::Syntax::Malformed)
    ok 3 - .message matches / sigilless /
ok 11 - did we throws-like X::Syntax::Malformed?
not ok 12 - Aliasing of $0 into $/ (1) # TODO cannot easily override [] at the moment
# Failed test 'Aliasing of $0 into $/ (1)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names-vars/varnames.rakudo line 43
# expected: 'foo0'
#      got: 'MyMatch<140306682388064>'
not ok 13 - Aliasing of $0 into $/ (2) # TODO cannot easily override [] at the moment
# Failed test 'Aliasing of $0 into $/ (2)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names-vars/varnames.rakudo line 44
# expected: 'foo4'
#      got: (Failure)
ok 14 - with <> def, multiple adverbs allowed on end, canonicalizing < >
ok 15 - with <> def, multiple adverbs allowed on end, canonicalizing « »
ok 16 - with <> def, multiple adverbs allowed on end, canonicalizing [ ]
ok 17 - with <> def, multiple adverbs allowed on end, canonicalizing [ ]
ok 18 - with «» def, multiple adverbs allowed on end, canonicalizing < >
ok 19 - with «» def, multiple adverbs allowed on end, canonicalizing « »
ok 20 - with «» def, multiple adverbs allowed on end, canonicalizing [ ]
ok 21 - with «» def, multiple adverbs allowed on end, canonicalizing [ ]
ok 22 - with [] def, multiple adverbs allowed on end, canonicalizing < >
ok 23 - with [] def, multiple adverbs allowed on end, canonicalizing « »
ok 24 - with [] def, multiple adverbs allowed on end, canonicalizing [ ]
ok 25 - with [] def, multiple adverbs allowed on end, canonicalizing [ ]
ok 26 - with () def, multiple adverbs allowed on end, canonicalizing < >
ok 27 - with () def, multiple adverbs allowed on end, canonicalizing « »
ok 28 - with () def, multiple adverbs allowed on end, canonicalizing [ ]
ok 29 - with () def, multiple adverbs allowed on end, canonicalizing [ ]
# FUDGED!
1..6
ok 1 - SETTING:: works
ok 2 - ::("SETTING") works
ok 3 - # SKIP NYI
ok 4 - # SKIP NYI
ok 5 - # SKIP NYI
ok 6 - # SKIP NYI
# FUDGED!
1..12
ok 1 - basic $CALLER:: works
ok 2 - $CALLER:: with nested subs works
ok 3 - $CALLER::CALLER:: is recalculated on each access (1)
ok 4 - $CALLER::CALLER:: is recalculated on each access (2)
ok 5 - vars not declared "is dynamic" are not accessible via $CALLER::
ok 6 - "is dynamic" vars are rw in the creating scope (1)
ok 7 - "is dynamic" vars are rw in the creating scope (2)
ok 8 - # SKIP ::= NYI
ok 9 - "is dynamic" vars declared "is rw" are rw when accessed with $CALLER:: (2)
ok 10 - $DYNAMIC:: searches call stack
ok 11 - rebinding $CALLER:: variables works (2)
ok 12 - rebinding $CALLER:: variables works (3)
# FUDGED!
1..187
ok 1 - uninitialized untyped variable should have its default
ok 2 - is the default set correctly for $a
ok 3 - should be able to update untyped variable
ok 4 - update of untyped variable to 43 was successful
ok 5 - should be able to assign Nil to untyped variable
ok 6 - untyped variable returned to its default with Nil
ok 7 - should be able to update untyped variable
ok 8 - update of untyped variable to 314 was successful
ok 9 - untyped variable should be initialized
ok 10 - is the default set correctly for $b
ok 11 - is the default set correctly for $c
ok 12 - should be able to increment untyped variable
ok 13 - untyped variable should be incremented
ok 14 - should be able to assign Nil to untyped variable
ok 15 - is the default value correctly reset for $c
ok 16 - untyped variable should be initialized
ok 17 - is the default set correctly for $d
ok 18 - uninitialized untyped attribute should have its default
ok 19 - is the default set correctly for $!a
ok 20 - should be able to update untyped attribute
ok 21 - update of untyped attribute to 43 was successful
ok 22 - should be able to assign Nil to untyped attribute
ok 23 - untyped attribute returned to its default with Nil
ok 24 - should be able to update untyped attribute
ok 25 - update of untyped attribute to 314 was successful
ok 26 - untyped attribute should be initialized
ok 27 - is the default set correctly for $!b
ok 28 - is the default set correctly for $!c
ok 29 - should be able to increment untyped attribute
ok 30 - untyped attribute should be incremented
ok 31 - should be able to assign Nil to untyped attribute
ok 32 - is the default value correctly reset for $!c
ok 33 - untyped attribute should be initialized
ok 34 - is the default set correctly for $!d
ok 35 - is default() works on a group of variables too (1)
ok 36 - is default() works on a group of variables too (2)
ok 37 - is default on attributes: basic sanity
ok 38 - is default on attributes applies to all in a list
ok 39 - uninitialized typed variable should have its default
ok 40 - is the default set correctly for Int $a
ok 41 - should be able to update typed variable
ok 42 - update of typed variable to 43 was successful
ok 43 - should be able to assign Nil to typed variable
ok 44 - typed variable returned to its default with Nil
ok 45 - should be able to update typed variable
ok 46 - update of typed variable to 314 was successful
ok 47 - typed variable should be initialized
ok 48 - is the default set correctly for Int $b
ok 49 - uninitialized typed attribute should have its default
ok 50 - is the default set correctly for Int $!a
ok 51 - should be able to update typed attribute
ok 52 - update of typed attribute to 43 was successful
ok 53 - should be able to assign Nil to typed attribute
ok 54 - typed attribute returned to its default with Nil
ok 55 - should be able to update typed attribute
ok 56 - update of typed attribute to 314 was successful
ok 57 - typed attribute should be initialized
ok 58 - is the default set correctly for Int $!b
ok 59 - uninitialized untyped array element should have its default
ok 60 - is the default set correctly for @a
ok 61 - should be able to update untyped array element
ok 62 - update of untyped array element to 43 was successful
ok 63 - assign Nil to untyped array element
ok 64 - untyped array element returned to its default with Nil
ok 65 - should be able to update untyped array element
ok 66 - update of untyped array element to 314 was successful
ok 67 - untyped array element should be initialized
ok 68 - is the default set correctly for @b
ok 69 - is the default set correctly for @c
ok 70 - should be able to increment untyped variable
ok 71 - untyped variable should be incremented
ok 72 - able to assign Nil to untyped variable
ok 73 - is the default value correctly reset for @c[0]
ok 74 - untyped variable should be initialized
ok 75 - is the default set correctly for @d
ok 76 - uninitialized untyped attrib element should have its default
ok 77 - is the default set correctly for @!a
ok 78 - should be able to update untyped attrib element
ok 79 - update of untyped attrib element to 43 was successful
ok 80 - assign Nil to untyped attrib element
ok 81 - untyped attrib element returned to its default with Nil
ok 82 - should be able to update untyped attrib element
ok 83 - update of untyped attrib element to 314 was successful
ok 84 - untyped attrib element should be initialized
ok 85 - is the default set correctly for @!b
ok 86 - is the default set correctly for @!c
ok 87 - should be able to increment untyped variable
ok 88 - untyped variable should be incremented
ok 89 - able to assign Nil to untyped variable
ok 90 - is the default value correctly reset for @!c[0]
ok 91 - untyped variable should be initialized
ok 92 - is the default set correctly for @!d
ok 93 - uninitialized typed array element should have its default
ok 94 - is the default set correctly for Int @a
ok 95 - should be able to update typed array element
ok 96 - update of typed array element to 43 was successful
ok 97 - assign Nil to typed array element
ok 98 - typed array element returned to its default with Nil
ok 99 - should be able to update typed array element
ok 100 - update of typed array element to 314 was successful
ok 101 - typed array element should be initialized
ok 102 - is the default set correctly for Int @b
ok 103 - uninitialized typed attrib element should have its default
ok 104 - is the default set correctly for Int @!a
ok 105 - should be able to update typed attrib element
ok 106 - update of typed attrib element to 43 was successful
ok 107 - assign Nil to typed attrib element
ok 108 - typed attrib element returned to its default with Nil
ok 109 - should be able to update typed attrib element
ok 110 - update of typed attrib element to 314 was successful
ok 111 - typed attrib element should be initialized
ok 112 - is the default set correctly for Int @!b
ok 113 - uninitialized untyped hash element should have its default
ok 114 - is the default set correctly for %a
ok 115 - should be able to update untyped hash element
ok 116 - update of untyped hash element to 43 was successful
ok 117 - assign Nil to untyped hash element
ok 118 - untyped hash element returned to its default with Nil
ok 119 - should be able to update untyped hash element
ok 120 - update of untyped hash element to 314 was successful
ok 121 - untyped hash element should be initialized
ok 122 - is the default set correctly for %b
ok 123 - is the default set correctly for %c
ok 124 - should be able to increment untyped variable
ok 125 - untyped variable should be incremented
ok 126 - able to assign Nil to untyped variable
ok 127 - is the default value correctly reset for %c<o>
ok 128 - untyped variable should be initialized
ok 129 - is the default set correctly for %d
ok 130 - uninitialized untyped attrib hash element should have its default
ok 131 - is the default set correctly for %!a
ok 132 - should be able to update untyped attrib hash element
ok 133 - update of untyped attrib hash element to 43 was successful
ok 134 - assign Nil to untyped attrib hash element
ok 135 - untyped attrib hash element returned to its default with Nil
ok 136 - should be able to update untyped attrib hash element
ok 137 - update of untyped attrib hash element to 314 was successful
ok 138 - untyped attrib hash element should be initialized
ok 139 - is the default set correctly for %!b
ok 140 - is the default set correctly for %!c
ok 141 - should be able to increment untyped attrib hash element
ok 142 - untyped attrib hash element should be incremented
ok 143 - able to assign Nil to untyped attrib hash element
ok 144 - is the default value correctly reset for %!c<o>
ok 145 - untyped attrib hash element should be initialized
ok 146 - is the default set correctly for %!d
ok 147 - uninitialized typed hash element should have its default
ok 148 - is the default set correctly for Int %a
ok 149 - should be able to update typed hash element
ok 150 - update of hash array element to 43 was successful
ok 151 - assign Nil to hash array element
ok 152 - typed hash element returned to its default with Nil
ok 153 - should be able to update typed hash element
ok 154 - update of typed hash element to 314 was successful
ok 155 - typed hash element should be initialized
ok 156 - is the default set correctly for Int %b
ok 157 - uninitialized type attrib hash element should have its default
ok 158 - is the default set correctly for Int %!a
ok 159 - should be able to update type attrib hash element
ok 160 - update of hash array element to 43 was successful
ok 161 - assign Nil to hash array element
ok 162 - type attrib hash element returned to its default with Nil
ok 163 - should be able to update type attrib hash element
ok 164 - update of type attrib hash element to 314 was successful
ok 165 - type attrib hash element should be initialized
ok 166 - is the default set correctly for Int %!b
    1..4
    ok 1 - 'my Int $a is default("foo")' died
    ok 2 - right exception type (X::Parameter::Default::TypeCheck)
    ok 3 - .expected matches (Int)
    ok 4 - .got matches foo
ok 167 - did we throws-like X::Parameter::Default::TypeCheck?
    1..4
    ok 1 - 'my Int $a is default(Nil)' died
    ok 2 - right exception type (X::Parameter::Default::TypeCheck)
    ok 3 - .got matches Nil
    ok 4 - .expected matches (Int)
ok 168 - did we throws-like X::Parameter::Default::TypeCheck?
    1..4
    ok 1 - 'my Int @a is default("foo")' died
    ok 2 - right exception type (X::Parameter::Default::TypeCheck)
    ok 3 - .expected matches (Array[Int])
    ok 4 - .got matches foo
ok 169 - did we throws-like X::Parameter::Default::TypeCheck?
    1..4
    ok 1 - 'my Int @a is default(Nil)' died
    ok 2 - right exception type (X::Parameter::Default::TypeCheck)
    ok 3 - .expected matches (Array[Int])
    ok 4 - .got matches Nil
ok 170 - did we throws-like X::Parameter::Default::TypeCheck?
    1..4
    ok 1 - 'my Int %a is default("foo")' died
    ok 2 - right exception type (X::Parameter::Default::TypeCheck)
    ok 3 - .got matches foo
    ok 4 - .expected matches (Hash[Int])
ok 171 - did we throws-like X::Parameter::Default::TypeCheck?
    1..4
    ok 1 - 'my Int %a is default(Nil)' died
    ok 2 - right exception type (X::Parameter::Default::TypeCheck)
    ok 3 - .got matches Nil
    ok 4 - .expected matches (Hash[Int])
ok 172 - did we throws-like X::Parameter::Default::TypeCheck?
    1..4
    ok 1 - 'class IntFoo { has Int $!a is default("foo") }' died
    not ok 2 - right exception type (X::Parameter::Default::TypeCheck) # TODO LTA wrong kind of exception
    # Failed test 'right exception type (X::Parameter::Default::TypeCheck)'
    # at SETTING::src/core.c/Exception.pm6 line 71
    # Expected: X::Parameter::Default::TypeCheck
    # Got:      X::TypeCheck::Assignment+{X::Comp}
    # Exception message: Type check failed in assignment to $!a; expected Int but got Str ("foo")
    ok 3 - # SKIP wrong exception type
    ok 4 - # SKIP wrong exception type
not ok 173 - did we throws-like X::Parameter::Default::TypeCheck? # TODO LTA wrong kind of exception
# Failed test 'did we throws-like X::Parameter::Default::TypeCheck?'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names/is_default.rakudo line 346
    1..4
    ok 1 - 'class IntNil { has Int $!a is default(Nil) }' died
    not ok 2 - right exception type (X::Parameter::Default::TypeCheck) # TODO LTA wrong kind of exception
    # Failed test 'right exception type (X::Parameter::Default::TypeCheck)'
    # at SETTING::src/core.c/Exception.pm6 line 71
    # Expected: X::Parameter::Default::TypeCheck
    # Got:      X::TypeCheck::Assignment+{X::Comp}
    # Exception message: Type check failed in assignment to $!a; expected Int but got Nil (Nil)
    ok 3 - # SKIP wrong exception type
    ok 4 - # SKIP wrong exception type
not ok 174 - did we throws-like X::Parameter::Default::TypeCheck? # TODO LTA wrong kind of exception
# Failed test 'did we throws-like X::Parameter::Default::TypeCheck?'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names/is_default.rakudo line 350
    1..4
    ok 1 - 'my int $a is default(42)' died
    ok 2 - right exception type (X::Comp::Trait::NotOnNative)
    ok 3 - .subtype matches default
    ok 4 - .type matches is
ok 175 - did we throws-like X::Comp::Trait::NotOnNative?
    1..4
    ok 1 - 'my int @a is default(42)' died
    ok 2 - right exception type (X::Comp::Trait::NotOnNative)
    ok 3 - .type matches is
    ok 4 - .subtype matches default
ok 176 - did we throws-like X::Comp::Trait::NotOnNative?
    1..4
    ok 1 - 'my int %a is default(42)' died
    not ok 2 - right exception type (X::Comp::Trait::NotOnNative) # TODO fails first on native int hashes being NYI
    # Failed test 'right exception type (X::Comp::Trait::NotOnNative)'
    # at SETTING::src/core.c/Exception.pm6 line 62
    # Expected: X::Comp::Trait::NotOnNative
    # Got:      X::Comp::NYI
    # Exception message: native value types for hashes not yet implemented. Sorry.
    ok 3 - # SKIP wrong exception type
    ok 4 - # SKIP wrong exception type
not ok 177 - did we throws-like X::Comp::Trait::NotOnNative? # TODO fails first on native int hashes being NYI
# Failed test 'did we throws-like X::Comp::Trait::NotOnNative?'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names/is_default.rakudo line 367
ok 178 - Default value that is subtype of constraint works fine
ok 179 - Default value that is subtype of attribute constraint works fine
ok 180 - Mu as a default value on an unconstrained Scalar works
    1..3
    ok 1 - defaults to default value on instantiation
    ok 2 - constructor sets the value
    ok 3 - assigning Nil restores Mu default
ok 181 - can use `Mu` as default for attributes
ok 182 - Failure.new as a default value on an unconstrained Scalar works
ok 183 - Failure.new as a default value on an unconstrained Scalar attribute works
    1..2
        1..3
            1..2
            ok 1 - 'my $a is default("foo") of Int' died
            ok 2 - right exception type (X::Parameter::Default::TypeCheck)
        ok 1 - is default() + of
            1..2
            ok 1 - 'my $a of Int is default("foo")' died
            ok 2 - right exception type (X::Parameter::Default::TypeCheck)
        ok 2 - of is default()
            1..2
            ok 1 - 'my Int $a is default("foo")' died
            ok 2 - right exception type (X::Parameter::Default::TypeCheck)
        ok 3 - Type $ is default()
    ok 1 - variable
        1..3
            1..2
            ok 1 - 'class { has $.a is default("foo") of Int }' died
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 1 - is default() + of
            1..2
            ok 1 - 'class { has $.a of Int is default("foo") }' died
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 2 - of is default()
            1..2
            ok 1 - 'class { has Int $.a is default("foo") }' died
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 3 - Type $ is default()
    ok 2 - attribute
ok 184 - is default() respects type constraint
    1..2
        1..3
        ok 1 - uninitialized read
        ok 2 - set a value
        ok 3 - setting to Nil restores correct default
    ok 1 - variable
        1..4
        ok 1 - uninitialized read (rw attr)
        ok 2 - uninitialized read (ro attr)
        ok 3 - set a value
        ok 4 - setting to Nil restores correct default
    ok 2 - attribute
ok 185 - default `is default()` gets adjusted to type constraint
ok 186 - uninitialized typed:D attribute should have its default
    1..2
    ok 1 - 'class NilDefaultTyped { has Int:D $.a is rw is default(Nil) }' died
    ok 2 - right exception type (X::TypeCheck::Assignment)
ok 187 - did we throws-like X::TypeCheck::Assignment?
# FUDGED!
1..10
ok 1 - can define a sub in eval
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Undeclared::Symbols)
ok 2 - call to eval-born sub outside eval dies
ok 3 - call to eval-born our sub via OUR works
ok 4 - c is 2 from enum
ok 5 - can define my sub c in eval after c defined in enum
ok 6 - c is still 2 from enum
ok 7 - # SKIP OUR::subname() does not work
ok 8 - can compile a class that modifies our variable
ok 9 - can instantiate class that modifies our variable
ok 10 - class can modify our variable
# FUDGED!
1..159
ok 1 - # SKIP the binding in here is NYI
ok 2 - # SKIP the binding in here is NYI
ok 3 - # SKIP the binding in here is NYI
ok 4 - # SKIP the binding in here is NYI
ok 5 - # SKIP various issues, skipping all for now
ok 6 - # SKIP various issues, skipping all for now
ok 7 - # SKIP various issues, skipping all for now
ok 8 - # SKIP various issues, skipping all for now
ok 9 - # SKIP various issues, skipping all for now
ok 10 - # SKIP various issues, skipping all for now
ok 11 - # SKIP various issues, skipping all for now
ok 12 - # SKIP various issues, skipping all for now
ok 13 - # SKIP various issues, skipping all for now
ok 14 - # SKIP various issues, skipping all for now
ok 15 - # SKIP various issues, skipping all for now
ok 16 - # SKIP various issues, skipping all for now
ok 17 - # SKIP various issues, skipping all for now
ok 18 - # SKIP various issues, skipping all for now
ok 19 - # SKIP various issues, skipping all for now
ok 20 - # SKIP various issues, skipping all for now
ok 21 - # SKIP various issues, skipping all for now
ok 22 - # SKIP various issues, skipping all for now
ok 23 - # SKIP various issues, skipping all for now
ok 24 - # SKIP various issues, skipping all for now
ok 25 - # SKIP various issues, skipping all for now
ok 26 - # SKIP various issues, skipping all for now
ok 27 - # SKIP various issues, skipping all for now
ok 28 - # SKIP various issues, skipping all for now
ok 29 - # SKIP various issues, skipping all for now
ok 30 - # SKIP various issues, skipping all for now
ok 31 - # SKIP various issues, skipping all for now
ok 32 - # SKIP various issues, skipping all for now
ok 33 - # SKIP various issues, skipping all for now
ok 34 - # SKIP various issues, skipping all for now
ok 35 - # SKIP various issues, skipping all for now
ok 36 - # SKIP various issues, skipping all for now
ok 37 - # SKIP various issues, skipping all for now
ok 38 - # SKIP various issues, skipping all for now
ok 39 - # SKIP various issues, skipping all for now
ok 40 - # SKIP various issues, skipping all for now
ok 41 - basic OUR:: testing
ok 42 - can bind through OUR::
ok 43 - basic OUR::.{} works
ok 44 - can bind through OUR::.{}
ok 45 - OUR works when indirectly accessed
ok 46 - $OUR:: does not find GLOBAL
ok 47 - $OUR:: does find current package
ok 48 - OUR::.{} does not find GLOBAL
ok 49 - OUR::.{} does find current package
ok 50 - ::("OUR") does not find GLOBAL
ok 51 - ::("OUR") does find current package
ok 52 - $OUR:: syntax can indirect through a package
ok 53 - ::("OUR") can also indirect
ok 54 - $OUR:: can autovivify packages (reference)
ok 55 - $OUR:: can autovivify packages (binding)
not ok 56 - ::("OUR") can autovivify packages (r) # TODO interpolation and auto-viv NYI
# Failed test '::("OUR") can autovivify packages (r)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names/pseudo-6c.rakudo line 180
# expected: '43'
#      got: (Any)
not ok 57 - ::("OUR") can autovivify packages (b) # TODO binding and interpolation together NYI
# Failed test '::("OUR") can autovivify packages (b)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names/pseudo-6c.rakudo line 184
# expected: '44'
#      got: (Any)
not ok 58 - ::("OUR") can follow aliased packages # TODO binding and interpolation together NYI
# Failed test '::("OUR") can follow aliased packages'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names/pseudo-6c.rakudo line 188
# expected: '41'
#      got: (Failure)
ok 59 - &CORE:: works
ok 60 - CORE::.{} works
ok 61 - ::("CORE") works
ok 62 - &CORE:: works when shadowed
ok 63 - CORE::.{} works when shadowed
ok 64 - ::("CORE") works when shadowed
ok 65 - &CORE:: is not &SETTING::
ok 66 - CORE::.{} is not SETTING::
ok 67 - ::("CORE") is not SETTING
ok 68 - &CORE:: binding lives
ok 69 - ... and works
ok 70 - CORE::.{} binding lives
ok 71 - ... and works
ok 72 - # SKIP Cannot bind to &::("CORE")::foo
ok 73 - # SKIP Cannot bind to &::("CORE")::foo
ok 74 - Binding to $CORE::_ lives
ok 75 - Accessing $CORE::_ works
ok 76 - # SKIP Cannot bind to &::("CORE")::foo
ok 77 - # SKIP Cannot bind to &::("CORE")::foo
ok 78 - $GLOBAL:: works
ok 79 - ::("GLOBAL") works
ok 80 - GLOBAL::.{} works
ok 81 - GLOBAL:: does not find CORE symbols
ok 82 - $PROCESS:: works
ok 83 - PROCESS::.{} works
ok 84 - ::("PROCESS") works
ok 85 - existing $* assignable via PROCESS
ok 86 - new $* assignable via PROCESS
ok 87 - # SKIP various issues to resolve
ok 88 - # SKIP various issues to resolve
ok 89 - # SKIP various issues to resolve
ok 90 - # SKIP various issues to resolve
ok 91 - # SKIP various issues to resolve
ok 92 - # SKIP various issues to resolve
ok 93 - # SKIP various issues to resolve
ok 94 - # SKIP various issues to resolve
ok 95 - # SKIP various issues to resolve
ok 96 - # SKIP various issues to resolve
ok 97 - # SKIP various issues to resolve
ok 98 - # SKIP various issues to resolve
ok 99 - # SKIP various issues to resolve
ok 100 - # SKIP various issues to resolve
ok 101 - # SKIP various issues to resolve
ok 102 - # SKIP various issues to resolve
ok 103 - # SKIP various issues to resolve
ok 104 - # SKIP various issues to resolve
ok 105 - # SKIP various issues to resolve
ok 106 - # SKIP various issues to resolve
ok 107 - # SKIP various issues to resolve
ok 108 - # SKIP various issues to resolve
ok 109 - # SKIP various issues to resolve
ok 110 - $CALLER:: works
ok 111 - CALLER::.{} works
ok 112 - ::("CALLER") works
ok 113 - CALLER::CALLER:: works
ok 114 - indirect CALLER::CALLER works
ok 115 - CALLER::<$*bar> works
ok 116 - ::("CALLER")::<$*bar> works
ok 117 - CALLER:: works in inline blocks
ok 118 - ::("CALLER") works in inline blocks
ok 119 - $CALLERS:: works
ok 120 - CALLERS::.{} works
ok 121 - ::("CALLERS") works
ok 122 - CALLERS::CALLERS:: works
ok 123 - indirect CALLERS::CALLERS works
ok 124 - CALLERS::<$*foo> works
ok 125 - ::("CALLERS")::<$*foo> works
ok 126 - CALLERS:: works in inline blocks
ok 127 - ::("CALLERS") works in inline blocks
ok 128 - $OUTER:: works
ok 129 - OUTER::.{} works
ok 130 - ::("OUTER") works
ok 131 - $OUTER:: keeps going until match
ok 132 - ::("OUTER") keeps going until match
ok 133 - $OUTER::OUTER:: works
ok 134 - ::("OUTER")::("OUTER") works
ok 135 - OUTER:: is not CALLER::
ok 136 - ::("OUTER") is not CALLER::
ok 137 - CALLER::OUTER:: works
ok 138 - OUTER::<$*x> works
ok 139 - ::("OUTER")::<$*x> works
ok 140 - $UNIT:: works
ok 141 - ::("UNIT") works
ok 142 - $UNIT:: finds eval heads
ok 143 - ::("UNIT") finds eval heads
ok 144 - CALLER::UNIT works
ok 145 - CALLER::UNIT works (indirect)
ok 146 - SETTING:: works
ok 147 - ::("SETTING") works
ok 148 - SETTING finds eval context
ok 149 - ::("SETTING") finds eval context
ok 150 - CALLER::SETTING works
ok 151 - CALLER::SETTING works (ind)
ok 152 - MY::.values actually produces values
ok 153 - OUTER::.values actually produces values
ok 154 - calling CORE::.keys lives
    1..14
    ok 1 - CORE::CALLERS::CORE::...
    ok 2 - CORE::UNIT::...
    ok 3 - mixed
    ok 4 - DYNAMIC::
    ok 5 - OUTER::
    ok 6 - CALLER::
    ok 7 - UNIT::
    ok 8 - MY::
    ok 9 - CORE::
    ok 10 - LEXICAL::
    ok 11 - OUTERS::
    ok 12 - CALLERS::
    ok 13 - SETTING::
    ok 14 - OUR::
ok 155 - no guts spillage when going too high up scope in pseudopackages
ok 156 - CORE symbols are available at compile-time
ok 157 - CORE symbols are available at compile-time inside EVAL
ok 158 - CORE symbols are available at compile-time in BEGIN
ok 159 - CORE symbols are available at compile-time in BEGIN inside EVAL
# FUDGED!
1..159
ok 1 - # SKIP the binding in here is NYI
ok 2 - # SKIP the binding in here is NYI
ok 3 - # SKIP the binding in here is NYI
ok 4 - # SKIP the binding in here is NYI
ok 5 - # SKIP various issues, skipping all for now
ok 6 - # SKIP various issues, skipping all for now
ok 7 - # SKIP various issues, skipping all for now
ok 8 - # SKIP various issues, skipping all for now
ok 9 - # SKIP various issues, skipping all for now
ok 10 - # SKIP various issues, skipping all for now
ok 11 - # SKIP various issues, skipping all for now
ok 12 - # SKIP various issues, skipping all for now
ok 13 - # SKIP various issues, skipping all for now
ok 14 - # SKIP various issues, skipping all for now
ok 15 - # SKIP various issues, skipping all for now
ok 16 - # SKIP various issues, skipping all for now
ok 17 - # SKIP various issues, skipping all for now
ok 18 - # SKIP various issues, skipping all for now
ok 19 - # SKIP various issues, skipping all for now
ok 20 - # SKIP various issues, skipping all for now
ok 21 - # SKIP various issues, skipping all for now
ok 22 - # SKIP various issues, skipping all for now
ok 23 - # SKIP various issues, skipping all for now
ok 24 - # SKIP various issues, skipping all for now
ok 25 - # SKIP various issues, skipping all for now
ok 26 - # SKIP various issues, skipping all for now
ok 27 - # SKIP various issues, skipping all for now
ok 28 - # SKIP various issues, skipping all for now
ok 29 - # SKIP various issues, skipping all for now
ok 30 - # SKIP various issues, skipping all for now
ok 31 - # SKIP various issues, skipping all for now
ok 32 - # SKIP various issues, skipping all for now
ok 33 - # SKIP various issues, skipping all for now
ok 34 - # SKIP various issues, skipping all for now
ok 35 - # SKIP various issues, skipping all for now
ok 36 - # SKIP various issues, skipping all for now
ok 37 - # SKIP various issues, skipping all for now
ok 38 - # SKIP various issues, skipping all for now
ok 39 - # SKIP various issues, skipping all for now
ok 40 - # SKIP various issues, skipping all for now
ok 41 - basic OUR:: testing
ok 42 - can bind through OUR::
ok 43 - basic OUR::.{} works
ok 44 - can bind through OUR::.{}
ok 45 - OUR works when indirectly accessed
ok 46 - $OUR:: does not find GLOBAL
ok 47 - $OUR:: does find current package
ok 48 - OUR::.{} does not find GLOBAL
ok 49 - OUR::.{} does find current package
ok 50 - ::("OUR") does not find GLOBAL
ok 51 - ::("OUR") does find current package
ok 52 - $OUR:: syntax can indirect through a package
ok 53 - ::("OUR") can also indirect
ok 54 - $OUR:: can autovivify packages (reference)
ok 55 - $OUR:: can autovivify packages (binding)
not ok 56 - ::("OUR") can autovivify packages (r) # TODO interpolation and auto-viv NYI
# Failed test '::("OUR") can autovivify packages (r)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names/pseudo-6d.rakudo line 180
# expected: '43'
#      got: (Any)
not ok 57 - ::("OUR") can autovivify packages (b) # TODO binding and interpolation together NYI
# Failed test '::("OUR") can autovivify packages (b)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names/pseudo-6d.rakudo line 184
# expected: '44'
#      got: (Any)
not ok 58 - ::("OUR") can follow aliased packages # TODO binding and interpolation together NYI
# Failed test '::("OUR") can follow aliased packages'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names/pseudo-6d.rakudo line 188
# expected: '41'
#      got: (Failure)
ok 59 - &CORE:: works
ok 60 - CORE::.{} works
ok 61 - ::("CORE") works
ok 62 - &CORE:: works when shadowed
ok 63 - CORE::.{} works when shadowed
ok 64 - ::("CORE") works when shadowed
ok 65 - &CORE:: is not &SETTING::
ok 66 - CORE::.{} is not SETTING::
ok 67 - ::("CORE") is not SETTING
ok 68 - &CORE:: binding lives
ok 69 - ... and works
ok 70 - CORE::.{} binding lives
ok 71 - ... and works
ok 72 - # SKIP Cannot bind to &::("CORE")::foo
ok 73 - # SKIP Cannot bind to &::("CORE")::foo
ok 74 - Binding to $CORE::_ lives
ok 75 - Accessing $CORE::_ works
ok 76 - # SKIP Cannot bind to &::("CORE")::foo
ok 77 - # SKIP Cannot bind to &::("CORE")::foo
ok 78 - $GLOBAL:: works
ok 79 - ::("GLOBAL") works
ok 80 - GLOBAL::.{} works
ok 81 - GLOBAL:: does not find CORE symbols
ok 82 - $PROCESS:: works
ok 83 - PROCESS::.{} works
ok 84 - ::("PROCESS") works
ok 85 - existing $* assignable via PROCESS
ok 86 - new $* assignable via PROCESS
ok 87 - # SKIP various issues to resolve
ok 88 - # SKIP various issues to resolve
ok 89 - # SKIP various issues to resolve
ok 90 - # SKIP various issues to resolve
ok 91 - # SKIP various issues to resolve
ok 92 - # SKIP various issues to resolve
ok 93 - # SKIP various issues to resolve
ok 94 - # SKIP various issues to resolve
ok 95 - # SKIP various issues to resolve
ok 96 - # SKIP various issues to resolve
ok 97 - # SKIP various issues to resolve
ok 98 - # SKIP various issues to resolve
ok 99 - # SKIP various issues to resolve
ok 100 - # SKIP various issues to resolve
ok 101 - # SKIP various issues to resolve
ok 102 - # SKIP various issues to resolve
ok 103 - # SKIP various issues to resolve
ok 104 - # SKIP various issues to resolve
ok 105 - # SKIP various issues to resolve
ok 106 - # SKIP various issues to resolve
ok 107 - # SKIP various issues to resolve
ok 108 - # SKIP various issues to resolve
ok 109 - # SKIP various issues to resolve
ok 110 - $CALLER:: works
ok 111 - CALLER::.{} works
ok 112 - ::("CALLER") works
ok 113 - CALLER::CALLER:: works
ok 114 - indirect CALLER::CALLER works
ok 115 - CALLER::<$*bar> works
ok 116 - ::("CALLER")::<$*bar> works
ok 117 - CALLER:: works in inline blocks
ok 118 - ::("CALLER") works in inline blocks
ok 119 - $CALLERS:: works
ok 120 - CALLERS::.{} works
ok 121 - ::("CALLERS") works
ok 122 - CALLERS::CALLERS:: works
ok 123 - indirect CALLERS::CALLERS works
ok 124 - CALLERS::<$*foo> works
ok 125 - ::("CALLERS")::<$*foo> works
ok 126 - CALLERS:: works in inline blocks
ok 127 - ::("CALLERS") works in inline blocks
ok 128 - $OUTER:: works
ok 129 - OUTER::.{} works
ok 130 - ::("OUTER") works
ok 131 - $OUTER:: keeps going until match
ok 132 - ::("OUTER") keeps going until match
ok 133 - $OUTER::OUTER:: works
ok 134 - ::("OUTER")::("OUTER") works
ok 135 - OUTER:: is not CALLER::
ok 136 - ::("OUTER") is not CALLER::
ok 137 - CALLER::OUTER:: works
ok 138 - OUTER::<$*x> works
ok 139 - ::("OUTER")::<$*x> works
ok 140 - $UNIT:: works
ok 141 - ::("UNIT") works
ok 142 - $UNIT:: finds eval heads
ok 143 - ::("UNIT") finds eval heads
ok 144 - CALLER::UNIT works
ok 145 - CALLER::UNIT works (indirect)
ok 146 - SETTING:: works
ok 147 - ::("SETTING") works
ok 148 - SETTING finds eval context
ok 149 - ::("SETTING") finds eval context
ok 150 - CALLER::SETTING works
ok 151 - CALLER::SETTING works (ind)
ok 152 - MY::.values actually produces values
ok 153 - OUTER::.values actually produces values
ok 154 - calling CORE::.keys lives
    1..14
    ok 1 - CORE::CALLERS::CORE::...
    ok 2 - CORE::UNIT::...
    ok 3 - mixed
    ok 4 - DYNAMIC::
    ok 5 - OUTER::
    ok 6 - CALLER::
    ok 7 - UNIT::
    ok 8 - MY::
    ok 9 - CORE::
    ok 10 - LEXICAL::
    ok 11 - OUTERS::
    ok 12 - CALLERS::
    ok 13 - SETTING::
    ok 14 - OUR::
ok 155 - no guts spillage when going too high up scope in pseudopackages
ok 156 - CORE symbols are available at compile-time
ok 157 - CORE symbols are available at compile-time inside EVAL
ok 158 - CORE symbols are available at compile-time in BEGIN
ok 159 - CORE symbols are available at compile-time in BEGIN inside EVAL
# FUDGED!
1..7
ok 1 - variable gets auto-declared when strict is turned off
ok 2 - variable gets auto-declared in packages
ok 3 - lax declared variable is package scoped
    1..3
    ok 1 - '$foo = 10;' died
    ok 2 - right exception type (X::Undeclared)
    ok 3 - .suggestions matches Foo
ok 4 - did we throws-like X::Undeclared?
ok 5 - # SKIP lax mode does not propagate into EVAL yet
ok 6 - "6;" no longer means "no strict;" and "(6;)" no longer results in a compile time error
    1..4
    ok 1 - `temp` on Hash key
    ok 2 - `let`  on Hash key
    ok 3 - postcircumfix {} on Hash key
    ok 4 - non-existent keys are `Any`
ok 7 - `no strict` does not cause autovivification container issues
# FUDGED!
1..36
ok 1 - basic symbolic scalar dereferentiation works
ok 2 - can use $::(...) as lvalue
ok 3 - and the assignment worked
ok 4 - ... and it is item assignment
ok 5 - basic symbolic array dereferentiation works
ok 6 - can assign to symbolic deref
ok 7 - ... and it is list assignment when the sigil is @
ok 8 - basic symbolic hash dereferentiation works
ok 9 - basic symbolic code dereferentiation works
ok 10 - can look up a type object with ::()
ok 11 - can look up lexical from same block
ok 12 - can look up lexical from outer block
ok 13 - Can use ::() as lvalue
ok 14 - and the assignment worked
ok 15 - can look up lexical sub
ok 16 - Can look up numerical constants
ok 17 - can look up name with :: (1)
ok 18 - can look up name with :: (1)
ok 19 - not so basic symbolic dereferentiation works
ok 20 - symbolic derefertiation with multiple packages in one variable works
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Syntax::Confused)
ok 21 - $::($foo)bar is illegal
ok 22 - symbolic dereferentation works with ::CALLER, too
ok 23 - symbolic dereferentiation of Unicode vars works
ok 24 - # SKIP NYI
ok 25 - # SKIP NYI
not ok 26 - symbolic dereferentiation of globals works (3) # TODO no such symbol
# Failed test 'symbolic dereferentiation of globals works (3)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names/symbolic-deref.rakudo line 122
ok 27 - symbolic dereferentiation of CORE subs works (1)
ok 28 - symbolic dereferentiation of CORE subs works (2)
ok 29 - symbolic dereferentiation of CORE subs works (3)
ok 30 - symbolic dereferentiation of type vars works (1)
ok 31 - symbolic dereferentiation of (own) type vars works (2)
ok 32 - symbolic dereferentiation works with special chars (1)
not ok 33 - symbolic dereferentiation works with special chars (3) # TODO NYI
# Failed test 'symbolic dereferentiation works with special chars (3)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names/symbolic-deref.rakudo line 153
ok 34 - symbolic dereferentiation works with package vars
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 35 - Cannot look up empty name
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Undeclared)
ok 36 - name with trailing :: not same as sans
# FUDGED!
1..42
ok 1 - The object is-a 'Sub'
ok 2 - sub { } works
ok 3 - The object is-a 'Sub'
ok 4 - sub ($arg) {} works
ok 5 - The object is-a 'Block'
ok 6 - {} <anon block> works
not ok 7 - too many parameters # TODO Parrot support for zero-arg subs?
# Failed test 'too many parameters'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/anon_block.rakudo line 36
ok 8 - # SKIP tests don't work if previous test fails
ok 9 - # SKIP tests don't work if previous test fails
ok 10 - The object is-a 'Block'
ok 11 - -> {} <"pointy" block> works
ok 12 - The object is-a 'Block'
ok 13 - -> $arg {} <"pointy" block w/args> works
ok 14 - The object is-a 'Block'
ok 15 - -> $arg1, $arg2 {} <"pointy" block w/multiple args> works
ok 16 - The object is-a 'Block'
ok 17 - The object is-a 'Block'
ok 18 - -> $a { -> $b { $a+$b }} nested <"pointy" block> works
ok 19 - lone block actually executes it's content
ok 20 - lone block w/out a semicolon actually executes it's content
ok 21 - block enclosed by parentheses should not auto-execute (2)
ok 22 - two blocks ({} {}) no semicolon after either,.. first block does not execute
ok 23 - ... but second block does (parsed as hash subscript)
ok 24 - ... two blocks ({}; {}) semicolon after the first only,.. first block does execute
ok 25 - ... and second block does too
ok 26 - ... two stand-alone blocks ({\n...\n}\n{\n...\n}),.. first block does execute
ok 27 - ... and second block does too
ok 28 - ... two blocks ({}; {};) semicolon after both,.. first block does execute
ok 29 - ... and second block does too
ok 30 - bare blocks immediately runs even as the last statement
ok 31 - ditto for anonymous subs
ok 32 - ditto, even if nested
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 33 - implicit params become errors
ok 34 - as are pointies
ok 35 - check that sub is callable via &
ok 36 - call via { &^pos() }( &s ) works for sub
ok 37 - call via -> &point { &point() }.( &s ) works for sub
ok 38 - call via (sub (&x) { &x() }).( &s ) works for sub
ok 39 - check that mutli is callable via &
ok 40 - call via { &^pos() }( &s ) works for multi
ok 41 - call via -> &point { &point() }.( &s ) works for multi
ok 42 - call via (sub (&x) { &x() }).( &s ) works for multi
# FUDGED!
1..40
ok 1 - my @arr[*] autoextends like my @arr
ok 2 - my @arr[num] can hold num things
    1..3
    ok 1 - 'push @arr, 'h'' died
    ok 2 - right exception type (X::IllegalOnFixedDimensionArray)
    ok 3 - .operation matches push
ok 3 - adding past num items in my @arr[num] dies
    1..2
    ok 1 - '@arr[7]' died
    ok 2 - right exception type (Exception)
ok 4 - accessing past num items in my @arr[num] dies
ok 5 - array with fixed size with unspace
    1..2
    not ok 1 - 'my @arr.[8]' died # TODO code does not die, array shapes
    # Failed test ''my @arr.[8]' died'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/array-shapes.rakudo line 29
    ok 2 - # SKIP Code did not die, can not check exception
not ok 6 - array with dot form dies # TODO code does not die, array shapes
# Failed test 'array with dot form dies'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/array-shapes.rakudo line 29
    1..2
    not ok 1 - 'my @arr\    .[8]' died # TODO code does not die, array shapes
    # Failed test ''my @arr\    .[8]' died'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/array-shapes.rakudo line 32
    ok 2 - # SKIP Code did not die, can not check exception
not ok 7 - array with dot form and unspace dies # TODO code does not die, array shapes
# Failed test 'array with dot form and unspace dies'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/array-shapes.rakudo line 32
ok 8 - my @arr of Type works
    1..2
    ok 1 - 'push @arr, 's'' died
    ok 2 - right exception type (X::TypeCheck)
ok 9 - type constraints on my @arr of Type works (1)
    1..2
    ok 1 - 'push @arr, 4.2' died
    ok 2 - right exception type (X::TypeCheck)
ok 10 - type constraints on my @arr of Type works (2)
ok 11 - my Type @arr works
    1..2
    ok 1 - 'push @arr, 's'' died
    ok 2 - right exception type (X::TypeCheck)
ok 12 - type constraints on my Type @arr works (1)
    1..2
    ok 1 - 'push @arr, 4.2' died
    ok 2 - right exception type (X::TypeCheck)
ok 13 - type constraints on my Type @arr works (2)
ok 14 - my @arr[Int] of Type works
    1..2
    ok 1 - 'push @arr, 123' died
    ok 2 - right exception type (Exception)
ok 15 - boundary constraints on my @arr[Int] of Type works
ok 16 - my type @arr works
ok 17 - push on native @arr works
    1..2
    ok 1 - 'push @arr, "s"' died
    ok 2 - right exception type (X::TypeCheck)
ok 18 - type constraints on my type @arr works (1)
    1..2
    ok 1 - 'push @arr, 4.2' died
    ok 2 - right exception type (X::TypeCheck)
ok 19 - type constraints on my type @arr works (2)
ok 20 - my Type @arr[num] works
    1..3
    ok 1 - 'push @arr, 123' died
    ok 2 - right exception type (X::IllegalOnFixedDimensionArray)
    ok 3 - .operation matches push
ok 21 - did we throws-like X::IllegalOnFixedDimensionArray?
    1..3
    ok 1 - 'pop @arr' died
    ok 2 - right exception type (X::IllegalOnFixedDimensionArray)
    ok 3 - .operation matches pop
ok 22 - did we throws-like X::IllegalOnFixedDimensionArray?
    1..3
    ok 1 - 'push @arr, 's'' died
    ok 2 - right exception type (X::IllegalOnFixedDimensionArray)
    ok 3 - .operation matches push
ok 23 - did we throws-like X::IllegalOnFixedDimensionArray?
    1..3
    ok 1 - 'push @arr, 4.2' died
    ok 2 - right exception type (X::IllegalOnFixedDimensionArray)
    ok 3 - .operation matches push
ok 24 - did we throws-like X::IllegalOnFixedDimensionArray?
    1..2
    ok 1 - 'my @a[0]' died
    ok 2 - right exception type (X::IllegalDimensionInShape)
ok 25 - did we throws-like X::IllegalDimensionInShape?
    1..2
    ok 1 - 'my @a[-9999999999999999]' died
    ok 2 - right exception type (X::IllegalDimensionInShape)
ok 26 - did we throws-like X::IllegalDimensionInShape?
    1..2
    ok 1 - 'my @a[-9223372036854775808,-2]' died
    ok 2 - right exception type (X::IllegalDimensionInShape)
ok 27 - did we throws-like X::IllegalDimensionInShape?
    1..2
    ok 1 - does not die
    ok 2 - gives correct results
ok 28 - .List on uninited shaped array
    1..3
    ok 1 - does not die
    ok 2 - gives correct results
    ok 3 - and is mutable
ok 29 - .Array on uninited shaped array
ok 30 - @c[some shape] accepts a .new: :shape(same shape)...
ok 31 - @shaped-array.pairs provides with writable container in .value
ok 32 - @shaped-array.values provides with writable containers
ok 33 - For statement across simple uninitialized shaped array
ok 34 - For loop across simple uninitialized shaped array
ok 35 - .map of simple uninitialized shaped array
ok 36 - Z= shape filling
ok 37 - Z= shape filling
ok 38 - Z= shape filling
ok 39 - # SKIP coercion of shaped array indicesdd
ok 40 - Accept dynamic shaped arrays
# FUDGED!
1..105
ok 1 - for 1, 2, 3 does three iterations
ok 2 - for 0, (1, 2, 3).item does two iteraions
ok 3 - for flat 0, $(1, 2, 3) does two iterations
ok 4 - for flat 0, $[1, 2, 3] does two iterations
ok 5 - @a.raku on uninitialized variable
ok 6 - The object is-a 'Array'
ok 7 - the array1 has 3 elements
ok 8 - got the right value at array1 index 0
ok 9 - got the right value at array1 index 1
ok 10 - got the right value at array1 index 2
ok 11 - got the right value at array1 index 0 using the . notation
ok 12 - The object is-a 'Array'
ok 13 - the array2 has 3 elements
ok 14 - got the right value at array2 index 0
ok 15 - got the right value at array2 index 1
ok 16 - got the right value at array2 index 2
ok 17 - The object is-a 'Array'
ok 18 - the array3 has 6 elements
ok 19 - got the right value at array3 index 0
ok 20 - got the right value at array3 index 1
ok 21 - got the right value at array3 index 2
ok 22 - got the right value at array3 index 3
ok 23 - got the right value at array3 index 4
ok 24 - got the right value at array3 index 5
ok 25 - The object is-a 'Array'
ok 26 - the array4 has 3 elements
ok 27 - got the right value at array4 index 0
ok 28 - got the right value at array4 index 1
ok 29 - got the right value at array4 index 2
ok 30 - The object is-a 'Array'
ok 31 - the array5 has 6 elements
ok 32 - got the right value at array5 index 0
ok 33 - got the right value at array5 index 1
ok 34 - got the right value at array5 index 2
ok 35 - got the right value at array5 index 3
ok 36 - got the right value at array5 index 4
ok 37 - got the right value at array5 index 5
ok 38 - The object is-a 'Array'
ok 39 - the array6 has 3 elements
ok 40 - got the right value at array6 index 0
ok 41 - got the right value at array6 index 1
ok 42 - got the right value at array6 index 2
ok 43 - The object is-a 'Array'
ok 44 - the array7 has 3 elements
ok 45 - got the right value at array7 index 0
ok 46 - got the right value at array7 index 1
ok 47 - got the right value at array7 index 2
ok 48 - got the right value from the slice
ok 49 - got the right value from the slice
ok 50 - The object is-a 'Array'
ok 51 - new arrays are empty
ok 52 - trailing commas make correct array
ok 53 - # SKIP multi-dim arrays NYI
ok 54 - # SKIP multi-dim arrays NYI
ok 55 - stuffing Ints in an Int array works
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck::Assignment)
ok 56 - stuffing IO in an Int array does not work
ok 57 - indexing from the end [*-1]
ok 58 - end indices [*-4 .. *-2]
ok 59 - assigns to the correct end slice index
ok 60 - assignment to end index correctly alters the array
ok 61 - end range as lvalue
ok 62 - hat trick:
#         assign to a end-indexed slice array from array
#         lvalue in assignment is then lvalue to end-indexed slice as rvalue
ok 63 - Infinite range subscript as rvalues clip to existing elems
ok 64 - Lazy range subscript as rvalues clip to existing elems
ok 65 - modifying of array contents (constants) works
ok 66 - readonly accessing [*-1] of an empty array is not fatal
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::OutOfRange)
ok 67 - readonly accessing [*-1] of an empty array throws X::OutOfRange
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::OutOfRange)
ok 68 - assigning to [*-1] of an empty array throws X::OutOfRange
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Bind::Slice)
ok 69 - binding [*-1] of an empty array throws X::Bind::Slice
ok 70 - readonly accessing [*-2] of an one-elem array is not fatal
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::OutOfRange)
ok 71 - readonly accessing [*-2] of an one-elem array throws X::OutOfRange
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::OutOfRange)
ok 72 - assigning to [*-2] of an one-elem array throws X::OutOfRange
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Bind::Slice)
ok 73 - binding [*-2] of an one-elem array throws X::Bind::Slice
    1..3
    ok 1 - '@arr[-2]' died
    ok 2 - right exception type (X::Obsolete)
    ok 3 - .message matches /^ 'Unsupported use of a negative -2 subscript to index from the end'/
ok 74 - readonly accessing [-2] of normal array throws X::Obsolete and is fatal
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::OutOfRange)
ok 75 - indirectly accessing [-1] through a variable throws X::OutOfRange
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::OutOfRange)
ok 76 - assigning to [-1] of a normal array throws X::OutOfRange
    1..2
    ok 1 - code dies
    not ok 2 - right exception type (X::Subscript::Negative) # TODO bind_pos NYI
    # Failed test 'right exception type (X::Subscript::Negative)'
    # at SETTING::src/core.c/Exception.pm6 line 62
    # Expected: X::Subscript::Negative
    # Got:      X::OutOfRange
    # Exception message: Index out of range. Is: -1, should be in 0..^Inf
not ok 77 - binding [-1] of a normal array throws X::Subscript::Negative # TODO bind_pos NYI
# Failed test 'binding [-1] of a normal array throws X::Subscript::Negative'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/array.rakudo line 264
ok 78 - [][] returns empty list/array
ok 79 - .[0] is identity operation for scalars (Int)
ok 80 - .[0] is identity operation for scalars (Str)
ok 81 - .[1] on a scalar is not defined
ok 82 - indexing a scalar with other than 0 returns a Failure
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Multi::NoMatch X::TypeCheck::Binding::Parameter)
ok 83 - but Mu has no .[]
ok 84 - using * to access all array elements works
ok 85 - using [] to listify all array elements works
ok 86 - using [] decontainerizes
ok 87 - Numifying an Array yields an Int
ok 88 - modifier form of 'if' within 'for' loop works
ok 89 - non-modifier form of 'if' within 'for' loop also works
ok 90 - Array.hash created a sensible hash
ok 91 - ... and did not consume itself in the process
ok 92 - 0..^ *-1 works as an array index
ok 93 - Array(...) makes an Array
ok 94 - Array(1,2,3) makes correct array
    1..4
    ok 1 - code dies
    not ok 2 - right exception type (X::Item) # TODO regression to AdHoc exception
    # Failed test 'right exception type (X::Item)'
    # at SETTING::src/core.c/Exception.pm6 line 62
    # Expected: X::Item
    # Got:      X::Numeric::CannotConvert
    # Exception message: Cannot convert Inf to Int: 
    ok 3 - # SKIP wrong exception type
    ok 4 - # SKIP wrong exception type
not ok 95 - did we throws-like X::Item? # TODO regression to AdHoc exception
# Failed test 'did we throws-like X::Item?'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/array.rakudo line 346
    1..4
    ok 1 - code dies
    not ok 2 - right exception type (X::Item) # TODO regression to AdHoc exception
    # Failed test 'right exception type (X::Item)'
    # at SETTING::src/core.c/Exception.pm6 line 62
    # Expected: X::Item
    # Got:      X::Numeric::CannotConvert
    # Exception message: Cannot convert NaN to Int: 
    ok 3 - # SKIP wrong exception type
    ok 4 - # SKIP wrong exception type
not ok 96 - did we throws-like X::Item? # TODO regression to AdHoc exception
# Failed test 'did we throws-like X::Item?'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/array.rakudo line 349
ok 97 - ~@bar containing a Str type object lives
ok 98 - ~@bar containing a Str type object gives empty string
ok 99 - simple integer sum in array works
ok 100 - handle sparse arrays correctly
ok 101 - [*-0] index references correct element when autovivifying
    1..4
    ok 1 - method, True
    ok 2 - method, False
    ok 3 - sub, True
    ok 4 - sub, False
ok 102 - flat propagates .is-lazy
    1..5
    ok 1 - gist gives useful value
    ok 2 - 100 els
    ok 3 - 101 els
    ok 4 - 102 els
    ok 5 - 1000 els
ok 103 - .gist shows only first 100 els
    1..2
    ok 1 - zen slice does not reify
    ok 2 - whatever slice does reify
ok 104 - reification of zen and whatever slices
    1..9
    ok 1 - can reference values in an `our` var
    ok 2 - we reified only non-lazy parts on assignment
    ok 3 - eagerizing the array, we reified the rest of the parts
    ok 4 - pushed values get updated
    ok 5 - is default work on Arrays
    ok 6 - can use return value of assignment (1)
    ok 7 - can use return value of assignment (2)
    ok 8 - can use return value of assignment (3)
    ok 9 - works fine when re-entrant
ok 105 - no funny business in assignment
# FUDGED!
1..333
We do get here, right?
ok 1 - we got a BagHash
ok 2 - ...with the right elements
ok 3 - Defaults to 0
ok 4 - Single-key subscript (existing element)
ok 5 - Single-key subscript yields an Int
ok 6 - Single-key subscript (nonexistent element)
ok 7 - Single-key subscript yields an Int (nonexistent element)
ok 8 - exists with existing element
ok 9 - exists with nonexistent element
ok 10 - Values returns the correct number of values
ok 11 - Values returns the correct sum
ok 12 - Bool returns True if there is something in the BagHash
ok 13 - Bool returns False if there is nothing in the BagHash
ok 14 - .hash doesn't die
ok 15 - ...and it returned a Hash
ok 16 - ...with the right elements
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Assignment::RO)
ok 17 - Can't assign to .keys
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Assignment::RO)
ok 18 - Can't assign to .values
ok 19 - Multiple-element access
ok 20 - Multiple-element access (with nonexistent elements)
ok 21 - .total gives sum of values
ok 22 - .elems gives number of elements
ok 23 - +$bag gives sum of values
ok 24 - Can assign to an existing element
ok 25 - ... and assignment takes effect
ok 26 - Can assign to a new element
ok 27 - ... and assignment takes effect
ok 28 - Can assign zero to a nonexistent element
ok 29 - ... and that didn't create the element
ok 30 - Can assign zero to a existing element
ok 31 - ... and it goes away
ok 32 - Can ++ an existing element
ok 33 - ... and the increment happens
ok 34 - Can ++ a new element
ok 35 - ... and the element is created
ok 36 - Can -- an existing element
ok 37 - ... and the decrement happens
ok 38 - Can -- an element with value 1
ok 39 - ... and it goes away
ok 40 - Can -- an element that doesn't exist
ok 41 - ... but it doesn't create it
ok 42 - Identical bags smartmatch with each other
ok 43 - Identical bags smartmatch with each other
ok 44 - Subset does not smartmatch
ok 45 - Subset (only quantity different) does not smartmatch
ok 46 - Superset does not smartmatch
ok 47 - Superset (only quantity different) does not smartmatch
ok 48 - Smartmatch is not element of
ok 49 - Type-checking smartmatch works
ok 50 - Set smartmatches with equivalent BagHash.new:
ok 51 - ... but not if the Bag has greater quantities
ok 52 - Type-checking smartmatch works
ok 53 - Str.BagHash makes a BagHash
ok 54 - 'a'.BagHash is bag a
ok 55 - Pair.BagHash makes a BagHash
ok 56 - (a => 100000).BagHash is bag a:100000
ok 57 - (a => 0).BagHash is the empty bag
ok 58 - <a b c>.BagHash makes a BagHash
ok 59 - <a b c a>.BagHash makes the bag a:2 b:1 c:1
ok 60 - [a b c a].BagHash makes the bag a:2 b:1 c:1
ok 61 - [a => 3, b => 0, 'c', 'a'].BagHash makes the bag a:4 c:1
ok 62 - a	2 b	4 c	0.BagHash makes a BagHash
ok 63 - a	2 b	4 c	0.BagHash makes the bag a:2 b:4
ok 64 - :exists with existing element
ok 65 - :exists with nonexistent element
ok 66 - :delete works on BagHash
ok 67 - ...and actually deletes
ok 68 - Int keys are left as Ints
ok 69 - Bool keys are left as Bools
ok 70 - And Str keys are permitted in the same set
ok 71 - All keys have the right values
ok 72 - BagHash.kv returns list of keys and values
ok 73 - &BagHash.new given an array of strings produces a BagHash
ok 74 - ...with the right elements
ok 75 - &BagHash.new given something and an array of pairs produces a BagHash
ok 76 - ... with two elements
ok 77 - &BagHash.new given a Hash produces a BagHash
ok 78 - ... with four elements
ok 79 - ... which are all Pairs
ok 80 - &BagHash.new given a Hash and something produces a BagHash
ok 81 - ... with one element
ok 82 - &BagHash.new given a Set produces a BagHash
ok 83 - ... with one element
ok 84 - &BagHash.new given a SetHash produces a BagHash
ok 85 - ... with one element
ok 86 - &BagHash.new given a Bag produces a BagHash
ok 87 - ... with one element
ok 88 - .list returns 3 things
ok 89 - ... all of which are Pairs
ok 90 - .pairs returns 3 things
ok 91 - ... all of which are Pairs
ok 92 - ... the keys of which are Strs
ok 93 - ... and the values of which are Ints
ok 94 - .raku lives
ok 95 - ... and produces a string
ok 96 - ... of reasonable length
ok 97 - .raku.EVAL lives
ok 98 - ... and produces a BagHash
ok 99 - ... and it has the correct values
ok 100 - .Str lives
ok 101 - ... and produces a string
ok 102 - ... which only contains bar baz and foo with the proper counts and separated by spaces
ok 103 - .gist lives
ok 104 - ... and produces a string
ok 105 - ... of reasonable length
ok 106 - ... which mentions foo
ok 107 - ... which mentions bar
ok 108 - ... which mentions baz
ok 109 - A BagHash bound to a %var is a BagHash
ok 110 - ...with the right elements
ok 111 - Single-key subscript (existing element)
ok 112 - Single-key subscript (nonexistent element)
ok 113 - Assign to an element
ok 114 - ... and gets the correct value
ok 115 - We got one of the two choices
ok 116 - .roll(2) returns the right number of items
ok 117 - .roll(2) returned "a"s and "b"s
ok 118 - .roll(100) returns 100 items
ok 119 - .roll(100) (1)
ok 120 - .roll(100) (2)
ok 121 - .roll(100) (1)
ok 122 - .roll(100) (2)
ok 123 - .roll should not change BagHash
ok 124 - .roll should not change BagHash
ok 125 - We got one of the two choices (and this was pretty quick, we hope!)
ok 126 - .roll(100) returns 100 items
ok 127 - .roll(100) (1)
ok 128 - .roll(100) (2)
ok 129 - .roll should not change BagHash
ok 130 - .roll should not change BagHash
ok 131 - We got one of the two choices
ok 132 - .pick(2) returns the right number of items
ok 133 - .pick(2) returned at most one "a"
ok 134 - .pick(2) and the rest are "b"
ok 135 - .pick(*) returns the right number of items
ok 136 - .pick(*) (1)
ok 137 - .pick(*) (2)
ok 138 - .pick should not change BagHash
ok 139 - .pick should not change BagHash
ok 140 - .pick(Callable) returns the right number of items
ok 141 - .pick should not change BagHash
ok 142 - .pick should not change BagHash
ok 143 - .pick(<negative number>) does not return any items
ok 144 - .pick int-ifies arg
ok 145 - We got one of the two choices (and this was pretty quick, we hope!)
ok 146 - .pick(100) returns 100 items
ok 147 - .pick(100) (1)
ok 148 - .pick(100) (2)
ok 149 - .pick should not change BagHash
ok 150 - .pick should not change BagHash
:a(:a(1))
ok 151 - Did we get a Pair
ok 152 - We got one of the two choices
ok 153 - .pickpairs(2) returns the right number of items
ok 154 - .pickpairs(2) returned one "a"
ok 155 - .pickpairs(2) returned one "b"
ok 156 - .pickpairs(*) returns the right number of items
ok 157 - .pickpairs(*) (1)
ok 158 - .pickpairs(*) (2)
ok 159 - .pickpairs should not change Bag
ok 160 - .pickpairs(<negative number>) does not return any items
ok 161 - .pickpairs(Callable) returns the right number of items
ok 162 - are they all Pairs
ok 163 - and they all have an expected value
ok 164 - .pickpairs should not change BagHash
ok 165 - .pickpairs should not change BagHash
ok 166 - We got one of the two choices
ok 167 - .grab(2) returns the right number of items
ok 168 - .grab(2) returned at most one "a"
ok 169 - .grab(2) and the rest are "b"
ok 170 - .grab *should* change BagHash
ok 171 - .grab *should* change BagHash
ok 172 - .grab(*) returns the right number of items
ok 173 - .grab(*) (1)
ok 174 - .grab(*) (2)
ok 175 - .grab *should* change BagHash
ok 176 - .grab *should* change BagHash
ok 177 - .grab(Callable) returns the right number of items
ok 178 - .grab *should* change BagHash
ok 179 - We got one of the two choices (and this was pretty quick, we hope!)
ok 180 - .grab(100) returns 100 items
ok 181 - .grab(100) (1)
ok 182 - .grab(100) (2)
ok 183 - .grab *should* change BagHash
ok 184 - .grab *should* change BagHash
ok 185 - did we get a Pair
ok 186 - We got one of the two choices
ok 187 - .grabpairs(2) returns the right number of items
ok 188 - are they all Pairs
ok 189 - We got one of the two choices
ok 190 - .grabpairs *should* change BagHash
ok 191 - .grabpairs *should* change BagHash
ok 192 - .grabpairs(*) returns the right number of items
ok 193 - are they all Pairs
ok 194 - and they all have an expected value
ok 195 - SetHash.grabpairs(*) gets all elements
ok 196 - SetHash.grabpairs(*) returns elements in a random order
ok 197 - .grabpairs *should* change BagHash
ok 198 - .grabpairs *should* change BagHash
ok 199 - .grabpairs(Callable) returns the right number of items
ok 200 - are they all Pairs
ok 201 - and they all have an expected value
ok 202 - .grabpairs *should* change BagHash
ok 203 - .grabpairs *should* change BagHash
ok 204 - can we parameterize for strings?
ok 205 - does .keyof return the correct type
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck::Binding)
ok 206 - does attempt to add item of wrong type croak
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck::Binding)
ok 207 - do wrong values make initialization croak
ok 208 - "b", initialized to zero, does not exist
ok 209 - Inititalization worked
ok 210 - .elems works
ok 211 - %h<nonexisting> is an Int
ok 212 - %h<nonexisting> is 0
ok 213 - can set an item to 0
ok 214 - "c", set to zero, does not exist
ok 215 - one item left
ok 216 - ... and the right one is gone
ok 217 - can add (++) an item that was removed
ok 218 - ++ on an item reinstates it
ok 219 - can "add" (++) an existing item
ok 220 - ++ on an existing item increments the counter
ok 221 - ++ on an existing item does not add a key
ok 222 - can remove an item with decrement (--)
ok 223 - decrement (--) removes items
ok 224 - item is gone according to exists too
ok 225 - removed item is zero
ok 226 - remove a missing item lives
ok 227 - removing missing item does not change contents
ok 228 - item removed again is still zero
ok 229 - is the hash really a BagHash
not ok 230 - Assigning a Bag to a BagHash # TODO in flux
# Failed test 'Assigning a Bag to a BagHash'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/baghash.rakudo line 515
# Type check failed in assignment to %h; expected BagHash but got Int (2)
not ok 231 - ... works as expected # TODO in flux
# Failed test '... works as expected'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/baghash.rakudo line 516
# expected: 'a:1 b:2 c:2 d:1'
#      got: ''
ok 232 - Method .BagHash works on Int-1
ok 233 - Method .BagHash works on Int-2
ok 234 - Method .BagHash works on Str-1
ok 235 - Method .BagHash works on Str-2
ok 236 - Method .BagHash works on Array-1
ok 237 - Method .BagHash works on Array-2
ok 238 - Method .BagHash works on Hash-1
ok 239 - Method .BagHash works on Hash-2
ok 240 - Method .BagHash works on List-1
ok 241 - Method .BagHash works on List-2
ok 242 - .total gives sum of values (non-empty) 10
ok 243 - +$bag gives sum of values (non-empty) 10
ok 244 - .minpairs works (non-empty) 10
ok 245 - .maxpairs works (non-empty) 10
ok 246 - .fmt(%s) works (non-empty 10)
ok 247 - .fmt(%s,sep) works (non-empty 10)
ok 248 - .fmt(%s%s) works (non-empty 10)
ok 249 - .fmt(%s%s,sep) works (non-empty 10)
ok 250 - .total gives sum of values (non-empty) 8
ok 251 - +$bag gives sum of values (non-empty) 8
ok 252 - .minpairs works (non-empty) 8
ok 253 - .maxpairs works (non-empty) 8
ok 254 - .total gives sum of values (non-empty) 4
ok 255 - +$bag gives sum of values (non-empty) 4
ok 256 - .minpairs works (non-empty) 4
ok 257 - .maxpairs works (non-empty) 4
ok 258 - .total gives sum of values (empty)
ok 259 - +$bag gives sum of values (empty)
ok 260 - .minpairs works (empty)
ok 261 - .maxpairs works (empty)
ok 262 - .fmt(%s) works (empty)
ok 263 - .fmt(%s,sep) works (empty)
ok 264 - .fmt(%s%s) works (empty)
ok 265 - .fmt(%s%s,sep) works (empty)
ok 266 - first key of BagHash is a Pair ("a" => "b")
ok 267 - again first key of BagHash is a Pair ("a" => "b")
ok 268 - named argument is happily eaten by .new method
ok 269 - did we set an Int value
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Str::Numeric)
ok 270 - Make sure we cannot assign Str on a key
ok 271 - did we set an Int value from a .values alias
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Str::Numeric)
ok 272 - Make sure we cannot assign Str on a .values alias
ok 273 - did we set an Int value from a .pairs alias
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Str::Numeric)
ok 274 - Make sure we cannot assign Str on a .pairs alias
ok 275 - did we set an Int value from a .kv alias
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Str::Numeric)
ok 276 - Make sure we cannot assign Str on a .kv alias
ok 277 - did we see all values
ok 278 - did we see all keys
ok 279 - did we see all the pairs
ok 280 - did we see all the kv
ok 281 - did we see all the antipairs
ok 282 - did we see all the kxxv
    1..2
    ok 1 - BagHash.new
    ok 2 - .BagHash
ok 283 - .hash does not cause keys to be stringified
ok 284 - .BagHash returns equivalent BagHash
ok 285 - .Mix returns a Mix
ok 286 - .Mix values are correct
    1..10
    ok 1 - correct return of postfix ++
    ok 2 - correct result of postfix ++
    ok 3 - correct return of postfix --
    ok 4 - correct result of postfix --
    ok 5 - correct return of prefix ++
    ok 6 - correct result of prefix ++
    ok 7 - correct return of prefix --
    ok 8 - correct result of prefix --
    ok 9 - correct return of assignment
    ok 10 - correct result of assignment
ok 287 - BagHash autovivification of non-existent keys
ok 288 - Can use $_ from .values to remove occurrences from BagHash
ok 289 - Can use $_ from .values to set number occurrences in BagHash
ok 290 - Can use $_ from .values to remove items from BagHash
ok 291 - Can use value from .kv to remove occurrences from BagHash
ok 292 - Can use value from .kv to set number occurrences in BagHash
ok 293 - Can use $_ from .kv to remove items from BagHash
ok 294 - Can use value from .pairs to remove occurrences from BagHash
ok 295 - Can use value from .pairs to set number occurrences in BagHash
ok 296 - Can use $_ from .pairs to remove items from BagHash
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Lazy)
    ok 3 - .what matches BagHash
ok 297 - did we throws-like X::Cannot::Lazy?
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Lazy)
    ok 3 - .what matches BagHash
ok 298 - did we throws-like X::Cannot::Lazy?
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Lazy)
    ok 3 - .what matches BagHash
ok 299 - did we throws-like X::Cannot::Lazy?
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Str::Numeric)
ok 300 - (:a("a")).BagHash throws
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Str::Numeric)
ok 301 - BagHash.new-from-pairs( (:a("a")) ) throws
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Numeric::CannotConvert)
ok 302 - (:a(Inf)).BagHash throws
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Numeric::CannotConvert)
ok 303 - BagHash.new-from-pairs( (:a(Inf)) ) throws
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Numeric::CannotConvert)
ok 304 - (:a(-Inf)).BagHash throws
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Numeric::CannotConvert)
ok 305 - BagHash.new-from-pairs( (:a(-Inf)) ) throws
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Numeric::CannotConvert)
ok 306 - (:a(NaN)).BagHash throws
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Numeric::CannotConvert)
ok 307 - BagHash.new-from-pairs( (:a(NaN)) ) throws
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Numeric::CannotConvert)
ok 308 - (:a(<0+3i>)).BagHash throws
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Numeric::CannotConvert)
ok 309 - BagHash.new-from-pairs( (:a(<0+3i>)) ) throws
    1..3
    ok 1 - weight decrement
    ok 2 - Pair value decrement
    ok 3 - weight set to zero
ok 310 - elements with weight zero are removed
    1..2
    ok 1 - weight < 0 removes element
    ok 2 - Pair value < 0 removes element
ok 311 - elements with negative weights are removed
ok 312 - can .grab() a BagHash key with weight larger than 64 bits
ok 313 - did we get right number of elements
ok 314 - do we get 1 for a
ok 315 - do we get 0 value for e
ok 316 - is the %h really a BagHash
ok 317 - did we get right number of elements after re-init
ok 318 - did we get 5 by removing e
ok 319 - did we get right number of elements after :delete
ok 320 - can delete from BagHash by assignment
ok 321 - did we get right number of elements assignment
ok 322 - can successfully set >64-bit value
ok 323 - can we smartmatch empty
ok 324 - coerce BagHash -> Set
ok 325 - coerce BagHash -> SetHash
ok 326 - coerce BagHash -> Bag
ok 327 - coerce BagHash -> Mix
ok 328 - coerce BagHash -> MixHash
ok 329 - parameterized BagHash
ok 330 - did it parameterize ok
ok 331 - adding element of wrong type fails
ok 332 - must have Ints on creation
ok 333 - does .item work on BagHashes
# FUDGED!
1..7
ok 1 - basic sanity test (1)
ok 2 - basic sanity test (2)
ok 3 - # SKIP cat NYI
ok 4 - # SKIP cat NYI
ok 5 - # SKIP cat NYI
ok 6 - # SKIP cat NYI
ok 7 - # SKIP cat NYI
# FUDGED!
1..70
ok 1 - The object is-a 'Int'
ok 2 - The object is-a 'Num'
ok 3 - The object is-a 'Complex'
ok 4 - The object is-a 'Rat'
ok 5 - The object is-a 'Str'
ok 6 - # SKIP Bit NYI
ok 7 - The object is-a 'Regex'
ok 8 - The object is-a 'Set'
ok 9 - The object is-a 'Block'
ok 10 - The object is-a 'List'
ok 11 - The object is-a 'Scalar'
ok 12 - The object is-a 'Array'
ok 13 - The object is-a 'Hash'
ok 14 - 
ok 15 - The object is-a 'Routine'
ok 16 - The object is-a 'Stash'
ok 17 - 
ok 18 - # SKIP Integral NYI
    1..3
    ok 1 - code dies
    ok 2 - right exception type (Exception)
    ok 3 - .message matches Cannot unbox 101 bit wide bigint into native integer
ok 19 - Assign big bigint to native won't overflow silently
ok 20 - num reports as Num
ok 21 - num dispatches properly
ok 22 - # SKIP complex NYI
ok 23 - # SKIP rat NYI
ok 24 - # SKIP bit NYI
ok 25 - # SKIP buf NYI
ok 26 - 
ok 27 - The object is-a 'Whatever'
ok 28 - 
ok 29 - The object is-a 'Failure'
ok 30 - The object is-a 'Exception'
ok 31 - The object is-a 'Range'
ok 32 - The object is-a 'Bag'
ok 33 - The object is-a 'Signature'
ok 34 - The object is-a 'Capture'
ok 35 - 
ok 36 - The object is-a 'Instant'
ok 37 - The object is-a 'Duration'
ok 38 - The object does QuantHash
ok 39 - The object is-a 'SetHash'
ok 40 - The object is-a 'BagHash'
ok 41 - The object is-a 'Pair'
ok 42 - The object is-a 'Map'
ok 43 - The object is-a 'Routine'
ok 44 - The object is-a 'Sub'
ok 45 - The object is-a 'Sub'
ok 46 - nested sub call
ok 47 - nested sub call
ok 48 - The object is-a 'Method'
ok 49 - The object is-a 'Submethod'
ok 50 - The object is-a 'Macro'
ok 51 - The object is-a 'Match'
ok 52 - The object is-a 'Grammar'
ok 53 - The object is-a 'Any'
ok 54 - The object is-a 'Bool'
ok 55 - The object is-a 'Order'
ok 56 - # SKIP Matcher isa NYI
ok 57 - The object is-a 'Proxy'
ok 58 - Positional exists
ok 59 - Associative exists
ok 60 - # SKIP Ordering NYI
ok 61 - # SKIP KeyExtractor NYI
ok 62 - # SKIP Comparator NYI
ok 63 - # SKIP OrderingPair NYI
ok 64 - The object is-a 'HyperWhatever'
ok 65 - The object is-a 'utf8'
ok 66 - The object is-a 'utf16'
ok 67 - The object is-a 'utf32'
ok 68 - # SKIP num16  NYI
ok 69 - Array of Int @box
ok 70 - Array of Array of Int @box
# FUDGED!
1..21
ok 1 - numeric equal
ok 2 - string equal
ok 3 - negative numeric equal
ok 4 - negative string equal
ok 5 - # SKIP integer Inf
ok 6 - # SKIP integer Inf
ok 7 - # SKIP integer -Inf
ok 8 - # SKIP integer -Inf
ok 9 - truncate(Inf) ~~ Inf
    1..2
    ok 1 - code returned a Failure
        1..2
        ok 1 - code dies
        ok 2 - right exception type (X::Numeric::CannotConvert)
    ok 2 - Failure threw when sunk
ok 10 - attempting to convert Inf to Int throws
    1..2
    ok 1 - code returned a Failure
        1..2
        ok 1 - code dies
        ok 2 - right exception type (X::Numeric::CannotConvert)
    ok 2 - Failure threw when sunk
ok 11 - attempting to convert Inf to Int throws
    1..2
    ok 1 - code returned a Failure
        1..2
        ok 1 - code dies
        ok 2 - right exception type (X::Numeric::CannotConvert)
    ok 2 - Failure threw when sunk
ok 12 - attempting to convert ∞ to Int throws
    1..2
    ok 1 - code returned a Failure
        1..2
        ok 1 - code dies
        ok 2 - right exception type (X::Numeric::CannotConvert)
    ok 2 - Failure threw when sunk
ok 13 - attempting to convert -∞ to Int throws
    1..2
    ok 1 - code returned a Failure
        1..2
        ok 1 - code dies
        ok 2 - right exception type (X::Numeric::CannotConvert)
    ok 2 - Failure threw when sunk
ok 14 - attempting to convert NaN to Int throws
ok 15 - multiply rand by Inf without maximum recursion depth exceeded
    1..4
    ok 1 - 'my Int $x = Inf' died
    ok 2 - right exception type (X::Syntax::Number::LiteralType)
    ok 3 - .vartype matches (Int)
    ok 4 - .value matches Inf
ok 16 - trying to assign Inf to Int gives a helpful error
ok 17 - assigning Inf to Num works without errors
ok 18 - -Inf² follows mathematical order of operations
ok 19 - -∞² follows mathematical order of operations
ok 20 - −Inf² follows mathematical order of operations (U+2212 minus)
ok 21 - −∞² follows mathematical order of operations (U+2212 minus)
# FUDGED!
1..103
ok 1 - int8 can be 127
ok 2 - int8 can be -128
ok 3 - int8 overflows to -128
ok 4 - int8 underflows to 127
    1..2
    not ok 1 - code dies # TODO setting more than max throws
    # Failed test 'code dies'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 77
    ok 2 - # SKIP Code did not die, can not check exception
not ok 5 - setting int8 to more than 127 throws # TODO setting more than max throws
# Failed test 'setting int8 to more than 127 throws'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 77
    1..2
    not ok 1 - code dies # TODO setting less than min throws
    # Failed test 'code dies'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 92
    ok 2 - # SKIP Code did not die, can not check exception
not ok 6 - setting int8 to less than -128 throws # TODO setting less than min throws
# Failed test 'setting int8 to less than -128 throws'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 92
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 7 - int8 cannot be a string
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 8 - int8 cannot be non-integer
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 9 - int8 cannot be NaN
ok 10 - int8 $var++ works
ok 11 - int8 $var-- works
ok 12 - int16 can be 32767
ok 13 - int16 can be -32768
ok 14 - int16 overflows to -32768
ok 15 - int16 underflows to 32767
    1..2
    not ok 1 - code dies # TODO setting more than max throws
    # Failed test 'code dies'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 77
    ok 2 - # SKIP Code did not die, can not check exception
not ok 16 - setting int16 to more than 32767 throws # TODO setting more than max throws
# Failed test 'setting int16 to more than 32767 throws'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 77
    1..2
    not ok 1 - code dies # TODO setting less than min throws
    # Failed test 'code dies'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 92
    ok 2 - # SKIP Code did not die, can not check exception
not ok 17 - setting int16 to less than -32768 throws # TODO setting less than min throws
# Failed test 'setting int16 to less than -32768 throws'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 92
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 18 - int16 cannot be a string
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 19 - int16 cannot be non-integer
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 20 - int16 cannot be NaN
ok 21 - int16 $var++ works
ok 22 - int16 $var-- works
ok 23 - int32 can be 2147483647
ok 24 - int32 can be -2147483648
ok 25 - int32 overflows to -2147483648
ok 26 - int32 underflows to 2147483647
    1..2
    not ok 1 - code dies # TODO setting more than max throws
    # Failed test 'code dies'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 77
    ok 2 - # SKIP Code did not die, can not check exception
not ok 27 - setting int32 to more than 2147483647 throws # TODO setting more than max throws
# Failed test 'setting int32 to more than 2147483647 throws'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 77
    1..2
    not ok 1 - code dies # TODO setting less than min throws
    # Failed test 'code dies'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 92
    ok 2 - # SKIP Code did not die, can not check exception
not ok 28 - setting int32 to less than -2147483648 throws # TODO setting less than min throws
# Failed test 'setting int32 to less than -2147483648 throws'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 92
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 29 - int32 cannot be a string
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 30 - int32 cannot be non-integer
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 31 - int32 cannot be NaN
ok 32 - int32 $var++ works
ok 33 - int32 $var-- works
ok 34 - int64 can be 9223372036854775807
ok 35 - int64 can be -9223372036854775808
ok 36 - int64 overflows to -9223372036854775808
ok 37 - int64 underflows to 9223372036854775807
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 38 - setting int64 to more than 9223372036854775807 throws
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 39 - setting int64 to less than -9223372036854775808 throws
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 40 - int64 cannot be a string
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 41 - int64 cannot be non-integer
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 42 - int64 cannot be NaN
ok 43 - int64 $var++ works
ok 44 - int64 $var-- works
ok 45 - uint8 can be 255
ok 46 - uint8 can be 0
ok 47 - uint8 overflows to 0
ok 48 - uint8 underflows to 255
    1..2
    not ok 1 - code dies # TODO setting more than max throws
    # Failed test 'code dies'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 77
    ok 2 - # SKIP Code did not die, can not check exception
not ok 49 - setting uint8 to more than 255 throws # TODO setting more than max throws
# Failed test 'setting uint8 to more than 255 throws'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 77
    1..2
    not ok 1 - code dies # TODO setting less than min throws
    # Failed test 'code dies'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 92
    ok 2 - # SKIP Code did not die, can not check exception
not ok 50 - setting uint8 to less than 0 throws # TODO setting less than min throws
# Failed test 'setting uint8 to less than 0 throws'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 92
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 51 - uint8 cannot be a string
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 52 - uint8 cannot be non-integer
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 53 - uint8 cannot be NaN
ok 54 - uint8 $var++ works
ok 55 - uint8 $var-- works
ok 56 - uint16 can be 65535
ok 57 - uint16 can be 0
ok 58 - uint16 overflows to 0
ok 59 - uint16 underflows to 65535
    1..2
    not ok 1 - code dies # TODO setting more than max throws
    # Failed test 'code dies'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 77
    ok 2 - # SKIP Code did not die, can not check exception
not ok 60 - setting uint16 to more than 65535 throws # TODO setting more than max throws
# Failed test 'setting uint16 to more than 65535 throws'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 77
    1..2
    not ok 1 - code dies # TODO setting less than min throws
    # Failed test 'code dies'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 92
    ok 2 - # SKIP Code did not die, can not check exception
not ok 61 - setting uint16 to less than 0 throws # TODO setting less than min throws
# Failed test 'setting uint16 to less than 0 throws'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 92
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 62 - uint16 cannot be a string
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 63 - uint16 cannot be non-integer
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 64 - uint16 cannot be NaN
ok 65 - uint16 $var++ works
ok 66 - uint16 $var-- works
ok 67 - uint32 can be 4294967295
ok 68 - uint32 can be 0
ok 69 - uint32 overflows to 0
ok 70 - uint32 underflows to 4294967295
    1..2
    not ok 1 - code dies # TODO setting more than max throws
    # Failed test 'code dies'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 77
    ok 2 - # SKIP Code did not die, can not check exception
not ok 71 - setting uint32 to more than 4294967295 throws # TODO setting more than max throws
# Failed test 'setting uint32 to more than 4294967295 throws'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 77
    1..2
    not ok 1 - code dies # TODO setting less than min throws
    # Failed test 'code dies'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 92
    ok 2 - # SKIP Code did not die, can not check exception
not ok 72 - setting uint32 to less than 0 throws # TODO setting less than min throws
# Failed test 'setting uint32 to less than 0 throws'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 92
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 73 - uint32 cannot be a string
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 74 - uint32 cannot be non-integer
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 75 - uint32 cannot be NaN
ok 76 - uint32 $var++ works
ok 77 - uint32 $var-- works
not ok 78 - uint64 can be 18446744073709551615 # TODO getting -1 instead of 18446744073709551615
# Failed test 'uint64 can be 18446744073709551615'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 27
# expected: '18446744073709551615'
#      got: '-1'
ok 79 - uint64 can be 0
ok 80 - uint64 overflows to 0
not ok 81 - uint64 underflows to 18446744073709551615 # TODO getting -1 instead of 0
# Failed test 'uint64 underflows to 18446744073709551615'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 51
# expected: '18446744073709551615'
#      got: '-1'
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 82 - setting uint64 to more than 18446744073709551615 throws
    1..2
    not ok 1 - code dies # TODO setting less than min throws
    # Failed test 'code dies'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 92
    ok 2 - # SKIP Code did not die, can not check exception
not ok 83 - setting uint64 to less than 0 throws # TODO setting less than min throws
# Failed test 'setting uint64 to less than 0 throws'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 92
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 84 - uint64 cannot be a string
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 85 - uint64 cannot be non-integer
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 86 - uint64 cannot be NaN
ok 87 - uint64 $var++ works
ok 88 - uint64 $var-- works
ok 89 - byte can be 255
ok 90 - byte can be 0
ok 91 - byte overflows to 0
ok 92 - byte underflows to 255
    1..2
    not ok 1 - code dies # TODO setting more than max throws
    # Failed test 'code dies'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 77
    ok 2 - # SKIP Code did not die, can not check exception
not ok 93 - setting byte to more than 255 throws # TODO setting more than max throws
# Failed test 'setting byte to more than 255 throws'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 77
    1..2
    not ok 1 - code dies # TODO setting less than min throws
    # Failed test 'code dies'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 92
    ok 2 - # SKIP Code did not die, can not check exception
not ok 94 - setting byte to less than 0 throws # TODO setting less than min throws
# Failed test 'setting byte to less than 0 throws'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 92
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 95 - byte cannot be a string
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 96 - byte cannot be non-integer
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 97 - byte cannot be NaN
ok 98 - byte $var++ works
ok 99 - byte $var-- works
ok 100 - uint32 in union is unsigned
not ok 101 - uint16 in union is unsigned # TODO uint behaves like signed int in CUnion
# Failed test 'uint16 in union is unsigned'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 122
# expected: '54919'
#      got: '-10617'
not ok 102 - uint8 in union is unsigned # TODO uint behaves like signed int in CUnion
# Failed test 'uint8 in union is unsigned'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 123
# expected: '135'
#      got: '-121'
ok 103 - byte.Range works
# FUDGED!
1..14
ok 1 - is TypeName on @ sigil has effect (my)
ok 2 - is TypeName on % sigil has effect (my)
ok 3 - is TypeName on @ sigil has effect (state)
ok 4 - is TypeName on % sigil has effect (state)
ok 5 - is TypeName on @ sigil has effect (has)
ok 6 - is TypeName on % sigil has effect (has)
ok 7 - Get fresh BagHash in my variable per iteration (0)
ok 8 - Get fresh BagHash in my variable per iteration (1)
ok 9 - # SKIP state variables with `is BagHash`
ok 10 - # SKIP state variables with `is BagHash`
ok 11 - Get fresh BagHash in new object per iteration (0)
ok 12 - Get fresh BagHash in new object per iteration (1)
ok 13 - can we have parameterized type
    1..4
    ok 1 - 'my @a is Int is Str' died
    ok 2 - right exception type (X::Syntax::Variable::ConflictingTypes)
    ok 3 - .inner matches (Str)
    ok 4 - .outer matches (Int)
ok 14 - did we throw on multiple "is" types
# FUDGED!
1..13
ok 1 - was "a" really called
ok 2 - right deprecation for a()
ok 3 - was "awith" really called
ok 4 - right deprecation for awith()
not ok 5 - right deprecation for A.new # TODO NYI
# Failed test 'right deprecation for A.new'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/isDEPRECATED.rakudo line 50
# expected: 'Saw 1 occurrence of deprecated code.
# ================================================================================
# Method new (from A) seen at:
#   /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/isDEPRECATED.rakudo, line 48
# Please use something else instead.
# --------------------------------------------------------------------------------'
#      got: (Nil)
not ok 6 - right deprecation for Awith.new # TODO NYI
# Failed test 'right deprecation for Awith.new'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/isDEPRECATED.rakudo line 62
# expected: 'Saw 1 occurrence of deprecated code.
# ================================================================================
# Method new (from Awith) seen at:
#   /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/isDEPRECATED.rakudo, lines 59,60
# Please use 'Fnorkle.new' instead.
# --------------------------------------------------------------------------------'
#      got: (Nil)
ok 7 - was "C.new.foo" really called
ok 8 - right deprecation for C.new.foo
ok 9 - was "Cwith.new.foo" really called
ok 10 - right deprecation Cwith.new.foo
ok 11 - right deprecation for D.new.foo
not ok 12 - right deprecation Dwith.new.foo # TODO NYI
# Failed test 'right deprecation Dwith.new.foo'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/isDEPRECATED.rakudo line 121
# expected: 'Saw 1 occurrence of deprecated code.
# ================================================================================
# Method foo (from Dwith) seen at:
#   /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/isDEPRECATED.rakudo, lines 118,119
# Please use 'bar' instead.
# --------------------------------------------------------------------------------'
#      got: (Nil)
ok 13 - right deprecation for rt120908()
# FUDGED!
1..60
ok 1 - # SKIP 'is ObjectType' NYI
ok 2 - # SKIP 'is ObjectType' NYI
ok 3 - # SKIP 'is ObjectType' NYI
ok 4 - # SKIP 'is ObjectType' NYI
ok 5 - # SKIP 'is ObjectType' NYI
ok 6 - # SKIP 'is ObjectType' NYI
ok 7 - # SKIP 'is ObjectType' NYI
ok 8 - # SKIP 'is ObjectType' NYI
ok 9 - # SKIP 'is ObjectType' NYI
ok 10 - # SKIP 'is ObjectType' NYI
ok 11 - # SKIP 'is ObjectType' NYI
ok 12 - # SKIP 'is ObjectType' NYI
ok 13 - # SKIP 'is ObjectType' NYI
ok 14 - # SKIP 'is ObjectType' NYI
ok 15 - # SKIP 'is ObjectType' NYI
ok 16 - # SKIP 'is ObjectType' NYI
ok 17 - # SKIP 'is ObjectType' NYI
ok 18 - # SKIP 'is ObjectType'
ok 19 - # SKIP 'is ObjectType'
ok 20 - # SKIP 'is ObjectType'
ok 21 - # SKIP 'is ObjectType'
ok 22 - # SKIP 'is ObjectType'
ok 23 - # SKIP 'is ObjectType'
ok 24 - # SKIP 'is ObjectType'
ok 25 - # SKIP 'is ObjectType'
ok 26 - # SKIP 'is ObjectType'
ok 27 - # SKIP 'is ObjectType'
ok 28 - # SKIP 'is ObjectType'
ok 29 - # SKIP 'is ObjectType'
ok 30 - # SKIP 'is ObjectType'
ok 31 - # SKIP 'is ObjectType'
ok 32 - # SKIP 'is ObjectType'
ok 33 - # SKIP 'is ObjectType'
ok 34 - # SKIP 'is ObjectType'
ok 35 - # SKIP 'is ObjectType' NYI
ok 36 - # SKIP 'is ObjectType' NYI
ok 37 - # SKIP 'is ObjectType' NYI
ok 38 - # SKIP 'is ObjectType' NYI
ok 39 - # SKIP 'is ObjectType' NYI
ok 40 - # SKIP 'is ObjectType' NYI
ok 41 - # SKIP 'is ObjectType' NYI
ok 42 - # SKIP 'is ObjectType' NYI
ok 43 - # SKIP 'is ObjectType' NYI
ok 44 - # SKIP 'is ObjectType' NYI
ok 45 - # SKIP 'is ObjectType' NYI
ok 46 - # SKIP 'is ObjectType' NYI
ok 47 - # SKIP 'is ObjectType' NYI
ok 48 - # SKIP 'is ObjectType' NYI
ok 49 - # SKIP 'is ObjectType' NYI
ok 50 - # SKIP 'is ObjectType' NYI
ok 51 - # SKIP 'is ObjectType' NYI
ok 52 - # SKIP 'is ObjectType' NYI
ok 53 - # SKIP 'is ObjectType' NYI
ok 54 - # SKIP 'is ObjectType' NYI
ok 55 - # SKIP 'is ObjectType' NYI
ok 56 - # SKIP 'is ObjectType'
ok 57 - # SKIP 'is ObjectType'
ok 58 - # SKIP 'is ObjectType'
ok 59 - # SKIP 'is ObjectType'
    1..7
    ok 1 - custom QuantHash
    ok 2 - Set
    ok 3 - SetHash
    ok 4 - Bag
    ok 5 - BagHash
    ok 6 - Mix
    ok 7 - MixHash
ok 60 - QuantHash.Capture
# FUDGED!
1..80
ok 1 - The object is-a 'Array'
ok 2 - The object is-a 'Pair'
ok 3 - the array has one value in it
ok 4 - The object is-a 'Pair'
ok 5 - got the right pair value
ok 6 - the array has two values in it
ok 7 - The object is-a 'Pair'
ok 8 - got the right pair value
ok 9 - The object is-a 'Array'
ok 10 - The object is-a 'Hash'
ok 11 - our hash has two keys
ok 12 - the array has one value in it
ok 13 - The object is-a 'Hash'
ok 14 - got the right value for key
ok 15 - got the right value1 for key1
ok 16 - The object is-a 'Array'
ok 17 - got 4 elements in the Array of Arrays
ok 18 - got the right first element
ok 19 - The object is-a 'Array'
ok 20 - got the right second/first element
ok 21 - got the right second/second element
ok 22 - The object is-a 'Array'
ok 23 - got the right third/first element
ok 24 - got the right third/second element
ok 25 - got the right fourth element
ok 26 - The object is-a 'Array'
ok 27 - got three elements in the Array
ok 28 - The object is-a 'Sub'
ok 29 - The object is-a 'Block'
ok 30 - The object is-a 'Block'
ok 31 - the first element (when executed) is 1
ok 32 - the second element (when executed) is 2
ok 33 - the third element (when executed) is 3
ok 34 - The object is-a 'Hash'
ok 35 - The object is-a 'Array'
ok 36 - it should have 3 values in it
ok 37 - got the right value
ok 38 - got the right value
ok 39 - got the right value
ok 40 - it should have 3 values in it
ok 41 - got the right value (when I pull the array out)
ok 42 - got the right value (when I pull the array out)
ok 43 - got the right value (when I pull the array out)
ok 44 - it should now have 4 values in it
ok 45 - got the right value (which we just pushed onto the list)
ok 46 - The object is-a 'Hash'
ok 47 - The object is-a 'Array'
ok 48 - The object is-a 'Array'
ok 49 - it should have 3 values in it
ok 50 - got the right value
ok 51 - got the right value
ok 52 - got the right value
ok 53 - it should have 3 values in it
ok 54 - got the right value (when I pull the array out)
ok 55 - got the right value (when I pull the array out)
ok 56 - got the right value (when I pull the array out)
ok 57 - it should now have 4 values in it
ok 58 - got the right value (which we just pushed onto the array)
ok 59 - itemized hash should not get decomposed
ok 60 - itemized hash should not get decomposed
ok 61 - itemized hash should not get decomposed
ok 62 - array nested in hashitem in one declaration
ok 63 - The object is-a 'Array'
ok 64 - The object is-a 'Array'
ok 65 - The object is-a 'Array'
ok 66 - The object is-a 'Array'
ok 67 - The object is-a 'Array'
ok 68 - 5 level deep arrays only structure
ok 69 - The object is-a 'Array'
ok 70 - The object is-a 'Hash'
ok 71 - The object is-a 'Array'
ok 72 - The object is-a 'Hash'
ok 73 - one key at level 4
ok 74 - The object is-a 'Array'
ok 75 - The object is-a 'Hash'
ok 76 - 6 level deep mixed structure
ok 77 - The object is-a 'Hash'
not ok 78 - The object is-a 'Hash' # TODO isa hash
# Failed test 'The object is-a 'Hash''
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/mixed_multi_dimensional.rakudo line 197
# Actual type: Any
not ok 79 - two keys at level 4 # TODO unknown
# Failed test 'two keys at level 4'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/mixed_multi_dimensional.rakudo line 199
# expected: '2'
#      got: '1'
not ok 80 - more keys at level 4 # TODO unknown
# Failed test 'more keys at level 4'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/mixed_multi_dimensional.rakudo line 200
# expected: '5'
#      got: (Any)
# FUDGED!
1..284
We do get here, right?
ok 1 - we got a MixHash
ok 2 - ...with the right elements
ok 3 - Defaults to 0
ok 4 - Single-key subscript (existing element)
ok 5 - Single-key subscript yields an Int
ok 6 - Single-key subscript (nonexistent element)
ok 7 - Single-key subscript yields an Int (nonexistent element)
ok 8 - exists with existing element
ok 9 - exists with nonexistent element
ok 10 - Values returns the correct number of values
ok 11 - Values returns the correct sum
ok 12 - Bool returns True if there is something in the MixHash
ok 13 - Bool returns False if there is nothing in the MixHash
ok 14 - .hash doesn't die
ok 15 - ...and it returned a Hash
ok 16 - ...with the right elements
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Assignment::RO)
ok 17 - Can't assign to .keys
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Assignment::RO)
ok 18 - Can't assign to .values
ok 19 - Multiple-element access
ok 20 - Multiple-element access (with nonexistent elements)
ok 21 - .total gives sum of values
ok 22 - .total gives sum of values
ok 23 - +$mix gives sum of values
ok 24 - Can assign to an existing element
ok 25 - ... and assignment takes effect
ok 26 - Can assign to a new element
ok 27 - ... and assignment takes effect
ok 28 - Can assign zero to a nonexistent element
ok 29 - ... and that didn't create the element
ok 30 - Can assign zero to a existing element
ok 31 - ... and it goes away
ok 32 - Can ++ an existing element
ok 33 - ... and the increment happens
ok 34 - Can ++ a new element
ok 35 - ... and the element is created
ok 36 - Can -- an existing element
ok 37 - ... and the decrement happens
ok 38 - Can -- an element with value 1
ok 39 - ... and it goes away
ok 40 - Can -- an element that doesn't exist
ok 41 - ... and everything is still okay
ok 42 - Identical mixs smartmatch with each other
ok 43 - Identical mixs smartmatch with each other
ok 44 - Subset does not smartmatch
ok 45 - Subset (only quantity different) does not smartmatch
ok 46 - Superset does not smartmatch
ok 47 - Superset (only quantity different) does not smartmatch
ok 48 - Smartmatch is not element of
ok 49 - Type-checking smartmatch works
ok 50 - Set smartmatches with equivalent MixHash.new:
ok 51 - ... but not if the Mix has greater quantities
ok 52 - Type-checking smartmatch works
ok 53 - Str.MixHash makes a MixHash
ok 54 - 'a'.MixHash is mix a
ok 55 - Pair.MixHash makes a MixHash
ok 56 - (a => 100000).MixHash is mix a:100000
ok 57 - (a => 0).MixHash is the empty mix
ok 58 - <a b c>.MixHash makes a MixHash
ok 59 - <a b c a>.MixHash makes the mix a:2 b:1 c:1
ok 60 - [a b c a].MixHash makes the mix a:2 b:1 c:1
ok 61 - [a => 3, b => 0, 'c', 'a'].MixHash makes the mix a:4 c:1
ok 62 - a	2 b	4 c	0.MixHash makes a MixHash
ok 63 - a	2 b	4 c	0.MixHash makes the mix a:2 b:4
ok 64 - :exists with existing element
ok 65 - :exists with nonexistent element
ok 66 - :delete works on MixHash
ok 67 - ...and actually deletes
ok 68 - Int keys are left as Ints
ok 69 - Bool keys are left as Bools
ok 70 - And Str keys are permitted in the same set
ok 71 - All keys have the right values
ok 72 - MixHash.kv returns list of keys and values
ok 73 - &MixHash.new given an array of strings produces a MixHash
ok 74 - ...with the right elements
ok 75 - &MixHash.new given an array of pairs produces a MixHash
ok 76 - make sure .total is ok
ok 77 - make sure .elems is ok
ok 78 - &MixHash.new given a Hash produces a MixHash
ok 79 - ... with four elements
ok 80 - ... which are all Pairs
ok 81 - &MixHash.new given a Hash produces a MixHash
ok 82 - ... with four elements
ok 83 - &MixHash.new given a Set produces a MixHash
ok 84 - ... with one element
ok 85 - &MixHash.new given a MixHash produces a MixHash
ok 86 - ... with one element
ok 87 - &MixHash.new given a Mix produces a MixHash
ok 88 - ... with one element
ok 89 - make sure .total is ok
ok 90 - make sure .elems is ok
ok 91 - .list returns 3 things
ok 92 - ... all of which are Pairs
ok 93 - .pairs returns 3 things
ok 94 - ... all of which are Pairs
ok 95 - ... the keys of which are Strs
ok 96 - ... and the values of which are Ints
ok 97 - .raku lives
ok 98 - ... and produces a string
ok 99 - ... of reasonable length
ok 100 - .raku.EVAL lives
ok 101 - ... and produces a MixHash
ok 102 - ... and it has the correct values
ok 103 - .Str lives
ok 104 - ... and produces a string
ok 105 - ... which only contains bar baz and foo with the proper counts and separated by spaces
ok 106 - .gist lives
ok 107 - ... and produces a string
ok 108 - ... of reasonable length
ok 109 - ... which mentions foo
ok 110 - ... which mentions bar
ok 111 - ... which mentions baz
ok 112 - A MixHash bound to a %var is a MixHash
ok 113 - ...with the right elements
ok 114 - Single-key subscript (existing element)
ok 115 - Single-key subscript (nonexistent element)
ok 116 - Assign to an element
ok 117 - ... and gets the correct value
ok 118 - We got one of the two choices
ok 119 - .roll with no arguments returns a key of the MixHash
ok 120 - .roll(0) gives you an Iterable
ok 121 - .roll(1) gives you an Iterable
ok 122 - .roll(2) gives you an Iterable
ok 123 - .roll(0) returns 0 results
ok 124 - .roll(1) returns 1 result
ok 125 - .roll(2) returns the right number of items
ok 126 - .roll(2) returned "a"s and "b"s
ok 127 - .roll(100) returns 100 items
ok 128 - .roll(100) (1)
ok 129 - .roll(100) (2)
ok 130 - .roll(*)[^100] (1)
ok 131 - .roll(*)[^100] (2)
ok 132 - .roll should not change MixHash
ok 133 - .roll should not change MixHash
ok 134 - make sure total is ok
ok 135 - .roll should not change MixHash
ok 136 - We got one of the two choices (and this was pretty quick, we hope!)
ok 137 - .roll(100) returns 100 items
ok 138 - .roll(100) (1)
ok 139 - .roll(100) (2)
ok 140 - .roll should not change MixHash
ok 141 - .roll should not change MixHash
ok 142 - did we get a Pair
ok 143 - We got one of the two choices
ok 144 - .grabpairs(2) returns the right number of items
ok 145 - are they all Pairs
ok 146 - We got one of the two choices
ok 147 - .grabpairs *should* change MixHash
ok 148 - .grabpairs *should* change MixHash
ok 149 - .grabpairs(*) returns the right number of items
ok 150 - are they all Pairs
ok 151 - and they all have an expected value
ok 152 - MixHash.grabpairs(*) gets all elements
ok 153 - MixHash.grabpairs(*) returns elements in a random order
ok 154 - .grabpairs *should* change MixHash
ok 155 - .grabpairs *should* change MixHash
ok 156 - "b", initialized to zero, does not exist
ok 157 - Inititalization worked
ok 158 - .elems works
ok 159 - %h<nonexisting> is an Int
ok 160 - %h<nonexisting> is 0
ok 161 - can set an item to 0
ok 162 - "c", set to zero, does not exist
ok 163 - one item left
ok 164 - ... and the right one is gone
ok 165 - can add (++) an item that was removed
ok 166 - ++ on an item reinstates it
ok 167 - can "add" (++) an existing item
ok 168 - ++ on an existing item increments the counter
ok 169 - ++ on an existing item does not add a key
ok 170 - can remove an item with decrement (--)
ok 171 - decrement (--) removes items
ok 172 - item is gone according to exists too
ok 173 - removed item is zero
ok 174 - going negative returns 0
ok 175 - item exists too
ok 176 - going negative adds the item
ok 177 - item now at -1
ok 178 - is the hash really a MixHash
not ok 179 - Assigning a Mix to a MixHash # TODO in flux
# Failed test 'Assigning a Mix to a MixHash'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/mixhash.rakudo line 369
# Type check failed in assignment to %h; expected MixHash but got Int (1)
not ok 180 - ... works as expected # TODO in flux
# Failed test '... works as expected'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/mixhash.rakudo line 370
# expected: 'a:1 b:2 c:2 d:1'
#      got: ''
ok 181 - Method .MixHash works on Int-1
ok 182 - Method .MixHash works on Int-2
ok 183 - Method .MixHash works on Str-1
ok 184 - Method .MixHash works on Str-2
ok 185 - Method .MixHash works on Array-1
ok 186 - Method .MixHash works on Array-2
ok 187 - Method .MixHash works on Hash-1
ok 188 - Method .MixHash works on Hash-2
ok 189 - Method .MixHash works on List-1
ok 190 - Method .MixHash works on List-2
ok 191 - .total gives sum of values (non-empty) 11
ok 192 - +$mix gives sum of values (non-empty) 11
ok 193 - .minpairs works (non-empty) 11
ok 194 - .maxpairs works (non-empty) 11
ok 195 - .fmt(%s) works (non-empty 11)
ok 196 - .fmt(%s,sep) works (non-empty 11)
ok 197 - .fmt(%s%s) works (non-empty 11)
ok 198 - .fmt(%s%s,sep) works (non-empty 11)
ok 199 - .total gives sum of values (non-empty) 8.8
ok 200 - +$mix gives sum of values (non-empty) 8.8
ok 201 - .minpairs works (non-empty) 8.8
ok 202 - .maxpairs works (non-empty) 8.8
ok 203 - .total gives sum of values (non-empty) 4.4
ok 204 - +$mix gives sum of values (non-empty) 4.4
ok 205 - .minpairs works (non-empty) 4.4
ok 206 - .maxpairs works (non-empty) 4.4
ok 207 - .total gives sum of values (empty)
ok 208 - +$mix gives sum of values (empty)
ok 209 - .minpairs works (empty)
ok 210 - .maxpairs works (empty)
ok 211 - .fmt(%s) works (empty)
ok 212 - .fmt(%s,sep) works (empty)
ok 213 - .fmt(%s%s) works (empty)
ok 214 - .fmt(%s%s,sep) works (empty)
ok 215 - did we set a Real value
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Str::Numeric)
ok 216 - Make sure we cannot assign Str on a key
ok 217 - did we set a Real value from a .values alias
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Str::Numeric)
ok 218 - Make sure we cannot assign Str on a .values alias
ok 219 - did we set a Real value from a .pairs alias
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Str::Numeric)
ok 220 - Make sure we cannot assign Str on a .pairs alias
ok 221 - did we set a Real value from a .kv alias
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Str::Numeric)
ok 222 - Make sure we cannot assign Str on a .kv alias
ok 223 - did we see all values
ok 224 - did we see all keys
ok 225 - did we see all the pairs
ok 226 - did we see all the kv
ok 227 - did we see all the antipairs
    1..2
    ok 1 - MixHash.new
    ok 2 - .MixHash
ok 228 - .hash does not cause keys to be stringified
ok 229 - .Bag coercer
ok 230 - .BagHash coercer
ok 231 - negative MixHash weights removed from Bag coercion without warnings
    1..10
    ok 1 - correct return of postfix ++
    ok 2 - correct result of postfix ++
    ok 3 - correct return of postfix --
    ok 4 - correct result of postfix --
    ok 5 - correct return of prefix ++
    ok 6 - correct result of prefix ++
    ok 7 - correct return of prefix --
    ok 8 - correct result of prefix --
    ok 9 - correct return of assignment
    ok 10 - correct result of assignment
ok 232 - MixHash autovivification of non-existent keys
ok 233 - negative weights remain with  ∪  operator
ok 234 - negative weights remain with (|) operator
ok 235 - Can use $_ from .values to remove occurrences from MixHash
ok 236 - Can use $_ from .values to set number occurrences in MixHash
ok 237 - Can use $_ from .values to remove items from MixHash
ok 238 - Can use value from .kv to remove occurrences from MixHash
ok 239 - Can use value from .kv to set number occurrences in MixHash
ok 240 - Can use $_ from .kv to remove items from MixHash
ok 241 - Can use value from .pairs to remove occurrences from MixHash
ok 242 - Can use value from .pairs to set number occurrences in MixHash
ok 243 - Can use $_ from .pairs to remove items from MixHash
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Lazy)
    ok 3 - .what matches MixHash
ok 244 - did we throws-like X::Cannot::Lazy?
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Lazy)
    ok 3 - .what matches MixHash
ok 245 - did we throws-like X::Cannot::Lazy?
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Lazy)
    ok 3 - .what matches MixHash
ok 246 - did we throws-like X::Cannot::Lazy?
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Str::Numeric)
ok 247 - (:a("a")).MixHash throws
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Str::Numeric)
ok 248 - MixHash.new-from-pairs( (:a("a")) ) throws
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::OutOfRange)
ok 249 - (:a(Inf)).MixHash throws
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::OutOfRange)
ok 250 - MixHash.new-from-pairs( (:a(Inf)) ) throws
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::OutOfRange)
ok 251 - (:a(-Inf)).MixHash throws
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::OutOfRange)
ok 252 - MixHash.new-from-pairs( (:a(-Inf)) ) throws
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::OutOfRange)
ok 253 - (:a(NaN)).MixHash throws
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::OutOfRange)
ok 254 - MixHash.new-from-pairs( (:a(NaN)) ) throws
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Numeric::Real)
ok 255 - (:a(<0+3i>)).MixHash throws
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Numeric::Real)
ok 256 - MixHash.new-from-pairs( (:a(<0+3i>)) ) throws
ok 257 - can we parameterize for strings?
ok 258 - does .keyof return the correct type
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck::Binding)
ok 259 - does attempt to add item of wrong type croak
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck::Binding)
ok 260 - do wrong values make initialization croak
ok 261 - final value 0 disappears in MixHash (1)
ok 262 - final value 0 disappears in MixHash (2)
    1..3
    ok 1 - weight decrement
    ok 2 - Pair value decrement
    ok 3 - weight set to zero
ok 263 - elements with weight zero are removed
    1..2
    ok 1 - negative weights are ok
    ok 2 - negative Pair values are ok
ok 264 - elements with negative weights are allowed in MixHashes
ok 265 - did we get right number of elements
ok 266 - do we get 1 for a
ok 267 - do we get 0 value for e
ok 268 - is the %h really a BagHash
ok 269 - did we get right number of elements after re-init
ok 270 - did we get 5 by removing e
ok 271 - did we get right number of elements after :delete
ok 272 - can delete from MixHash by assignment
ok 273 - did we get right number of elements assignment
ok 274 - can we smartmatch empty
ok 275 - coerce MixHash -> Set
ok 276 - coerce MixHash -> SetHash
ok 277 - coerce MixHash -> Bag
ok 278 - coerce MixHash -> BagHash
ok 279 - coerce MixHash -> Mix
ok 280 - parameterized MixHash
ok 281 - did it parameterize ok
ok 282 - adding element of wrong type fails
ok 283 - must have Ints on creation
ok 284 - does .item work on MixHashes
# FUDGED!
1..59
ok 1 - accessing an array as [0;0] works (1)
ok 2 - accessing an array as [0;0] works (2)
ok 3 - accessing an array as [0;0] works (3)
ok 4 - accessing an array as [0;0] works (4)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 5 - setting a multi-d array beyond boundaries fails
ok 6 - .elems works on multidimensional array
ok 7 - # SKIP multi-dim sized arrays NYI
ok 8 - # SKIP multi-dim sized arrays NYI
ok 9 - # SKIP multi-dim sized arrays NYI
ok 10 - # SKIP multi-dim sized arrays NYI
ok 11 - the multi1 has 3 elements
ok 12 - got the right value at multi1 index 0
ok 13 - multi1[1] has 3 elements
ok 14 - +$multi1[1] works
ok 15 - The object is-a 'List'
ok 16 - got the right value at multi1 index 1,0
ok 17 - got the right value at multi1 index 1,1
ok 18 - got the right value at multi1 index 1,2
ok 19 - got the right value at multi1 index 1,0
ok 20 - got the right value at multi1 index 1,1
ok 21 - got the right value at multi1 index 1,2
ok 22 - got the right value at multi1 index 2
ok 23 - the multi2 has 2 elements
ok 24 - multi2[0] has 3 elements
ok 25 - +$multi2[0] works
ok 26 - The object is-a 'List'
ok 27 - got the right value at multi2 index 0,0
ok 28 - got the right value at multi2 index 0,1
ok 29 - got the right value at multi2 index 0,2
ok 30 - got the right value at multi2 index 0,0
ok 31 - got the right value at multi2 index 0,1
ok 32 - got the right value at multi2 index 0,2
ok 33 - multi2[1] has 3 elements
ok 34 - +$multi2[1] works
ok 35 - The object is-a 'List'
ok 36 - got the right value at multi2 index 1,0
ok 37 - got the right value at multi2 index 1,1
ok 38 - got the right value at multi2 index 1,2
ok 39 - got the right value at multi2 index 1,0
ok 40 - got the right value at multi2 index 1,1
ok 41 - got the right value at multi2 index 1,2
ok 42 - got the right values at multi2 index {0,1},0
ok 43 - got the right values at multi2 index {0,1},1
ok 44 - got the right values at multi2 index {0,1},2
ok 45 - got the right values at multi2 index *,0
ok 46 - got the right values at multi2 index *,1
ok 47 - got the right values at multi2 index *,2
ok 48 - [1 ; 0,1,2 ; 2]
ok 49 - [1 ; * ; 2]
ok 50 - [0,1 ; 2 ; 2]
ok 51 - [1 ; 0,2 ; 1]
ok 52 - [1 ; 2 ; 1,2]
ok 53 - [0,1 ; 0,2 ; 1,2]
ok 54 - can assign to multi-dim slice
ok 55 - overall assignment worked
ok 56 - assigned the right thing to [0;0;1]
ok 57 - assigned the right thing to [0;1;1]
ok 58 - assigned the right thing to [0;2;1]
    1..158
    ok 1 - got the right value from array with dim 1 at 0
    ok 2 - .elems for a shaped array (dim 1) returns the first dimension
    ok 3 - got the right value from array with dim 2 at 0 0
    ok 4 - got the right value from array with dim 2 at 1 0
    ok 5 - .elems for a shaped array (dim 2) returns the first dimension
    ok 6 - got the right value from array with dim 3 at 0 0 0
    ok 7 - got the right value from array with dim 3 at 0 1 0
    ok 8 - got the right value from array with dim 3 at 1 0 0
    ok 9 - got the right value from array with dim 3 at 1 1 0
    ok 10 - got the right value from array with dim 3 at 2 0 0
    ok 11 - got the right value from array with dim 3 at 2 1 0
    ok 12 - .elems for a shaped array (dim 3) returns the first dimension
    ok 13 - got the right value from array with dim 4 at 0 0 0 0
    ok 14 - got the right value from array with dim 4 at 0 0 1 0
    ok 15 - got the right value from array with dim 4 at 0 1 0 0
    ok 16 - got the right value from array with dim 4 at 0 1 1 0
    ok 17 - got the right value from array with dim 4 at 0 2 0 0
    ok 18 - got the right value from array with dim 4 at 0 2 1 0
    ok 19 - got the right value from array with dim 4 at 1 0 0 0
    ok 20 - got the right value from array with dim 4 at 1 0 1 0
    ok 21 - got the right value from array with dim 4 at 1 1 0 0
    ok 22 - got the right value from array with dim 4 at 1 1 1 0
    ok 23 - got the right value from array with dim 4 at 1 2 0 0
    ok 24 - got the right value from array with dim 4 at 1 2 1 0
    ok 25 - got the right value from array with dim 4 at 2 0 0 0
    ok 26 - got the right value from array with dim 4 at 2 0 1 0
    ok 27 - got the right value from array with dim 4 at 2 1 0 0
    ok 28 - got the right value from array with dim 4 at 2 1 1 0
    ok 29 - got the right value from array with dim 4 at 2 2 0 0
    ok 30 - got the right value from array with dim 4 at 2 2 1 0
    ok 31 - got the right value from array with dim 4 at 3 0 0 0
    ok 32 - got the right value from array with dim 4 at 3 0 1 0
    ok 33 - got the right value from array with dim 4 at 3 1 0 0
    ok 34 - got the right value from array with dim 4 at 3 1 1 0
    ok 35 - got the right value from array with dim 4 at 3 2 0 0
    ok 36 - got the right value from array with dim 4 at 3 2 1 0
    ok 37 - .elems for a shaped array (dim 4) returns the first dimension
    ok 38 - got the right value from array with dim 5 at 0 0 0 0 0
    ok 39 - got the right value from array with dim 5 at 0 0 0 1 0
    ok 40 - got the right value from array with dim 5 at 0 0 1 0 0
    ok 41 - got the right value from array with dim 5 at 0 0 1 1 0
    ok 42 - got the right value from array with dim 5 at 0 0 2 0 0
    ok 43 - got the right value from array with dim 5 at 0 0 2 1 0
    ok 44 - got the right value from array with dim 5 at 0 1 0 0 0
    ok 45 - got the right value from array with dim 5 at 0 1 0 1 0
    ok 46 - got the right value from array with dim 5 at 0 1 1 0 0
    ok 47 - got the right value from array with dim 5 at 0 1 1 1 0
    ok 48 - got the right value from array with dim 5 at 0 1 2 0 0
    ok 49 - got the right value from array with dim 5 at 0 1 2 1 0
    ok 50 - got the right value from array with dim 5 at 0 2 0 0 0
    ok 51 - got the right value from array with dim 5 at 0 2 0 1 0
    ok 52 - got the right value from array with dim 5 at 0 2 1 0 0
    ok 53 - got the right value from array with dim 5 at 0 2 1 1 0
    ok 54 - got the right value from array with dim 5 at 0 2 2 0 0
    ok 55 - got the right value from array with dim 5 at 0 2 2 1 0
    ok 56 - got the right value from array with dim 5 at 0 3 0 0 0
    ok 57 - got the right value from array with dim 5 at 0 3 0 1 0
    ok 58 - got the right value from array with dim 5 at 0 3 1 0 0
    ok 59 - got the right value from array with dim 5 at 0 3 1 1 0
    ok 60 - got the right value from array with dim 5 at 0 3 2 0 0
    ok 61 - got the right value from array with dim 5 at 0 3 2 1 0
    ok 62 - got the right value from array with dim 5 at 1 0 0 0 0
    ok 63 - got the right value from array with dim 5 at 1 0 0 1 0
    ok 64 - got the right value from array with dim 5 at 1 0 1 0 0
    ok 65 - got the right value from array with dim 5 at 1 0 1 1 0
    ok 66 - got the right value from array with dim 5 at 1 0 2 0 0
    ok 67 - got the right value from array with dim 5 at 1 0 2 1 0
    ok 68 - got the right value from array with dim 5 at 1 1 0 0 0
    ok 69 - got the right value from array with dim 5 at 1 1 0 1 0
    ok 70 - got the right value from array with dim 5 at 1 1 1 0 0
    ok 71 - got the right value from array with dim 5 at 1 1 1 1 0
    ok 72 - got the right value from array with dim 5 at 1 1 2 0 0
    ok 73 - got the right value from array with dim 5 at 1 1 2 1 0
    ok 74 - got the right value from array with dim 5 at 1 2 0 0 0
    ok 75 - got the right value from array with dim 5 at 1 2 0 1 0
    ok 76 - got the right value from array with dim 5 at 1 2 1 0 0
    ok 77 - got the right value from array with dim 5 at 1 2 1 1 0
    ok 78 - got the right value from array with dim 5 at 1 2 2 0 0
    ok 79 - got the right value from array with dim 5 at 1 2 2 1 0
    ok 80 - got the right value from array with dim 5 at 1 3 0 0 0
    ok 81 - got the right value from array with dim 5 at 1 3 0 1 0
    ok 82 - got the right value from array with dim 5 at 1 3 1 0 0
    ok 83 - got the right value from array with dim 5 at 1 3 1 1 0
    ok 84 - got the right value from array with dim 5 at 1 3 2 0 0
    ok 85 - got the right value from array with dim 5 at 1 3 2 1 0
    ok 86 - got the right value from array with dim 5 at 2 0 0 0 0
    ok 87 - got the right value from array with dim 5 at 2 0 0 1 0
    ok 88 - got the right value from array with dim 5 at 2 0 1 0 0
    ok 89 - got the right value from array with dim 5 at 2 0 1 1 0
    ok 90 - got the right value from array with dim 5 at 2 0 2 0 0
    ok 91 - got the right value from array with dim 5 at 2 0 2 1 0
    ok 92 - got the right value from array with dim 5 at 2 1 0 0 0
    ok 93 - got the right value from array with dim 5 at 2 1 0 1 0
    ok 94 - got the right value from array with dim 5 at 2 1 1 0 0
    ok 95 - got the right value from array with dim 5 at 2 1 1 1 0
    ok 96 - got the right value from array with dim 5 at 2 1 2 0 0
    ok 97 - got the right value from array with dim 5 at 2 1 2 1 0
    ok 98 - got the right value from array with dim 5 at 2 2 0 0 0
    ok 99 - got the right value from array with dim 5 at 2 2 0 1 0
    ok 100 - got the right value from array with dim 5 at 2 2 1 0 0
    ok 101 - got the right value from array with dim 5 at 2 2 1 1 0
    ok 102 - got the right value from array with dim 5 at 2 2 2 0 0
    ok 103 - got the right value from array with dim 5 at 2 2 2 1 0
    ok 104 - got the right value from array with dim 5 at 2 3 0 0 0
    ok 105 - got the right value from array with dim 5 at 2 3 0 1 0
    ok 106 - got the right value from array with dim 5 at 2 3 1 0 0
    ok 107 - got the right value from array with dim 5 at 2 3 1 1 0
    ok 108 - got the right value from array with dim 5 at 2 3 2 0 0
    ok 109 - got the right value from array with dim 5 at 2 3 2 1 0
    ok 110 - got the right value from array with dim 5 at 3 0 0 0 0
    ok 111 - got the right value from array with dim 5 at 3 0 0 1 0
    ok 112 - got the right value from array with dim 5 at 3 0 1 0 0
    ok 113 - got the right value from array with dim 5 at 3 0 1 1 0
    ok 114 - got the right value from array with dim 5 at 3 0 2 0 0
    ok 115 - got the right value from array with dim 5 at 3 0 2 1 0
    ok 116 - got the right value from array with dim 5 at 3 1 0 0 0
    ok 117 - got the right value from array with dim 5 at 3 1 0 1 0
    ok 118 - got the right value from array with dim 5 at 3 1 1 0 0
    ok 119 - got the right value from array with dim 5 at 3 1 1 1 0
    ok 120 - got the right value from array with dim 5 at 3 1 2 0 0
    ok 121 - got the right value from array with dim 5 at 3 1 2 1 0
    ok 122 - got the right value from array with dim 5 at 3 2 0 0 0
    ok 123 - got the right value from array with dim 5 at 3 2 0 1 0
    ok 124 - got the right value from array with dim 5 at 3 2 1 0 0
    ok 125 - got the right value from array with dim 5 at 3 2 1 1 0
    ok 126 - got the right value from array with dim 5 at 3 2 2 0 0
    ok 127 - got the right value from array with dim 5 at 3 2 2 1 0
    ok 128 - got the right value from array with dim 5 at 3 3 0 0 0
    ok 129 - got the right value from array with dim 5 at 3 3 0 1 0
    ok 130 - got the right value from array with dim 5 at 3 3 1 0 0
    ok 131 - got the right value from array with dim 5 at 3 3 1 1 0
    ok 132 - got the right value from array with dim 5 at 3 3 2 0 0
    ok 133 - got the right value from array with dim 5 at 3 3 2 1 0
    ok 134 - got the right value from array with dim 5 at 4 0 0 0 0
    ok 135 - got the right value from array with dim 5 at 4 0 0 1 0
    ok 136 - got the right value from array with dim 5 at 4 0 1 0 0
    ok 137 - got the right value from array with dim 5 at 4 0 1 1 0
    ok 138 - got the right value from array with dim 5 at 4 0 2 0 0
    ok 139 - got the right value from array with dim 5 at 4 0 2 1 0
    ok 140 - got the right value from array with dim 5 at 4 1 0 0 0
    ok 141 - got the right value from array with dim 5 at 4 1 0 1 0
    ok 142 - got the right value from array with dim 5 at 4 1 1 0 0
    ok 143 - got the right value from array with dim 5 at 4 1 1 1 0
    ok 144 - got the right value from array with dim 5 at 4 1 2 0 0
    ok 145 - got the right value from array with dim 5 at 4 1 2 1 0
    ok 146 - got the right value from array with dim 5 at 4 2 0 0 0
    ok 147 - got the right value from array with dim 5 at 4 2 0 1 0
    ok 148 - got the right value from array with dim 5 at 4 2 1 0 0
    ok 149 - got the right value from array with dim 5 at 4 2 1 1 0
    ok 150 - got the right value from array with dim 5 at 4 2 2 0 0
    ok 151 - got the right value from array with dim 5 at 4 2 2 1 0
    ok 152 - got the right value from array with dim 5 at 4 3 0 0 0
    ok 153 - got the right value from array with dim 5 at 4 3 0 1 0
    ok 154 - got the right value from array with dim 5 at 4 3 1 0 0
    ok 155 - got the right value from array with dim 5 at 4 3 1 1 0
    ok 156 - got the right value from array with dim 5 at 4 3 2 0 0
    ok 157 - got the right value from array with dim 5 at 4 3 2 1 0
    ok 158 - .elems for a shaped array (dim 5) returns the first dimension
ok 59 - Insertion and reading of shaped array elements
# FUDGED!
1..67
ok 1 - empty sub returns Nil
ok 2 - do {} is Nil
ok 3 - if 1 {} is Nil
ok 4 - else {} is Nil
ok 5 - bare return returns Nil
ok 6 - EVAL of empty string is Nil
ok 7 - Nil is not defined
ok 8 - () is defined
ok 9 - assigning Nil to scalar leaves it undefined
ok 10 - assigning () to scalar results in a defined list
ok 11 - Nil.so is False
not ok 12 - Nil.ACCEPTS always returns Nil # TODO returns True/False
# Failed test 'Nil.ACCEPTS always returns Nil'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/nil.rakudo line 29
ok 13 - Any method on Nil should return Nil (no args)
ok 14 - Any method on Nil should return Nil (with args)
ok 15 - return_nil() === Nil
ok 16 - return_nil().raku says Nil
ok 17 - return_nil() called twice
ok 18 - variable holding nil is not defined
ok 19 - $Statement for Nil; does one iteration
ok 20 - Nil is not any sort of Iter*
ok 21 - Nil assigned to scalar produces an Any
ok 22 - 
ok 23 - Nil.gist eq "Nil"
ok 24 - Nil.new is not defined
ok 25 - can assign Nil to subsets
ok 26 - assigns to subset type object
ok 27 - can bind to Nil
    1..2
    not ok 1 - code dies # TODO triage
    # Failed test 'code dies'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/nil.rakudo line 81
    ok 2 - # SKIP Code did not die, can not check exception
not ok 28 - param: dies for mandatory # TODO triage
# Failed test 'param: dies for mandatory'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/nil.rakudo line 81
ok 29 - # SKIP triage
not ok 30 - ... set to type object # TODO triage
# Failed test '... set to type object'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/nil.rakudo line 91
not ok 31 - param: lives for optional from var # TODO triage
# Failed test 'param: lives for optional from var'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/nil.rakudo line 94
# Type check failed in binding to parameter '$x'; expected Int but got Nil (Nil)
not ok 32 - ... set to type object # TODO triage
# Failed test '... set to type object'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/nil.rakudo line 96
ok 33 - param: lives for with-default
not ok 34 - ... set to default # TODO triage
# Failed test '... set to default'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/nil.rakudo line 101
# expected: '123'
#      got: (Any)
ok 35 - can use Nil as a default (natural)
ok 36 - can use Nil as a default (nil-triggered)
ok 37 - $/ is by default Nil
ok 38 - $! is by default Nil
ok 39 - $_ is by default Any
ok 40 - $/ has Nil as default
ok 41 - $! has Nil as default
ok 42 - $_ has Any as default
ok 43 - sanity
ok 44 - calling methods on Nil gives Nil again I
ok 45 - calling methods on Nil gives Nil again II
ok 46 - calling methods on Nil gives Nil again III
ok 47 - array access on Nil gives Nil again I
ok 48 - array access on Nil gives Nil again II
ok 49 - array access on Nil gives Nil again III
ok 50 - hash access on Nil gives Nil again I
ok 51 - hash access on Nil gives Nil again II
ok 52 - hash access on Nil gives Nil again II
ok 53 - .<> and .[] works properly, too
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 54 - .BIND-POS throws
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 55 - .BIND-KEY throws
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 56 - .ASSIGN-POS throws
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 57 - .ASSIGN-KEY throws
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 58 - .STORE throws
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 59 - .push throws
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 60 - .append throws
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 61 - .unshift throws
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 62 - .prepend throws
ok 63 - Nil.ords warns
ok 64 - Nil.ords gives an empty Seq
ok 65 - Nil.chrs warns
ok 66 - Nil.chrs gives a null byte
ok 67 - Assignment to scalar after assigning Nil takes effect
# FUDGED!
1..108
ok 1 - EVAL 1.Num.raku is Num
ok 2 - EVAL 1.Num.raku is 1
ok 3 - EVAL 0.Num.raku is Num
ok 4 - EVAL 0.Num.raku is 0
ok 5 - EVAL -1.Num.raku is Num
ok 6 - EVAL -1.Num.raku is -1
ok 7 - EVAL 1.1.Num.raku is Num
ok 8 - EVAL 1.1.Num.raku is 1.1
ok 9 - EVAL -1.1.Num.raku is Num
ok 10 - EVAL -1.1.Num.raku is -1.1
ok 11 - EVAL 1e100.Num.raku is Num
ok 12 - EVAL 1e100.Num.raku is 1
ok 13 - The object is-a 'Int'
ok 14 - 1 stringification works
ok 15 - The object is-a 'Int'
ok 16 - -1 stringification works
ok 17 - The object is-a 'Rat'
ok 18 - 1/1 stringification works
ok 19 - The object is-a 'Rat'
ok 20 - -1 stringification works
ok 21 - The object is-a 'Rat'
ok 22 - 0.1 stringification works
ok 23 - The object is-a 'Rat'
ok 24 - -0.1 stringification works
ok 25 - The object is-a 'Rat'
ok 26 - 10.01 stringification works
ok 27 - The object is-a 'Num'
ok 28 - -1 stringification works
ok 29 - The object is-a 'Num'
ok 30 - 0.1 stringification works
ok 31 - The object is-a 'Num'
ok 32 - -0.1 stringification works
ok 33 - The object is-a 'Num'
ok 34 - 10.01 stringification works
ok 35 - 1e3 conforms to Num
ok 36 - 1e3 stringification works
ok 37 - The object is-a 'Num'
ok 38 - 10.01e3 stringification works
ok 39 - The object is-a 'Int'
ok 40 - 0b100 (binary) stringification works
ok 41 - The object is-a 'Int'
ok 42 - 0x100 (hex) stringification works
ok 43 - The object is-a 'Int'
ok 44 - 0o100 (octal) stringification works
ok 45 - basic addition works
ok 46 - basic addition with negative numbers works
ok 47 - The object is-a 'Rat'
ok 48 - The object is-a 'Rat'
ok 49 - trailing zeros compare correctly
ok 50 - The object is-a 'Num'
ok 51 - trailing zeros compare correctly
ok 52 - The object is-a 'Int'
ok 53 - 1.01 intifies to 1
ok 54 - The object is-a 'Int'
ok 55 - 0d0101 numifies to 101
ok 56 - we have bignums, not weeny floats
ok 57 - underscores allowed (and ignored) in numeric literals
ok 58 - multiple underscores ok
ok 59 - underscores in fraction ok
ok 60 - underscores in whole part ok
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Method::NotFound)
ok 61 - single underscores are not ok directly after the dot
ok 62 - single underscores are ok
ok 63 - 0_1 is parsed as 0d1
ok 64 - +^1 == -2 as promised
ok 65 - 0xFFFFFFFFFFFFFFFF is not -1
ok 66 - Num === Num should be truthy, and not die
ok 67 - 1e0.atanh returns ∞
ok 68 - Num:U.Range gives -Inf to Inf range
    1..6
    ok 1 - Num
    ok 2 - Rat
    ok 3 - Int
    ok 4 - Complex
    ok 5 - Str
        1..2
        ok 1 - code dies
        ok 2 - right exception type (Exception)
    ok 6 - class that cannot .Num
ok 69 - Num.new coerces types that can .Num
    1..8
    ok 1 - return value (:D)
    ok 2 - new value (:D)
    ok 3 - return value (:U)
    ok 4 - new value (:U)
    ok 5 - return value (native)
    ok 6 - new value (native)
    ok 7 - return value (uninit. native)
    ok 8 - new value (uninit. native)
ok 70 - ++Num
    1..8
    ok 1 - return value (:D)
    ok 2 - new value (:D)
    ok 3 - return value (:U)
    ok 4 - new value (:U)
    ok 5 - return value (native)
    ok 6 - new value (native)
    ok 7 - return value (uninit. native)
    ok 8 - new value (uninit. native)
ok 71 - --Num
    1..4
    ok 1 - return value
    ok 2 - new value
    ok 3 - return value (uninit. native)
    ok 4 - new value (uninit. native)
ok 72 - Num++
    1..6
    ok 1 - return value (:U)
    ok 2 - new value (:U)
    ok 3 - return value (native)
    ok 4 - new value (native)
    ok 5 - return value (uninit. native)
    ok 6 - new value (uninit. native)
ok 73 - Num--
    1..8
    ok 1 - - uninitialized
    ok 2 - − (U+2212) uninitialized
    ok 3 - - zero
    ok 4 - − (U+2212) zero
    ok 5 - - positive
    ok 6 - − (U+2212) positive
    ok 7 - - negative
    ok 8 - − (U+2212) negative
ok 74 - prefix:<->(num) and U+2212 prefix op
    1..4
    ok 1 - uninitialized
    ok 2 - zero
    ok 3 - positive
    ok 4 - negative
ok 75 - abs(num)
    1..16
    ok 1 - uninit + zero
    ok 2 - uninit + positive
    ok 3 - uninit + negative
    ok 4 - uninit + uninit
    ok 5 - zero + uninit
    ok 6 - positive + uninit
    ok 7 - negative + uninit
    ok 8 - zero + positive
    ok 9 - zero + negative
    ok 10 - zero + zero
    ok 11 - positive + negative
    ok 12 - positive + zero
    ok 13 - positive + positive
    ok 14 - negative + zero
    ok 15 - negative + positive
    ok 16 - negative + negative
ok 76 - infix:<+>(num, num)
    1..16
    ok 1 - uninit * zero
    ok 2 - uninit * positive
    ok 3 - uninit * negative
    ok 4 - uninit * uninit
    ok 5 - zero * uninit
    ok 6 - positive * uninit
    ok 7 - negative * uninit
    ok 8 - zero * positive
    ok 9 - zero * negative
    ok 10 - zero * zero
    ok 11 - positive * negative
    ok 12 - positive * zero
    ok 13 - positive * positive
    ok 14 - negative * zero
    ok 15 - negative * positive
    ok 16 - negative * negative
ok 77 - infix:<*>(num, num)
    1..9
    ok 1 - uninit % defined
        1..2
        not ok 1 - expected code to fail but it threw X::AdHoc instead # TODO we die https://github.com/rakudo/rakudo/issues/2434
        # Failed test 'expected code to fail but it threw X::AdHoc instead'
        # at SETTING::src/core.c/Mu.pm6 line 983
        ok 2 - # SKIP expected code to fail but it threw X::AdHoc instead
    not ok 2 - defined % uninit # TODO we die https://github.com/rakudo/rakudo/issues/2434
    # Failed test 'defined % uninit'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/num.rakudo line 358
        1..2
        not ok 1 - expected code to fail but it threw X::AdHoc instead # TODO we die https://github.com/rakudo/rakudo/issues/2434
        # Failed test 'expected code to fail but it threw X::AdHoc instead'
        # at SETTING::src/core.c/Mu.pm6 line 983
        ok 2 - # SKIP expected code to fail but it threw X::AdHoc instead
    not ok 3 - uninit % uninit # TODO we die https://github.com/rakudo/rakudo/issues/2434
    # Failed test 'uninit % uninit'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/num.rakudo line 360
    ok 4 - 0 % 4
    ok 5 - 4 % 5
    ok 6 - 5 % 4
    ok 7 - 0 % -4
    ok 8 - -4 % 5
    ok 9 - 5 % -4
ok 78 - infix:<%>(num, num)
    1..22
    ok 1 - uninit ** 1st power
    ok 2 - uninit ** positive
    ok 3 - uninit ** negative
    ok 4 - uninit ** uninit
    ok 5 - zero ** uninit
    ok 6 - positive ** uninit
    ok 7 - negative ** uninit
    ok 8 - 1 ** uninit
    ok 9 - uninit ** zero
    ok 10 - zero ** positive
    ok 11 - zero ** zero
    ok 12 - zero ** 1st power
    ok 13 - positive ** zero
    ok 14 - positive ** 1st power
    ok 15 - positive ** positive
    ok 16 - negative ** zero
    ok 17 - negative ** 1st power
    ok 18 - negative ** positive
    ok 19 - positive ** negative
    ok 20 - negative ** negative
    ok 21 - 1/3 power (third root)
    ok 22 - 4/6 power (6th root of 4th power)
ok 79 - infix:<**>(num, num)
    1..9
    ok 1 - uninitialized
    ok 2 - NaN
    ok 3 - negative
    ok 4 - -∞
    ok 5 - +∞
    ok 6 - zero
    ok 7 - neg zero
    ok 8 - one
    ok 9 - 42
ok 80 - log(num)
    1..10
    ok 1 - uninitialized
    ok 2 - NaN
    ok 3 - -∞
    ok 4 - +∞
    ok 5 - zero
    ok 6 - neg zero
    ok 7 - positive (1)
    ok 8 - positive (2)
    ok 9 - negative (1)
    ok 10 - negative (2)
ok 81 - ceiling(num)
    1..13
    ok 1 - uninitialized
    ok 2 - NaN
    ok 3 - -∞
    ok 4 - +∞
    ok 5 - 0e0
    ok 6 - τ
    ok 7 - -τ
    ok 8 - π
    ok 9 - -π
    ok 10 - π/2
    ok 11 - -π/2
    ok 12 - π/4
    ok 13 - -π/4
ok 82 - sin(num)
    1..11
    ok 1 - uninitialized
    ok 2 - NaN
    ok 3 - -∞
    ok 4 - +∞
    ok 5 - -1.1e0
    ok 6 - +1.1e0
    ok 7 - 0e0
    ok 8 - 1e0
    ok 9 - -1e0
    ok 10 - ½√2
    ok 11 - -½√2
ok 83 - asin(num)
    1..13
    ok 1 - uninitialized
    ok 2 - NaN
    ok 3 - -∞
    ok 4 - +∞
    ok 5 - 0e0
    ok 6 - π/4
    ok 7 - -π/4
    ok 8 - π
    ok 9 - -π
    ok 10 - π/2
    ok 11 - -π/2
    ok 12 - π/4
    ok 13 - -π/4
ok 84 - cos(num)
    1..11
    ok 1 - NaN
    ok 2 - -∞
    ok 3 - +∞
    ok 4 - -1.1e0
    ok 5 - +1.1e0
    ok 6 - 1e0
    ok 7 - 1e0
    ok 8 - -1e0
    ok 9 - 0e0
    ok 10 - ½√2
    ok 11 - -½√2
ok 85 - acos(num)
    1..13
    ok 1 - NaN
    ok 2 - -∞
    ok 3 - +∞
    ok 4 - uninitialized
    ok 5 - 0e0
    ok 6 - τ
    ok 7 - -τ
    ok 8 - π
    ok 9 - -π
    ok 10 - π/4
    ok 11 - -π/4
    ok 12 - π/2
    ok 13 - -π/2
ok 86 - tan(num)
    1..7
    ok 1 - NaN
    ok 2 - uninitialized
    ok 3 - 0e0
    ok 4 - 1e0
    ok 5 - -1e0
    ok 6 - π
    ok 7 - -π
ok 87 - atan(num)
    1..13
    ok 1 - NaN
    ok 2 - -∞
    ok 3 - +∞
    ok 4 - uninitialized
    ok 5 - 0e0
    ok 6 - τ
    ok 7 - -τ
    ok 8 - π
    ok 9 - -π
    ok 10 - π/4
    ok 11 - -π/4
    ok 12 - π/2
    ok 13 - -π/2
ok 88 - sec(num)
    1..10
    ok 1 - uninitialized
    ok 2 - NaN
    ok 3 - 0e0
    ok 4 - .9e0
    ok 5 - -.9e0
    ok 6 - 1e0
    ok 7 - ∞
    ok 8 - -∞
    ok 9 - 2/√2
    ok 10 - -2/√2
ok 89 - asec(num)
    1..38
    ok 1 - uninitialized
    ok 2 - NaN
    ok 3 - -∞
    ok 4 - +∞
    ok 5 - 0e0
    ok 6 - -0e0
    ok 7 - π/12
    ok 8 - π/10
    ok 9 - π/8
    ok 10 - π/6
    ok 11 - π/5
    ok 12 - π/4
    ok 13 - 3*π/10
    ok 14 - π/3
    ok 15 - 3*π/8
    ok 16 - 2*π/5
    ok 17 - 5*π/12
    ok 18 - -π/2
    ok 19 - 3*π/2
    ok 20 - 5*π/2
    ok 21 - -π/12
    ok 22 - -π/10
    ok 23 - -π/8
    ok 24 - -π/6
    ok 25 - -π/5
    ok 26 - -π/4
    ok 27 - -3*π/10
    ok 28 - -π/3
    ok 29 - -3*π/8
    ok 30 - -2*π/5
    ok 31 - -5*π/12
    ok 32 - -π/2
    ok 33 - -3*π/2
    ok 34 - -5*π/2
    ok 35 - π
    ok 36 - -π
    ok 37 - τ
    ok 38 - -τ
ok 90 - cotan(num)
    1..29
    ok 1 - NaN
    ok 2 - uninitialized
    ok 3 - -∞ is -0
    ok 4 - ∞
    ok 5 - -∞
    ok 6 - 0e0
    ok 7 - -0e0
    ok 8 - 2+√3
    ok 9 - √(5+2*√5)
    ok 10 - 1+√2
    ok 11 - √3
    ok 12 - √(1+2/√5)
    ok 13 - 1e0
    ok 14 - √(5-2*√5)
    ok 15 - √3/3
    ok 16 - √2-1
    ok 17 - √(1-2/√5)
    ok 18 - 2-√3
    ok 19 - -(2+√3)
    ok 20 - -√(5+2*√5)
    ok 21 - -(1+√2)
    ok 22 - -√3
    ok 23 - -√(1+2/√5)
    ok 24 - -1e0
    ok 25 - -√(5-2*√5)
    ok 26 - -√3/3
    ok 27 - -(√2-1)
    ok 28 - -√(1-2/√5)
    ok 29 - -(2-√3)
ok 91 - acotan(num)
    1..18
    ok 1 - uninitialized
    ok 2 - NaN
    ok 3 - ∞
    ok 4 - -∞
    ok 5 - 1e20
    ok 6 - -1e20
    ok 7 - 2.718281828459045
    ok 8 - -2.718281828459045
    ok 9 - 0
    ok 10 - -0
    ok 11 - 1
    ok 12 - -1
    ok 13 - 3.141592653589793
    ok 14 - -3.141592653589793
    ok 15 - 6.283185307179586
    ok 16 - -6.283185307179586
    ok 17 - 100
    ok 18 - -100
ok 92 - sinh(num)
    1..19
    ok 1 - uninitialized
    ok 2 - NaN
    ok 3 - ∞
    ok 4 - -∞
    ok 5 - 1e200
    ok 6 - -1e200 # TODO asinh does not comply with IEEE
    not ok 7 - -0e0 actually gives a minus 0 # TODO asinh does not comply with IEEE
    # Failed test '-0e0 actually gives a minus 0'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/num.rakudo line 705
    # expected: '-0'
    #      got: '0'
    ok 8 - 2.718281828459045
    ok 9 - -2.718281828459045
    ok 10 - 0
    ok 11 - -0
    ok 12 - 1
    ok 13 - -1
    ok 14 - 3.141592653589793
    ok 15 - -3.141592653589793
    ok 16 - 6.283185307179586
    ok 17 - -6.283185307179586
    ok 18 - 100
    ok 19 - -100
ok 93 - asinh(num)
    1..18
    ok 1 - uninitialized
    ok 2 - NaN
    ok 3 - ∞
    ok 4 - -∞
    ok 5 - 1e20
    ok 6 - -1e20
    ok 7 - 2.718281828459045
    ok 8 - -2.718281828459045
    ok 9 - 0
    ok 10 - -0
    ok 11 - 1
    ok 12 - -1
    ok 13 - 3.141592653589793
    ok 14 - -3.141592653589793
    ok 15 - 6.283185307179586
    ok 16 - -6.283185307179586
    ok 17 - 100
    ok 18 - -100
ok 94 - cosh(num)
    1..20
    ok 1 - uninitialized
    ok 2 - NaN
    ok 3 - 0e0
    ok 4 - .9e0
    ok 5 - -1e0
    ok 6 - -1e100
    ok 7 - -1e200
    ok 8 - -∞
    ok 9 - ∞
    ok 10 - 1e200
    ok 11 - 2.718281828459045
    ok 12 - -2.718281828459045
    ok 13 - 1
    ok 14 - -1
    ok 15 - 3.141592653589793
    ok 16 - -3.141592653589793
    ok 17 - 6.283185307179586
    ok 18 - -6.283185307179586
    ok 19 - 1e+20
    ok 20 - -1e+20
ok 95 - acosh(num)
    1..18
    ok 1 - uninitialized
    ok 2 - NaN
    ok 3 - ∞
    ok 4 - -∞
    ok 5 - 1e20
    ok 6 - -1e20
    ok 7 - 2.718281828459045
    ok 8 - -2.718281828459045
    ok 9 - 0
    ok 10 - -0
    ok 11 - 1
    ok 12 - -1
    ok 13 - 3.141592653589793
    ok 14 - -3.141592653589793
    ok 15 - 6.283185307179586
    ok 16 - -6.283185307179586
    ok 17 - 100
    ok 18 - -100
ok 96 - tanh(num)
    1..32
    ok 1 - 1e0
    ok 2 - -1e0
    ok 3 - 2.718281828459045
    ok 4 - -2.718281828459045
    ok 5 - 10
    ok 6 - -10
    ok 7 - 3.141592653589793
    ok 8 - -3.141592653589793
    ok 9 - 6.283185307179586
    ok 10 - -6.283185307179586
    ok 11 - 1e+20
    ok 12 - -1e+20
    ok 13 - 1e+100
    ok 14 - -1e+100
    ok 15 - 1e+200
    ok 16 - -1e+200
    ok 17 - Inf
    ok 18 - -Inf
    ok 19 - Inf
    ok 20 - -Inf
    ok 21 - 0
    ok 22 - -0
    ok 23 - 0.2
    ok 24 - -0.2
    ok 25 - 0.3
    ok 26 - -0.3
    ok 27 - 0.5
    ok 28 - -0.5
    ok 29 - 0.7
    ok 30 - -0.7
    ok 31 - 0.9
    ok 32 - -0.9
ok 97 - atanh(num)
ok 98 - Literal Nums close to the upper limit are not Inf
    1..5
    ok 1 - positive
    ok 2 - negative
    ok 3 - zero
    ok 4 - negative zero
    ok 5 - NaN
ok 99 - .Bool
    1..3
    ok 1 - (1)
    ok 2 - (2)
    ok 3 - (3)
ok 100 - no parsing glitches in the way Num is parsed
ok 101 - Nums that are close to each other parsed correctly as different
    1..2
    ok 1 - 9.999e-5
    ok 2 - 9.99899999999999995e-5
ok 102 - Num literals yield closest available Num to their nominal value
    1..13
    ok 1 - 
    ok 2 - 
    ok 3 - 
    ok 4 - 
    ok 5 - 
    ok 6 - 
    ok 7 - 
    ok 8 - 
    ok 9 - 
    ok 10 - 
    ok 11 - 
    ok 12 - 
    ok 13 - 
ok 103 - parsed nums choose closest available representation
ok 104 - Rat->Num conversion is monotonic
    1..5
    ok 1 - parsed number stringification
    ok 2 - Str.Num stringification
    ok 3 - val().Numeric.Str stringification
    ok 4 - parsed matches Str.Num
    ok 5 - parsed matches val()
ok 105 - parsed nums are the same as those produced from Str.Num
    1..3
    ok 1 - ==
    ok 2 - ===
    ok 3 - === of .WHICHes
ok 106 - distinct num literals do not compare the same
ok 107 - .raku roundtrips the Num correctly
    1..2
        1..7
        ok 1 - Num literal
        ok 2 - Num literal in EVAL
        ok 3 - +Str
        ok 4 - Str.Numeric
        ok 5 - Str.Num
        ok 6 - Num allomorph
        ok 7 - Num allomorph in EVAL
    ok 1 - huge-ish exponent
        1..7
        ok 1 - Num literal
        ok 2 - Num literal in EVAL
        ok 3 - +Str
        ok 4 - Str.Numeric
        ok 5 - Str.Num
        ok 6 - Num allomorph
        ok 7 - Num allomorph in EVAL
    ok 2 - huge-huge-huge exponent
ok 108 - no hangs/crashes when parsing nums with huge exponents
# FUDGED!
1..182
ok 1 - The object is-a 'Pair'
ok 2 - got the right key($pair:)
ok 3 - got the right value($pair:)
ok 4 - got the right $pair.key()
ok 5 - got the right $pair.value()
ok 6 - got the right $pair.key
ok 7 - got the right $pair.value
ok 8 - got the right number of elements in the list
ok 9 - got the right key
ok 10 - got the right value
ok 11 - got the right number of elements in the list
ok 12 - got the right key
ok 13 - got the right value
ok 14 - got the right number of elements in the list
ok 15 - got the right key
ok 16 - got the right value
ok 17 - got the right number of elements in the list
ok 18 - got the right key
ok 19 - got the right value
ok 20 - The object is-a 'Pair'
ok 21 - got the right key($pair:)
ok 22 - got the right value($pair:)
ok 23 - got the right $pair.key()
ok 24 - got the right $pair.value()
ok 25 - got the right $pair.key
ok 26 - got the right $pair.value
ok 27 - got the right number of elements in the list
ok 28 - got the right key
ok 29 - got the right value
ok 30 - got the right number of elements in the list
ok 31 - got the right key
ok 32 - got the right value
ok 33 - got the right number of elements in the list
ok 34 - got the right key
ok 35 - got the right value
ok 36 - got the right number of elements in the list
ok 37 - got the right key
ok 38 - got the right value
ok 39 - The object is-a 'Pair'
ok 40 - got the right key($pair:)
ok 41 - got the right value($pair:)
ok 42 - got the right $pair.key()
ok 43 - got the right $pair.value()
ok 44 - got the right $pair.key
ok 45 - got the right $pair.value
ok 46 - got the right number of elements in the list
ok 47 - got the right key
ok 48 - got the right value
ok 49 - got the right number of elements in the list
ok 50 - got the right key
ok 51 - got the right value
ok 52 - got the right number of elements in the list
ok 53 - got the right key
ok 54 - got the right value
ok 55 - got the right number of elements in the list
ok 56 - got the right key
ok 57 - got the right value
ok 58 - The object is-a 'Pair'
ok 59 - got the right key($pair:)
ok 60 - got the right value($pair:)
ok 61 - got the right $pair.key()
ok 62 - got the right $pair.value()
ok 63 - got the right $pair.key
ok 64 - got the right $pair.value
ok 65 - got the right number of elements in the list
ok 66 - got the right key
ok 67 - got the right value
ok 68 - got the right number of elements in the list
ok 69 - got the right key
ok 70 - got the right value
ok 71 - got the right number of elements in the list
ok 72 - got the right key
ok 73 - got the right value
ok 74 - got the right number of elements in the list
ok 75 - got the right key
ok 76 - got the right value
ok 77 - The object is-a 'Pair'
ok 78 - got the right value
ok 79 - The object is-a 'Pair'
ok 80 - The object is-a 'Pair'
ok 81 - got right nested pair key
ok 82 - got right nested pair key
ok 83 - got right nested pair key (method chaining)
ok 84 - got right nested pair key (method chaining)
ok 85 - The object is-a 'Pair'
ok 86 - got the right value
ok 87 - The object is-a 'Pair'
ok 88 - got right nested key
ok 89 - got right nested value
ok 90 - lhs quotes
not ok 91 - hash stringification # TODO should it really have \n on the end?
# Failed test 'hash stringification'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/pair.rakudo line 89
# expected: "when\tnow\n"
#      got: "when\tnow"
ok 92 - %() makes creates a real Hash
ok 93 - got the right key :foo.key
ok 94 - :foo.value isa Bool
ok 95 - :foo is True
ok 96 - :foo.value is True
ok 97 - got the right key :!foo.key
ok 98 - :!foo.value isa Bool
ok 99 - :!foo.value is False
ok 100 - The object is-a 'Pair'
ok 101 - The object is-a 'Pair'
ok 102 - The object is-a 'Pair'
ok 103 - in sub test1 got the right $pair.key
ok 104 - in sub test1 got the right $pair.value
ok 105 - The object is-a 'Pair'
ok 106 - The object is-a 'Pair'
ok 107 - The object is-a 'Pair'
ok 108 - in for loop got the right $pair.key
ok 109 - in for loop got the right $pair.value
ok 110 - The object is-a 'Pair'
ok 111 - in sub test2 got the right $pair.key
ok 112 - in sub test2 got the right $pair.value
ok 113 - The object is-a 'Pair'
ok 114 - sub test3: $pair[0] is $pair
ok 115 - sub test3: $pair[1] is failure
ok 116 - => has correct precedence
ok 117 - Zaphod is 2
ok 118 - Ford is 42
ok 119 - Zaphod is still 2
ok 120 - Ford is still 42
ok 121 - pairs stringify correctly (1)
ok 122 - pairs stringify correctly (2)
ok 123 - pairs with arrayitems as values stringify correctly (1)
ok 124 - pairs with arrayitems as values stringify correctly (2)
ok 125 - => should not stringify the key (1)
ok 126 - => should not stringify the key (2)
ok 127 - => should not stringify the key (3)
ok 128 - => should not stringify the key (4)
ok 129 - => should not stringify the key (5)
ok 130 - => should not stringify the key (6)
ok 131 - the keys of pairs should not get auto-stringified when passed to a sub (1)
ok 132 - the keys of pairs should not get auto-stringified when passed to a sub (2)
ok 133 - the keys of pairs should not get auto-stringified when passed to a sub (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Assignment::RO)
ok 134 - setting .key dies
ok 135 - attempt to set .key doesn't change the key
ok 136 - attempt to set .key does not change the original var either
ok 137 - setting .value does not die
ok 138 - setting .value actually changes the value
ok 139 - setting .value does change the original var as it was itemized
ok 140 - :$foo syntax works
ok 141 - :@foo syntax works
ok 142 - :%foo syntax works
ok 143 - :&foo syntax works
ok 144 - can parse ":a()"
ok 145 - can execute ":a()"
ok 146 - can parse ":a[]"
ok 147 - can execute ":a[]"
ok 148 - can parse "(a => ())"
ok 149 - can execute "(a => ())"
ok 150 - can parse "(a => [])"
ok 151 - can execute "(a => [])"
ok 152 - Pair.antipair.key
ok 153 - Pair.antipair.key type
ok 154 - Pair.antipair.value
ok 155 - Pair.invert splits positional values
ok 156 - Pair.invert splits positional values and preserves order
ok 157 - Pair.invert.key type
ok 158 - Pair.invert splits positional values and dups keys
ok 159 - list of array pairs can be inverted
ok 160 - list of hash pairs can be inverted
ok 161 - chained colonpairs in parens build a list of pairs
ok 162 - chained colonpairs in curlies construct hashes with more than one element
ok 163 - both key and value can convey a raw Nil
ok 164 - both key and value can convey a Mu type
ok 165 - both key and value can convey an Any type
ok 166 - both key and value can convey a Junction type
ok 167 - both key and value can convey a Junction object
ok 168 - The object is-a 'Int'
ok 169 - can assign integer value and return that
ok 170 - the expected Int value was set
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck::Assignment)
ok 171 - cannot assign a Str to an Int
ok 172 - pair binding
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck)
    ok 3 - .got matches (Int)
    ok 4 - .expected matches (Pair)
ok 173 - List.invert maps via a required Pair binding
ok 174 - accessing non-existent key on a Pair returns Nil
ok 175 - .Pair on Pair:D is identity
ok 176 - .Pair on Pair:U is identity
    1..24
    ok 1 - ("z"=>1,"a"=>3).Bag (True)
    ok 2 - ("a"=>3,"z"=>1).BagHash (True)
    ok 3 - ("a"=>3,"z"=>2).Mix (True)
    ok 4 - ("a"=>3,"z"=>2).MixHash (True)
    ok 5 - ${:a(3), :z(5)} (True)
    ok 6 - $(Map.new((:a(3),:z(5)))) (True)
    ok 7 - :a(3) (True)
    ok 8 - :z(3) (True)
    ok 9 - ("z"=>1,"a"=>1).Bag (False)
    ok 10 - ("a"=>1,"z"=>1).BagHash (False)
    ok 11 - Set.new("z","a") (False)
    ok 12 - SetHash.new("a","z") (False)
    ok 13 - ("a"=>1,"z"=>1).Mix (False)
    ok 14 - ("z"=>1,"a"=>1).MixHash (False)
    ok 15 - ${:a(Bool::True), :z(Bool::True)} (False)
    ok 16 - $(Map.new((:a,:z))) (False)
    ok 17 - :a (False)
    ok 18 - :z (False)
    ok 19 - Set (True)
    ok 20 - SetHash (True)
    ok 21 - custom class (True, 1)
    ok 22 - custom class (True, 2)
    ok 23 - custom class (True, 3)
    ok 24 - custom class (False)
ok 177 - Pair.ACCEPTS
    1..7
    ok 1 - :a(42)
    ok 2 - 42 => 70
    ok 3 - :foo(:bar(:meow(42)))
    ok 4 - ("a", "b", "c") => ("d", "e", "f")
    ok 5 - {:a("b"), :c("d")} => {:e("f"), :g("h")}
        1..4
        ok 1 - return's type
        ok 2 - return's number of elements
        ok 3 - .key
        ok 4 - .value
    ok 6 - (Any) => (Mu)
        1..4
        ok 1 - return's type
        ok 2 - return's number of elements
        ok 3 - .key
        ok 4 - .value
    ok 7 - (Mu) => (Any)
ok 178 - Pair.invert
    1..5
    ok 1 - roundtrip of Bool:U .value does not eqv :!foo
    ok 2 - (Str) => Str
    ok 3 - (Rat) => Num
    ok 4 - (Bool) => Bool
    ok 5 - (Numeric) => Numeric
ok 179 - Pair.raku with type objects
    1..2
    ok 1 - clone, same value
    ok 2 - clone, different value
ok 180 - Clone of Pair does not share .WHICH
ok 181 - fake-infix adverbs (named args) on a construct inside args to another routine
ok 182 - did we not do parens?
# FUDGED!
1..240
ok 1 - &set produces a Set
ok 2 - ...with the right elements
ok 3 - Default value is false
ok 4 - Single-key subscript (existing element)
ok 5 - Single-key subscript has correct type (existing element)
ok 6 - Single-key subscript (nonexistent element)
ok 7 - Single-key subscript has correct type (nonexistent element)
ok 8 - exists with existing element
ok 9 - exists with nonexistent element
ok 10 - Bool returns True if there is something in the Set
ok 11 - Bool returns False if there is nothing in the Set
ok 12 - .hash doesn't die
ok 13 - ...and it returned a Hash
ok 14 - ...with the right elements
ok 15 - ...and values
ok 16 - Can't assign to an element (Sets are immutable)
ok 17 - Can't assign to .keys
ok 18 - Can't assign to .values
ok 19 - Can't :delete from Set
ok 20 - Multiple-element access
ok 21 - Multiple-element access (with nonexistent elements)
ok 22 - .elems gives number of keys
ok 23 - +$set gives number of keys
ok 24 - Identical sets smartmatch with each other
ok 25 - Subset does not smartmatch
ok 26 - Superset does not smartmatch
ok 27 - Smartmatch is not element of
ok 28 - Type-checking smartmatch works
ok 29 - Bag smartmatches with equivalent set
ok 30 - ... even if the Bag has greater quantities
ok 31 - Subset does not smartmatch
ok 32 - Superset does not smartmatch
ok 33 - Type-checking smartmatch works
ok 34 - Str.Set makes a Set
ok 35 - 'a'.Set is set a
ok 36 - Pair.Set makes a Set
ok 37 - (a => 1).Set is set a
ok 38 - (a => 0).Set is the empty set
ok 39 - <a b c>.Set makes a Set
ok 40 - <a b c a>.Set makes the set a b c
ok 41 - [a b c a].Set makes the set a b c
ok 42 - [a => 3, b => 0, 'c', 'a'].Set makes the set a c
ok 43 - {a => 2, b => 4, c => 0}.Set makes a Set
ok 44 - {a => 2, b => 4, c => 0}.Set makes the set a b
ok 45 - .Set on List of Pairs treats Pair.value as weight
ok 46 - .Set on Hash of Pairs treats Pair.value as weight
ok 47 - :exists with existing element
ok 48 - :exists with nonexistent element
ok 49 - :delete does not work on set
ok 50 - Int keys are left as Ints
ok 51 - Bool keys are left as Bools
ok 52 - And Str keys are permitted in the same set
ok 53 - Keys are counted correctly even when a key is False
ok 54 - A hash to which a Set has been bound becomes a set
ok 55 - ...with the right keys
ok 56 - ...and values all True
ok 57 - &set discards duplicates
ok 58 - &Set.new given an array of pairs produces a Set
ok 59 - ... with three elements under the single arg rule
ok 60 - &Set.new given an itemized array of pairs produces a Set
ok 61 - ... with one element
ok 62 - &Set.new given a Hash produces a Set
ok 63 - ... with three elements
ok 64 - ... all of which are Pairs
ok 65 - &Set.new given a Hash produces a Set
ok 66 - ... with three elements under the single arg rule
ok 67 - &Set.new given an itemized Hash produces a Set
ok 68 - ... with one element
ok 69 - &Set.new given a Set produces a Set
ok 70 - ... with one element
ok 71 - &Set.new given a SetHash produces a Set
ok 72 - ... with one element
ok 73 - &Set.new given a SetHash produces a Set
ok 74 - ... with one element
ok 75 - &set given a Bag produces a Set
ok 76 - ... with one element
ok 77 - .list returns 3 things
ok 78 - ... all of which are Pairs
ok 79 - .pairs returns 3 things
ok 80 - ... all of which are Pairs
ok 81 - ... the keys of which are Strs
ok 82 - ... and the values of which are Bool
ok 83 - .raku lives
ok 84 - ... and produces a string
ok 85 - .raku.EVAL lives
ok 86 - ... and produces a Set
ok 87 - ... and it has the correct values
ok 88 - .Str lives
ok 89 - ... and produces a string
ok 90 - ... which only contains bar baz and foo separated by spaces
ok 91 - .gist lives
ok 92 - ... and produces a string
ok 93 - ... which mentions foo
ok 94 - ... which mentions bar
ok 95 - ... which mentions baz
ok 96 - A Set bound to a %var is a Set
ok 97 - ...with the right elements
ok 98 - Single-key subscript (existing element)
ok 99 - Single-key subscript (nonexistent element)
ok 100 - Can't assign to an element (Sets are immutable)
ok 101 - Can't assign to a %var implemented by Set
ok 102 - Can't :delete a key from a Set
ok 103 - # SKIP Hypers not yet Set compatible
ok 104 - # SKIP Hypers not yet Set compatible
ok 105 - # SKIP Hypers not yet Set compatible
ok 106 - # SKIP Hypers not yet Set compatible
ok 107 - # SKIP Hypers not yet Set compatible
ok 108 - # SKIP Hypers not yet Set compatible
ok 109 - # SKIP Hypers not yet Set compatible
ok 110 - # SKIP Hypers not yet Set compatible
ok 111 - # SKIP Hypers not yet Set compatible
ok 112 - We got one of the three choices
ok 113 - .roll(2) returns the right number of items
ok 114 - .roll(2) returned "a"s, "b"s, and "c"s
ok 115 - .roll(100) returns 100 items
ok 116 - .roll(100) returned "a"s, "b"s, and "c"s
ok 117 - .roll should not change Set
ok 118 - empty set.roll -> Nil
ok 119 - empty set.roll(1) -> ().Seq
ok 120 - empty set.roll(*-1) -> ().Seq
ok 121 - empty set.roll(*) -> ().Seq
ok 122 - empty set.roll(Inf) -> ().Seq
ok 123 - empty set.roll(-1) -> ().Seq
ok 124 - empty set.roll(-Inf) -> ().Seq
ok 125 - empty set.roll(NaN) should die
ok 126 - Set.pick(*) gets all elements
ok 127 - Set.pick(*) returns elements in a random order
ok 128 - .pick should not change Set
ok 129 - We got one of the three choices
ok 130 - .pick(2) returns the right number of items
ok 131 - .pick(2) returned "a"s, "b"s, and "c"s
ok 132 - .pick(2) returned at most one "a"
ok 133 - .pick(2) returned at most one "b"
ok 134 - .pick(2) returned at most one "c"
ok 135 - .pick should not change Set
ok 136 - empty set.pick -> Nil
ok 137 - empty set.pick(1) -> ().Seq
ok 138 - empty set.pick(*-1) -> ().Seq
ok 139 - empty set.pick(*) -> ().Seq
ok 140 - empty set.pick(Inf) -> ().Seq
ok 141 - empty set.pick(-1) -> ().Seq
ok 142 - empty set.pick(-Inf) -> ().Seq
ok 143 - empty set.pick(NaN) should die
ok 144 - cannot call .grab on a Set
ok 145 - cannot call .grab(1) on a Set
ok 146 - cannot call .grab(*-1) on a Set
ok 147 - cannot call .grab(*) on a Set
ok 148 - cannot call .grab(Inf) on a Set
ok 149 - cannot call .grab(-1) on a Set
ok 150 - cannot call .grab(-Inf) on a Set
ok 151 - cannot call .grab(NaN) on a Set
ok 152 - cannot call .grabpairs on a Set
ok 153 - Two elements
ok 154 - One of the set's elements is indeed a Set!
ok 155 - With the proper elements
ok 156 - One of the set's elements is indeed a List!
ok 157 - With the proper elements
ok 158 - Two elements
ok 159 - One of the set's elements is indeed a set!
ok 160 - With the proper elements
ok 161 - One of the set's elements is indeed a List!
ok 162 - With the proper elements
ok 163 - Method .Set works on Int-1
ok 164 - Method .Set works on Int-2
ok 165 - Method .Set works on Str-1
ok 166 - Method .Set works on Str-2
ok 167 - Method .Set works on Array-1
ok 168 - Method .Set works on Array-2
ok 169 - Method .Set works on Hash-1
ok 170 - Method .Set works on Hash-2
ok 171 - Method .Set works on List-1
ok 172 - Method .Set works on List-2
ok 173 - .total gives sum of values (non-empty)
ok 174 - +$set gives sum of values (non-empty)
ok 175 - .minpairs works (non-empty)
ok 176 - .maxpairs works (non-empty)
ok 177 - .fmt(%s) works (non-empty)
ok 178 - .fmt(%s,sep) works (non-empty)
ok 179 - .fmt(%s%s) works (non-empty)
ok 180 - .fmt(%s%s,sep) works (non-empty)
ok 181 - .total gives sum of values (empty)
ok 182 - +$set gives sum of values (empty)
ok 183 - .minpairs works (empty)
ok 184 - .maxpairs works (empty)
ok 185 - .fmt(%s) works (empty)
ok 186 - .fmt(%s,sep) works (empty)
ok 187 - .fmt(%s%s) works (empty)
ok 188 - .fmt(%s%s,sep) works (empty)
ok 189 - Cannot change key of Set.pairs
ok 190 - Cannot change value of Set.pairs
ok 191 - can metaop set assign like: (|)=
ok 192 - Faulty .WHICH creation
ok 193 - arrays not flattened out by Set.new (1)
ok 194 - arrays not flattened out by Set.new (2)
ok 195 - arrays not flattened out by Set.new (3)
ok 196 - Can subclass Set
    1..2
    ok 1 - 'my $rt125611 = RT125611.new.foo: "a"' died
    ok 2 - right exception type (X::Assignment::RO)
ok 197 - trying to assign throws X::Assignment::RO
ok 198 - Set.kv returns list of keys and values (1)
ok 199 - Set.kv returns list of keys and values (2)
ok 200 - smartmatch a Seq
ok 201 - make sure set.Hash returns objects
    1..3
    ok 1 - Set.new
    ok 2 - .Set
    ok 3 - set()
ok 202 - .hash does not cause keys to be stringified
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 203 - autovivification of of Set:U complains about immutability
ok 204 - .Mix on set gives correct Mix
ok 205 - .MixHash on set gives correct MixHash
ok 206 - ().Set returns the empty set
ok 207 - coercion of Map to Set 1
ok 208 - coercion of Map to Set 2
ok 209 - coercion of object Hash to Set 1
ok 210 - coercion of object Hash to Set 2
ok 211 - can we parameterize for strings?
ok 212 - does .keyof return the correct type
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck::Binding)
ok 213 - do wrong values make initialization croak
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Lazy)
    ok 3 - .what matches Set
ok 214 - did we throws-like X::Cannot::Lazy?
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Lazy)
    ok 3 - .what matches Set
ok 215 - did we throws-like X::Cannot::Lazy?
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Lazy)
    ok 3 - .what matches Set
ok 216 - did we throws-like X::Cannot::Lazy?
    1..3
    ok 1 - 'set;' died
    ok 2 - right exception type (Exception)
    ok 3 - .message matches /set/
ok 217 - set listop called without arguments and parentheses dies (1)
    1..3
    ok 1 - 'set<a b c>;' died
    ok 2 - right exception type (X::Syntax::Confused)
    ok 3 - .message matches /subscript/
ok 218 - set listop called without arguments dies (2)
    1..180
    ok 1 - Set ∈
    ok 2 - Set (elem)
    ok 3 - Set ∉
    ok 4 - Set ∋
    ok 5 - Set (cont)
    ok 6 - Set ∌
    ok 7 - Set ⊆
    ok 8 - Set (<=)
    ok 9 - Set ⊈
    ok 10 - Set ⊂
    ok 11 - Set (<)
    ok 12 - Set ⊄
    ok 13 - Set ⊇
    ok 14 - Set (>=)
    ok 15 - Set ⊉
    ok 16 - Set ⊃
    ok 17 - Set (>)
    ok 18 - Set ⊅
    ok 19 - Set ∪
    ok 20 - Set (|)
    ok 21 - Set ∩
    ok 22 - Set (&)
    ok 23 - Set ∖ 
    ok 24 - Set (-)
    ok 25 - Set ⊖
    ok 26 - Set (^)
    ok 27 - Set ⊍
    ok 28 - Set (.)
    ok 29 - Set ⊎
    ok 30 - Set (+)
    ok 31 - SetHash ∈
    ok 32 - SetHash (elem)
    ok 33 - SetHash ∉
    ok 34 - SetHash ∋
    ok 35 - SetHash (cont)
    ok 36 - SetHash ∌
    ok 37 - SetHash ⊆
    ok 38 - SetHash (<=)
    ok 39 - SetHash ⊈
    ok 40 - SetHash ⊂
    ok 41 - SetHash (<)
    ok 42 - SetHash ⊄
    ok 43 - SetHash ⊇
    ok 44 - SetHash (>=)
    ok 45 - SetHash ⊉
    ok 46 - SetHash ⊃
    ok 47 - SetHash (>)
    ok 48 - SetHash ⊅
    ok 49 - SetHash ∪
    ok 50 - SetHash (|)
    ok 51 - SetHash ∩
    ok 52 - SetHash (&)
    ok 53 - SetHash ∖ 
    ok 54 - SetHash (-)
    ok 55 - SetHash ⊖
    ok 56 - SetHash (^)
    ok 57 - SetHash ⊍
    ok 58 - SetHash (.)
    ok 59 - SetHash ⊎
    ok 60 - SetHash (+)
    ok 61 - Bag ∈
    ok 62 - Bag (elem)
    ok 63 - Bag ∉
    ok 64 - Bag ∋
    ok 65 - Bag (cont)
    ok 66 - Bag ∌
    ok 67 - Bag ⊆
    ok 68 - Bag (<=)
    ok 69 - Bag ⊈
    ok 70 - Bag ⊂
    ok 71 - Bag (<)
    ok 72 - Bag ⊄
    ok 73 - Bag ⊇
    ok 74 - Bag (>=)
    ok 75 - Bag ⊉
    ok 76 - Bag ⊃
    ok 77 - Bag (>)
    ok 78 - Bag ⊅
    ok 79 - Bag ∪
    ok 80 - Bag (|)
    ok 81 - Bag ∩
    ok 82 - Bag (&)
    ok 83 - Bag ∖ 
    ok 84 - Bag (-)
    ok 85 - Bag ⊖
    ok 86 - Bag (^)
    ok 87 - Bag ⊍
    ok 88 - Bag (.)
    ok 89 - Bag ⊎
    ok 90 - Bag (+)
    ok 91 - BagHash ∈
    ok 92 - BagHash (elem)
    ok 93 - BagHash ∉
    ok 94 - BagHash ∋
    ok 95 - BagHash (cont)
    ok 96 - BagHash ∌
    ok 97 - BagHash ⊆
    ok 98 - BagHash (<=)
    ok 99 - BagHash ⊈
    ok 100 - BagHash ⊂
    ok 101 - BagHash (<)
    ok 102 - BagHash ⊄
    ok 103 - BagHash ⊇
    ok 104 - BagHash (>=)
    ok 105 - BagHash ⊉
    ok 106 - BagHash ⊃
    ok 107 - BagHash (>)
    ok 108 - BagHash ⊅
    ok 109 - BagHash ∪
    ok 110 - BagHash (|)
    ok 111 - BagHash ∩
    ok 112 - BagHash (&)
    ok 113 - BagHash ∖ 
    ok 114 - BagHash (-)
    ok 115 - BagHash ⊖
    ok 116 - BagHash (^)
    ok 117 - BagHash ⊍
    ok 118 - BagHash (.)
    ok 119 - BagHash ⊎
    ok 120 - BagHash (+)
    ok 121 - Mix ∈
    ok 122 - Mix (elem)
    ok 123 - Mix ∉
    ok 124 - Mix ∋
    ok 125 - Mix (cont)
    ok 126 - Mix ∌
    ok 127 - Mix ⊆
    ok 128 - Mix (<=)
    ok 129 - Mix ⊈
    ok 130 - Mix ⊂
    ok 131 - Mix (<)
    ok 132 - Mix ⊄
    ok 133 - Mix ⊇
    ok 134 - Mix (>=)
    ok 135 - Mix ⊉
    ok 136 - Mix ⊃
    ok 137 - Mix (>)
    ok 138 - Mix ⊅
    ok 139 - Mix ∪
    ok 140 - Mix (|)
    ok 141 - Mix ∩
    ok 142 - Mix (&)
    ok 143 - Mix ∖ 
    ok 144 - Mix (-)
    ok 145 - Mix ⊖
    ok 146 - Mix (^)
    ok 147 - Mix ⊍
    ok 148 - Mix (.)
    ok 149 - Mix ⊎
    ok 150 - Mix (+)
    ok 151 - MixHash ∈
    ok 152 - MixHash (elem)
    ok 153 - MixHash ∉
    ok 154 - MixHash ∋
    ok 155 - MixHash (cont)
    ok 156 - MixHash ∌
    ok 157 - MixHash ⊆
    ok 158 - MixHash (<=)
    ok 159 - MixHash ⊈
    ok 160 - MixHash ⊂
    ok 161 - MixHash (<)
    ok 162 - MixHash ⊄
    ok 163 - MixHash ⊇
    ok 164 - MixHash (>=)
    ok 165 - MixHash ⊉
    ok 166 - MixHash ⊃
    ok 167 - MixHash (>)
    ok 168 - MixHash ⊅
    ok 169 - MixHash ∪
    ok 170 - MixHash (|)
    ok 171 - MixHash ∩
    ok 172 - MixHash (&)
    ok 173 - MixHash ∖ 
    ok 174 - MixHash (-)
    ok 175 - MixHash ⊖
    ok 176 - MixHash (^)
    ok 177 - MixHash ⊍
    ok 178 - MixHash (.)
    ok 179 - MixHash ⊎
    ok 180 - MixHash (+)
ok 219 - set ops do not hang with Setty/Baggy/Mixy type objects
ok 220 - did we get right number of elements
ok 221 - do we get a truthy value for a
ok 222 - do we get a falsy value for e
ok 223 - is the %h really a Set
ok 224 - cannot re-initialize Set
ok 225 - cannot :delete from Set
ok 226 - cannot delete from Set by assignment
ok 227 - Nums that are close to each other remain distinct when put in sets
ok 228 - have typechecking on a Hashifeid Set iterator
ok 229 - can we smartmatch empty
ok 230 - coerce Set -> SetHash
ok 231 - coerce Set -> Bag
ok 232 - coerce Set -> BagHash
ok 233 - coerce Set -> Mix
ok 234 - coerce Set -> MixHash
ok 235 - parameterized Set
ok 236 - did it parameterize ok
ok 237 - must have Ints
ok 238 - multi method Setty(Set:U:) returns a Set type object
ok 239 - the two Set:D.STORE candidates create equivalent objects
ok 240 - does .item work on Sets
# FUDGED!
1..27
ok 1 - unitialized $var does Mu
ok 2 - value contained in a $var does Mu
ok 3 - unitialized @var does Positional
ok 4 - value contained in a @var does Positional
ok 5 - generic val in a @var is converted to Positional
ok 6 - List does Positional
ok 7 - Array does Positional
ok 8 - Range does Positional
ok 9 - Buf does Positional
not ok 10 - Capture does Positional # TODO Capture does Positional
# Failed test 'Capture does Positional'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/sigils-and-types.rakudo line 31
# Type: Capture doesn't do role Positional
ok 11 - uninitialized %var does Associative
ok 12 - value in %var does Associative
ok 13 - Pair does Associative
ok 14 - Set does Associative
ok 15 - Bag does Associative
ok 16 - QuantHash does Associative
not ok 17 - Capture does Associative # TODO Capture does Associative
# Failed test 'Capture does Associative'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/sigils-and-types.rakudo line 43
# Type: Capture doesn't do role Associative
ok 18 - a Sub does Callable
ok 19 - a Method does Callable
ok 20 - a multi does Callable
ok 21 - a proto does Callable
ok 22 - a token does Callable
ok 23 - a rule does Callable
ok 24 - a macro does Callable
ok 25 - cannot just assign &b to &a
ok 26 - and the correct function is still in place
ok 27 - can use &$x() for invoking
# FUDGED!
1..80
ok 1 - compile my Int $foo
ok 2 - compile my Str $bar
ok 3 - Int $foo isa Int
ok 4 - Str $bar isa Str
    1..2
    ok 1 - '$foo = 'xyz'' died
    ok 2 - right exception type (X::TypeCheck::Assignment)
ok 5 - Int restricts to integers
    1..2
    ok 1 - '$foo = Mu' died
    ok 2 - right exception type (X::TypeCheck::Assignment)
ok 6 - Int does not accept Mu
ok 7 - Int is an integer
    1..2
    ok 1 - '$bar = 42' died
    ok 2 - right exception type (X::TypeCheck::Assignment)
ok 8 - Str restricts to strings
    1..2
    ok 1 - '$bar = Mu' died
    ok 2 - right exception type (X::TypeCheck::Assignment)
ok 9 - Str does not accept Mu
ok 10 - Str is a strings
    1..2
    ok 1 - '$baz = 'xyz'' died
    ok 2 - right exception type (X::TypeCheck::Assignment)
ok 11 - of Int restricts to integers
ok 12 - of Int is an integer
ok 13 - Has native type int
    1..2
    ok 1 - 'my int $alpha = Nil' died
    ok 2 - right exception type (Exception)
ok 14 - native int type cannot be undefined
ok 15 - object Int type can be undefined
ok 16 - Has native type num
not ok 17 - native num type can be undefined # TODO assigning Nil to natives
# Failed test 'native num type can be undefined'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/type.rakudo line 48
# Error: Cannot unbox a type object (Nil) to a num.
ok 18 - object Num type can be undefined
ok 19 - object Str type can be undefined, list context
ok 20 - sub parameters with matching type
    1..2
    ok 1 - 'paramtype("foo")' died
    ok 2 - right exception type (X::TypeCheck::Argument)
ok 21 - sub parameters with non-matching type dies
ok 22 - recursive factorial with type contstraints work
    1..2
    ok 1 - 'my Num $n; $n = 42' died
    ok 2 - right exception type (X::Syntax::Number::LiteralType)
ok 23 - Num does not accept Int
    1..2
    ok 1 - 'my Num $n; $n = $*PID' died
    ok 2 - right exception type (X::TypeCheck::Assignment)
ok 24 - Num does not accept Int
    1..2
    ok 1 - 'my Complex $n; $n = 42' died
    ok 2 - right exception type (X::Syntax::Number::LiteralType)
ok 25 - Complex does not accept Int
    1..2
    ok 1 - 'my Complex $n; $n = $*PID' died
    ok 2 - right exception type (X::TypeCheck::Assignment)
ok 26 - Complex does not accept Int
    1..2
    ok 1 - 'my Rat $n; $n = 42' died
    ok 2 - right exception type (X::Syntax::Number::LiteralType)
ok 27 - Rat does not accept Int
    1..2
    ok 1 - 'my Rat $n; $n = $*PID' died
    ok 2 - right exception type (X::TypeCheck::Assignment)
ok 28 - Rat does not accept Int
    1..2
    ok 1 - 'my Int $n; $n = 42e0' died
    ok 2 - right exception type (X::Syntax::Number::LiteralType)
ok 29 - Int does not accept Num
    1..2
    ok 1 - 'my Int $n; $n = $*PID.Num' died
    ok 2 - right exception type (X::TypeCheck::Assignment)
ok 30 - Int does not accept Num
    1..2
    ok 1 - 'my Complex $n; $n = 42e0' died
    ok 2 - right exception type (X::Syntax::Number::LiteralType)
ok 31 - Complex does not accept Num
    1..2
    ok 1 - 'my Complex $n; $n = $*PID.Num' died
    ok 2 - right exception type (X::TypeCheck::Assignment)
ok 32 - Complex does not accept Num
    1..2
    ok 1 - 'my Rat $n; $n = 42e0' died
    ok 2 - right exception type (X::Syntax::Number::LiteralType)
ok 33 - Rat does not accept Num
    1..2
    ok 1 - 'my Rat $n; $n = $*PID.Num' died
    ok 2 - right exception type (X::TypeCheck::Assignment)
ok 34 - Rat does not accept Num
    1..2
    ok 1 - 'my Int $n; $n = 42.0' died
    ok 2 - right exception type (X::Syntax::Number::LiteralType)
ok 35 - Int does not accept Rat
    1..2
    ok 1 - 'my Int $n; $n = $*PID.Rat' died
    ok 2 - right exception type (X::TypeCheck::Assignment)
ok 36 - Int does not accept Rat
    1..2
    ok 1 - 'my Complex $n; $n = 42.0' died
    ok 2 - right exception type (X::Syntax::Number::LiteralType)
ok 37 - Complex does not accept Rat
    1..2
    ok 1 - 'my Complex $n; $n = $*PID.Rat' died
    ok 2 - right exception type (X::TypeCheck::Assignment)
ok 38 - Complex does not accept Rat
    1..2
    ok 1 - 'my Num $n; $n = 42.0' died
    ok 2 - right exception type (X::Syntax::Number::LiteralType)
ok 39 - Num does not accept Rat
    1..2
    ok 1 - 'my Num $n; $n = $*PID.Rat' died
    ok 2 - right exception type (X::TypeCheck::Assignment)
ok 40 - Num does not accept Rat
    1..2
    ok 1 - 'my Int $n; $n = <42+0i>' died
    ok 2 - right exception type (X::Syntax::Number::LiteralType)
ok 41 - Int does not accept Complex
    1..2
    ok 1 - 'my Int $n; $n = $*PID\i' died
    ok 2 - right exception type (X::TypeCheck::Assignment)
ok 42 - Int does not accept Complex
    1..2
    ok 1 - 'my Rat $n; $n = <42+0i>' died
    ok 2 - right exception type (X::Syntax::Number::LiteralType)
ok 43 - Rat does not accept Complex
    1..2
    ok 1 - 'my Rat $n; $n = $*PID\i' died
    ok 2 - right exception type (X::TypeCheck::Assignment)
ok 44 - Rat does not accept Complex
    1..2
    ok 1 - 'my Num $n; $n = <42+0i>' died
    ok 2 - right exception type (X::Syntax::Number::LiteralType)
ok 45 - Num does not accept Complex
    1..2
    ok 1 - 'my Num $n; $n = $*PID\i' died
    ok 2 - right exception type (X::TypeCheck::Assignment)
ok 46 - Num does not accept Complex
    1..2
    ok 1 - 'my num $n; $n = 42' died
    ok 2 - right exception type (X::Syntax::Number::LiteralType)
ok 47 - num does not accept Int
    1..2
    ok 1 - 'my int $n; $n = 42e0' died
    ok 2 - right exception type (X::Syntax::Number::LiteralType)
ok 48 - int does not accept Num
    1..2
    ok 1 - 'my int $n; $n = 42.0' died
    ok 2 - right exception type (X::Syntax::Number::LiteralType)
ok 49 - int does not accept Rat
    1..2
    ok 1 - 'my num $n; $n = 42.0' died
    ok 2 - right exception type (X::Syntax::Number::LiteralType)
ok 50 - num does not accept Rat
    1..2
    ok 1 - 'my int $n; $n = <42+0i>' died
    ok 2 - right exception type (X::Syntax::Number::LiteralType)
ok 51 - int does not accept Complex
    1..2
    ok 1 - 'my num $n; $n = <42+0i>' died
    ok 2 - right exception type (X::Syntax::Number::LiteralType)
ok 52 - num does not accept Complex
ok 53 - good return value works (returns)
    1..2
    ok 1 - 'returntype1(Bool::False)' died
    ok 2 - right exception type (X::TypeCheck::Return)
ok 54 - bad return value dies (returns)
ok 55 - good return value works (of)
    1..2
    ok 1 - 'returntype2(Bool::False)' died
    ok 2 - right exception type (X::TypeCheck::Return)
ok 56 - bad return value dies (of)
ok 57 - good return value works (my Type sub)
    1..2
    ok 1 - 'returntype3(Bool::False)' died
    ok 2 - right exception type (X::TypeCheck::Return)
ok 58 - bad return value dies (my Type sub)
ok 59 - good return value works (-->)
    1..2
    ok 1 - 'returntype4(Bool::False)' died
    ok 2 - right exception type (X::TypeCheck::Return)
ok 60 - bad return value dies (-->)
ok 61 - good implicit return value works (returns)
    1..2
    ok 1 - 'returntype1(Bool::False)' died
    ok 2 - right exception type (X::TypeCheck::Return)
ok 62 - bad implicit return value dies (returns)
ok 63 - good implicit return value works (of)
    1..2
    ok 1 - 'returntype2(Bool::False)' died
    ok 2 - right exception type (X::TypeCheck::Return)
ok 64 - bad implicit return value dies (of)
ok 65 - good implicit return value works (my Type sub)
    1..2
    ok 1 - 'returntype3(Bool::False)' died
    ok 2 - right exception type (X::TypeCheck::Return)
ok 66 - bad implicit return value dies (my Type sub)
ok 67 - good implicit return value works (-->)
    1..2
    ok 1 - 'returntype4(Bool::False)' died
    ok 2 - right exception type (X::TypeCheck::Return)
ok 68 - bad implicit return value dies (-->)
    1..2
    ok 1 - 'my Int Str $x' died
    ok 2 - right exception type (X::Comp::NYI)
ok 69 - multiple prefix constraints not allowed
    1..2
    ok 1 - 'sub foo(Int Str $x) { }' died
    ok 2 - right exception type (X::Parameter::MultipleTypeConstraints)
ok 70 - multiple prefix constraints not allowed
    1..2
    ok 1 - 'sub foo(--> Int Str) { }' died
    ok 2 - right exception type (Exception)
ok 71 - multiple prefix constraints not allowed
    1..2
    ok 1 - 'our Int Str sub foo() { }' died
    ok 2 - right exception type (X::Comp::NYI)
ok 72 - multiple prefix constraints not allowed
ok 73 - Any ~~ Mu
ok 74 - Mu !~~ Any
ok 75 - Mu !~~ Int
ok 76 - Int ~~ Numeric
ok 77 - Numeric !~~ Int
ok 78 - Array is a kind of List
ok 79 - A List is not an Array
ok 80 - Array does Positional too
# FUDGED!
1..49
ok 1 - () is defined
ok 2 - Nil as part of list is element
ok 3 - Empty as part of list, is empty list
ok 4 - Pushing Empty returns same array
ok 5 - Pushing Empty in list context is empty list
ok 6 - Unshifting Empty returns same array
ok 7 - Unshifting Empty in list context is empty list
ok 8 - Setting array to Empty returns empty string
ok 9 - Setting to Empty restores original state
ok 10 - assigning Nil to Int should work
ok 11 - Nil makes undefined here
not ok 12 - Check that we have an 'Int' array # TODO .clone doesn't copy typedness
# Failed test 'Check that we have an 'Int' array'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/undefined-types.rakudo line 32
# expected: '(Int)'
#      got: (Int)
ok 13 - Empty as part of Int list, is empty list
ok 14 - assigning Empty returns same array
ok 15 - Pushing Empty in Int list context is empty list
ok 16 - assigning Empty returns same array
ok 17 - Unshifting Empty in Int list context is empty list
ok 18 - assigning Nil to Int should work
ok 19 - Nil makes undefined here
ok 20 - setting array to Empty returns empty string
not ok 21 - Check that we still have an 'Int' array # TODO .clone doesn't copy typedness
# Failed test 'Check that we still have an 'Int' array'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/undefined-types.rakudo line 42
# expected: '(Int)'
#      got: (Int)
ok 22 - Setting to Empty restores original state
not ok 23 - Check that we have an 'Int' hash # TODO .clone doesn't copy typedness
# Failed test 'Check that we have an 'Int' hash'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/undefined-types.rakudo line 50
# expected: '(Int)'
#      got: (Int)
ok 24 - Empty as part of Int list, is empty pair
ok 25 - assigning Nil to hash element should work
ok 26 - Nil makes undefined here
ok 27 - setting hash to Empty returns empty string
not ok 28 - Check that we still have an 'Int' hash # TODO .clone doesn't copy typedness
# Failed test 'Check that we still have an 'Int' hash'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/undefined-types.rakudo line 56
# expected: '(Int)'
#      got: (Int)
ok 29 - Setting to Empty restores original state
ok 30 - sink statement prefix returns Nil (list context)
ok 31 - sink execucted the statement
ok 32 - sink block prefix returns Nil (list context)
ok 33 - the block was executed
ok 34 - sink in scalar context (statement)
ok 35 - ... statement executed
ok 36 - sink in scalar context (block)
ok 37 - ... block executed
ok 38 - prefix:<~> on type object gives empty string (Any)
ok 39 - prefix:<~> on type object gives empty string (Int)
ok 40 - .Stringy on type object gives empty string (Any)
ok 41 - .Stringy on type object gives empty string (Int)
ok 42 - prefix:<~> returns a Stringy (Any)
ok 43 - prefix:<~> returns a Stringy (Int)
ok 44 - .Stringy returns a Stringy (Any)
ok 45 - .Stringy returns a Stringy (Int)
ok 46 - .gist on type object gives (Any)
ok 47 - .gist on type object gives (Int)
ok 48 - infix:<~> uses coercion to Stringy (Any)
ok 49 - infix:<~> uses coercion to Stringy (Int)
# FUDGED!
1..130
ok 1 - can assign * to a variable and isa works
ok 2 - can type variables with Whatever
ok 3 - *.WHAT does not autocurry
ok 4 - (*-1).WHAT lives
ok 5 - *-1 is some form of Code
ok 6 - *-1 is a WhateverCode object
ok 7 - and we can execute that Code
ok 8 - *.abs is of type Code
ok 9 - ... WhateverCode, more specifically
ok 10 - 1..* is a Range, not a Code
ok 11 - 1..*-1 is a WhateverCode
ok 12 - (1..*-1)(10) is a Range
ok 13 - *.meth created closure works
ok 14 - Enums and Whatever star interact OK
ok 15 - "*.uc eq $str" produces a Callable object
ok 16 - and it works (+)
ok 17 - and it works (-)
ok 18 - @a[1..*] skips first element, stops at last
ok 19 - array is unmodified after reference to [1..*]
ok 20 - *-1..* lives and clips to range of List
ok 21 - $_ % * works
ok 22 - +* is of type Code
ok 23 - -> $key {+$key} generates closure to numify
ok 24 - +* generates closure to numify
ok 25 - +* generates closure to numify
ok 26 - +* in hash slice
ok 27 - * * * generated a closure
ok 28 - ... that takes two arguments
ok 29 - * * * + * generated a closure
ok 30 - ... that works
ok 31 - ... that respects precedence
ok 32 - that can work with three different arguments
ok 33 - * + * * * generated a closure
ok 34 - ... that works
ok 35 - ... that respects precedence
ok 36 - that can work with three different arguments
ok 37 - xx * works
ok 38 - *.defined works in grep
ok 39 - *.defined generates a closure
ok 40 - *.defined works (true)
ok 41 - *.defined works (false)
not ok 42 - can dummy-asign to * # TODO * as dummy
# Failed test 'can dummy-asign to *'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/whatever.rakudo line 132
# Error: Cannot modify an immutable Whatever (*)
ok 43 - Can skip lvalues and replace them by Whatever
ok 44 - can use a declaration in Whatever-curried expression
ok 45 - and it did not get promoted into its own scope
ok 46 - * works on LHS of user-defined operator (type)
ok 47 - * works on RHS of user-defined operator (type)
ok 48 - * works on both sides of user-defined operator (type)
ok 49 - * works on LHS of user-defined operator (result)
ok 50 - * works on RHS of user-defined operator (result)
ok 51 - * works on both sides of user-defined operator (result)
ok 52 - also with three *
ok 53 - also if the last is not a *, but a normal value
ok 54 - '* + 2' curries
ok 55 - '* min 2' curries
ok 56 - '* max 2' curries
ok 57 - '* max *' curries
ok 58 - in *.foo(oh_noes()), oh_noes() not called when making closure
ok 59 - and we get a Callable as expected
ok 60 - does get called when invoked
ok 61 - does get called when invoked
ok 62 - we get a Callable from chained methods with *
ok 63 - we call both methods
ok 64 - prefix:<!> Whatever-curries correctly
ok 65 - Whatever-curried method calls have a signature
ok 66 - Whatever-curried operators have a signature
    1..2
    ok 1 - '{*.{}}()' died
    ok 2 - right exception type (X::Syntax::Malformed)
ok 67 - {*.{}}() dies
ok 68 - Whatever-currying !< (1)
ok 69 - Whatever-currying !< (2)
ok 70 - Whatever-currying !< (3)
ok 71 - Whatever-currying !< (4)
ok 72 - Whatever-currying with R- (1)
ok 73 - Whatever-currying with R- (2)
ok 74 - Whatever-currying with R- (3)
ok 75 - &infix:<+>(*, 42) doesn't make a closure
ok 76 - &infix:<+>(*, 42) doesn't make a closure
ok 77 - Whatever-currying single * with X+ (1)
ok 78 - Whatever-currying single * with X+ (2)
ok 79 - Whatever-currying single * with X+ (3)
ok 80 - Whatever-currying multi * with X+ (1)
ok 81 - Whatever-currying multi * with X+ (2)
ok 82 - Whatever-currying multi * with X+ (3)
ok 83 - Whatever-currying with X+ lists (1)
ok 84 - Whatever-currying with X+ lists (2)
ok 85 - Whatever-currying single * with Z+ (1)
ok 86 - Whatever-currying single * with Z+ (2)
ok 87 - Whatever-currying single * with Z+ (3)
ok 88 - Whatever-currying multi * with Z+ (1)
ok 89 - Whatever-currying multi * with Z+ (2)
ok 90 - Whatever-currying multi * with Z+ (3)
ok 91 - Whatever-currying with Z+ lists (1)
ok 92 - Whatever-currying with Z+ lists (2)
ok 93 - assignment of whatever still works
ok 94 - assignment to variable with whatever in it
ok 95 - *.&sub curries
ok 96 - *[0] curries
ok 97 - ... it works
ok 98 - Chained comparison (1)
ok 99 - Chained comparison (2)
ok 100 - Chained comparison (3)
ok 101 - *.[1] is some kind of code
ok 102 - *.<a> is some kind of code
ok 103 - *.{1} is some kind of code
ok 104 - Whatever type object does not autoprime
ok 105 - WhateverCode type object does not autoprime
ok 106 - *++ is some kind of code
ok 107 - ++* is some kind of code
ok 108 - Can call *++ WhateverCode
ok 109 - WhateverCode parameters are rw
    1..3
    ok 1 - '*(42)' died
    ok 2 - right exception type (X::Method::NotFound)
    ok 3 - .typename matches Whatever
ok 110 - did we throws-like X::Method::NotFound?
ok 111 - Code.ACCEPTS preserves container
ok 112 - Whatever-currying !~~ (1)
ok 113 - Whatever-currying !~~ (2)
not ok 114 - *+* does not warn from inside EVAL # TODO useless use corner case
# Failed test '*+* does not warn from inside EVAL'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/whatever.rakudo line 352
ok 115 - no warning when WhateverCode passed as arg and invoked
ok 116 - combinations(2..*)
not ok 117 - outer parameter in rx in WhateverCode in closure # TODO closure/scoping of outer parameter with rx
# Failed test 'outer parameter in rx in WhateverCode in closure'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/whatever.rakudo line 365
# expected: $[(), ("foo",), ("fie",), ()]
#      got: $[(), ("foo",), ("fie",), ()]
ok 118 - topic refreshed in immediate invocation of WhateverCode
ok 119 - no issues with //= and WhateverCode
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Str::Numeric)
ok 120 - WhateverCode curry correctly propagates `use fatal` pragma
ok 121 - Mu:U smartmatches as True with Whatever
    1..5
    ok 1 - `where` clause + is default trait on attribute
    ok 2 - `where` clause + is default on variable
    ok 3 - non-block BEGIN with WhateverCode execution
    ok 4 - non-block BEGIN with WhateverCode in subscript
    ok 5 - subset + default on variable
ok 122 - compile time WhateverCode evaluation
    1..3
    ok 1 - `where` clause + is default trait on attribute
    ok 2 - `where` clause + is default on variable
    ok 3 - subset + default on variable
ok 123 - compile time Junction in `where` thunk evaluation
    1..11
    ok 1 - /<$_>/ curry
    ok 2 - in-regex block
    ok 3 - /<$_>/ curry
    ok 4 - in-regex block
    ok 5 - in block inside in-regex block
    ok 6 - /<$_>/ curry
    ok 7 - in <?{...}> block
    ok 8 - in <!{...}> block
    ok 9 - in-regex block
    ok 10 - in block inside in-regex block
    ok 11 - /<$_>/ curry
ok 124 - regex whatever curry
    1..6
    ok 1 - op curry inside (1)
    ok 2 - op curry inside (2)
    ok 3 - op curry inside (3)
    ok 4 - method curry inside (2)
    ok 5 - method curry inside (1)
    ok 6 - method curry inside (3)
ok 125 - chained ops with whatever curry in them
    1..10
    ok 1 - 1
    ok 2 - 2
    ok 3 - 3
    ok 4 - 4
    ok 5 - 5
    ok 6 - 6
    ok 7 - 7
    ok 8 - 8
    ok 9 - 9
    ok 10 - 9
ok 126 - various wild cases
ok 127 - postfix curry with another curry inside
ok 128 - curry + regex + method call does not crash
    1..6
    ok 1 - .&{}
    ok 2 - method, .&{}
    ok 3 - method, .&{}, method
    ok 4 - method, .&, method, .& with whatever curry in it
    ok 5 - method, .&(1arg), method, .& with whatever curry in it, .&sub
    ok 6 - method, .&(2args), method, .& with whatever curry, .&sub
ok 129 - can curry chains with .& calls on them
    1..4
    ok 1 - 1-param, 1 assumed
    ok 2 - 2-param, 1 assumed
    ok 3 - 2-param, 2 assumed
    ok 4 - 5-params with nested calls, 2 assumed
ok 130 - can .assuming with WhateverCode
# FUDGED!
1..16
ok 1 - attribute binding lives
ok 2 - binding $!x instance attribute (1)
ok 3 - binding $!x instance attribute (2)
ok 4 - binding $x instance attribute (1)
ok 5 - binding $x instance attribute (2)
ok 6 - binding $x instance attribute (3)
ok 7 - # SKIP class attributes
ok 8 - # SKIP class attributes
ok 9 - # SKIP class attributes
ok 10 - binding private class attribute (1)
ok 11 - binding private class attribute (2)
ok 12 - binding private class attribute (3)
ok 13 - is the scalar attribute mixed in?
ok 14 - is the array attribute mixed in?
ok 15 - is the hash attribute mixed in?
ok 16 - is the code attribute mixed in?
# FUDGED!
1..8
ok 1 - Calling block binding without argument. (Runtime)
ok 2 - # SKIP ::= NYI
ok 3 - Calling block binding with argument. (Runtime, with parens)
ok 4 - Calling block binding with argument. (Runtime, no parens)
ok 5 - # SKIP ::= NYI
ok 6 - # SKIP ::= NYI
ok 7 - Testing the value for placeholder(Runtime binding)
ok 8 - # SKIP ::= NYI
# FUDGED!
1..11
ok 1 - # SKIP ::= NYI
ok 2 - # SKIP ::= NYI
ok 3 - # SKIP ::= NYI
ok 4 - # SKIP ::= NYI
ok 5 - # SKIP ::= NYI
ok 6 - # SKIP ::= NYI
ok 7 - # SKIP ::= NYI
ok 8 - # SKIP ::= NYI
ok 9 - # SKIP ::= NYI
    1..2
    ok 1 - 'my $a is readonly = 5;' died
    ok 2 - right exception type (X::Comp::Trait::Unknown)
ok 10 - variable trait "is readonly" is no longer valid (1)
    1..2
    ok 1 - '(my $a is readonly) = 5;' died
    ok 2 - right exception type (X::Comp::Trait::Unknown)
ok 11 - variable trait "is readonly" is no longer valid (2)
# FUDGED!
1..33
ok 1 - normal assignment works
ok 2 - y is now bound to x
ok 3 - y is bound to x (we checked with the =:= identity op)
ok 4 - z is not bound to x
ok 5 - z is not bound to x (we checked with the =:= identity op)
ok 6 - y has been changed to "Raku Hacker"
ok 7 - x has also been changed to "Raku Hacker"
ok 8 - z is still "Just Another" because it was not bound to x
    1..2
    ok 1 - '0 := 1' died
    ok 2 - right exception type (X::Bind)
ok 9 - cannot bind to a literal
ok 10 - CALLER resolves bindings in caller's dynamic scope
ok 11 - # SKIP list binding: RT  \#122369
ok 12 - # SKIP list binding: RT  \#122369
ok 13 - # SKIP list binding: RT  \#122369
ok 14 - # SKIP list binding: RT  \#122369
ok 15 - # SKIP list binding: RT  \#122369
ok 16 - # SKIP list binding: RT  \#122369
ok 17 - # SKIP list binding: RT  \#122369
ok 18 - bound readonly sub param was bound correctly (1)
ok 19 - bound readonly sub param was bound correctly (2) (no change)
ok 20 - bound readonly sub param remains readonly (1)
ok 21 - bound readonly sub param remains readonly (2)
ok 22 - bound readonly sub param remains readonly (3)
ok 23 - bound rw sub param was bound correctly (1)
ok 24 - bound rw sub param was bound correctly (2)
ok 25 - bound rw sub param remains rw (1)
ok 26 - bound rw sub param remains rw (2)
ok 27 - bound rw sub param remains rw (3)
ok 28 - # SKIP list binding: RT  \#122369
ok 29 - # SKIP list binding: RT  \#122369
ok 30 - binding has same precdence as list assignment
ok 31 - can bind variable to itself (no-oop)
ok 32 - interaction between signature binding and ordinary binding
ok 33 - rebinding
# FUDGED!
1..23
ok 1 - ltr feed as simple assignment
ok 2 - rtl feed as simple assignment
ok 3 - array ==> grep ==> result
ok 4 - result <== grep <== array
ok 5 - result = do {array ==> grep}
ok 6 - result = (array ==> grep)
ok 7 - x was passed as explicit param
not ok 8 - optional param y was not bound to fed list # TODO feeds + signatures
# Failed test 'optional param y was not bound to fed list'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-feeds/basic.rakudo line 58
not ok 9 - ...slurpy array *@z got it # TODO feeds + signatures
# Failed test '...slurpy array *@z got it'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-feeds/basic.rakudo line 59
# expected: '1 2 3 4 5'
#      got: ''
not ok 10 - @arr <== grep <== eager @arr works # TODO feeds + eager
# Failed test '@arr <== grep <== eager @arr works'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-feeds/basic.rakudo line 69
# expected: '1 5 7'
#      got: '1 2 4 5 7 8 1 5 7'
not ok 11 - @arr <== eager grep <== @arr works # TODO feeds + eager
# Failed test '@arr <== eager grep <== @arr works'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-feeds/basic.rakudo line 73
# expected: '1 5 7'
#      got: '1 2 4 5 7 8 1 5 7'
ok 12 - @tap contained what was expected at the time
not ok 13 - final result was unaffected by the tap variable # TODO feeds + eager
# Failed test 'final result was unaffected by the tap variable'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-feeds/basic.rakudo line 84
# expected: '2 4 6 8 10'
#      got: '0 1 2 3 4 5 6 7 8 9 2 4 6 8 10'
ok 14 - # SKIP double-ended feeds
ok 15 - # SKIP double-ended feeds
ok 16 - # SKIP double-ended feeds
ok 17 - # SKIP double-ended feeds
ok 18 - 
not ok 19 -  # TODO isn't lazy
# Failed test at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-feeds/basic.rakudo line 124
# expected: '1'
#      got: '10'
ok 20 - # SKIP * feeds
ok 21 - # SKIP * feeds
ok 22 - # SKIP * feeds
ok 23 - # SKIP * feeds
# FUDGED!
1..412
ok 1 - ascii hyper >> <<
ok 2 - unicode hyper >> <<
ok 3 - ascii hyper >> >>
ok 4 - unicode hyper >> >>
ok 5 - ascii hyper << >>
ok 6 - unicode hyper << >>
ok 7 - ascii hyper << <<
ok 8 - unicode hyper << <<
ok 9 - ascii hyper >>[ ]<<
ok 10 - unicode hyper >>[ ]<<
ok 11 - ascii hyper >>[ ]>>
ok 12 - unicode hyper >>[ ]>>
ok 13 - ascii hyper <<[ ]>>
ok 14 - unicode hyper <<[ ]>>
ok 15 - ascii hyper <<[ ]<<
ok 16 - unicode hyper <<[ ]<<
ok 17 - precedence - »+« vs »*«
ok 18 - hyper auto increment an array
ok 19 - hyper auto increment an array ASCII notation
ok 20 - hyper op on assignment/pipeline
ok 21 - hyper op on assignment/pipeline ASCII notation
ok 22 - auto dimension upgrade on rhs ASCII notation
ok 23 - auto dimension upgrade on lhs ASCII notation
ok 24 - both dwim short side lengthening on ASCII notation
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::HyperOp::NonDWIM)
    ok 3 - .left-elems matches 3
    ok 4 - .right-elems matches 5
ok 25 - both non-dwim dies correctly on ASCII notation
ok 26 - list-level element truncate on rhs ASCII notation
ok 27 - list-level element truncate on lhs ASCII notation
ok 28 - list-level element extension on rhs ASCII notation
ok 29 - list-level element extension on lhs ASCII notation
ok 30 - list-level element extension on rhs ASCII notation
ok 31 - list-level element extension on lhs ASCII notation
ok 32 - list-level element extension on rhs ASCII notation
ok 33 - list-level element extension on lhs ASCII notation
ok 34 - scalar element extension on rhs ASCII notation
ok 35 - scalar element extension on lhs ASCII notation
ok 36 - list-level element truncate on rhs unicode notation
ok 37 - list-level element truncate on lhs unicode notation
ok 38 - list-level element extension on rhs unicode notation
ok 39 - list-level element extension on lhs unicode notation
ok 40 - list-level element extension on rhs unicode notation
ok 41 - list-level element extension on lhs unicode notation
ok 42 - list-level element extension on rhs unicode notation
ok 43 - list-level element extension on lhs unicode notation
ok 44 - scalar element extension on rhs unicode notation
ok 45 - scalar element extension on lhs unicode notation
ok 46 - lazy list-level extension on lhs ascii notation
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::HyperOp::Infinite)
    ok 3 - .side matches left
ok 47 - lazy list on left side with both dwim dies correctly
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::HyperOp::Infinite)
    ok 3 - .side matches left
ok 48 - lazy list on left side with right dwim dies correctly
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::HyperOp::Infinite)
    ok 3 - .side matches left
ok 49 - lazy list on left side with both non-dwim dies correctly
ok 50 - lazy list-level extension on rhs ascii notation
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::HyperOp::Infinite)
    ok 3 - .side matches right
ok 51 - lazy list on right side with both dwim dies correctly
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::HyperOp::Infinite)
    ok 3 - .side matches right
ok 52 - lazy list on right side with left dwim dies correctly
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::HyperOp::Infinite)
    ok 3 - .side matches right
ok 53 - lazy list on right side with both non-dwim dies correctly
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::HyperOp::Infinite)
    ok 3 - .side matches both
ok 54 - lazy list on both sides with both non-dwim dies correctly
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::HyperOp::Infinite)
    ok 3 - .side matches both
ok 55 - lazy list on both sides with both dwim dies correctly
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::HyperOp::Infinite)
    ok 3 - .side matches both
ok 56 - lazy list on both sides with left dwim dies correctly
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::HyperOp::Infinite)
    ok 3 - .side matches both
ok 57 - lazy list on both sides with right dwim dies correctly
ok 58 - method call on integer list elements
ok 59 - method call on integer list elements (ASCII)
ok 60 - operator call on integer list elements
ok 61 - operator call on integer list elements (Same thing, dot form)
ok 62 - postfix operator (dotted form) on integer list elements after unary postfix hyper operator
ok 63 - postfix operator (dotted form) on integer list elements after unary postfix hyper operator (ASCII)
ok 64 - postfix operator (dotted form) on integer list elements after unary postfix hyper operator (unspace form)
ok 65 - non-wordy postfix operator
ok 66 - non-wordy postfix operator, ASCII
ok 67 - non-wordy postfix operator, dotted form
ok 68 - non-wordy postfix operator, ASCII, dotted form
ok 69 - wordy postfix operator
ok 70 - wordy postfix operator, ASCII
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Method::NotFound)
    ok 3 - .message matches No such method 'foo' for invocant of type 'Int'
ok 71 - wordy postfix operator: dotted form not allowed
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Method::NotFound)
    ok 3 - .message matches No such method 'foo' for invocant of type 'Int'
ok 72 - wordy postfix operator, ASCII: dotted form not allowed
ok 73 - manually defined method i is not confused with postfix:<i>
ok 74 - manually defined method i is not confused with postfix:<i>
ok 75 - postfix:<i> still works
ok 76 - postfix:<i> still works (2)
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Method::NotFound)
    ok 3 - .message matches WhateverCode.new
ok 77 - dotted form of postfix:<i> fails
ok 78 - postfix:<i> works on list elements
ok 79 - postfix:<i> works on list elements (ASCII form)
ok 80 - calling .() on list elements works
ok 81 - calling .() on list elements works, ASCII
ok 82 - method call on list elements
ok 83 - method call on list elements (Same thing, dot form)
ok 84 - method call on list elements (ASCII)
ok 85 - method call on list elements (ASCII, Same thing, dot form)
ok 86 - method call on list elements (quoted method name)
ok 87 - method call on list elements (ASCII, quoted method name)
ok 88 - plain method call works OK
ok 89 - hyper-method-call on list of user-defined objects
ok 90 - distribution for unary prefix
ok 91 - distribution for unary prefix, deep comparison
ok 92 - distribution for unary postfix autoincr
ok 93 - distribution for unary postfix autoincr, deep comparison
ok 94 - nodal postcircumfixes do not distribute
ok 95 - nodal methods do not distribute (elems)
ok 96 - nodal methods do not distribute (reverse)
ok 97 - .all is nodal
ok 98 - .antipairs is nodal
ok 99 - .any is nodal
ok 100 - .Array is nodal
ok 101 - .BagHash is nodal
ok 102 - .Bag is nodal
ok 103 - .categorize is nodal
ok 104 - .classify is nodal
ok 105 - .combinations is nodal
ok 106 - .deepmap is nodal
ok 107 - .duckmap is nodal
ok 108 - .eager is nodal
ok 109 - .elems is nodal
ok 110 - .end is nodal
ok 111 - .first is nodal
ok 112 - .flat is nodal
ok 113 - .flatmap is nodal
ok 114 - .grep is nodal
ok 115 - .hash is nodal
ok 116 - .Hash is nodal
ok 117 - .join is nodal
ok 118 - .keys is nodal
ok 119 - .kv is nodal
ok 120 - .list is nodal
ok 121 - .List is nodal
ok 122 - .map is nodal
ok 123 - .max is nodal
ok 124 - .min is nodal
ok 125 - .minmax is nodal
ok 126 - .MixHash is nodal
ok 127 - .Mix is nodal
ok 128 - .nodemap is nodal
ok 129 - .none is nodal
ok 130 - .one is nodal
ok 131 - .pairs is nodal
ok 132 - .pairup is nodal
ok 133 - .permutations is nodal
ok 134 - .pick is nodal
ok 135 - .postcircumfix:<[ ]> is nodal
ok 136 - .postcircumfix:<[; ]> is nodal
ok 137 - .produce is nodal
ok 138 - .reduce is nodal
ok 139 - .repeated is nodal
ok 140 - .reverse is nodal
ok 141 - .roll is nodal
ok 142 - .rotate is nodal
ok 143 - .rotor is nodal
ok 144 - .Seq is nodal
ok 145 - .SetHash is nodal
ok 146 - .Set is nodal
ok 147 - .Slip is nodal
ok 148 - .sort is nodal
ok 149 - .squish is nodal
ok 150 - .Supply is nodal
ok 151 - .tree is nodal
ok 152 - .unique is nodal
ok 153 - .values is nodal
ok 154 - .push is nodal
ok 155 - .pop is nodal
ok 156 - .append is nodal
ok 157 - .unshift is nodal
ok 158 - .shift is nodal
ok 159 - .prepend is nodal
not ok 160 - .splice is nodal # TODO doesn't seem to see the nodal
# Failed test '.splice is nodal'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-metaops/hyper.rakudo line 424
# expected: ''
#      got: '([2] [4])'
ok 161 - distribution for binary infix, same shape, ASCII
ok 162 - distribution for binary infix, same shape, ASCII, deep comparison
ok 163 - distribution for binary infix, dimension upgrade, ASCII
ok 164 - distribution for binary infix, dimension upgrade, ASCII, deep comparison
ok 165 - distribution for binary infix, S03 cross-upgrade, ASCII
ok 166 - distribution for binary infix, S03 cross-upgrade, ASCII, deep comparison
ok 167 - distribution for binary infix, same shape
ok 168 - distribution for binary infix, same shape, deep comparison
ok 169 - distribution for binary infix, dimension upgrade
ok 170 - distribution for binary infix, dimension upgrade, deep comparison
ok 171 - distribution for binary infix, S03 cross-upgrade
ok 172 - distribution for binary infix, S03 cross-upgrade, deep comparison
ok 173 - hyper op works on variables, too.
ok 174 - hyper op and correctly promotes scalars
ok 175 - hyper-dereference an array
ok 176 - hyper-dereference an array slice
ok 177 - »|« hyperjunction evals
ok 178 - >>|<< hyperjunction evals, ASCII
ok 179 - »&« hyperjunction evals
ok 180 - >>&<< hyperjunction evals, ASCII
ok 181 - hash - >>+<< result has right number of keys (same keys)
ok 182 - hash - correct result from >>+<< (same keys)
ok 183 - hash - correct result from >>+<< (same keys)
ok 184 - hash - correct result from >>+<< (same keys)
ok 185 - hash - »+« result has right number of keys (union test)
ok 186 - hash - correct result from »+« (union test)
ok 187 - hash - correct result from »+« (union test)
ok 188 - hash - correct result from »+« (union test)
ok 189 - hash - >>+<< result has right number of keys (union test)
ok 190 - hash - correct result from >>+<< (union test)
ok 191 - hash - correct result from >>+<< (union test)
ok 192 - hash - correct result from >>+<< (union test)
ok 193 - hash - <<+>> result has right number of keys (same keys)
ok 194 - hash - correct result from <<+>> (same keys)
ok 195 - hash - correct result from <<+>> (same keys)
ok 196 - hash - correct result from <<+>> (same keys)
ok 197 - hash - <<+>> result has right number of keys (intersection test)
ok 198 - hash - correct result from <<+>> (intersection test)
ok 199 - hash - correct result from <<+>> (intersection test)
ok 200 - hash - <<+>> result has right number of keys (intersection test)
ok 201 - hash - correct result from <<+>> (intersection test)
ok 202 - hash - correct result from <<+>> (intersection test)
ok 203 - hash - >>+>> result has right number of keys
ok 204 - hash - correct result from >>+>>
ok 205 - hash - correct result from >>+>>
ok 206 - hash - correct result from >>+>>
ok 207 - hash - >>+>> result has right number of keys
ok 208 - hash - correct result from >>+>>
ok 209 - hash - correct result from >>+>>
ok 210 - hash - <<+<< result has right number of keys
ok 211 - hash - correct result from <<+<<
ok 212 - hash - correct result from <<+<<
ok 213 - hash - correct result from <<+<<
ok 214 - hash - <<+<< result has right number of keys
ok 215 - hash - correct result from <<+<<
ok 216 - hash - correct result from <<+<<
ok 217 - hash - -<< result has right number of keys
ok 218 - hash - correct result from -<<
ok 219 - hash - correct result from -<<
ok 220 - hash - correct result from -<<
ok 221 - hash - --<< result has right number of keys
ok 222 - hash - correct result from --<<
ok 223 - hash - correct result from --<<
ok 224 - hash - correct result from --<<
ok 225 - hash - --<< result has right number of keys
ok 226 - hash - correct result from --<<
ok 227 - hash - correct result from --<<
ok 228 - hash - correct result from --<<
ok 229 - hash - >>++ result has right number of keys
ok 230 - hash - correct result from >>++
ok 231 - hash - correct result from >>++
ok 232 - hash - correct result from >>++
ok 233 - hash - >>++ result has right number of keys
ok 234 - hash - correct result from >>++
ok 235 - hash - correct result from >>++
ok 236 - hash - correct result from >>++
ok 237 - hash - >>! result has right number of keys
ok 238 - hash - correct result from >>!
ok 239 - hash - correct result from >>!
ok 240 - hash - correct result from >>!
ok 241 - hash - >>*>> result has right number of keys
ok 242 - hash - correct result from >>*>>
ok 243 - hash - correct result from >>*>>
ok 244 - hash - correct result from >>*>>
ok 245 - hash - <<**<< result has right number of keys
ok 246 - hash - correct result from <<**<<
ok 247 - hash - correct result from <<**<<
ok 248 - hash - correct result from <<**<<
ok 249 - hash - <<*>> result has right number of keys
ok 250 - hash - correct result from <<*>>
ok 251 - hash - correct result from <<*>>
ok 252 - hash - correct result from <<*>>
ok 253 - hash - <<**>> result has right number of keys
ok 254 - hash - correct result from <<**>>
ok 255 - hash - correct result from <<**>>
ok 256 - hash - correct result from <<**>>
ok 257 - hash - >>.abs result has right number of keys
ok 258 - hash - correct result from >>.abs
ok 259 - hash - correct result from >>.abs
ok 260 - hash - correct result from >>.abs
ok 261 - hash in array - result array is the correct length
ok 262 - hash in array - correct result from <<~>>
ok 263 - hash in array - correct result from <<~>>
ok 264 - hash in array - correct result from <<~>>
ok 265 - hash in array - correct result from <<~>>
ok 266 - hash in array - result array is the correct length
ok 267 - hash in array - correct result from >>~<<
ok 268 - hash in array - correct result from >>~<<
ok 269 - hash in array - correct result from >>~<<
ok 270 - hash in array - correct result from >>~<<
ok 271 - hash in array - result array is the correct length
ok 272 - hash in array - correct result from >>~>>
ok 273 - hash in array - correct result from >>~>>
ok 274 - hash in array - correct result from >>~>>
ok 275 - hash in array - correct result from >>~>>
ok 276 - hash in array - result array is the correct length
ok 277 - hash in array - correct result from <<R~<<
ok 278 - hash in array - correct result from <<R~<<
ok 279 - hash in array - correct result from <<R~<<
ok 280 - hash in array - correct result from <<R~<<
ok 281 - hash in array - result array is the correct length
ok 282 - hash in array - correct result from <<~>>
ok 283 - hash in array - correct result from <<~>>
ok 284 - hash in array - correct result from <<~>>
ok 285 - hash in array - correct result from <<~>>
ok 286 - hash in array - correct result from <<~>>
ok 287 - hash in array - correct result from <<~>>
ok 288 - hash in array - correct result from <<~>>
ok 289 - hash in array - correct result from <<~>>
ok 290 - hash in array - result array is the correct length
ok 291 - hash in array - correct result from «~»
ok 292 - hash in array - correct result from «~»
ok 293 - hash in array - correct result from «~»
ok 294 - hash in array - correct result from «~»
ok 295 - hash in array - result array is the correct length
ok 296 - hash in array - correct result from »~«
ok 297 - hash in array - correct result from »~«
ok 298 - hash in array - correct result from »~«
ok 299 - hash in array - correct result from »~«
ok 300 - hash in array - result array is the correct length
ok 301 - hash in array - correct result from »~»
ok 302 - hash in array - correct result from »~»
ok 303 - hash in array - correct result from »~»
ok 304 - hash in array - correct result from »~»
ok 305 - hash in array - result array is the correct length
ok 306 - hash in array - correct result from «R~«
ok 307 - hash in array - correct result from «R~«
ok 308 - hash in array - correct result from «R~«
ok 309 - hash in array - correct result from «R~«
ok 310 - hash in array - result array is the correct length
ok 311 - hash in array - correct result from «~»
ok 312 - hash in array - correct result from «~»
ok 313 - hash in array - correct result from «~»
ok 314 - hash in array - correct result from «~»
ok 315 - hash in array - correct result from «~»
ok 316 - hash in array - correct result from «~»
ok 317 - hash in array - correct result from «~»
ok 318 - hash in array - correct result from «~»
ok 319 - hash in array - result array is the correct length
ok 320 - hash in array - correct result from -<<
ok 321 - hash in array - correct result from -<<
ok 322 - hash in array - correct result from -<<
ok 323 - hash in array - correct result from -<<
ok 324 - hash in array - result array is the correct length
ok 325 - hash in array - correct result from ++<<
ok 326 - hash in array - correct result from ++<<
ok 327 - hash in array - correct result from ++<<
ok 328 - hash in array - correct result from ++<<
ok 329 - hash in array - result array is the correct length
ok 330 - hash in array - correct result from ++<<
ok 331 - hash in array - correct result from ++<<
ok 332 - hash in array - correct result from ++<<
ok 333 - hash in array - correct result from ++<<
ok 334 - hash in array - result array is the correct length
ok 335 - hash in array - correct result from ++<<
ok 336 - hash in array - correct result from ++<<
ok 337 - hash in array - correct result from ++<<
ok 338 - hash in array - correct result from ++<<
ok 339 - # SKIP EVAL(Buf) RT  \#122256
ok 340 - dwimmy hyper doesn't return an itemized list
ok 341 - dwimmy hyper extends lists ending with * by copying the last element
ok 342 - dwimmy hyper extends lists ending with * by copying the last element
ok 343 - dwimmy hyper extends lists ending with * by copying the last element
ok 344 - dwimmy hyper extends lists ending with * by copying the last element
ok 345 - dwimmy hyper omits * when both arguments of same length have one
ok 346 - dwimmy hyper takes longer length given two arguments ending with *
ok 347 - can use hypers with local scoped user-defined operators
ok 348 - ranges and hyper ops mix
ok 349 - <<-<<
ok 350 - >>->>
ok 351 - >>-<<
ok 352 - <<->>
ok 353 - »+=« returns the right value
ok 354 - »+=« changes its lvalue
ok 355 - »*=» returns the right value
ok 356 - »*=» changes its lvalue
ok 357 - »~=» with list of scalars on the left returns the right value
ok 358 - »~=» changes each scalar
ok 359 - >>[+]<< works
ok 360 - .>> works with .()
ok 361 - .>>.() means the same as >>.()
ok 362 - can call Callable objects in a list in parallel using >>.()
    1..2
    not ok 1 - 'my @a >>[=]>> (1,2,3)' died # TODO can_meta check for meta operators NYI
    # Failed test ''my @a >>[=]>> (1,2,3)' died'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-metaops/hyper.rakudo line 925
    ok 2 - # SKIP Code did not die, can not check exception
not ok 363 - hypering assignment dies correctly # TODO can_meta check for meta operators NYI
# Failed test 'hypering assignment dies correctly'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-metaops/hyper.rakudo line 925
ok 364 - hyper against an undefined Iterable doesn't hang
ok 365 - hyper against an undefined Associative doesn't hang
ok 366 - no-dwim hyper between empty lists doesn't hang
ok 367 - left-dwim hyper between empty lists doesn't hang
ok 368 - right-dwim hyper between empty lists doesn't hang
ok 369 - both-dwim hyper between empty lists doesn't hang
ok 370 - left-dwim hyper against empty RHS doesn't hang
ok 371 - right-dwim hyper against empty RHS doesn't hang
ok 372 - both-dwim hyper against empty RHS doesn't hang
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::HyperOp::NonDWIM)
    ok 3 - .right-elems matches 0
    ok 4 - .left-elems matches 1
ok 373 - non-dwim hyper against empty RHS dies
ok 374 - left-dwim hyper against empty LHS doesn't hang
ok 375 - right-dwim hyper against empty LHS doesn't hang
ok 376 - both-dwim hyper against empty LHS doesn't hang
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::HyperOp::NonDWIM)
    ok 3 - .right-elems matches 1
    ok 4 - .left-elems matches 0
ok 377 - non-dwim hyper against empty RHS dies
ok 378 - left-dwim hyper against empty RHS doesn't hang
ok 379 - right-dwim hyper against empty RHS doesn't hang
ok 380 - both-dwim hyper against empty RHS doesn't hang
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::HyperOp::NonDWIM)
    ok 3 - .left-elems matches 5
    ok 4 - .right-elems matches 0
ok 381 - non-dwim hyper against empty RHS dies
ok 382 - left-dwim hyper against empty LHS doesn't hang
ok 383 - right-dwim hyper against empty LHS doesn't hang
ok 384 - both-dwim hyper against empty LHS doesn't hang
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::HyperOp::NonDWIM)
    ok 3 - .right-elems matches 5
    ok 4 - .left-elems matches 0
ok 385 - non-dwim hyper against empty RHS dies
    1..2
    ok 1 - '3 «.» foo' died
    ok 2 - right exception type (Exception)
ok 386 - «.» can't be hypered
ok 387 - hyper op works with range on non-magical side (1)
ok 388 - hyper op works with range on non-magical side (2)
ok 389 - hyper op works with (finite) range on non-magical side (3)
ok 390 - Hyper prefix can autogen with &
ok 391 - Hyper prefix can autogen without &
ok 392 - Hyper >><< can autogen with &
ok 393 - Hyper >>>> can autogen with &
ok 394 - Hyper <<<< can autogen with &
ok 395 - Hyper <<>> can autogen with &
ok 396 - Hyper >><< can autogen without &
ok 397 - Hyper >>>> can autogen without &
ok 398 - Hyper <<<< can autogen without &
ok 399 - Hyper <<>> can autogen without &
ok 400 - Hyper >><< can autogen with &[]
ok 401 - Hyper >>>> can autogen with &[]
ok 402 - Hyper <<<< can autogen with &[]
ok 403 - Hyper <<>> can autogen with &[]
ok 404 - Hyper postfix can autogen with &
ok 405 - Hyper postfix can autogen without &
ok 406 - union hyperoperator on a hash shouldn't warn about missing keys
    1..20
    ok 1 - ».
    ok 2 - ».""()
    ok 3 - ».&
    ok 4 - ».$
    ok 5 - ».::
    ok 6 - ».?
    ok 7 - ».?""()
    ok 8 - ».?&
    ok 9 - ».?$
    ok 10 - ».?::
    ok 11 - ».+
    ok 12 - ».+""()
    ok 13 - ».+&
    ok 14 - ».+$
    ok 15 - ».+::
    ok 16 - ».*
    ok 17 - ».*""()
    ok 18 - ».*&
    ok 19 - ».*$
    ok 20 - ».*::
ok 407 - method call variants respect nodality
    1..8
        1..2
        ok 1 - right result
        ok 2 - producing method name ran only once
    ok 1 - ».""() evaluates given value only once
        1..2
        ok 1 - right result
        ok 2 - producing method name ran only once
    ok 2 - ».?""() evaluates given value only once
        1..2
        ok 1 - right result
        ok 2 - producing method name ran only once
    ok 3 - ».+""() evaluates given value only once
        1..2
        ok 1 - right result
        ok 2 - producing method name ran only once
    ok 4 - ».*""() evaluates given value only once
        1..2
        ok 1 - right result
        ok 2 - sub ran expected number of times
    ok 5 - ».& sub calls
        1..2
        ok 1 - right result
        ok 2 - sub ran expected number of times
    ok 6 - ».?& sub calls
        1..2
        ok 1 - right result
        ok 2 - sub ran expected number of times
    ok 7 - ».+& sub calls
        1..2
        ok 1 - right result
        ok 2 - sub ran expected number of times
    ok 8 - ».*& sub calls
ok 408 - hyper method calls string/var method names
ok 409 - No crash when RHS to be expanded is an itemized list
ok 410 - An array built with a hyperoperator is mutable
ok 411 - Hyper on slip values is correct
ok 412 - Values created with a hyperoperator can be wrapped in a slip
# FUDGED!
1..47
ok 1 - 4 !< 5
ok 2 - 4 !< 5 is Bool
ok 3 - 4 !> 5
ok 4 - 4 !> 5 is Bool
ok 5 - 4 !<= 5
ok 6 - 4 !<= 5 is Bool
ok 7 - 4 !>= 5
ok 8 - 4 !>= 5 is Bool
ok 9 - 4 !== 5
ok 10 - 4 !== 5 is Bool
ok 11 - 'bat' !lt 'ace'
ok 12 - 'bat' !lt 'ace' is Bool
ok 13 - 'bat' !gt 'ace'
ok 14 - 'bat' !gt 'ace' is Bool
ok 15 - 'bat' !le 'ace'
ok 16 - 'bat' !le 'ace' is Bool
ok 17 - 'bat' !ge 'ace'
ok 18 - 'bat' !ge 'ace' is Bool
ok 19 - 'bat' !eq 'ace'
ok 20 - 'bat' !eq 'ace' is Bool
ok 21 - 'bat' !before 'ace'
ok 22 - 'bat' !before 'ace' is Bool
ok 23 - 'bat' !after 'ace'
ok 24 - 'bat' !after 'ace' is Bool
ok 25 - 4 !=== 5
ok 26 - 4 !=== 5 is Bool
ok 27 - 4 !eqv 5
ok 28 - 4 !eqv 5 is Bool
ok 29 - 4 !=:= 5
ok 30 - 4 !=:= 5 is Bool
    1..2
    ok 1 - '"a" !!eq "a"' died
    ok 2 - right exception type (X::Syntax::Confused)
ok 31 - Doubled prefix:<!> is illegal
ok 32 - ![!eq] is legal and works (1)
ok 33 - ![!eq] is legal and works (2)
ok 34 - !&& is legal and works (1)
ok 35 - !&& is legal and works (2)
ok 36 - !|| is legal and works (1)
ok 37 - !|| is legal and works (2)
ok 38 - !^^ is legal and works (1)
ok 39 - !^^ is legal and works (2)
    1..2
    ok 1 - '3 !. foo' died
    ok 2 - right exception type (X::Syntax::CannotMeta)
ok 40 - !. is too fiddly
    1..2
    ok 1 - '3 !. "foo"' died
    ok 2 - right exception type (X::Obsolete)
ok 41 - !. can't do P5 concat
ok 42 - Meta not can autogen (!===)
ok 43 - Meta not can autogen (!%%)
ok 44 - Meta not can autogen (![!%%])
ok 45 - Meta not can autogen (!===) without &
ok 46 - Meta not can autogen (!===) with &[]
    1..12
    ok 1 - !after/!after (Str)
    ok 2 - !before/!before (Str)
    ok 3 - # SKIP Should this work? https://github.com/rakudo/rakudo/issues/1304
    ok 4 - # SKIP Should this work? https://github.com/rakudo/rakudo/issues/1304
    ok 5 - # SKIP Should this work? https://github.com/rakudo/rakudo/issues/1304
    ok 6 - # SKIP Should this work? https://github.com/rakudo/rakudo/issues/1304
    ok 7 - !after/!after (Int)
    ok 8 - !before/!before (Int)
    ok 9 - # SKIP Should this work? https://github.com/rakudo/rakudo/issues/1304
    ok 10 - # SKIP Should this work? https://github.com/rakudo/rakudo/issues/1304
    ok 11 - # SKIP Should this work? https://github.com/rakudo/rakudo/issues/1304
    ok 12 - # SKIP Should this work? https://github.com/rakudo/rakudo/issues/1304
ok 47 - chaining of !before/!after
# FUDGED!
1..581
ok 1 - [+] works
ok 2 - [*] works
ok 3 - [-] works
ok 4 - [/] works
ok 5 - [div] works
ok 6 - [**] works
ok 7 - [%] works
ok 8 - [mod] works
ok 9 - [\+] works
ok 10 - [\-] works
ok 11 - [~] works
ok 12 - [\~] works
ok 13 - [<] works (1)
ok 14 - [<] works (2)
ok 15 - [>] works (1)
ok 16 - [>] works (2)
ok 17 - [==] works (1)
ok 18 - [==] works (2)
ok 19 - [!=] works (1)
ok 20 - [!=] works (2)
ok 21 - [eq] basic sanity (positive)
ok 22 - [eq] basic sanity (negative)
ok 23 - [ne] basic sanity (positive)
ok 24 - [ne] basic sanity (negative)
ok 25 - [lt] basic sanity (positive)
ok 26 - [lt] basic sanity (negative)
ok 27 - [=:=] basic sanity 1
ok 28 - [=:=] basic sanity 2
ok 29 - [!=:=] basic sanity (positive)
ok 30 - [!=:=] basic sanity (negative)
ok 31 - [=:=] after binding
ok 32 - [===] with literals
ok 33 - [===] with vars (positive)
ok 34 - [===] with vars (negative)
ok 35 - [!===] basic sanity (positive)
ok 36 - [!===] basic sanity (negative)
ok 37 - [\<] works (1)
ok 38 - [\<] works (2)
ok 39 - [\>] works (1)
ok 40 - [\>] works (2)
ok 41 - [\==] works (1)
ok 42 - [\==] works (2)
ok 43 - [\!=] works (1)
ok 44 - [\!=] works (2)
ok 45 - [\**] (right assoc) works (1)
ok 46 - [\**] (right assoc) works (2)
ok 47 - two nested [\+]
ok 48 - [+] does not flatten []-arrays
ok 49 - [//] works
ok 50 - [orelse] works
ok 51 - [||] works
ok 52 - [or] works
ok 53 - [\||] works
ok 54 - [&&] works with 1 false
ok 55 - [&&] works
ok 56 - [and] works with 1 false
ok 57 - [and] works
ok 58 - [=>] works (1)
ok 59 - [=>] works (2)
ok 60 - [=>] works (3)
ok 61 - [=>] works on Seq
not ok 62 - [,] returns a single Array # TODO item context
# Failed test '[,] returns a single Array'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-metaops/reduce.rakudo line 160
# expected: '1'
#      got: '6'
ok 63 - [,] returns something Positional
ok 64 - Sanity Check
ok 65 - Parse [>>+<<]
ok 66 - reduce metaop of hyper metaop works with only one element
not ok 67 - reduce metaop of hyper metaop works with zero elements # TODO reduce metaop of hyper metaop works with zero elements
# Failed test 'reduce metaop of hyper metaop works with zero elements'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-metaops/reduce.rakudo line 175
# Error: Too few positionals passed; expected 2 arguments but got 0
ok 68 - [...] reduce metaop works on user defined ops
ok 69 - [*]() returns 1
ok 70 - [+]() returns 0
ok 71 - [*] 41 returns 41
ok 72 - [*] 42 returns 42
ok 73 - [*] 42 returns (42)
ok 74 - [~] 'towel' returns 'towel'
ok 75 - [~] 'washcloth' returns 'washcloth'
ok 76 - [~] 'towel' returns 'towel'
ok 77 - [~] 'towel' returns something Iterable
ok 78 - [<] 42 returns true
ok 79 - [<] 42 returns '1'
ok 80 - [<] 42 returns something Iterable
ok 81 - triangle reduce is lazy
ok 82 - triangle reduce knows if it's lazy
ok 83 - triangle reduce knows if it's lazy
ok 84 - [max]() returns -Inf
ok 85 - [min]() returns -Inf
ok 86 - [max] Any, Any, 2 returns 2
ok 87 - [min] Any, Any, 2 returns 2
ok 88 - [^^] works (one of two true)
ok 89 - [^^] works (one of two true)
ok 90 - [^^] works (two true)
ok 91 - [^^] works (two false)
ok 92 - [^^] works (three false)
ok 93 - [^^] works (three true)
ok 94 - [^^] mix 1
ok 95 - [^^] mix 2
ok 96 - [^^] mix 3
ok 97 - [^^] mix 4
ok 98 - [^^] mix 5
ok 99 - [^^] mix 6
ok 100 - reduce empty list ok
ok 101 - |0| reduce [^^] false variable test  \#1
ok 102 - |0| reduce [^^] false variable test  \#2
ok 103 - |0| reduce [^^] false variable test  \#3
ok 104 - |0| reduce [^^] false variable test  \#4
ok 105 - |0| reduce [^^] false variable test  \#5
ok 106 - |0| reduce [^^] false variable test  \#6
ok 107 - |0| reduce [^^] false variable test  \#7
ok 108 - |0| reduce [^^] false variable test  \#8
ok 109 - |0| reduce [^^] false variable test  \#9
ok 110 - |0| reduce [^^] false variable test  \#10
ok 111 - |0| infix ^^ false variable test  \#1
ok 112 - |0| infix ^^ false variable test  \#2
ok 113 - |0| infix ^^ false variable test  \#3
ok 114 - |0| infix ^^ false variable test  \#4
ok 115 - |0| infix ^^ false variable test  \#5
ok 116 - |0| infix ^^ false variable test  \#6
ok 117 - |0| infix ^^ false variable test  \#7
ok 118 - |0| infix ^^ false variable test  \#8
ok 119 - |0| infix ^^ false variable test  \#9
ok 120 - |""| reduce [^^] false variable test  \#1
ok 121 - |""| reduce [^^] false variable test  \#2
ok 122 - |""| reduce [^^] false variable test  \#3
ok 123 - |""| reduce [^^] false variable test  \#4
ok 124 - |""| reduce [^^] false variable test  \#5
ok 125 - |""| reduce [^^] false variable test  \#6
ok 126 - |""| reduce [^^] false variable test  \#7
ok 127 - |""| reduce [^^] false variable test  \#8
ok 128 - |""| reduce [^^] false variable test  \#9
ok 129 - |""| reduce [^^] false variable test  \#10
ok 130 - |""| infix ^^ false variable test  \#1
ok 131 - |""| infix ^^ false variable test  \#2
ok 132 - |""| infix ^^ false variable test  \#3
ok 133 - |""| infix ^^ false variable test  \#4
ok 134 - |""| infix ^^ false variable test  \#5
ok 135 - |""| infix ^^ false variable test  \#6
ok 136 - |""| infix ^^ false variable test  \#7
ok 137 - |""| infix ^^ false variable test  \#8
ok 138 - |""| infix ^^ false variable test  \#9
ok 139 - |Bool::False| reduce [^^] false variable test  \#1
ok 140 - |Bool::False| reduce [^^] false variable test  \#2
ok 141 - |Bool::False| reduce [^^] false variable test  \#3
ok 142 - |Bool::False| reduce [^^] false variable test  \#4
ok 143 - |Bool::False| reduce [^^] false variable test  \#5
ok 144 - |Bool::False| reduce [^^] false variable test  \#6
ok 145 - |Bool::False| reduce [^^] false variable test  \#7
ok 146 - |Bool::False| reduce [^^] false variable test  \#8
ok 147 - |Bool::False| reduce [^^] false variable test  \#9
ok 148 - |Bool::False| reduce [^^] false variable test  \#10
ok 149 - |Bool::False| infix ^^ false variable test  \#1
ok 150 - |Bool::False| infix ^^ false variable test  \#2
ok 151 - |Bool::False| infix ^^ false variable test  \#3
ok 152 - |Bool::False| infix ^^ false variable test  \#4
ok 153 - |Bool::False| infix ^^ false variable test  \#5
ok 154 - |Bool::False| infix ^^ false variable test  \#6
ok 155 - |Bool::False| infix ^^ false variable test  \#7
ok 156 - |Bool::False| infix ^^ false variable test  \#8
ok 157 - |Bool::False| infix ^^ false variable test  \#9
ok 158 - |Any| reduce [^^] false variable test  \#1
ok 159 - |Any| reduce [^^] false variable test  \#2
ok 160 - |Any| reduce [^^] false variable test  \#3
ok 161 - |Any| reduce [^^] false variable test  \#4
ok 162 - |Any| reduce [^^] false variable test  \#5
ok 163 - |Any| reduce [^^] false variable test  \#6
ok 164 - |Any| reduce [^^] false variable test  \#7
ok 165 - |Any| reduce [^^] false variable test  \#8
ok 166 - |Any| reduce [^^] false variable test  \#9
ok 167 - |Any| reduce [^^] false variable test  \#10
ok 168 - |Any| infix ^^ false variable test  \#1
ok 169 - |Any| infix ^^ false variable test  \#2
ok 170 - |Any| infix ^^ false variable test  \#3
ok 171 - |Any| infix ^^ false variable test  \#4
ok 172 - |Any| infix ^^ false variable test  \#5
ok 173 - |Any| infix ^^ false variable test  \#6
ok 174 - |Any| infix ^^ false variable test  \#7
ok 175 - |Any| infix ^^ false variable test  \#8
ok 176 - |Any| infix ^^ false variable test  \#9
ok 177 - |Mu| reduce [^^] false variable test  \#1
ok 178 - |Mu| reduce [^^] false variable test  \#2
ok 179 - |Mu| reduce [^^] false variable test  \#3
ok 180 - |Mu| reduce [^^] false variable test  \#4
ok 181 - |Mu| reduce [^^] false variable test  \#5
ok 182 - |Mu| reduce [^^] false variable test  \#6
ok 183 - |Mu| reduce [^^] false variable test  \#7
ok 184 - |Mu| reduce [^^] false variable test  \#8
ok 185 - |Mu| reduce [^^] false variable test  \#9
ok 186 - |Mu| reduce [^^] false variable test  \#10
ok 187 - |Mu| infix ^^ false variable test  \#1
ok 188 - |Mu| infix ^^ false variable test  \#2
ok 189 - |Mu| infix ^^ false variable test  \#3
ok 190 - |Mu| infix ^^ false variable test  \#4
ok 191 - |Mu| infix ^^ false variable test  \#5
ok 192 - |Mu| infix ^^ false variable test  \#6
ok 193 - |Mu| infix ^^ false variable test  \#7
ok 194 - |Mu| infix ^^ false variable test  \#8
ok 195 - |Mu| infix ^^ false variable test  \#9
ok 196 - |Nil| reduce [^^] false variable test  \#1
ok 197 - |Nil| reduce [^^] false variable test  \#2
ok 198 - |Nil| reduce [^^] false variable test  \#3
ok 199 - |Nil| reduce [^^] false variable test  \#4
ok 200 - |Nil| reduce [^^] false variable test  \#5
ok 201 - |Nil| reduce [^^] false variable test  \#6
ok 202 - |Nil| reduce [^^] false variable test  \#7
ok 203 - |Nil| reduce [^^] false variable test  \#8
ok 204 - |Nil| reduce [^^] false variable test  \#9
ok 205 - |Nil| reduce [^^] false variable test  \#10
ok 206 - |Nil| infix ^^ false variable test  \#1
ok 207 - |Nil| infix ^^ false variable test  \#2
ok 208 - |Nil| infix ^^ false variable test  \#3
ok 209 - |Nil| infix ^^ false variable test  \#4
ok 210 - |Nil| infix ^^ false variable test  \#5
ok 211 - |Nil| infix ^^ false variable test  \#6
ok 212 - |Nil| infix ^^ false variable test  \#7
ok 213 - |Nil| infix ^^ false variable test  \#8
ok 214 - |Nil| infix ^^ false variable test  \#9
ok 215 - |1| reduce [^^] true numbery variable test  \#1
ok 216 - |1| reduce [^^] true numbery variable test  \#2
ok 217 - |1| reduce [^^] true numbery variable test  \#3
ok 218 - |1| reduce [^^] true numbery variable test  \#4
ok 219 - |1| reduce [^^] true numbery variable test  \#5
ok 220 - |1| reduce [^^] true numbery variable test  \#6
ok 221 - |1| reduce [^^] true numbery variable test  \#7
ok 222 - |1| reduce [^^] true numbery variable test  \#8
ok 223 - |1| reduce [^^] true numbery variable test  \#9
ok 224 - |1| infix ^^ true numbery variable test  \#1
ok 225 - |1| infix ^^ true numbery variable test  \#2
ok 226 - |1| infix ^^ true numbery variable test  \#3
ok 227 - |1| infix ^^ true numbery variable test  \#4
ok 228 - |1| infix ^^ true numbery variable test  \#5
ok 229 - |1| infix ^^ true numbery variable test  \#6
ok 230 - |1| infix ^^ true numbery variable test  \#7
ok 231 - |1| infix ^^ true numbery variable test  \#8
ok 232 - |-147| reduce [^^] true numbery variable test  \#1
ok 233 - |-147| reduce [^^] true numbery variable test  \#2
ok 234 - |-147| reduce [^^] true numbery variable test  \#3
ok 235 - |-147| reduce [^^] true numbery variable test  \#4
ok 236 - |-147| reduce [^^] true numbery variable test  \#5
ok 237 - |-147| reduce [^^] true numbery variable test  \#6
ok 238 - |-147| reduce [^^] true numbery variable test  \#7
ok 239 - |-147| reduce [^^] true numbery variable test  \#8
ok 240 - |-147| reduce [^^] true numbery variable test  \#9
ok 241 - |-147| infix ^^ true numbery variable test  \#1
ok 242 - |-147| infix ^^ true numbery variable test  \#2
ok 243 - |-147| infix ^^ true numbery variable test  \#3
ok 244 - |-147| infix ^^ true numbery variable test  \#4
ok 245 - |-147| infix ^^ true numbery variable test  \#5
ok 246 - |-147| infix ^^ true numbery variable test  \#6
ok 247 - |-147| infix ^^ true numbery variable test  \#7
ok 248 - |-147| infix ^^ true numbery variable test  \#8
ok 249 - |3.141592653589793e0| reduce [^^] true numbery variable test  \#1
ok 250 - |3.141592653589793e0| reduce [^^] true numbery variable test  \#2
ok 251 - |3.141592653589793e0| reduce [^^] true numbery variable test  \#3
ok 252 - |3.141592653589793e0| reduce [^^] true numbery variable test  \#4
ok 253 - |3.141592653589793e0| reduce [^^] true numbery variable test  \#5
ok 254 - |3.141592653589793e0| reduce [^^] true numbery variable test  \#6
ok 255 - |3.141592653589793e0| reduce [^^] true numbery variable test  \#7
ok 256 - |3.141592653589793e0| reduce [^^] true numbery variable test  \#8
ok 257 - |3.141592653589793e0| reduce [^^] true numbery variable test  \#9
ok 258 - |3.141592653589793e0| infix ^^ true numbery variable test  \#1
ok 259 - |3.141592653589793e0| infix ^^ true numbery variable test  \#2
ok 260 - |3.141592653589793e0| infix ^^ true numbery variable test  \#3
ok 261 - |3.141592653589793e0| infix ^^ true numbery variable test  \#4
ok 262 - |3.141592653589793e0| infix ^^ true numbery variable test  \#5
ok 263 - |3.141592653589793e0| infix ^^ true numbery variable test  \#6
ok 264 - |3.141592653589793e0| infix ^^ true numbery variable test  \#7
ok 265 - |3.141592653589793e0| infix ^^ true numbery variable test  \#8
ok 266 - |Bool::True| reduce [^^] true numbery variable test  \#1
ok 267 - |Bool::True| reduce [^^] true numbery variable test  \#2
ok 268 - |Bool::True| reduce [^^] true numbery variable test  \#3
ok 269 - |Bool::True| reduce [^^] true numbery variable test  \#4
ok 270 - |Bool::True| reduce [^^] true numbery variable test  \#5
ok 271 - |Bool::True| reduce [^^] true numbery variable test  \#6
ok 272 - |Bool::True| reduce [^^] true numbery variable test  \#7
ok 273 - |Bool::True| reduce [^^] true numbery variable test  \#8
ok 274 - |Bool::True| reduce [^^] true numbery variable test  \#9
ok 275 - |Bool::True| infix ^^ true numbery variable test  \#1
ok 276 - |Bool::True| infix ^^ true numbery variable test  \#2
ok 277 - |Bool::True| infix ^^ true numbery variable test  \#3
ok 278 - |Bool::True| infix ^^ true numbery variable test  \#4
ok 279 - |Bool::True| infix ^^ true numbery variable test  \#5
ok 280 - |Bool::True| infix ^^ true numbery variable test  \#6
ok 281 - |Bool::True| infix ^^ true numbery variable test  \#7
ok 282 - |Bool::True| infix ^^ true numbery variable test  \#8
ok 283 - |"no"| reduce [^^] true string variable test  \#1
ok 284 - |"no"| reduce [^^] true string variable test  \#2
ok 285 - |"no"| reduce [^^] true string variable test  \#3
ok 286 - |"no"| reduce [^^] true string variable test  \#4
ok 287 - |"no"| reduce [^^] true string variable test  \#5
ok 288 - |"no"| reduce [^^] true string variable test  \#6
ok 289 - |"no"| reduce [^^] true string variable test  \#7
ok 290 - |"no"| reduce [^^] true string variable test  \#8
ok 291 - |"no"| reduce [^^] true string variable test  \#9
ok 292 - |"no"| reduce [^^] true string variable test  \#10
ok 293 - |"no"| infix ^^ true string variable test  \#1
ok 294 - |"no"| infix ^^ true string variable test  \#2
ok 295 - |"no"| infix ^^ true string variable test  \#3
ok 296 - |"no"| infix ^^ true string variable test  \#4
ok 297 - |"no"| infix ^^ true string variable test  \#5
ok 298 - |"no"| infix ^^ true string variable test  \#6
ok 299 - |"no"| infix ^^ true string variable test  \#7
ok 300 - |"no"| infix ^^ true string variable test  \#8
ok 301 - |"no"| infix ^^ true string variable test  \#9
ok 302 - |"Bob"| reduce [^^] true string variable test  \#1
ok 303 - |"Bob"| reduce [^^] true string variable test  \#2
ok 304 - |"Bob"| reduce [^^] true string variable test  \#3
ok 305 - |"Bob"| reduce [^^] true string variable test  \#4
ok 306 - |"Bob"| reduce [^^] true string variable test  \#5
ok 307 - |"Bob"| reduce [^^] true string variable test  \#6
ok 308 - |"Bob"| reduce [^^] true string variable test  \#7
ok 309 - |"Bob"| reduce [^^] true string variable test  \#8
ok 310 - |"Bob"| reduce [^^] true string variable test  \#9
ok 311 - |"Bob"| reduce [^^] true string variable test  \#10
ok 312 - |"Bob"| infix ^^ true string variable test  \#1
ok 313 - |"Bob"| infix ^^ true string variable test  \#2
ok 314 - |"Bob"| infix ^^ true string variable test  \#3
ok 315 - |"Bob"| infix ^^ true string variable test  \#4
ok 316 - |"Bob"| infix ^^ true string variable test  \#5
ok 317 - |"Bob"| infix ^^ true string variable test  \#6
ok 318 - |"Bob"| infix ^^ true string variable test  \#7
ok 319 - |"Bob"| infix ^^ true string variable test  \#8
ok 320 - |"Bob"| infix ^^ true string variable test  \#9
ok 321 - |"10"| reduce [^^] true string variable test  \#1
ok 322 - |"10"| reduce [^^] true string variable test  \#2
ok 323 - |"10"| reduce [^^] true string variable test  \#3
ok 324 - |"10"| reduce [^^] true string variable test  \#4
ok 325 - |"10"| reduce [^^] true string variable test  \#5
ok 326 - |"10"| reduce [^^] true string variable test  \#6
ok 327 - |"10"| reduce [^^] true string variable test  \#7
ok 328 - |"10"| reduce [^^] true string variable test  \#8
ok 329 - |"10"| reduce [^^] true string variable test  \#9
ok 330 - |"10"| reduce [^^] true string variable test  \#10
ok 331 - |"10"| infix ^^ true string variable test  \#1
ok 332 - |"10"| infix ^^ true string variable test  \#2
ok 333 - |"10"| infix ^^ true string variable test  \#3
ok 334 - |"10"| infix ^^ true string variable test  \#4
ok 335 - |"10"| infix ^^ true string variable test  \#5
ok 336 - |"10"| infix ^^ true string variable test  \#6
ok 337 - |"10"| infix ^^ true string variable test  \#7
ok 338 - |"10"| infix ^^ true string variable test  \#8
ok 339 - |"10"| infix ^^ true string variable test  \#9
ok 340 - |"False"| reduce [^^] true string variable test  \#1
ok 341 - |"False"| reduce [^^] true string variable test  \#2
ok 342 - |"False"| reduce [^^] true string variable test  \#3
ok 343 - |"False"| reduce [^^] true string variable test  \#4
ok 344 - |"False"| reduce [^^] true string variable test  \#5
ok 345 - |"False"| reduce [^^] true string variable test  \#6
ok 346 - |"False"| reduce [^^] true string variable test  \#7
ok 347 - |"False"| reduce [^^] true string variable test  \#8
ok 348 - |"False"| reduce [^^] true string variable test  \#9
ok 349 - |"False"| reduce [^^] true string variable test  \#10
ok 350 - |"False"| infix ^^ true string variable test  \#1
ok 351 - |"False"| infix ^^ true string variable test  \#2
ok 352 - |"False"| infix ^^ true string variable test  \#3
ok 353 - |"False"| infix ^^ true string variable test  \#4
ok 354 - |"False"| infix ^^ true string variable test  \#5
ok 355 - |"False"| infix ^^ true string variable test  \#6
ok 356 - |"False"| infix ^^ true string variable test  \#7
ok 357 - |"False"| infix ^^ true string variable test  \#8
ok 358 - |"False"| infix ^^ true string variable test  \#9
ok 359 - [\^^]
ok 360 - [\xor]
ok 361 - [\orelse]
ok 362 - [\orelse]
ok 363 - [~] works in first class
ok 364 - [~] works in second class
ok 365 - [~] works outside class
ok 366 - a listop with immediate () is a function call (RT  \#82210)
ok 367 - [+] is a normal listop
ok 368 - argumentless [+] parses
ok 369 - RT  \#99942
ok 370 - reduce with X
    1..2
    ok 1 - '[leg] <a b c>' died
    ok 2 - right exception type (X::Syntax::CannotMeta)
ok 371 - non-associative operator "[leg]" can not be used as reduction operator
ok 372 - does  [:a] parse ok and give the right value
ok 373 - does [:a,] parse ok and give the right value
ok 374 - does [:!a] parse ok and give the right value
ok 375 - . infix is not attempted in reduce
ok 376 - Reduce ** can autogen
ok 377 - Reduce R** can autogen
ok 378 - Reduce ** can autogen without &
ok 379 - [=] works
ok 380 - [&&] produces correct result without thunk
ok 381 - and doesn't have a side effect
ok 382 - [&&] produces correct result with thunk
ok 383 - and does have a side effect
ok 384 - [&&] on long list produces correct result without thunk
ok 385 - and doesn't have a side effect
ok 386 - [&&] on long list produces correct result with thunk
ok 387 - and does have a side effect
ok 388 - [||] produces correct result without thunk
ok 389 - and doesn't have a side effect
ok 390 - [||] produces correct result with thunk
ok 391 - and does have a side effect
ok 392 - [||] on long list produces correct result without thunk
ok 393 - and doesn't have a side effect
ok 394 - [||] on long list produces correct result with thunk
ok 395 - and does have a side effect
ok 396 - [and] produces correct result without thunk
ok 397 - and doesn't have a side effect
ok 398 - [and] produces correct result with thunk
ok 399 - and does have a side effect
ok 400 - [and] on long list produces correct result without thunk
ok 401 - and doesn't have a side effect
ok 402 - [and] on long list produces correct result with thunk
ok 403 - and does have a side effect
ok 404 - [or] produces correct result without thunk
ok 405 - and doesn't have a side effect
ok 406 - [or] produces correct result with thunk
ok 407 - and does have a side effect
ok 408 - [or] on long list produces correct result without thunk
ok 409 - and doesn't have a side effect
ok 410 - [or] on long list produces correct result with thunk
ok 411 - and does have a side effect
ok 412 - [xor] produces correct result without thunk
ok 413 - and doesn't have a side effect
ok 414 - [xor] produces correct result with thunk
ok 415 - and does have a side effect
ok 416 - [xor] produces correct result with thunk
ok 417 - and does have a side effect
ok 418 - [xor] produces correct result with thunk
ok 419 - and does have a side effect
ok 420 - [^^] produces correct result without thunk
ok 421 - and doesn't have a side effect
ok 422 - [^^] produces correct result with thunk
ok 423 - and does have a side effect
ok 424 - [^^] produces correct result with thunk
ok 425 - and does have a side effect
ok 426 - [^^] produces correct result with thunk
ok 427 - and does have a side effect
ok 428 - [andthen] produces correct result without thunk
ok 429 - and doesn't have a side effect
ok 430 - [andthen] produces correct result with thunk
ok 431 - and does have a side effect
ok 432 - [andthen] on long list produces correct result without thunk
ok 433 - and doesn't have a side effect
ok 434 - [andthen] on long list produces correct result with thunk
ok 435 - and does have a side effect
ok 436 - [orelse] produces correct result without thunk
ok 437 - and doesn't have a side effect
ok 438 - [orelse] produces correct result with thunk
ok 439 - and does have a side effect
ok 440 - [orelse] on long list produces correct result without thunk
ok 441 - and doesn't have a side effect
ok 442 - [orelse] on long list produces correct result with thunk
ok 443 - and does have a side effect
ok 444 - [Z&&] produces correct distributed result without thunk
ok 445 - and doesn't have a side effect
ok 446 - [Z&&] produces correct distributed result with thunk
ok 447 - and does have a side effect
ok 448 - [Z||] produces correct distributed result without thunk
ok 449 - and doesn't have a side effect
ok 450 - [Z||] produces correct distributed result with thunk
ok 451 - and does have a side effect
ok 452 - [Zand] produces correct distributed result without thunk
ok 453 - and doesn't have a side effect
ok 454 - [Zand] produces correct distributed result with thunk
ok 455 - and does have a side effect
ok 456 - [Zor] produces correct distributed result without thunk
ok 457 - and doesn't have a side effect
ok 458 - [Zor] produces correct distributed result with thunk
ok 459 - and does have a side effect
ok 460 - [\&&] produces correct result without thunk
ok 461 - and doesn't have a side effect
ok 462 - [\&&] produces correct result with thunk
ok 463 - and does have a side effect
ok 464 - [\&&] on long list produces correct result without thunk
ok 465 - and doesn't have a side effect
ok 466 - [\&&] on long list produces correct result with thunk
ok 467 - and does have a side effect
ok 468 - [\||] produces correct result without thunk
ok 469 - and doesn't have a side effect
ok 470 - [\||] produces correct result with thunk
ok 471 - and does have a side effect
ok 472 - [\||] on long list produces correct result without thunk
ok 473 - and doesn't have a side effect
ok 474 - [\||] on long list produces correct result with thunk
ok 475 - and does have a side effect
ok 476 - [\and] produces correct result without thunk
ok 477 - and doesn't have a side effect
ok 478 - [\and] produces correct result with thunk
ok 479 - and does have a side effect
ok 480 - [\and] on long list produces correct result without thunk
ok 481 - and doesn't have a side effect
ok 482 - [\and] on long list produces correct result with thunk
ok 483 - and does have a side effect
ok 484 - [\or] produces correct result without thunk
ok 485 - and doesn't have a side effect
ok 486 - [\or] produces correct result with thunk
ok 487 - and does have a side effect
ok 488 - [\or] on long list produces correct result without thunk
ok 489 - and doesn't have a side effect
ok 490 - [\or] on long list produces correct result with thunk
ok 491 - and does have a side effect
ok 492 - [\xor] produces correct result without thunk
ok 493 - and doesn't have a side effect
ok 494 - [\xor] produces correct result with thunk
ok 495 - and does have a side effect
ok 496 - [\xor] produces correct result with thunk
ok 497 - and does have a side effect
ok 498 - [\xor] produces correct result with thunk
ok 499 - and does have a side effect
ok 500 - [\^^] produces correct result without thunk
ok 501 - and doesn't have a side effect
ok 502 - [\^^] produces correct result with thunk
ok 503 - and does have a side effect
ok 504 - [\^^] produces correct result with thunk
ok 505 - and does have a side effect
ok 506 - [\^^] produces correct result with thunk
ok 507 - and does have a side effect
ok 508 - [\andthen] produces correct result without thunk
ok 509 - and doesn't have a side effect
ok 510 - [\andthen] produces correct result with thunk
ok 511 - and does have a side effect
ok 512 - [\andthen] on long list produces correct result without thunk
ok 513 - and doesn't have a side effect
ok 514 - [\andthen] on long list produces correct result with thunk
ok 515 - and does have a side effect
ok 516 - [\orelse] produces correct result without thunk
ok 517 - and doesn't have a side effect
ok 518 - [\orelse] produces correct result with thunk
ok 519 - and does have a side effect
ok 520 - [\orelse] on long list produces correct result without thunk
ok 521 - and doesn't have a side effect
ok 522 - [\orelse] on long list produces correct result with thunk
ok 523 - and does have a side effect
ok 524 - slipped args work with reduce
ok 525 - slipped args work with reduce
ok 526 - parses [-7] right
ok 527 - parses [+7] right
ok 528 - parses [^7] right
ok 529 - parses [?7] right
ok 530 - parses [~7] right
ok 531 - parses [-x] right
ok 532 - parses [+x] right
ok 533 - parses [^x] right
ok 534 - parses [?x] right
ok 535 - parses [~x] right
ok 536 - parses [-$x] right
ok 537 - parses [+$x] right
ok 538 - parses [^$x] right
ok 539 - parses [?$x] right
ok 540 - parses [~$x] right
ok 541 - parses [[-@x]] right
ok 542 - parses [[+@x]] right
ok 543 - parses [[^@x]] right
ok 544 - parses [[?@x]] right
ok 545 - parses [[~@x]] right
ok 546 - parses [[-7]] right
ok 547 - parses [[+7]] right
ok 548 - parses [[^7]] right
ok 549 - parses [[?7]] right
ok 550 - parses [[~7]] right
ok 551 - parses [[-x]] right
ok 552 - parses [[+x]] right
ok 553 - parses [[^x]] right
ok 554 - parses [[?x]] right
ok 555 - parses [[~x]] right
ok 556 - parses [[-$x]] right
ok 557 - parses [[+$x]] right
ok 558 - parses [[^$x]] right
ok 559 - parses [[?$x]] right
ok 560 - parses [[~$x]] right
ok 561 - parses [[-@x]] right
ok 562 - parses [[+@x]] right
ok 563 - parses [[^@x]] right
ok 564 - parses [[?@x]] right
ok 565 - parses [[~@x]] right
    1..2
    ok 1 - '[+] 'hello'' died
    ok 2 - right exception type (X::Str::Numeric)
ok 566 - [+] with single non-numeric argument errors
    1..2
    ok 1 - '[-] 'hello'' died
    ok 2 - right exception type (X::Str::Numeric)
ok 567 - [-] with single non-numeric argument errors
    1..2
    ok 1 - '[*] 'hello'' died
    ok 2 - right exception type (X::Str::Numeric)
ok 568 - [*] with single non-numeric argument errors
    1..2
    ok 1 - '[/] 'hello'' died
    ok 2 - right exception type (X::Str::Numeric)
ok 569 - [/] with single non-numeric argument errors
ok 570 - one-argument [*] numifies
ok 571 - functional form of reduce works with the plus operator
ok 572 - Triangle reduce X~ 1 lists
ok 573 - Triangle reduce X~ 2 lists
ok 574 - Triangle reduce X~ 3 lists
ok 575 - Triangle reduce Z~ 1 lists
ok 576 - Triangle reduce Z~ 2 lists
ok 577 - Triangle reduce Z~ 3 lists
ok 578 - Triangle reduce minmax
ok 579 - Triangle reduce minmax
ok 580 - Triangle reduce minmax
ok 581 - Reduce meta-operator respects chain associativity
# FUDGED!
1..42
ok 1 - user-defined prefix operator, long name
ok 2 - user-defined prefix operator, long name, optional parameter
ok 3 - user-defined prefix operator, long name, :times adverb, leading
ok 4 - user-defined prefix operator, long name, :times adverb, trailing
ok 5 - user-defined prefix operator, basic call
ok 6 - user-defined prefix operator, :times adverb, space
ok 7 - user-defined prefix operator, :times adverb, no space
ok 8 - :foo($bar)
ok 9 - :foo[1,2,3,@many]
ok 10 - :foo«alice bob charles»
ok 11 - :foo«alice»
ok 12 - :foo{ a => 1, b => 2 }
ok 13 - :foo{ dostuff() }
ok 14 - :foo(0)
ok 15 - :foo
ok 16 - fiddle(:x("a"):y("b"))
ok 17 - fiddle(:y("b"):x("a"))
ok 18 - fiddle(:x:y("b"))
ok 19 - fiddle(:x("a"):y)
ok 20 - fiddle(:x("a")):y("b")
ok 21 - fiddle(:y("b")):x("a")
ok 22 - fiddle(:x("a")):y("b")
ok 23 - fiddle(:x("a")):y
ok 24 - fiddle(:x):y
ok 25 - fiddle():x("a"):y("b")
ok 26 - fiddle():y("b"):x("a")
ok 27 - fiddle():x:y("b")
ok 28 - fiddle():x("a"):y
ok 29 - fiddle():x:y
ok 30 - f(:x("a") "b")
ok 31 - f(:x("a")"b")
ok 32 - f("b" :x("a"))
ok 33 - f("b":x("a"))
ok 34 - f(:x "b")
ok 35 - f("b" :x)
ok 36 - f("b"):x("a")
not ok 37 - f1(\:bar :x("b")) # TODO Multi colonpair syntax not yet understood
# Failed test 'f1(\:bar :x("b"))'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/adverbial-modifiers.rakudo line 171
# expected: '("bar" => Bool::True)b'
#      got: '\(:bar, :x("b"))'
ok 38 - f2((:bar))
ok 39 - f3((:bar),(:hee(3)))
ok 40 - (zpre 4 :x(5))
ok 41 - (4 zpost :x(5))
ok 42 - (3 zin 4 :x(5))
# FUDGED!
1..8
ok 1 - basic infix:<S&>
ok 2 - basic infix:<S&> (multiple S&'s)
not ok 3 - S& has and-semantics (first term 0) # TODO S metaop NYI
# Failed test 'S& has and-semantics (first term 0)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/also.rakudo line 10
not ok 4 - also has and-semantics (second term 0) # TODO S metaop NYI
# Failed test 'also has and-semantics (second term 0)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/also.rakudo line 13
ok 5 - S& with two blocks
not ok 6 - blocks called in the right order # TODO S metaop NYI
# Failed test 'blocks called in the right order'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/also.rakudo line 20
# expected: 'bc'
#      got: ''
not ok 7 - and semantics # TODO S metaop NYI
# Failed test 'and semantics'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/also.rakudo line 26
ok 8 - short-circuit
# FUDGED!
1..301
ok 1 - assigned correct value to first of two scalars
ok 2 - ... and second
ok 3 - swap assignment works for the first value
ok 4 - ... and second
ok 5 - assignment operator called as function
ok 6 - assignment as function with types (1)
ok 7 - assignment as function with types (2)
ok 8 - assignment operator called as function
ok 9 - slice assignment swapping two element in the same array
ok 10 - slice assignment swapping two element in the same array
ok 11 - slice assignment swapping with array dwim
ok 12 - slice assignment swapping with array dwim
ok 13 - slice assignment swapping with array dwim makes listop
ok 14 - list assignment my ($, $, $) = @ works
ok 15 - list assignment my ($, $, $) = @ works
ok 16 - list assignment my ($, $, $) = @ works
ok 17 - list assignment my ($a, $, $b) = @ works
ok 18 - list assignment my ($, $a) = @ works
ok 19 - list assignment my ($, $, $, $a) = @ works
ok 20 - list assignment my ($, @) = @ works
ok 21 - list assignment my ($, @, $c) = @ works
ok 22 - list assignment ($a, *, $b) = @ works
ok 23 - list assignment (*, $a, *) = @ works
ok 24 - list assignment (*, *, *, $a) = @ works
ok 25 - list assignment (*, @) = @ works
ok 26 - list assignment (*, @, $c) = @ works
ok 27 - list assignment ($a, $, $b) = @ works
ok 28 - signature binding my ($one, *@) = 1..4 works
ok 29 - signature binding my ($a, $b, *@) = 1..4 works
ok 30 - signature binding my ($c, $d, *@) = 1..2 works
ok 31 - '$a' is '1'?: ($,$,$) = 1 .. 3
ok 32 - '$b' is '2'?: ($,$,$) = 1 .. 3
ok 33 - '$c' is '3'?: ($,$,$) = 1 .. 3
ok 34 - '@a' is '1 2 3'?:        @a = 1 .. 3
ok 35 - $s is '1'?:    my ($s,@a) = 1 .. 3
ok 36 - '@b' is '2 3'?: my ($s,@a) = 1 .. 3
ok 37 - got scalar in (scalar,hash) = list
ok 38 - got hash in (scalar,hash) = list
ok 39 - assigned correct value from list to sliced array
ok 40 - ... and second
ok 41 - ... and third
ok 42 - won't modify unassigned one
ok 43 - assigned correct value from list to unsorted sliced array
ok 44 - ... and second
ok 45 - ... and third
ok 46 - assigned correct value from list to slice-in-list
ok 47 - ... and second
ok 48 - ... and third
ok 49 - ... and fourth
ok 50 - ... and fifth
ok 51 - won't modify unassigned one
ok 52 - chained @ = % = list assignment
ok 53 - chained @ = % = list assignment
ok 54 - chained $ = % = list assignment
ok 55 - chained $ = % = list assignment
ok 56 - (@b, @a) = (@a, @b) assignment \@a[0] == undefined
ok 57 - (@b, @a) = (@a, @b) assignment \@b[0]
ok 58 - (@b, @a) = (@a, @b) assignment \@b[1]
ok 59 - (@b, @a) = @a, @b assignment \@a[0] == undefined
ok 60 - (@b, @a) = @a, @b assignment \@b[0]
ok 61 - (@b, @a) = @a, @b assignment \@b[1]
ok 62 - ||= operator
ok 63 - ||= operator parses as item assignment 1
ok 64 - ||= operator parses as item assignment 2
ok 65 - ... and second
ok 66 - ||= operator parses as item assignment 3
ok 67 - ||= operator parses as item assignment 4
ok 68 - or= operator
ok 69 - or= operator parses as list assignment 1
ok 70 - or= operator parses as list assignment 2
ok 71 - ... and second
ok 72 - or= operator parses as list assignment 3
ok 73 - or= operator parses as list assignment 4
ok 74 - or= thunks RHS
ok 75 - //= operator
ok 76 - //= operator parses as item assignment 1
ok 77 - //= operator parses as item assignment 2
ok 78 - ... and second
ok 79 - //= operator parses as item assignment 3
ok 80 - //= operator parses as item assignment 4
ok 81 - Verify //= autovivifies correctly
ok 82 - Verify //= autovivifies correctly
ok 83 - //= also works in declaration
ok 84 - orelse= operator
ok 85 - orelse= operator parses as list assignment 1
ok 86 - orelse= operator parses as list assignment 2
ok 87 - ... and second
ok 88 - orelse= operator parses as list assignment 3
ok 89 - orelse= operator parses as list assignment 4
ok 90 - Verify orelse= autovivifies correctly
ok 91 - Verify orelse= autovivifies correctly
ok 92 - orelse= also works in declaration
ok 93 - &&= operator
ok 94 - &&= operator parses as item assignment 1
ok 95 - &&= operator parses as item assignment 2
ok 96 - ... and second
ok 97 - &&= operator parses as item assignment 3
ok 98 - &&= operator parses as item assignment 4
ok 99 - &&= operator with True and False
ok 100 - and= operator
ok 101 - and= operator parses as list assignment 1
ok 102 - and= operator parses as list assignment 2
ok 103 - ... and second
ok 104 - and= operator parses as list assignment 3
ok 105 - and= operator parses as list assignment 4
ok 106 - and= operator with True and False
ok 107 - and= thunks RHS
ok 108 - (($c = 3) = 4) return val should be good as an lval
ok 109 - += operator
ok 110 - += operator parses as item assignment 1
ok 111 - += operator parses as item assignment 2
ok 112 - -= operator
ok 113 - -= operator parses as item assignment 1
ok 114 - -= operator parses as item assignment 2
ok 115 - *= operator
ok 116 - *= operator parses as item assignment 1
ok 117 - *= operator parses as item assignment 2
ok 118 - div= operator
ok 119 - div= operator parses as item assignment 1
ok 120 - div= operator parses as item assignment 2
ok 121 - **= operator
ok 122 - **= operator parses as item assignment 1
ok 123 - **= operator parses as item assignment 2
ok 124 - ~= operator
ok 125 - ~= operator parses as item assignment 1
ok 126 - ~= operator parses as item assignment 2
    1..2
    ok 1 - 'my $foo = 'foo'; $foo R~= 'foo';' died
    ok 2 - right exception type (X::Assignment::RO)
ok 127 - use of R~= operator on a non-container dies
ok 128 - R~= operator works
ok 129 - use of += on a Failure will trigger the failure to be thrown
ok 130 - x= operator
ok 131 - x= operator parses as item assignment 1
ok 132 - x= operator parses as item assignment 2
ok 133 - +&= operator
ok 134 - +&= operator parses as item assignment 1
ok 135 - +&= operator parses as item assignment 2
ok 136 - +|= operator
ok 137 - +|= operator parses as item assignment 1
ok 138 - +|= operator parses as item assignment 2
ok 139 - ~&= operator
ok 140 - ~&= operator parses as item assignment 1
ok 141 - ~&= operator parses as item assignment 2
ok 142 - ~|= operator
ok 143 - ~|= operator parses as item assignment 1
ok 144 - ~|= operator parses as item assignment 2
ok 145 - %= operator
ok 146 - %= operator parses as item assignment 1
ok 147 - %= operator parses as item assignment 2
ok 148 - +^= operator
ok 149 - +^= operator parses as item assignment 1
ok 150 - +^= operator parses as item assignment 2
ok 151 - ~^= operator
ok 152 - ~^= operator parses as item assignment 1
ok 153 - ~^= operator parses as item assignment 2
ok 154 - ^^= operator
ok 155 - ^^= operator parses as item assignment 1
ok 156 - ^^= operator parses as item assignment 2
ok 157 - ^^= with two true arguments yields Nil -> Any
ok 158 - ^^= doesn't permanently falsify scalars
ok 159 - xor= operator
ok 160 - xor= operator parses as list assignment 1
ok 161 - xor= operator parses as list assignment 2
ok 162 - xor= with two true arguments yields Nil -> Any
ok 163 - xor= doesn't permanently falsify scalars
ok 164 - ?|= operator
ok 165 - ?|= operator parses as item assignment 1
ok 166 - ?|= operator parses as item assignment 2
ok 167 - ?&= operator
ok 168 - ?&= operator parses as item assignment 1
ok 169 - ?&= operator parses as item assignment 2
ok 170 - ?^= operator
ok 171 - ?^= operator parses as item assignment 1
ok 172 - ?^= operator parses as item assignment 2
ok 173 - +<= operator
ok 174 - +<= operator parses as item assignment 1
ok 175 - +<= operator parses as item assignment 2
ok 176 - +>= operator
ok 177 - +>= operator parses as item assignment 1
ok 178 - +>= operator parses as item assignment 2
ok 179 - # SKIP ~< and ~> NYI
ok 180 - # SKIP ~< and ~> NYI
ok 181 - # SKIP ~< and ~> NYI
ok 182 - # SKIP ~< and ~> NYI
ok 183 - # SKIP ~< and ~> NYI
ok 184 - # SKIP ~< and ~> NYI
ok 185 - [+]= operator (just like +=)
ok 186 - [+]= operator parses as item assignment 1
ok 187 - [+]= operator parses as item assignment 2
ok 188 - [[+]]= operator (just like +=)
ok 189 - [[+]]= operator parses as item assignment 1
ok 190 - [[+]]= operator parses as item assignment 2
ok 191 - item assignment infix:<=> is tighter than the comma
ok 192 - item assignment infix:<=> is tighter than the comma (2)
ok 193 - item assignment infix:<=> is tighter than the comma (3)
ok 194 - lhs treats $::('Foo::b') as scalar (1)
ok 195 - lhs treats $::('Foo::b') as scalar (2)
ok 196 - lhs treats $Foo::c as scalar (1)
ok 197 - lhs treats $Foo::c as scalar (2)
ok 198 - lhs treats $(@a[0]) as scalar (1)
ok 199 - lhs treats $(@a[0]) as scalar (2)
ok 200 - lhs treats ($a) as list
not ok 201 - lhs treats ($a) as list # TODO item/list assignment
# Failed test 'lhs treats ($a) as list'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/assign.rakudo line 592
# expected: '3'
#      got: '1'
ok 202 - lhs treats ($a, *) as list (1)
not ok 203 - lhs treats ($a, *) as list (2) # TODO list assignment with ($var, *)
# Failed test 'lhs treats ($a, *) as list (2)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/assign.rakudo line 600
# expected: '6'
#      got: '2'
ok 204 - # SKIP cannot modify an immutable value
ok 205 - # SKIP cannot modify an immutable value
ok 206 - # SKIP cannot modify an immutable value
ok 207 - lhs treats ($a,$b) as list
ok 208 - lhs treats ($a,$b) as list
ok 209 - lhs treats ($a,$b) as list, and passes only two items on
not ok 210 - lhs treats @a[0] as one-item list # TODO list assignment to scalar
# Failed test 'lhs treats @a[0] as one-item list'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/assign.rakudo line 631
# expected: '1'
#      got: '2'
ok 211 - lhs treats @a[0] as one-item list
ok 212 - lhs treats @a[0] as one-item list
ok 213 - lhs treats @a[0,] as one-item list
ok 214 - lhs treats @a[0,] as one-item list
ok 215 - lhs treats @a[0,] as one-item list
not ok 216 - lhs treats %a<x> as one-item list # TODO list assignment to scalar
# Failed test 'lhs treats %a<x> as one-item list'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/assign.rakudo line 648
# expected: '1'
#      got: '2'
not ok 217 - lhs treats %a<x> as one-item list # TODO list assignment to scalar
# Failed test 'lhs treats %a<x> as one-item list'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/assign.rakudo line 649
# expected: '1'
#      got: '2'
ok 218 - lhs treats %a<x> as one-item list
ok 219 - lhs treats %a<x y z> as list
ok 220 - lhs treats %a<x y z> as list
ok 221 - lhs treats %a<x y z> as list
not ok 222 - lhs treats %a{'x'} as list # TODO list assignment to scalar
# Failed test 'lhs treats %a{'x'} as list'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/assign.rakudo line 665
# expected: '1'
#      got: '1 2 1 2'
not ok 223 - lhs treats %a{'x'} as list # TODO list assignment to scalar
# Failed test 'lhs treats %a{'x'} as list'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/assign.rakudo line 666
# expected: '1'
#      got: '1 2 1 2'
ok 224 - lhs treats %a{'x'} as list
ok 225 - lhs treats %a{'x','y','z'} as list
ok 226 - lhs treats %a{'x','y','z'} as list
ok 227 - lhs treats %a{'x','y','z'} as list
ok 228 - lhs treats %a{'x','y','z'} as list
ok 229 - lhs treats %a{'x','y','z'} as list
ok 230 - lhs treats %a{'x','y','z'} as list
ok 231 - lhs treats %a{'x'..'z'} as list
ok 232 - lhs treats %a{'x'..'z'} as list
ok 233 - lhs treats %a{'x'..'z'} as list
ok 234 - lhs treats %a{'x'..'z'} as list
ok 235 - lhs treats %a{'x'..'z'} as list
ok 236 - lhs treats %a{'x'..'z'} as list
not ok 237 - lhs treats @a[@b[$c]] as list # TODO list assignment, autovivification (?)
# Failed test 'lhs treats @a[@b[$c]] as list'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/assign.rakudo line 699
# expected: '1'
#      got: '1 2 1 2'
not ok 238 - lhs treats @a[@b[$c]] as list # TODO list assignment, autovivification (?)
# Failed test 'lhs treats @a[@b[$c]] as list'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/assign.rakudo line 700
# expected: '1'
#      got: '1 2 1 2'
not ok 239 -  # TODO list assignment, autovivification (?)
# Failed test at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/assign.rakudo line 701
# expected: 'lhs treats @a[@b[$c]] as list'
#      got: 'True'
ok 240 - lhs treats @a[@b[$c,]] as list
not ok 241 - lhs treats @a[@b[$c,]] as list # TODO list assignment
# Failed test 'lhs treats @a[@b[$c,]] as list'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/assign.rakudo line 711
# expected: '2'
#      got: '1'
ok 242 - lhs treats @a[@b[$c,]] as list
ok 243 - lhs treats foo()[$b] as list
not ok 244 - lhs treats foo()[$b] as list # TODO list assignment
# Failed test 'lhs treats foo()[$b] as list'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/assign.rakudo line 722
# expected: '1'
#      got: '2'
ok 245 - lhs treats foo()[$b] as list
ok 246 - lhs treats foo()[$b,] as list
ok 247 - lhs treats foo()[$b,] as list
ok 248 - lhs treats foo()[$b,] as list
ok 249 - lhs treats $(@a[$b]) as item (1)
not ok 250 - lhs treats $(@a[$b]) as item (2) # TODO item assignment
# Failed test 'lhs treats $(@a[$b]) as item (2)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/assign.rakudo line 742
# expected: '1'
#      got: '2'
not ok 251 - lhs treats $(@a[$b]) as item (3) # TODO item assignment
# Failed test 'lhs treats $(@a[$b]) as item (3)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/assign.rakudo line 743
# expected: '3'
#      got: '2'
ok 252 - # SKIP ,= needs to be special cased after GLR to compile to push(@a, 3, 4)
ok 253 - # SKIP ,= needs to be special cased after GLR to compile to push(@a, 3, 4)
ok 254 - ,= works for hashes (return value)
ok 255 - ,= works for hashes (hash modified)
ok 256 - .= on scalars works
ok 257 - .= on array indexed values
ok 258 - .= on hash keyed values
ok 259 - min= worked (positive)
ok 260 - min= worked (negative)
ok 261 - max= worked (positive)
ok 262 - max= worked (negative)
ok 263 - my $t; $t = (cond) ?? !! gets value from ?? !!, not conds bool
ok 264 - .. also for false
ok 265 - truth with "our"
ok 266 - ... and false
ok 267 - my $t = (cond) ?? !! gets value from ?? !!
ok 268 - .. also for false
ok 269 - Can grep lazily through a very long range
ok 270 - ... with correct result
ok 271 - assignment to scalar via array item from array item
ok 272 - assignment to array item from array item to scalar
ok 273 - chained assignment works
ok 274 - chained assignment works
ok 275 - $rt125407 and @rt125407[0] should be equal
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Assignment::RO)
ok 276 - correct precedence between sub call and assignment (1)
ok 277 - correct precedence between sub call and assignment (2)
ok 278 - Assign to hash with the same hash on rhs
ok 279 - Assign to array with the same array on rhs
ok 280 - same with List
ok 281 - Assign to array with the same array on rhs
ok 282 - 
ok 283 - 
ok 284 - Assignment into parentheses'd my works.
ok 285 - Routine call taking a parenthesised my as argument works.  \#1
ok 286 - Routine call taking a parenthesised my as argument works.  \#2
ok 287 - Routine call taking a parenthesised my as argument works.  \#3
ok 288 - infix:<,=> has list precedence in the cases where infix:<=> does
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Syntax::CannotMeta)
ok 289 - Can't use diffy >= with the = metaop 
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Syntax::CannotMeta)
ok 290 - Can't use fiddly ~~ with the = metaop 
ok 291 - default-assignment (//=) does mix with implicit-variable method call
ok 292 - declarator gets its own precedence analysis (1)
ok 293 - declarator gets its own precedence analysis (2)
ok 294 - Chained assignment respects right associativity when evaluating left sigil for $
ok 295 - Internal chained item assignment does not mess up outer list assignment
ok 296 - @a[^2] on empty array vivifies the slots and assignment works
ok 297 - andthen= thunks RHS
ok 298 - notandthen= thunks RHS
ok 299 - orelse= thunks RHS
ok 300 - -= with :U target gives right result
    1..2
    ok 1 - 'my $b; $b %= 2' died
    ok 2 - right exception type (Exception)
ok 301 - %= with :U target throws
# FUDGED!
1..59
ok 1 - eqv on values (1)
ok 2 - eqv on values (2)
ok 3 - eqv on values (3)
ok 4 - eqv on value types (1-1)
ok 5 - eqv on value types (1-2)
ok 6 - eqv on value types (1-3)
ok 7 - eqv on value types (2-1)
ok 8 - eqv on value types (2-2)
ok 9 - eqv on value types (2-3)
ok 10 - eqv on array references (1)
ok 11 - eqv on array references (2)
not ok 12 - eqv on array references (3) # TODO huh?
# Failed test 'eqv on array references (3)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/eqv.rakudo line 42
ok 13 - \@array of two bound arrays are eqv
ok 14 - eqv on scalar references (1-1)
ok 15 - eqv on scalar references (1-2)
ok 16 - eqv on scalar references (1-3)
not ok 17 - eqv on scalar references (1-4) # TODO huh?
# Failed test 'eqv on scalar references (1-4)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/eqv.rakudo line 55
ok 18 - eqv on sub references (1-1)
ok 19 - eqv on sub references (1-2)
ok 20 - eqv on sub references (1-3)
ok 21 - eqv on sub references (1-4)
ok 22 - eqv on sub references (2-1)
ok 23 - eqv on sub references (2-2)
ok 24 - eqv on sub references (2-3)
ok 25 - eqv on scalar references (2-1)
ok 26 - eqv on scalar references (2-2)
ok 27 - eqv on scalar references (2-3)
ok 28 - eqv on anonymous array references (1)
ok 29 - eqv on anonymous array references (2)
ok 30 - eqv on anonymous array references (3)
ok 31 - eqv on anonymous hash references (-)
ok 32 - eqv on anonymous hash references (+)
ok 33 - order really does not matter
ok 34 - hashes: different number of pairs
ok 35 - eqv on anonymous scalar references (1)
not ok 36 - eqv on anonymous scalar references (2) # TODO huh?
# Failed test 'eqv on anonymous scalar references (2)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/eqv.rakudo line 103
ok 37 - # SKIP huh?
ok 38 - chained eqv (1)
ok 39 - chained eqv (2)
ok 40 - subparam binding doesn't affect eqv (1)
ok 41 - subparam binding doesn't affect eqv (2)
ok 42 - subparam binding doesn't affect eqv (3)
ok 43 - subparam binding doesn't affect eqv (4)
ok 44 - eqv returns Bool::True when true
ok 45 - eqv returns Bool::False when false
ok 46 - Any eqv Any
ok 47 - eqv autothreads correctly
ok 48 - list starting with () - 1
ok 49 - list starting with () - 1
ok 50 - list starting with () - 1
ok 51 - list starting with () - 1
ok 52 - ((), ())
ok 53 - Values should be eqv only if they are the same type
ok 54 - Str vs. Int
    1..8
    ok 1 - identical Sets eqv each other
    ok 2 - identical SetHashes eqv each other
    ok 3 - Set does not eqv SetHash
    ok 4 - IntStr does not eqv Int
    ok 5 - IntStr does not eqv Str
    ok 6 - Int    does not eqv IntStr
    ok 7 - Str    does not eqv IntStr
    ok 8 - IntStr does     eqv IntStr
ok 55 - Setty eqv Setty
    1..6
    ok 1 - Seq() not eqv List()
    ok 2 - Seq(1 2) not eqv List(1 2)
    ok 3 - Seq() not eqv List(1 2)
    ok 4 - Seq(1 2) not eqv List()
    ok 5 - Seq(...) not eqv List(...)
    ok 6 - List(...) not eqv Seq(...)
ok 56 - Seq eqv List
    1..7
    ok 1 - eqv between identical Seqs does not die
    ok 2 - eqv between identical Seqs returns True
    ok 3 - eqv between identical lazy Seqs does not die
    ok 4 - eqv between identical lazy Seqs returns True
    ok 5 - eqv between shorter and longer Seq
    ok 6 - eqv between longer and shorter Seq
    ok 7 - eqv between Seqs with different end values
ok 57 - Seq eqv Seq
ok 58 - HyperSeq eqv HyperSeq
    1..8
        1..3
        ok 1 - code dies
        ok 2 - right exception type (X::Cannot::Lazy)
        ok 3 - .action matches eqv
    ok 1 - both lazy, same types (Seqs)
        1..3
        ok 1 - code dies
        ok 2 - right exception type (X::Cannot::Lazy)
        ok 3 - .action matches eqv
    ok 2 - both lazy, same types (Lists)
        1..3
        ok 1 - code dies
        ok 2 - right exception type (X::Cannot::Lazy)
        ok 3 - .action matches eqv
    ok 3 - both lazy, same types (Arrays)
    ok 4 - both lazy, different types
    ok 5 - different types, only one lazy
    ok 6 - Seqs, only one lazy
    ok 7 - Lists, only one lazy
    ok 8 - Arrays, only one lazy
ok 59 - Throws/lives in lazy cases
# FUDGED!
1..40
ok 1 - flip-flop operator implemented
ok 2 - fff operator implemented
ok 3 - /B/ ff /D/, lhs != rhs
ok 4 - /B/ ^ff /D/, lhs != rhs
ok 5 - /B/ ff^ /D/, lhs != rhs
ok 6 - /B/ ^ff^ /D/, lhs != rhs
ok 7 - /B/ fff /D/, lhs != rhs
ok 8 - /B/ ^fff /D/, lhs != rhs
ok 9 - /B/ fff^ /D/, lhs != rhs
ok 10 - /B/ ^fff^ /D/, lhs != rhs
ok 11 - /B/ ff /B/, lhs == rhs
ok 12 - /B/ ^ff /B/, lhs == rhs
ok 13 - /B/ ff^ /B/, lhs == rhs
ok 14 - /B/ ^ff^ /B/, lhs == rhs
ok 15 - /B/ fff /B/, lhs == rhs
ok 16 - /B/ ^fff /B/, lhs == rhs
ok 17 - /B/ fff^ /B/, lhs == rhs
ok 18 - /B/ ^fff^ /B/, lhs == rhs
ok 19 - /B/ ff *
ok 20 - /B/ ff /D/, seq  \#s, lhs != rhs
ok 21 - /B/ ^ff /D/, seq  \#s, lhs != rhs
ok 22 - /B/ ff^ /D/, seq  \#s, lhs != rhs
ok 23 - /B/ ^ff^ /D/, seq  \#s, lhs != rhs
ok 24 - /B/ fff /D/, seq  \#s, lhs != rhs
ok 25 - /B/ ^fff /D/, seq  \#s, lhs != rhs
ok 26 - /B/ fff^ /D/, seq  \#s, lhs != rhs
ok 27 - /B/ ^fff^ /D/, seq  \#s, lhs != rhs
ok 28 - /B/ ff /B/, seq  \#s, lhs == rhs
ok 29 - /B/ ^ff /B/, seq  \#s, lhs == rhs
ok 30 - /B/ ff^ /B/, seq  \#s, lhs == rhs
ok 31 - /B/ ^ff^ /B/, seq  \#s, lhs == rhs
ok 32 - /B/ fff /B/, seq  \#s, lhs == rhs
ok 33 - /B/ ^fff /B/, seq  \#s, lhs == rhs
ok 34 - /B/ fff^ /B/, seq  \#s, lhs == rhs
ok 35 - /B/ ^fff^ /B/, seq  \#s, lhs == rhs
ok 36 - calls from different locations use the same ff
ok 37 - different clones of the sub get different ff
ok 38 - # SKIP dubious scoping?
ok 39 - # SKIP dubious scoping?
ok 40 - # SKIP NYM flip-flop with "True but $seqnum"
# FUDGED!
1..46
ok 1 - $foo =:= $foo is true
ok 2 - $bar =:= $bar is true
ok 3 - $foo =:= $bar is false
ok 4 - success returns a Bool
ok 5 - failure returns a Bool
ok 6 - $subref =:= $subref is true
ok 7 - &sub =:= &sub is true
ok 8 - $subref1 =:= $subref2 is false
ok 9 - basic sanity
ok 10 - =:= is true after rebinding (1-1)
ok 11 - =:= is true after rebinding (1-2)
ok 12 - =:= is true after rebinding (1-3)
ok 13 - =:= is true after rebinding (2-1)
ok 14 - =:= is true after rebinding (2-2)
ok 15 - =:= is true after rebinding (2-3)
ok 16 - =:= is true after rebinding (3-1)
ok 17 - =:= is true after rebinding (3-2)
ok 18 - =:= is true after rebinding (3-3)
ok 19 - =:= is true after rebinding (3-4)
ok 20 - =:= is true after rebinding (3-5)
ok 21 - =:= is true after rebinding (3-6)
ok 22 - rebinding of array elements (1)
ok 23 - rebinding of array elements (2)
ok 24 - assignment destroyed the bindings (1)
ok 25 - assignment destroyed the bindings (2)
ok 26 - assignment destroyed the bindings (3)
ok 27 - binding of scalar subparam retains =:= (1)
ok 28 - binding of scalar subparam retains =:= (2)
ok 29 - binding of scalar subparam retains =:= (3)
ok 30 - binding of scalar subparam marked is rw retains =:= (1)
ok 31 - binding of scalar subparam marked is rw retains =:= (2)
ok 32 - binding of scalar subparam marked is rw retains =:= (3)
not ok 33 - binding of slurpy array subparam retains =:= (1) # TODO unspecced
# Failed test 'binding of slurpy array subparam retains =:= (1)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/identity.rakudo line 95
ok 34 - binding of slurpy array subparam retains =:= (2)
not ok 35 - binding of slurpy array subparam retains =:= (3) # TODO unspecced
# Failed test 'binding of slurpy array subparam retains =:= (3)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/identity.rakudo line 99
not ok 36 - binding of implicit @_ subparam retains =:= (1) # TODO unspecced
# Failed test 'binding of implicit @_ subparam retains =:= (1)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/identity.rakudo line 108
ok 37 - binding of implicit @_ subparam retains =:= (2)
not ok 38 - binding of implicit @_ subparam retains =:= (3) # TODO unspecced
# Failed test 'binding of implicit @_ subparam retains =:= (3)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/identity.rakudo line 112
ok 39 - two identical objects are not the same object
ok 40 - two references to one object are still not the same object
ok 41 - binding makes two objects the same object
not ok 42 - misuse of =:= is failure (Mu) # TODO misuse of =:=
# Failed test 'misuse of =:= is failure (Mu)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/identity.rakudo line 131
not ok 43 - misuse of =:= is failure (literals) # TODO misuse of =:=
# Failed test 'misuse of =:= is failure (literals)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/identity.rakudo line 132
not ok 44 - misuse of =:= is failure (!=) # TODO misuse of =:=
# Failed test 'misuse of =:= is failure (!=)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/identity.rakudo line 133
not ok 45 - misuse of =:= is failure (even when ==) # TODO misuse of =:=
# Failed test 'misuse of =:= is failure (even when ==)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/identity.rakudo line 134
ok 46 - $a =:= $a || $a.WHAT =:= $a.WHAT returns True not an Int
# FUDGED!
1..38
ok 1 - .= runs with block
ok 2 - inplace map [0]
ok 3 - inplace map [1]
ok 4 - inplace map [2]
ok 5 - .= works without surrounding whitespace
ok 6 - inplace grep [0]
ok 7 - inplace grep [1]
ok 8 - inplace grep [2]
ok 9 - inplace int
ok 10 - # SKIP Method '' not found for invocant of class 'Str'
ok 11 - # SKIP Method '' not found for invocant of class 'Str'
ok 12 - # SKIP Method '' not found for invocant of class 'Str'
ok 13 - # SKIP Method '' not found for invocant of class 'Str'
ok 14 - inplace uc
ok 15 - inplace lc
ok 16 - inplace tc
ok 17 - inplace sort
ok 18 - .=foo form works on $_
ok 19 - worked: @a.sort: {1}
ok 20 - worked: @a.=sort: {1}
ok 21 - worked: @a.=sort
ok 22 - .= Int (type)
ok 23 - .= Int (value)
ok 24 - .= Str (type)
ok 25 - .= Str (value)
ok 26 - .= Bool (type)
ok 27 - .= Bool (value)
ok 28 - quoted method call with .= works with parens
ok 29 - quoted method call (variable) with .= works with parens
ok 30 - quoted method call with .= works with parens and whitespace
ok 31 - quoted method call (variable) with .= works with parens and whitespace
    1..4
    ok 1 - called STORE during .= on class instantiation
    ok 2 - .= on a class instantiation
        1..11
        ok 1 - .= with implied $_
        ok 2 - embedded in args of routine
        ok 3 - embedded in args of routine (spaced)
        ok 4 - embedded in args of routine (parenthesized)
        ok 5 - embedded in args of routine (parens + spaces)
        ok 6 - return value (no space)
        ok 7 - return value (spaced)
        ok 8 - standard; no space
        ok 9 - standard; spaced
        ok 10 - statement; no space
        ok 11 - statement; spaced
    ok 3 - Scalar
        1..11
        ok 1 - .= with implied $_
        ok 2 - embedded in args of routine
        ok 3 - embedded in args of routine (spaced)
        ok 4 - embedded in args of routine (parenthesized)
        ok 5 - embedded in args of routine (parens + spaces)
        ok 6 - return value (no space)
        ok 7 - return value (spaced)
        ok 8 - standard; no space
        ok 9 - standard; spaced
        ok 10 - statement; no space
        ok 11 - statement; spaced
    ok 4 - Array
ok 32 - coverage for performance optimizations
    1..4
    ok 1 - my ... .= new args
    ok 2 - ($ ... method chain).=new args
    ok 3 - my ... .= new no args
    ok 4 - ($ ... method chain).=new no args
ok 33 - .= works with fake-infix adverb named args
    1..16
    ok 1 - typeless var inits with Mu (.new, no args)
        1..2
        ok 1 - code dies
        ok 2 - right exception type (X::Assignment::RO)
    ok 2 - ...assigning to it throws
    ok 3 - typeless var inits with Mu (.new, args)
        1..2
        ok 1 - code dies
        ok 2 - right exception type (X::Assignment::RO)
    ok 4 - ...assigning to it throws
    ok 5 - typeless var inits with Mu (.new, fake-infix adverbs)
        1..2
        ok 1 - code dies
        ok 2 - right exception type (X::Assignment::RO)
    ok 6 - ...assigning to it throws
    ok 7 - typeless var inits with Mu (.Numeric)
        1..2
        ok 1 - code dies
        ok 2 - right exception type (X::Assignment::RO)
    ok 8 - ...assigning to it throws
    ok 9 - typed (.new, no args)
        1..2
        ok 1 - code dies
        ok 2 - right exception type (X::Assignment::RO)
    ok 10 - ...assigning to it throws
    ok 11 - typed (.new, pos args)
        1..2
        ok 1 - code dies
        ok 2 - right exception type (X::Assignment::RO)
    ok 12 - ...assigning to it throws
    ok 13 - typed (.new, named args)
        1..2
        ok 1 - code dies
        ok 2 - right exception type (X::Assignment::RO)
    ok 14 - ...assigning to it throws
    ok 15 - typed (.new, fake-infix adverbs)
        1..2
        ok 1 - code dies
        ok 2 - right exception type (X::Assignment::RO)
    ok 16 - ...assigning to it throws
ok 34 - .= works to init sigilles vars
ok 35 - Foo[Bar] type constraint with .= on attributes
    1..4
    ok 1 - no-arg, single notandthen
    ok 2 - fake-infix args + pos args, chained notandthen
    ok 3 - orelse, andthen chain
    ok 4 - chain of different ops
ok 36 - .= inside andthen and relatives
    1..2
        1..2
        ok 1 - right value in .=ed var
        ok 2 - called block in string only once
    ok 1 - nested calls with method name as string in one of them
        1..3
        ok 1 - right value in .=ed var
        ok 2 - called block in `do` only once
        ok 3 - called block in string only once
    ok 2 - nested calls with method name as string and do block
ok 37 - various weird cases of .= calls
    1..4
        1..2
        ok 1 - instantiated an object
        ok 2 - default type is Mu
    ok 1 - default type constraint
    ok 2 - basic type constraint
        1..4
        ok 1 - no args
        ok 2 - pos + named args
        ok 3 - 
        ok 4 - 
    ok 3 - class with `::` in name
    ok 4 - parametarized type
ok 38 - constants
# FUDGED!
1..16
ok 1 - 6 %% 3
ok 2 - 6 %% 3 isa Bool
ok 3 - 6 %% 4
ok 4 - 6 %% 4 isa Bool
ok 5 - %% works with explicit closure
ok 6 - %% works with whatever *
ok 7 - 6 !%% 3
ok 8 - 6 !%% 3 isa Bool
ok 9 - 6 !%% 4
ok 10 - 6 !%% 4 isa Bool
ok 11 - %% works with explicit closure
ok 12 - %% works with whatever *
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Syntax::CannotMeta)
ok 13 - infix<!%> is not iffy enough
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::Numeric::DivideByZero)
    ok 3 - .using matches infix:<%%>
    ok 4 - .numerator matches 9
ok 14 - cannot divide by zero using infix:<%%>
    1..4
    not ok 1 - code dies # TODO not sure why this doesn't fire
    # Failed test 'code dies'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/is-divisible-by.rakudo line 40
    ok 2 - # SKIP Code did not die, can not check exception
    ok 3 - # SKIP Code did not die, can not check exception
    ok 4 - # SKIP Code did not die, can not check exception
not ok 15 - cannot divide by zero using infix:<%%> # TODO not sure why this doesn't fire
# Failed test 'cannot divide by zero using infix:<%%>'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/is-divisible-by.rakudo line 40
    1..2
    ok 1 - %% op
    ok 2 - % op
ok 16 - no crashes with bigint args
# FUDGED!
1..39
ok 1 - can ye handle that?
ok 2 - how about this?
ok 3 - ooh! 3 numbers! More difficult
ok 4 - again! 3 numbers!
    1..2
    ok 1 - '1 min 2 max 3' died
    ok 2 - right exception type (X::Syntax::NonAssociative)
ok 5 - No! No left-associativeness!
    1..2
    ok 1 - '1 max 2 min 3' died
    ok 2 - right exception type (X::Syntax::NonAssociative)
ok 6 - This is also not OK
ok 7 - min works for strings, too
ok 8 - max works for strings, too
ok 9 - 
ok 10 - 
ok 11 - 
ok 12 - 
ok 13 - minmax does not flatten ranges
ok 14 - minmax works on two arrays
ok 15 - minmax works on two lists
ok 16 - minmax works when both are on left list
ok 17 - minmax works when both are on right list
ok 18 - minmax works when both are on left array
ok 19 - minmax works when both are on right array
ok 20 - minmax works for strings, too
ok 21 - minmax works on two disjoint ranges
ok 22 - minmax works on two overlapping ranges
ok 23 - minmax works when both are on left list
ok 24 - minmax works when both are on right list
ok 25 - # SKIP Annoying test that we haven't done the obvious yet unspecced, fails because we have indeed done the obvious
ok 26 - # SKIP Annoying test that we haven't done the obvious yet unspecced, fails because we have indeed done the obvious
ok 27 - 2 min Any
ok 28 - Any min 2
ok 29 - 2 max Any
ok 30 - Any max 2
    1..2
    ok 1 - 'no fatal; my $ = do { min +'a', +'a' }; Nil' died
    ok 2 - right exception type (X::Str::Numeric)
ok 31 - min with two Failures throws
    1..2
    ok 1 - 'no fatal; my $ = do { max +'a', +'a' }; Nil' died
    ok 2 - right exception type (X::Str::Numeric)
ok 32 - max with two Failures throws
    1..2
    ok 1 - code returned a Failure
        1..2
        ok 1 - code dies
        ok 2 - right exception type (X::Str::Numeric)
    ok 2 - Failure threw when sunk
ok 33 - min with one Failure throws
    1..2
    ok 1 - code returned a Failure
        1..2
        ok 1 - code dies
        ok 2 - right exception type (X::Str::Numeric)
    ok 2 - Failure threw when sunk
ok 34 - max with one Failure throws
    1..2
    ok 1 - 'Failure.new.min' died
    ok 2 - right exception type (Exception)
ok 35 - .min on Failure throws
    1..2
    ok 1 - 'Failure.new.max' died
    ok 2 - right exception type (Exception)
ok 36 - .max on Failure throws
    1..2
    ok 1 - 'Failure.new.min: &infix:<cmp>' died
    ok 2 - right exception type (Exception)
ok 37 - .min with :&by on Failure throws
    1..2
    ok 1 - 'Failure.new.max: &infix:<cmp>' died
    ok 2 - right exception type (Exception)
ok 38 - .max with :&by on Failure throws
    1..8
    ok 1 - .max()
    ok 2 - .min()
    ok 3 - .max(*.value)
    ok 4 - .min(*.value)
    ok 5 - &max()
    ok 6 - &min()
    ok 7 - &max(:by(*.value))
    ok 8 - &min(:by(*.value))
ok 39 - min/max operations on Hashes
# FUDGED!
1..78
ok 1 - ~
ok 2 - ?? !!
ok 3 - == (false)
ok 4 - == (true)
ok 5 - == (false)
ok 6 - != (true)
ok 7 - == (const on rhs)
ok 8 - != (const on rhs)
ok 9 - == (const on lhs)
ok 10 - != (const on lhs)
ok 11 - == (sum on rhs)
ok 12 - == (sum on rhs)
ok 13 - == (sum on lhs)
ok 14 - == (sum on lhs)
ok 15 - == (sum on lhs)
ok 16 - concatenation with ~ operator
ok 17 - || returns first true value
ok 18 - || returns last false value of list?
ok 19 - (my @s)[0] //= something works
ok 20 - (state @t)[0] //= something works
ok 21 - boolean or (?|) returns True or False
ok 22 - boolean or (?|) returns True or False
ok 23 - all elements in junction are incremented
ok 24 - any elements will match via junction
ok 25 - any test against scalar
ok 26 - any test array against any array
ok 27 - any test array against all array
ok 28 - all test array against any array
ok 29 - all test array against all array
ok 30 - test the all infix operator
ok 31 - hyper-add
ok 32 - joining of single items
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Syntax::Confused)
    ok 3 - .message matches -> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140243246096272) ... }
ok 33 - Guillemet form of subscript does not parse as infix hyperop
ok 34 - operator can start with a bang (!) and have Unicode character in it
    1..3
    ok 1 - '1%^^1' died
    ok 2 - right exception type (X::Syntax::DuplicatedPrefix)
    ok 3 - .prefixes matches ^^
ok 35 - %^^ fails to parse (RT  \#73198)
    1..3
    ok 1 - '555 ~~!~~ 666' died
    ok 2 - right exception type (X::Syntax::DuplicatedPrefix)
    ok 3 - .prefixes matches ~~
ok 36 - ~~!~~ fails to parse (RT  \#76436)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 37 - did we throws-like Exception?
    1..2
    not ok 1 - code dies # TODO 
    # Failed test 'code dies'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/misc.rakudo line 133
    ok 2 - # SKIP Code did not die, can not check exception
not ok 38 - did we throws-like Exception? # TODO 
# Failed test 'did we throws-like Exception?'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/misc.rakudo line 133
ok 39 - unary MINUS SIGN
ok 40 - infix MINUS SIGN
ok 41 - infix MINUS SIGN is not considered a hyphen
ok 42 - prefix MINUS SIGN works with infix
ok 43 - we have infix MULTIPLICATION SIGN
ok 44 - we have infix DIVISION SIGN
ok 45 - we have infix LESS-THAN OR EQUAL TO
ok 46 - we have infix GREATER-THAN OR EQUAL TO
ok 47 - we have infix NOT EQUAL TO
ok 48 - we have infix LESS-THAN OR EQUAL TO (not always True)
ok 49 - we have infix GREATER-THAN OR EQUAL TO (not always True)
ok 50 - we have infix NOT EQUAL TO (not always True)
ok 51 - unicode op chaining
ok 52 - unicode op chaining
ok 53 - unicode op chaining
ok 54 - unicode ops chain with ASCII ones
ok 55 - unicode ops chain with ASCII ones (not always True)
ok 56 - Date ≥ Date (true)
ok 57 - Date ≥ Date (false)
ok 58 - Date ≤ Date (true)
ok 59 - Date ≤ Date (false)
ok 60 - Date ≠ Date (true)
ok 61 - Date ≠ Date (false)
ok 62 - DateTime ≥ DateTime (true)
ok 63 - DateTime ≥ DateTime (false)
ok 64 - DateTime ≤ DateTime (true)
ok 65 - DateTime ≤ DateTime (false)
ok 66 - DateTime ≠ DateTime (true)
ok 67 - DateTime ≠ DateTime (false)
ok 68 - Version ≥ Version (true)
ok 69 - Version ≥ Version (false)
ok 70 - Version ≤ Version (true)
ok 71 - Version ≤ Version (false)
ok 72 - Version ≠ Version (true)
ok 73 - Version ≠ Version (false)
ok 74 - Junctions with ≠ works like for negated ops
    1..3
    ok 1 - original value
    ok 2 - `does` with Str overrode Str method
    ok 3 - `does` a custom class adds method from .^name
ok 75 - does works with non-roles
ok 76 - does a junction survive ~ Junction
ok 77 - does a junction survive Junction ~
ok 78 - does a junction survive Junction ~ Junction
# FUDGED!
1..77
ok 1 - bare postfix binds tighter than ++
ok 2 - dotted postfix binds tighter than ++
ok 3 - ++ bind tighter than **
ok 4 - -- does too
ok 5 - ** bind tighter than unary -
ok 6 - ~2**4 is a string
ok 7 - unary ! binds tighter than *
ok 8 - beh
ok 9 - binary -> numify causes reinterpretation as, binds tighter than *
ok 10 - on left side . is looser than ** and left-to-right with unary -
ok 11 - on right side . is tighter than addition
ok 12 - on right side . is tighter than methodcall
ok 13 - on left side . is tighter than *
ok 14 - * binds tighter than binary +
ok 15 - div binds tighter than binary -
ok 16 - / binds tighter than binary -
ok 17 - ~ binds looser than *
ok 18 - but tighter than &
ok 19 - and + binds tighter than |
ok 20 - x binds looser than binary +
ok 21 - doublecheck
ok 22 - x binds tighter than binary ~
ok 23 - and ~ binds tighter than |
ok 24 - & binds tighter than |
ok 25 - ditto
ok 26 - and also ^
ok 27 - blah blah blah
    1..2
    ok 1 - 'my Mu $a = (1 | 2 ^ 3)' died
    ok 2 - right exception type (X::Syntax::NonListAssociative)
ok 28 - | and ^ may not associate
    1..2
    ok 1 - 'my Mu $a = (1 ^ 2 | 3)' died
    ok 2 - right exception type (X::Syntax::NonListAssociative)
ok 29 - ^ and | may not associate
ok 30 - this is true because only one is == 1
ok 31 - 0 < 2 <=> 1 < 2 means 0 < 1 < 2
ok 32 - <=> binds looser than |
ok 33 - <=> binds tighter than ==
    1..2
    ok 1 - '1 .. 2 .. 3' died
    ok 2 - right exception type (X::Syntax::NonAssociative)
ok 34 - identical .. is not associative
    1..2
    ok 1 - '1 <=> 2 leg 3' died
    ok 2 - right exception type (X::Syntax::NonAssociative)
ok 35 - <=> and leg are not associative
ok 36 - != binds tighter than &&
ok 37 - == binds tighter than || also when chaning
ok 38 - && binds tighter than ??
ok 39 - ??!! binds tighter than =
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Syntax::ConditionalOperator::PrecedenceTooLoose)
ok 40 - Can't use assignop inside ??!!
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Syntax::ConditionalOperator::PrecedenceTooLoose)
ok 41 - Can't use meta-assignop inside ??!!
ok 42 - $ = binds tighter than ,
ok 43 - = binds tighter than X
ok 44 - item assignment is tighter than true
ok 45 - not is tighter than comma
ok 46 - list infix tighter than list assignment, looser t than comma
ok 47 - to complicate things further, it dwims
ok 48 - parens work around this
    1..2
    ok 1 - '4 X+> 1...2' died
    ok 2 - right exception type (X::Syntax::NonListAssociative)
ok 49 - X+> must not associate with ...
    1..2
    ok 1 - ''08:12:23'.split(':') Z* 60 X** reverse ^3' died
    ok 2 - right exception type (X::Syntax::NonListAssociative)
ok 50 - Z* and X** are non associative
ok 51 - any is less tight than comma and Z
ok 52 - @ = binds looser than ,
ok 53 - First arg is 5, run 1
ok 54 - First arg is 5, run 2
ok 55 - First arg is 5, run 3
ok 56 - First arg is 5, run 4
ok 57 - # SKIP superscript exponent associativity
ok 58 - # SKIP superscript exponent associativity
not ok 59 - mixed exponent does right associative # TODO superscript exponent associativity
# Failed test 'mixed exponent does right associative'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/precedence.rakudo line 228
# expected: '256'
#      got: '64'
ok 60 - superscript exponent binds tighter than unary -
ok 61 - ~2⁴ is a string
ok 62 - on left side . is looser than superscript exponent and left-to-right with unary -
ok 63 - on right side . is tighter than addition
ok 64 - on right side . is tighter than methodcall
ok 65 - uc has the correct precedence in comparison to eq
    1..2
    ok 1 - 'int 4.5' died
    ok 2 - right exception type (X::Syntax::Confused)
ok 66 - there is no more prefix:<int>
ok 67 - => is right-assoc (1)
ok 68 - => is right-assoc (2)
    1..2
    ok 1 - '1, 2 Z 3, 4 X 5, 6' died
    ok 2 - right exception type (X::Syntax::NonListAssociative)
ok 69 - list associativity only works between identical operators
ok 70 - sanity 3 != 3
not ok 71 - 3 !=3 does not die # TODO Inequality (!=) misparsed as assignment
# Failed test '3 !=3 does not die'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/precedence.rakudo line 271
# Cannot modify an immutable Int (3)
not ok 72 - ensure 3 !=3 gives same result as 3 != 3 # TODO Inequality (!=) misparsed as assignment
# Failed test 'ensure 3 !=3 gives same result as 3 != 3'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/precedence.rakudo line 272
# expected: 'False'
#      got: 'True'
ok 73 - and after say is not interpreted as infix:<and>
ok 74 - (|) has correct precedence.
ok 75 - "not(0) + 1" is parsed as "(not 0) + 1"
    1..2
    ok 1 - 'my $lizmat = 42; ++$lizmat++' died
    ok 2 - right exception type (X::Syntax::NonAssociative)
ok 76 - prefix/postfix ++ are not associative
not ok 77 - exported multi has correct precedence # TODO RT 128042
# Failed test 'exported multi has correct precedence'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/precedence.rakudo line 306
# expected: '1'
#      got: '0'
# FUDGED!
1..54
ok 1 - [**] () eq 1 (arguably nonsensical)
ok 2 - [*] () eq 1
ok 3 - [/] () should fail
ok 4 - [%] () should fail
ok 5 - [x] () should fail
ok 6 - [xx] () should fail
ok 7 - [+&] () eq +^0
ok 8 - [+<] () should fail
ok 9 - [+>] () should fail
ok 10 - [~&] () should fail
ok 11 - # SKIP ~< NYI
ok 12 - # SKIP ~> NYI
ok 13 - [+] () eq 0
ok 14 - [-] () eq 0
ok 15 - [~] () eq ''
ok 16 - [+|] () eq 0
ok 17 - [+^] () eq 0
ok 18 - [~|] () eq ''
ok 19 - [~^] () eq ''
ok 20 - [&] () eq all()
ok 21 - [|] () eq any()
ok 22 - [^] () eq one()
ok 23 - [!==] () eq True
ok 24 - [==] () eq True
ok 25 - [<] () eq True
ok 26 - [<=] () eq True
ok 27 - [>] () eq True
ok 28 - [>=] () eq True
ok 29 - [before] () eq True
ok 30 - [after] () eq True
ok 31 - [~~] () eq True
ok 32 - [!~~] () eq True
ok 33 - [eq] () eq True)
ok 34 - [ne] () eq True)
ok 35 - [!eq] () eq True
ok 36 - [lt] () eq True
ok 37 - [le] () eq True
ok 38 - [gt] () eq True
ok 39 - [ge] () eq True
ok 40 - [=:=] () eq True
ok 41 - [!=:=] () eq True
ok 42 - [===] () eq True
ok 43 - [!===] () eq True
ok 44 - [eqv] () eq True
ok 45 - [!eqv] () eq True
ok 46 - [&&] () eq True
ok 47 - [||] () eq False
ok 48 - [^^] () eq False
ok 49 - [//] () is Any
ok 50 - [,] () eq ()
ok 51 - [Z] () eq []
ok 52 - unary [==]
ok 53 - unary [!=]
ok 54 - unary [!==]
# FUDGED!
1..44
ok 1 - # SKIP hangs
ok 2 - # SKIP hangs
ok 3 - # SKIP hangs
ok 4 - # SKIP hangs
ok 5 - # SKIP hangs
ok 6 - # SKIP hangs
ok 7 - # SKIP hangs
ok 8 - # SKIP hangs
ok 9 - # SKIP hangs
ok 10 - # SKIP hangs
ok 11 - # SKIP hangs
ok 12 - finite sequence started with one letter
ok 13 - sequence started with one letter
ok 14 - sequence started with two different letters
ok 15 - character sequence started from array
ok 16 - descending sequence started with one letter
ok 17 - descending sequence started with two different letters
ok 18 - descending sequence started with three different letters
ok 19 - characters xand arity-1
ok 20 - sequence ending with 'z' don't cross to two-letter strings
ok 21 - sequence from 'A' to 'z' is finite and of correct length
ok 22 - sequence from 'α' to 'ω' is finite and of correct length
ok 23 - sequence from '☀' to '☕'
ok 24 - exclusive sequence from '☀' to '☕'
ok 25 - 'A' ... 'ZZ' does not go on forever
ok 26 - last element of 'ZZ' ... 'AA' is 'AA'
    1..3
    ok 1 - code dies
    ok 2 - right exception type (Exception)
    ok 3 - .message matches Decrement out of range
ok 27 - Str decrement fails after 'AA': leftmost characters are never removed
ok 28 - 'Y', 'Z' ... 'A' works
ok 29 - A is before AA
ok 30 - 'A' ...^ 'ZZ' omits last element
ok 31 - # SKIP lifting comparison ops
ok 32 - # SKIP lifting comparison ops
ok 33 - # SKIP lifting comparison ops
ok 34 - # SKIP lifting comparison ops
ok 35 - # SKIP lifting comparison ops
ok 36 - # SKIP lifting comparison ops
ok 37 - sequence with strings that starts with a digit but cannot convert to numbers
ok 38 - unicode blocks
ok 39 - mixture
ok 40 - intuition does not try to cmp a WhateverCode
ok 41 - can generate octals
ok 42 - can generate reverse octals
ok 43 - can juggle unicode balls
ok 44 - can juggle unicode balls upside down
# FUDGED!
1..6
ok 1 - # SKIP RT  \#124444
ok 2 - # SKIP RT  \#124444
ok 3 - # SKIP RT  \#124444
ok 4 - # SKIP RT  \#124444
ok 5 - # SKIP RT  \#124444
ok 6 - # SKIP RT  \#124444
# FUDGED!
1..23
ok 1 - :(Int $) ~~ :(Int $)
ok 2 - :(Int $) ~~ :(Int $, Str $)
ok 3 - :(Int $) ~~ :(Int $, Str $?)
ok 4 - :(Str $) ~~ :(Any $)
ok 5 - :(Int $, Rat $, &) ~~ :(*@_)
ok 6 - :(:a($x)) ~~ :(:a(:b(:c($x))))
ok 7 - :(Int $x ($y, Str $z)) ~~ :(Any $x ($l, Int $r))
ok 8 - :(:x($t) (Int $f, Any $k)) ~~ :(:x($r) (Str $g, Any $i))
ok 9 - :(:x($t) (Str $f, Str $k)) ~~ :(:x($r) (Str $g, Any $i))
ok 10 - :(Int @, Str $, Rat $, Str $) ~~ :(Int @x, Any $b, Rat $n?, *@_)
ok 11 - :(Str $a, Str $b?) ~~ :(Str $a, Str $b)
ok 12 - :(Any $, :$foo) ~~ :(Any $x, :$foo!)
ok 13 - :(Int $, Any :$x!, Str :$y) ~~ :(Int $, *%_)
ok 14 - :(@ (Complex $, Str $, Int $)) ~~ :(@ (Any $, Str $, Numeric $))
ok 15 - :(Complex $, *%rest) ~~ :(Complex $z, :$x, :$y, :$q)
ok 16 - :(*%_) ~~ :(:$x, Int :$y, Cool :$z, *%_)
ok 17 - :(:$x, *%_) ~~ :(:$x, *%_)
ok 18 - :($, *@_) ~~ :($, Any $, Numeric $)
ok 19 - # SKIP Parametric types
not ok 20 - Code params with signatures # TODO Parametric types
# Failed test 'Code params with signatures'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-smartmatch/signature-signature.rakudo line 38
ok 21 - Can smartmatch against empty signature (False)
ok 22 - Can smartmatch an empty signature (False)
ok 23 - Can smartmatch against empty signature (True)
# FUDGED!
1..46
ok 1 - temp() changed the variable (1)
ok 2 - temp() restored the variable (1)
ok 3 - changed the temp array
ok 4 - temp() restored the array
ok 5 - changed the temp hash
ok 6 - temp() restored the hash
ok 7 - temp() changed the variable (2-1)
ok 8 - temp() changed the variable (2-2)
ok 9 - temp() restored the variable (2)
ok 10 - temp() shouldn't change the variable containers
ok 11 - temp() changed the package variable (3-1)
ok 12 - temp() restored the package variable (3-2)
ok 13 - temp() changed the variable in a try block
ok 14 - temp() restored the variable, the block was exited using an exception
ok 15 - temp() changed our array element
ok 16 - temp() restored our array element
ok 17 - temp() changed our hash element
ok 18 - temp() restored our array element
not ok 19 - temp() removed previously non-existent key # TODO RT #126447
# Failed test 'temp() removed previously non-existent key'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-blocks-and-statements/temp.rakudo line 93
not ok 20 - temp() restored hash has correct .elems # TODO RT #126447
# Failed test 'temp() restored hash has correct .elems'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-blocks-and-statements/temp.rakudo line 94
# expected: '3'
#      got: '4'
ok 21 - temp() changed our nested arrayitem/hashitem element
ok 22 - temp() restored our nested arrayitem/hashitem element
ok 23 - TEMP block (1)
ok 24 - TEMP block (2)
ok 25 - TEMP block (3)
ok 26 - TEMP block (4)
not ok 27 - TEMP block (5) # TODO TEMP phasers NYI
# Failed test 'TEMP block (5)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-blocks-and-statements/temp.rakudo line 137
not ok 28 - TEMP block (6) # TODO TEMP phasers NYI
# Failed test 'TEMP block (6)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-blocks-and-statements/temp.rakudo line 138
not ok 29 - TEMP block (7) # TODO TEMP phasers NYI
# Failed test 'TEMP block (7)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-blocks-and-statements/temp.rakudo line 139
not ok 30 - TEMP block (8) # TODO TEMP phasers NYI
# Failed test 'TEMP block (8)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-blocks-and-statements/temp.rakudo line 140
ok 31 - TEMP block (9)
ok 32 - TEMP block (10)
ok 33 - TEMP block (11)
ok 34 - instantiating a WierdTemp worked
ok 35 - .TEMP method wasn't yet executed
not ok 36 - .TEMP method was executed on temporization # TODO TEMP phasers NYI
# Failed test '.TEMP method was executed on temporization'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-blocks-and-statements/temp.rakudo line 178
# expected: '1'
#      got: '0'
not ok 37 - .TEMP method was executed on restoration # TODO TEMP phasers NYI
# Failed test '.TEMP method was executed on restoration'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-blocks-and-statements/temp.rakudo line 181
# expected: '2'
#      got: '0'
ok 38 - recursive nested temps are restored properly
ok 39 - multiple temps in the same scope are restored properly
ok 40 - sanity
ok 41 - non-recursive function properly resets value
ok 42 - recursive function properly resets value
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Dynamic::NotFound)
ok 43 - Useful error conveyed when trying to temp a non-existing dynamic
ok 44 - temp works with parametarized Hashes
ok 45 - `temp` keeps around Nils in Arrays when they exist
ok 46 - `temp` keeps Nils around in Hashes when they exist
# FUDGED!
1..110
    1..2
    ok 1 - '$foo; my $foo = 42' died
    ok 2 - right exception type (X::Undeclared)
ok 1 - my() variable not yet visible prior to declaration
ok 2 - my() variable is visible now (2)
    1..2
    ok 1 - '$ret = $foo ~ my $foo;' died
    ok 2 - right exception type (X::Undeclared)
ok 3 - my() variable not yet visible (1)
ok 4 - my() variable not yet visible (2)
ok 5 - my() variable is visible (1)
ok 6 - my() variable is visible (2)
ok 7 - my variable with & sigil works (1)
ok 8 - my variable with & sigil works (2)
ok 9 - calling a lexically defined my()-code var worked
    1..2
    ok 1 - 'foo(42)' died
    ok 2 - right exception type (X::Undeclared::Symbols)
ok 10 - my &foo is lexically scoped
ok 11 - do{my $a = 3; $a} works
ok 12 - do{1; my $a = 3; $a} works
ok 13 - "my $x = my $y = 0" parses
ok 14 - value should still be set for arg, even if there's a later my
ok 15 - $a is available in this scope
ok 16 - $a is available in this scope
ok 17 - $b is available in this scope
    1..2
    ok 1 - '$b' died
    ok 2 - right exception type (X::Undeclared)
ok 18 - $b is not available in this scope
ok 19 - $c is still the same outer value
ok 20 - $c is available, and the outer value has been changed
ok 21 - $d is still the outer $d
ok 22 - $d is now the lexical (inner) $d
ok 23 - $d has not changed
ok 24 - $d is available, and the outer value has not changed
    1..2
    ok 1 - '$e' died
    ok 2 - right exception type (X::Undeclared)
ok 25 - $e is not available in this scope
ok 26 - $func2() just returns the $e lexical which is held by the closure
ok 27 - $func() increments the $e lexical which is held by the closure
ok 28 - ... and one more time just to be sure
ok 29 - can parse squinting my value
ok 30 - can capture squinting my value
ok 31 - can set squinting my variable
ok 32 - precedence of my wrt = and ,
ok 33 - Can use @a
ok 34 - Can use @b
ok 35 - push actually worked on @a
ok 36 - push actually worked on @b
ok 37 - my in while cond seen from body
ok 38 - my in while cond seen after
ok 39 - my in if cond seen from then
ok 40 - my in if cond seen from else
ok 41 - my in if cond seen after
ok 42 - 1st my in loop cond seen from body
ok 43 - 2nd my in loop cond seen from body
ok 44 - 1st my in loop cond seen after
ok 45 - 2nd my in loop cond seen after
ok 46 - two lexicals declared in scope is noop
    1..3
    ok 1 - 'my %h is default(%h<foo>)' died
    ok 2 - right exception type (X::Syntax::Variable::Initializer)
    ok 3 - .name matches %h
ok 47 - did we throws-like X::Syntax::Variable::Initializer?
    1..3
    ok 1 - 'my $z = $z' died
    ok 2 - right exception type (X::Syntax::Variable::Initializer)
    ok 3 - .name matches $z
ok 48 - did we throws-like X::Syntax::Variable::Initializer?
ok 49 - initializing a variable using a try block containing same name works
    1..3
    ok 1 - 'my @foo := 1..3, (@foo Z+ 100)' died
    ok 2 - right exception type (X::Syntax::Variable::Initializer)
    ok 3 - .name matches @foo
ok 50 - did we throws-like X::Syntax::Variable::Initializer?
ok 51 - EVAL() knows the pad where it is launched from
ok 52 - ... but initialization of variables might still happen afterwards
ok 53 - &x does not need to be pre-declared
    1..2
    ok 1 - '&x()' died
    ok 2 - right exception type (X::Undeclared::Symbols)
ok 54 - &x() dies when empty
ok 55 - my $x if 0
ok 56 - 
ok 57 - OUTER::<$x>
ok 58 - SETTING::<$x>
ok 59 - 
ok 60 - unreached declaration in effect at block start
ok 61 - type error
ok 62 - also a type error
ok 63 - native in declarator sig
ok 64 - natives in declarator sig
ok 65 - Native types in declarator sig 1/2 constrains
ok 66 - Native types in declarator sig 2/2 constrains
ok 67 - Native types in declarator sig allow correct assignments
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck)
ok 68 - Type in declarator sig 1/1 constrains
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck)
ok 69 - Types in declarator sig 1/2 constrain
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck)
ok 70 - Types in declarator sig 2/2 constrain
ok 71 - Types in declarator sig allow correct assignments
ok 72 - native outside declarator sig 1
ok 73 - native outside declarator sig 2
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck)
ok 74 - Type outside declarator sig 1/1 constrains
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck)
ok 75 - Type outside declarator sig 1/2 constrains
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck)
ok 76 - Type outside declarator sig 2/2 constrains
ok 77 - Native type outside declarator sig 1/2 constrains
ok 78 - Native type outside declarator sig 2/2 constrains
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck)
ok 79 - another Type in declarator sig
ok 80 - Can access variable returned from a named closure that is declared below the calling position
ok 81 - can call our-sub that accesses a lexical before the block was run
ok 82 - can call our-sub that accesses a lexical after the block was run
ok 83 - my (%h?) lives
ok 84 - global scoped variables are visible inside class definitions
ok 85 - typing a my-declared variable as ::a works.
ok 86 - declaration of anonymous Scalar
ok 87 - declaration of anonymous Array
ok 88 - declaration of anonymous Hash
ok 89 - can declare a variable inside a sub call
ok 90 - dies on undeclared routines
ok 91 - ... and it does so before run time
ok 92 - inner / outer
ok 93 - anonymous @ doesn't overshare
ok 94 - anonymous % doesn't overshare
ok 95 - anonymous sub doesn't overshare
ok 96 - can declare sigilless within parenthesis
ok 97 - cannot assign to sigilless variable after declaration (one)
ok 98 - declarator with multiple variables can contain sigilless
ok 99 - cannot assign to sigilless variable after declaration (many)
    1..2
    ok 1 - 'my (\a)' died
    ok 2 - right exception type (X::Syntax::Term::MissingInitializer)
ok 100 - did we throws-like X::Syntax::Term::MissingInitializer?
    1..2
    ok 1 - 'my (\a, \b)' died
    ok 2 - right exception type (X::Syntax::Term::MissingInitializer)
ok 101 - did we throws-like X::Syntax::Term::MissingInitializer?
ok 102 - can signature-bind to my (\a, \b) and get correct values (1)
ok 103 - can signature-bind to my (\a, \b) and get correct values (2)
ok 104 - can call postcircumfix () on subs inside my
ok 105 - no NullPointerException (and no segfault either)
    1..2
        1..2
        ok 1 - 'my Any :D $a' died
        ok 2 - right exception type (X::Syntax::Malformed)
    ok 1 - did we throws-like X::Syntax::Malformed?
        1..2
        ok 1 - 'my Any ^:D $a' died
        ok 2 - right exception type (X::Syntax::Malformed)
    ok 2 - did we throws-like X::Syntax::Malformed?
ok 106 - report Malformed my correctly
    1..2
        1..2
        ok 1 - 'my Int $a of Str' died
        ok 2 - right exception type (X::Syntax::Variable::ConflictingTypes)
    ok 1 - Type + of Type
        1..2
        ok 1 - 'my Int $a of Str is default("z") of Rat' died
        ok 2 - right exception type (X::Comp::Group)
    ok 2 - Type + of Type + is default
ok 107 - dies on conflicting type constraints
    1..3
    ok 1 - simple
    ok 2 - complex
    ok 3 - # SKIP not implemented
ok 108 - can assign to sigil-less variables
    1..3
    ok 1 - simple
    ok 2 - complex
    ok 3 - # SKIP not implemented
ok 109 - can bind to sigil-less variables
    1..3
    ok 1 - # SKIP ::= NYI
    ok 2 - # SKIP ::= NYI
    ok 3 - # SKIP ::= NYI
ok 110 - can compile-time bind to sigil-less variables
# FUDGED!
1..110
    1..2
    ok 1 - '$foo; my $foo = 42' died
    ok 2 - right exception type (X::Undeclared)
ok 1 - my() variable not yet visible prior to declaration
ok 2 - my() variable is visible now (2)
    1..2
    ok 1 - '$ret = $foo ~ my $foo;' died
    ok 2 - right exception type (X::Undeclared)
ok 3 - my() variable not yet visible (1)
ok 4 - my() variable not yet visible (2)
ok 5 - my() variable is visible (1)
ok 6 - my() variable is visible (2)
ok 7 - my variable with & sigil works (1)
ok 8 - my variable with & sigil works (2)
ok 9 - calling a lexically defined my()-code var worked
    1..2
    ok 1 - 'foo(42)' died
    ok 2 - right exception type (X::Undeclared::Symbols)
ok 10 - my &foo is lexically scoped
ok 11 - do{my $a = 3; $a} works
ok 12 - do{1; my $a = 3; $a} works
ok 13 - "my $x = my $y = 0" parses
ok 14 - value should still be set for arg, even if there's a later my
ok 15 - $a is available in this scope
ok 16 - $a is available in this scope
ok 17 - $b is available in this scope
    1..2
    ok 1 - '$b' died
    ok 2 - right exception type (X::Undeclared)
ok 18 - $b is not available in this scope
ok 19 - $c is still the same outer value
ok 20 - $c is available, and the outer value has been changed
ok 21 - $d is still the outer $d
ok 22 - $d is now the lexical (inner) $d
ok 23 - $d has not changed
ok 24 - $d is available, and the outer value has not changed
    1..2
    ok 1 - '$e' died
    ok 2 - right exception type (X::Undeclared)
ok 25 - $e is not available in this scope
ok 26 - $func2() just returns the $e lexical which is held by the closure
ok 27 - $func() increments the $e lexical which is held by the closure
ok 28 - ... and one more time just to be sure
ok 29 - can parse squinting my value
ok 30 - can capture squinting my value
ok 31 - can set squinting my variable
ok 32 - precedence of my wrt = and ,
ok 33 - Can use @a
ok 34 - Can use @b
ok 35 - push actually worked on @a
ok 36 - push actually worked on @b
ok 37 - my in while cond seen from body
ok 38 - my in while cond seen after
ok 39 - my in if cond seen from then
ok 40 - my in if cond seen from else
ok 41 - my in if cond seen after
ok 42 - 1st my in loop cond seen from body
ok 43 - 2nd my in loop cond seen from body
ok 44 - 1st my in loop cond seen after
ok 45 - 2nd my in loop cond seen after
ok 46 - two lexicals declared in scope is noop
    1..3
    ok 1 - 'my %h is default(%h<foo>)' died
    ok 2 - right exception type (X::Syntax::Variable::Initializer)
    ok 3 - .name matches %h
ok 47 - did we throws-like X::Syntax::Variable::Initializer?
    1..3
    ok 1 - 'my $z = $z' died
    ok 2 - right exception type (X::Syntax::Variable::Initializer)
    ok 3 - .name matches $z
ok 48 - did we throws-like X::Syntax::Variable::Initializer?
ok 49 - initializing a variable using a try block containing same name works
    1..3
    ok 1 - 'my @foo := 1..3, (@foo Z+ 100)' died
    ok 2 - right exception type (X::Syntax::Variable::Initializer)
    ok 3 - .name matches @foo
ok 50 - did we throws-like X::Syntax::Variable::Initializer?
ok 51 - EVAL() knows the pad where it is launched from
ok 52 - ... but initialization of variables might still happen afterwards
ok 53 - &x does not need to be pre-declared
    1..2
    ok 1 - '&x()' died
    ok 2 - right exception type (X::Undeclared::Symbols)
ok 54 - &x() dies when empty
ok 55 - my $x if 0
ok 56 - 
ok 57 - OUTER::<$x>
not ok 58 - SETTING::<$x>
ok 59 - 
ok 60 - unreached declaration in effect at block start
ok 61 - type error
ok 62 - also a type error
ok 63 - native in declarator sig
ok 64 - natives in declarator sig
ok 65 - Native types in declarator sig 1/2 constrains
ok 66 - Native types in declarator sig 2/2 constrains
ok 67 - Native types in declarator sig allow correct assignments
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck)
ok 68 - Type in declarator sig 1/1 constrains
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck)
ok 69 - Types in declarator sig 1/2 constrain
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck)
ok 70 - Types in declarator sig 2/2 constrain
ok 71 - Types in declarator sig allow correct assignments
ok 72 - native outside declarator sig 1
ok 73 - native outside declarator sig 2
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck)
ok 74 - Type outside declarator sig 1/1 constrains
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck)
ok 75 - Type outside declarator sig 1/2 constrains
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck)
ok 76 - Type outside declarator sig 2/2 constrains
ok 77 - Native type outside declarator sig 1/2 constrains
ok 78 - Native type outside declarator sig 2/2 constrains
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck)
ok 79 - another Type in declarator sig
ok 80 - Can access variable returned from a named closure that is declared below the calling position
ok 81 - can call our-sub that accesses a lexical before the block was run
ok 82 - can call our-sub that accesses a lexical after the block was run
ok 83 - my (%h?) lives
ok 84 - global scoped variables are visible inside class definitions
ok 85 - typing a my-declared variable as ::a works.
ok 86 - declaration of anonymous Scalar
ok 87 - declaration of anonymous Array
ok 88 - declaration of anonymous Hash
ok 89 - can declare a variable inside a sub call
ok 90 - dies on undeclared routines
ok 91 - ... and it does so before run time
ok 92 - inner/outer
ok 93 - anonymous @ doesn't overshare
ok 94 - anonymous % doesn't overshare
ok 95 - anonymous sub doesn't overshare
ok 96 - can declare sigilless within parenthesis
ok 97 - cannot assign to sigilless variable after declaration (one)
ok 98 - declarator with multiple variables can contain sigilless
ok 99 - cannot assign to sigilless variable after declaration (many)
    1..2
    ok 1 - 'my (\a)' died
    ok 2 - right exception type (X::Syntax::Term::MissingInitializer)
ok 100 - did we throws-like X::Syntax::Term::MissingInitializer?
    1..2
    ok 1 - 'my (\a, \b)' died
    ok 2 - right exception type (X::Syntax::Term::MissingInitializer)
ok 101 - did we throws-like X::Syntax::Term::MissingInitializer?
ok 102 - can signature-bind to my (\a, \b) and get correct values (1)
ok 103 - can signature-bind to my (\a, \b) and get correct values (2)
ok 104 - can call postcircumfix () on subs inside my
ok 105 - no NullPointerException (and no segfault either)
    1..2
        1..2
        ok 1 - 'my Any :D $a' died
        ok 2 - right exception type (X::Syntax::Malformed)
    ok 1 - did we throws-like X::Syntax::Malformed?
        1..2
        ok 1 - 'my Any ^:D $a' died
        ok 2 - right exception type (X::Syntax::Malformed)
    ok 2 - did we throws-like X::Syntax::Malformed?
ok 106 - report Malformed my correctly
    1..2
        1..2
        ok 1 - 'my Int $a of Str' died
        ok 2 - right exception type (X::Syntax::Variable::ConflictingTypes)
    ok 1 - Type + of Type
        1..2
        ok 1 - 'my Int $a of Str is default("z") of Rat' died
        ok 2 - right exception type (X::Comp::Group)
    ok 2 - Type + of Type + is default
ok 107 - dies on conflicting type constraints
    1..3
    ok 1 - simple
    ok 2 - complex
    ok 3 - # SKIP not implemented
ok 108 - can assign to sigil-less variables
    1..3
    ok 1 - simple
    ok 2 - complex
    ok 3 - # SKIP not implemented
ok 109 - can bind to sigil-less variables
    1..3
    ok 1 - # SKIP ::= NYI
    ok 2 - # SKIP ::= NYI
    ok 3 - # SKIP ::= NYI
ok 110 - can compile-time bind to sigil-less variables
# FUDGED!
1..44
ok 1 - Assignment to state variable with //= works.
ok 2 - Assignment to state variable with //= happens once.
ok 3 - state() works inside subs (first)
ok 4 - state() works inside subs (second)
ok 5 - state() works inside subs ( \#3)
ok 6 - state() works inside coderefs
ok 7 - state() works inside for-loops
ok 8 - array state initialized correctly
ok 9 - array state retained between calls
ok 10 - array state initialized from call correctly
ok 11 - array state retained between calls
ok 12 - (state @foo) = @bar is not state @foo = @bar
ok 13 - (state @foo) = @bar is not state @foo = @bar
ok 14 - RHS of state $x = ... only called once
ok 15 - state() and parens
ok 16 - state() variable referenced from regex replacement part works
ok 17 - chained state (1)
ok 18 - chained state (2)
ok 19 - state was initialized properly (first time)
ok 20 - state keeps its value across calls (first time)
ok 21 - state was initialized properly (second time)
ok 22 - state keeps its value across calls (second time)
ok 23 - state was initialized correctly for clone 1
ok 24 - state was initialized correctly for clone 2
ok 25 - state between clones is independent
ok 26 - fib 10 works
ok 27 - list assignment state in fib memoizes
ok 28 - fib 2 works
ok 29 - [list] assignment state in fib memoizes
ok 30 - growing subset types rejects too high values
ok 31 - the state variable in subset types works (1)
ok 32 - the state variable in subset types works (2)
ok 33 - the state variable in subset types works (3)
ok 34 - a state variable in parens works with a state variable with //= init
ok 35 - can parse "state $i++"
ok 36 - state var in anonymous closure in loop is not shared
ok 37 - state outside control structure
not ok 38 - initialization not reached on first run of the functions # TODO initialization happens only on first call(?)
# Failed test 'initialization not reached on first run of the functions'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-declarations/state.rakudo line 257
# expected: '5'
#      got: (Any)
ok 39 - state vars and list assignment mixes
ok 40 - anonymous state variable (1)
ok 41 - anonymous state variable (2)
ok 42 - Intensive use of state variable in inline-friendly sub does not hit problems
ok 43 - Statevars work in block following "do" statement prefix
ok 44 - Statevar uses the correct scope
# FUDGED!
1..20
ok 1 - all begin/check blocks in order
not ok 2 - all init blocks in order # TODO will init NYI
# Failed test 'all init blocks in order'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-declarations/will.rakudo line 22
# expected: 'abc'
#      got: 'ab'
ok 3 - # SKIP declared variable not visible in block yet
ok 4 - entered block ok
not ok 5 - all block blocks set variable # TODO will post NYI
# Failed test 'all block blocks set variable'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-declarations/will.rakudo line 49
# expected: 'abecd'
#      got: 'abec'
ok 6 - # SKIP declared variable not visible in block yet
not ok 7 - all block blocks get $_ # TODO declared variable not visible in block yet
# Failed test 'all block blocks get $_'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-declarations/will.rakudo line 64
# expected: 'abecd'
#      got: (Any)
ok 8 - for iteration  \#1
ok 9 - for iteration  \#2
ok 10 - for iteration  \#3
ok 11 - all for blocks set variable
ok 12 - # SKIP declared variable not visible in block yet
not ok 13 - all for blocks get $_ # TODO declared variable not visible in block yet
# Failed test 'all for blocks get $_'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-declarations/will.rakudo line 96
# expected: 'aebebebc'
#      got: (Any)
ok 14 - unknown will trait
ok 15 - block should not have executed
ok 16 - don't know how to test yet
ok 17 - block should not have executed
ok 18 - will leave trait on class-scoped my variable not run yet
ok 19 - will leave trait on class-scoped my variable ran
ok 20 - will begin block gets var as topic
# FUDGED!
1..21
ok 1 - $! has an exception
ok 2 - # SKIP $!.pending
ok 3 - # SKIP $!.pending
ok 4 - $! has been cleared
ok 5 - @fails is full of fail
ok 6 - fails do not enter $!
not ok 7 - $!.pending has three unhandled exceptions # TODO $!.pending
# Failed test '$!.pending has three unhandled exceptions'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-exceptions/pending.rakudo line 35
# expected: '4'
#      got: '1'
ok 8 - fail 0 is not handled
ok 9 - fail 0 is not true
ok 10 - fail 0 is now handled
ok 11 - fail 1 is not handled
ok 12 - fail 1 is not defined
ok 13 - fail 1 is now handled
ok 14 - fail 2 is not handled
ok 15 - assign to .handled
ok 16 - fail 2 is now handled
ok 17 - $!.pending has one unhandled exception
ok 18 - $! has been cleared
not ok 19 - unhandled Failures in $! at block exit are thrown # TODO $object.handled
# Failed test 'unhandled Failures in $! at block exit are thrown'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-exceptions/pending.rakudo line 73
# expected: '2'
#      got: '0'
ok 20 - $! has been cleared
ok 21 - # SKIP $object.handled
# FUDGED!
1..13
ok 1 - Can use BEGIN <block> as an expression
ok 2 - Can use BEGIN <expr> as an expression
ok 3 - can set outer lexical from a BEGIN block
ok 4 - can set outer package var from a BEGIN block
ok 5 - can call subs from an outer scope in BEGIN
ok 6 - can call subs from the setting in BEGIN
ok 7 - use a class at BEGIN time
ok 8 - Can execute an anonymous sub return from BEGIN
ok 9 - BEGIN block was executed before a parse error happened later in the file
ok 10 - Can use try at BEGIN time
ok 11 - no Null PMC access when looping over SomeEnum.enums in blockless BEGIN
not ok 12 - Value bound to variable in BEGIN persists # TODO RT#123776
# Failed test 'Value bound to variable in BEGIN persists'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-phasers/begin.rakudo line 81
# expected: 'foo'
#      got: (Any)
ok 13 - Assigment in BEGIN to list declared outside BEGIN lives
# FUDGED!
1..33
ok 1 - 
ok 2 - 
ok 3 - 
ok 4 - 
ok 5 - multiple ENTER/LEAVE worked
ok 6 - ENTER/LEAVE repeats on loop blocks
ok 7 - basic sanity check (1)
ok 8 - LEAVE executed at the 1st explicit return
ok 9 - basic sanity check (2)
ok 10 - LEAVE executed at the 2nd explicit return
ok 11 - # SKIP leave NYI RT  \#124960
ok 12 - die calls LEAVE blocks
ok 13 - $! set in LEAVE if exception thrown
not ok 14 - $! not set in LEAVE if exception not thrown # TODO is this spec? why would LEAVE not see outer $!? fossil?
# Failed test '$! not set in LEAVE if exception not thrown'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-phasers/enter-leave.rakudo line 124
# expected: 'ayeno'
#      got: 'ayeyes'
ok 15 - die in ENTER caught by try
ok 16 - die in LEAVE caught by try
ok 17 - die in ENTER calls LEAVE
ok 18 - die aborts ENTER queue
ok 19 - die doesn't abort LEAVE queue
ok 20 - single exception from LEAVE is rethrown after running LEAVEs
ok 21 - LEAVE fires in a multi sub
ok 22 - next triggers LEAVE
ok 23 - can run for loop in phaser in for loop
ok 24 - LEAVE fires after die in sub
ok 25 - "last" triggers LEAVE phaser in loop
ok 26 - "next" triggers LEAVE phaser in "for" loop
ok 27 - ENTER works as an r-value (mainline)
ok 28 - ENTER works as an r-value (sub)
ok 29 - return in nested block with LEAVE works
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::PhaserExceptions)
    ok 3 - .exceptions matches sub { }
ok 30 - did we throws-like X::PhaserExceptions?
ok 31 - using ENTER inside LEAVE does not crash
ok 32 - decont in ENTER works without locals
ok 33 - Did ENTER only run once
# FUDGED!
1..35
ok 1 - EVAL once {...} works
ok 2 - once {...} has not run yet
ok 3 - can run code with once block
ok 4 - once {...} fired
ok 5 - can run code with once block again
ok 6 - once {...} fired only once
ok 7 - cloning code does not run anything
ok 8 - can run clone of code with once block
ok 9 - once {...} fired again for the clone
ok 10 - can run clone of once block code again
ok 11 - cloned once {...} fired only once
ok 12 - EVAL INIT {...} works
not ok 13 - INIT did not run at compile time # TODO not sure
# Failed test 'INIT did not run at compile time'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-phasers/in-eval.rakudo line 40
ok 14 - can run code with INIT block
ok 15 - INIT {...} fires at run-time
ok 16 - can run code with INIT block again
ok 17 - INIT runs only once
ok 18 - cloning code does not run anything
ok 19 - can run clone of code with INIT block
ok 20 - INIT {...} did not fire again for the clone
ok 21 - EVAL CHECK {...} (and BEGIN {...}) works
ok 22 - CHECK and BEGIN blocks ran before run time
ok 23 - can run code with CHECK and BEGIN blocks
ok 24 - CHECK {...} runs at compile time after BEGIN
ok 25 - can run code with CHECK and BEGIN again
ok 26 - CHECK runs once
ok 27 - EVAL BEGIN {...} works
ok 28 - BEGIN ran before run time
ok 29 - can run code with BEGIN block
ok 30 - BEGIN does not run again at run time
ok 31 - EVAL END {...} works
ok 32 - END {} has not run yet
ok 33 - can call code with END block
ok 34 - END {} does not run at run time either
# FUDGED!
ok 35 - the END {...} in EVAL has run already
1..21
not ok 1 - trait blocks work properly in for loop # TODO NEXT/LEAVE ordering
# Failed test 'trait blocks work properly in for loop'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-phasers/in-loop.rakudo line 37
# expected: '(1 F)(1 E)(1 a)(1 N)(1 Lv)(2 E)(2 a)(2 b)(2 N)(2 Lv)(3 E)(3 a)(3 N)(3 Lv)(4 E)(4 Lv)(4 Lst)'
#      got: '(1 F)(1 E)(1 a)(1 N)(1 Lv)(2 E)(2 a)(2 b)(2 Lv)(2 N)(3 E)(3 a)(3 N)(3 Lv)(4 E)(4 Lv)(4 Lst)'
not ok 2 - trait blocks work properly in for loop # TODO NEXT/LEAVE ordering
# Failed test 'trait blocks work properly in for loop'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-phasers/in-loop.rakudo line 69
# expected: '(1 F1)(1 F2)(1 E1)(1 E2)(1 a)(1 N2)(1 N1)(1 Lv2)(1 Lv1)(2 E1)(2 E2)(2 a)(2 b)(2 N2)(2 N1)(2 Lv2)(2 Lv1)(3 E1)(3 E2)(3 a)(3 N2)(3 N1)(3 Lv2)(3 Lv1)(4 E1)(4 E2)(4 Lv2)(4 Lv1)(4 Lst2)(4 Lst1)'
#      got: '(1 F1)(1 F2)(1 E1)(1 E2)(1 a)(1 N2)(1 N1)(1 Lv2)(1 Lv1)(2 E1)(2 E2)(2 a)(2 b)(2 Lv2)(2 Lv1)(2 N2)(2 N1)(3 E1)(3 E2)(3 a)(3 N2)(3 N1)(3 Lv2)(3 Lv1)(4 E1)(4 E2)(4 Lv2)(4 Lv1)(4 Lst1)(4 Lst2)'
ok 3 - LAST does not fire for empty loop
ok 4 - "last" statement called by LEAVE breaks out of while loop
ok 5 - LEAVE in while loop works as expected
ok 6 - no UnwindException with "last" and "ENTER" in for loop
ok 7 - LAST phaser without block does not put Mu in the iteration variable
ok 8 - LAST phaser with    block does not put Mu in the iteration variable
ok 9 - FIRST in loop works fine with recursion
ok 10 - NEXT in loop works fine with recursion
ok 11 - LAST in loop works fine with recursion
ok 12 - NEXT can see outer $_
ok 13 - LAST can see outer $_
ok 14 - POST should not see outer $_
not ok 15 - KEEP should not see outer $_ # TODO KEEP should not see outer 
# Failed test 'KEEP should not see outer $_'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-phasers/in-loop.rakudo line 175
# expected: '42 42 42 42 42 42 42 42 42 42'
#      got: '0 1 2 3 4 5 6 7 8 9'
ok 16 - LAST can see outer $_
ok 17 - LEAVE can see outer $_
ok 18 - PRE can see outer $_
ok 19 - UNDO can see outer $_
    1..2
    ok 1 - unwanted loop
    ok 2 - wanted loop
ok 20 - FIRST+LAST loops as last statement in subs work and do not crash
ok 21 - FIRST statement in loop does not warn
# FUDGED!
1..16
ok 1 - NEXT called by both next and normal falling out
ok 2 - NEXT called by both next and normal falling out
ok 3 - NEXT called by both next and normal falling out
ok 4 - NEXT are LAST blocks may not be exclusive
ok 5 - die didn't trigger NEXT {}
ok 6 - leave didn't trigger NEXT {}
ok 7 - return didn't trigger NEXT {}
ok 8 - last bypass NEXT {}
not ok 9 - NEXT {} ran before LEAVE {} (1) # TODO NEXT/LEAVE ordering RT #124952
# Failed test 'NEXT {} ran before LEAVE {} (1)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-phasers/next.rakudo line 111
# expected: 'nlnl'
#      got: 'lnln'
not ok 10 - NEXT {} ran before LEAVE {} (2) # TODO NEXT/LEAVE ordering RT #124952
# Failed test 'NEXT {} ran before LEAVE {} (2)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-phasers/next.rakudo line 123
# expected: 'nlnl'
#      got: 'lnln'
ok 11 - NEXT {} ran in reversed order
ok 12 - NEXT {} works in loop (;;) {}
ok 13 - NEXT {} works in for loop
ok 14 - last in a NEXT in a for loop terminates the loop
ok 15 - last in a NEXT in a for loop terminates the loop, when triggered by next
ok 16 - last in a NEXT in a loop terminates the loop
# FUDGED!
1..22
ok 1 - sub with PRE  compiles and runs
ok 2 - sub with POST compiles and runs
    1..3
    ok 1 - 'foo(10)' died
    ok 2 - right exception type (X::Phaser::PrePost)
    ok 3 - .phaser matches PRE
ok 3 - Violated PRE  throws (catchable) exception
    1..3
    ok 1 - 'bar(10)' died
    ok 2 - right exception type (X::Phaser::PrePost)
    ok 3 - .phaser matches POST
ok 4 - Violated POST throws (catchable) exception
ok 5 - sub with two PREs compiles and runs
    1..3
    ok 1 - 'baz(-1)' died
    ok 2 - right exception type (X::Phaser::PrePost)
    ok 3 - .phaser matches PRE
ok 6 - sub with two PREs fails when first is violated
    1..3
    ok 1 - 'baz(42)' died
    ok 2 - right exception type (X::Phaser::PrePost)
    ok 3 - .phaser matches PRE
ok 7 - sub with two PREs fails when second is violated
ok 8 - sub with two POSTs compiles and runs
    1..3
    ok 1 - 'qox(-1)' died
    ok 2 - right exception type (X::Phaser::PrePost)
    ok 3 - .phaser matches POST
ok 9 - sub with two POSTs fails if first POST is violated
    1..3
    ok 1 - 'qox(123)' died
    ok 2 - right exception type (X::Phaser::PrePost)
    ok 3 - .phaser matches POST
ok 10 - sub with two POSTs fails if second POST is violated
ok 11 - POST receives return value as $_ (succeess)
    1..3
    ok 1 - '$pt.test(1)' died
    ok 2 - right exception type (X::Phaser::PrePost)
    ok 3 - .phaser matches POST
ok 12 - POST receives return value as $_ (failure)
ok 13 - PRE and POST run on ordinary blocks
ok 14 - PRE/POST run outside ENTER/LEAVE
ok 15 - failing PRE runs nothing else
ok 16 - failing POST runs LEAVE but not more POSTs
ok 17 - POST runs on exception, with correct $!
not ok 18 - POST has undefined $! on no exception # TODO POST and exceptions RT #124961
# Failed test 'POST has undefined $! on no exception'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-phasers/pre-post.rakudo line 163
# expected: 'ayeno'
#      got: 'ayeyes'
not ok 19 - failing POST on exception doesn't replace $!
ok 20 - blockless PRE/POST (+)
ok 21 - blockless PRE/POST (-, 1)
ok 22 - blockless PRE/POST (-, 2)
# FUDGED!
1..35
ok 1 - post with
ok 2 - post with
ok 3 - post with
ok 4 - post with in a loop
ok 5 - outer $_ did not get updated in lhs of with
ok 6 - postfix with worked
ok 7 - with modifies the $_ that is visible to the {} interpolator
ok 8 - Correct $_ in try block in statement-modifying with
ok 9 - with modifier with $_-using block runs block with correct arg
ok 10 - with modifier with placeholder block runs block with correct arg
ok 11 - with thunk does not mess up statement modifier closures
ok 12 - post with True
ok 13 - post with False
ok 14 - post with type object
ok 15 - sanity check
ok 16 - with expr on true cond
ok 17 - sanity check
ok 18 - with expr on true cond
ok 19 - sanity check
ok 20 - with expr on false cond
ok 21 - sanity check
ok 22 - with expr on false cond
ok 23 - condition in statement level respects context
ok 24 - (3 with 1) worked in scalar context
ok 25 - (3 with 0) worked in scalar context
ok 26 - my $y = (3 with Nil) leaves $y false
ok 27 - "$something with Nil" is Empty
ok 28 - Statement-modifier with runs bare block
ok 29 - Statement-modifier with runs bare code with topic
ok 30 - Statement-modifier with runs block with placeholder
ok 31 - with treats @a with elems as defined
ok 32 - with/for list comprehension works with parens
not ok 33 - with/for list comprehension works without parens # TODO parenless with/for doesn't work yet
# Failed test 'with/for list comprehension works without parens'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statement-modifiers/with.rakudo line 198
# expected: '12 6 4 3'
#      got: ''
ok 34 - without/for list comprehension works with parens
ok 35 - with is a terminator even after comma
# FUDGED!
1..111
    1..2
    ok 1 - 'foreach 1..10 { $times_run++ }; 1' died
    ok 2 - right exception type (X::Obsolete)
ok 1 - foreach is gone
    1..2
    ok 1 - 'foreach (1..10) { $times_run++}; 1' died
    ok 2 - right exception type (X::Obsolete)
ok 2 - foreach is gone, even with parens
ok 3 - foreach doesn't work
ok 4 - for 0..5 {} works
ok 5 - for 0 .. 5 -> {} works
ok 6 - for zip(@a; @b) -> $x, $y works
ok 7 - for 0 .. 5 { .some_sub } works
ok 8 - for () {} works
ok 9 - for () -> {} works
ok 10 - Implicit default topic is seen by lc()
ok 11 - After the loop the implicit topic gets restored
ok 12 - Implicit default topic is seen by lc()
ok 13 - After the loop the implicit topic gets restored
ok 14 - for 0 .. 5 -> $topic {} works
ok 15 - for () -> $topic {} works
ok 16 - for @array {} works
ok 17 - for @array -> {} works
ok 18 - for (@array) {} works
ok 19 - for (@array) -> {} works
ok 20 - for (@a) { ... $_ ... } iterates all elems
ok 21 - for (@a)->$_ { ... $_ ... } iterates all elems
ok 22 - for (@a) { ... $_ ... $_ ... } iterates all elems, not just odd
    1..2
    ok 1 - 'for @a -> $elem {$elem = 5}' died
    ok 2 - right exception type (Exception)
ok 23 - -> $var is ro by default
ok 24 - <-> $var is rw
ok 25 - <-> $var, $var2 works
ok 26 - <-> $_ is rw
ok 27 - for @array { $_++ }
ok 28 - mutating $_ in for works
ok 29 - for @array -> $val is rw { $val++ }
ok 30 - for @array.values -> $val is rw { $val++ }
ok 31 - for @array.kv -> $key, $val is rw { $val++ }
ok 32 - for %hash.values -> $val is rw { $val++ }
ok 33 - for %hash.kv -> $key, $val is rw { $val++ }
ok 34 - .key //= ++$i for @array1;
ok 35 - .key = 1 for @array1;
ok 36 - $_.key = 1 for @array1;
ok 37 - for ($a,$b,$c) { $_++ }
ok 38 - for ($a,$b,$c) -> $x is rw { $x++ }
ok 39 - List context
ok 40 - List context
ok 41 - List context
ok 42 - Can mix recursion and for
ok 43 - can mix recursion and for (RT  \#103332)
ok 44 - grep works in for
ok 45 - sort works in for
ok 46 - grep and sort work in for
    1..2
    ok 1 - 'for(0..5) { }' died
    ok 2 - right exception type (X::Comp::Group)
ok 47 - keyword needs at least one whitespace after it
ok 48 - for loop with two variables
    1..2
    ok 1 - 'for 1..5 ->  $x, $y { $str ~= "$x$y" }' died
    ok 2 - right exception type (Exception)
ok 49 - Should throw exception, no value for parameter $y
ok 50 - loop ran before throwing exception
ok 51 - 
ok 52 - default values in for-loops
ok 53 - Z -ed for loop
ok 54 - Z-ed for loop with 5 arrays
    1..2
    ok 1 - 'for 1.. { };' died
    ok 2 - right exception type (X::Comp::Group)
ok 55 - Please use ..* for indefinite range
    1..2
    ok 1 - 'for 1... { };' died
    ok 2 - right exception type (X::Comp::Group)
ok 56 - 1... does not exist
ok 57 - for loop ends in time using last
ok 58 - infinte for loop ends in time using last
ok 59 - infinte for loop ends in time using last
ok 60 - list comprehension
ok 61 - for loop value is list of iter values
ok 62 - for loop with label-less next flattens out nexted iterations
ok 63 - for loop iteration with label-less 'next' gives Empty
ok 64 - for loop with label-less last flattens out last iteration
not ok 65 - for loop iteration with label-less 'last' gives () # TODO Rakudo still uses Nil here RT #124569
# Failed test 'for loop iteration with label-less 'last' gives ()'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/for.rakudo line 482
# expected: '()'
#      got: 'Nil'
ok 66 - mentions C-style
ok 67 - mentions for
ok 68 - mentions loop
ok 69 - for (1..3)->$n   fails to parse
ok 70 - can stringify "for ^1 {}" without death
ok 71 - result of "for ^1 {}" is Nil
    1..2
    ok 1 - 'for (my $i; $i <=3; $i++) { $i; }' died
    ok 2 - right exception type (X::Obsolete)
ok 72 - Unsupported use of C-style "for (;;)" loop; in Perl 6 please use "loop (;;)"
ok 73 - Sensible error message
ok 74 - for on Range with huge max value is lazy and enters block
ok 75 - Iteration variables do not need to add up if one is optional
ok 76 - RT  \#78232
ok 77 - Lazy lists interact properly with multi-element for loops
ok 78 - for-loop as last statement returns Nil
ok 79 - Can use statement-modifying "for" in list comprehension
ok 80 - assigning list comprehension to sigilless works (1)
ok 81 - assigning list comprehension to sigilless works (2)
ok 82 - iterating over an expanding list
ok 83 - array expanded in for loop is expanded
ok 84 - $_ is read-only here
ok 85 - ... and $_ is *always* read-only here
ok 86 - for in called method runs (was a sink context bug)
ok 87 - 
ok 88 - Anon sub inside for works.
ok 89 - for-loop as last statement returns Nil
ok 90 - is rw on slurpy parameters works (1)
ok 91 - is rw on slurpy parameters works (2)
ok 92 - is rw on slurpy parameters works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Multi::NoMatch)
ok 93 - did we throws-like X::Multi::NoMatch?
ok 94 - $0 works in substitution in for loop (1)
ok 95 - $0 works in substition in for loop (2)
ok 96 - .WHICH value did not change in for loop
ok 97 - substitution with backreferences in for loop
ok 98 - substitution with backreferences outside of loop
ok 99 - substitution with backreferences inside of loop
ok 100 - for loops do not decontainerize
ok 101 - topic of for loop has correct value in ("{$_}") construct
ok 102 - for loop properly sinks final statement method call
    1..4
    ok 1 - just a for with Range
    ok 2 - 1 at a time, no phasers, non slippy
    ok 3 - two at a time, no phasers, non slippy
    ok 4 - 
ok 103 - next with label works inside list comprehended for loops
ok 104 - for statement sinks its content
ok 105 - Lazy for loop does not execution until asked for values
ok 106 - Lazy for loop produces correct values on demand
ok 107 - Lazy for loop does no more work than required
ok 108 - holes are mutable (for @a)
ok 109 - holes were changed correctly (for @a)
ok 110 - holes are mutable (for @a[*])
ok 111 - holes were changed correctly (for @a[*])
# FUDGED!
1..39
ok 1 - not yet gathered
ok 2 - 5 elements gathered
ok 3 - gather code executed
ok 4 - first elem taken
ok 5 - last elem taken
ok 6 - nested gather works (two levels)
ok 7 - nested gather works (three levels)
ok 8 - take on lists and multiple takes work
ok 9 - gather scopes dynamically, not lexically
ok 10 - gather array-refs
ok 11 - gather as a statement_prefix
ok 12 - gather is lazy
ok 13 - gather with nested while
ok 14 - gather with nested loop
ok 15 - take with multiple arguments produces one item each
ok 16 - take with multiple arguments .flat tens out
ok 17 - Nested identical gathers
ok 18 - Elements in gather/take stringify correctly
ok 19 - decontainerization happens (1)
ok 20 - decontainerization happens (2)
ok 21 - method form of take works.
ok 22 - return value of take
ok 23 - first example in S04-control.pod works
ok 24 - take in flat context flattens
ok 25 - take in item context doesn't flatten
ok 26 - .flat flattens fully into a list of Ints.
ok 27 - gather/take does not flatten out sublists
ok 28 - a list of Lists, as an item.
ok 29 - # SKIP RT  \#66820, and hangs under GLR
ok 30 - # SKIP RT  \#66820, and hangs under GLR
ok 31 - Neighbor is same object as in grid
ok 32 - There are eight neighbors
    1..4
    ok 1 - 'say (gather for 1..3 { INIT take "OH HAI"; take $_ })' died
    ok 2 - right exception type (X::ControlFlow)
    ok 3 - .illegal matches take
    ok 4 - .enclosing matches gather
ok 33 - "INIT take" inside of a "gather for" fails with X::ControlFlow
ok 34 - take on a listy expression takes each element of that list
ok 35 - AT-POS on gather Seq with take-rw value lives
ok 36 - AT-POS on gather Seq with take-rw value works
ok 37 - Got the value equality expected from take-rw
ok 38 - Got the reference equality expected from take-rw
ok 39 - take inside m:g runs the expected number of times
# FUDGED!
1..10
not ok 1 - non-compiling test # TODO lazy in not there yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/lazy.rakudo line 25
not ok 2 - non-compiling test # TODO lazy in not there yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/lazy.rakudo line 25
not ok 3 - non-compiling test # TODO lazy in not there yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/lazy.rakudo line 25
not ok 4 - non-compiling test # TODO lazy in not there yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/lazy.rakudo line 25
not ok 5 - non-compiling test # TODO lazy in not there yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/lazy.rakudo line 25
not ok 6 - non-compiling test # TODO lazy in not there yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/lazy.rakudo line 37
not ok 7 - non-compiling test # TODO lazy in not there yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/lazy.rakudo line 37
not ok 8 - non-compiling test # TODO lazy in not there yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/lazy.rakudo line 49
not ok 9 - non-compiling test # TODO lazy in not there yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/lazy.rakudo line 49
    1..2
    ok 1 - '(lazy { 43 }) = 23 ' died
    not ok 2 - right exception type (X::Assignment::RO) # TODO lazy in not there yet
    # Failed test 'right exception type (X::Assignment::RO)'
    # at SETTING::src/core.c/Exception.pm6 line 62
    # Expected: X::Assignment::RO
    # Got:      X::Method::NotFound
    # Exception message: No such method 'lazy' for invocant of type 'Int'.  Did you mean any of
    # these: 'any', 'say'?
not ok 10 - assigning to a lazily computed value does not work # TODO lazy in not there yet
# Failed test 'assigning to a lazily computed value does not work'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/lazy.rakudo line 53
# FUDGED!
1..23
not ok 1 - non-compiling test # TODO leave is not implemented yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 20
not ok 2 - non-compiling test # TODO leave is not implemented yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 212
not ok 3 - non-compiling test # TODO leave is not implemented yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 212
not ok 4 - non-compiling test # TODO leave is not implemented yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 212
not ok 5 - non-compiling test # TODO leave is not implemented yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 212
not ok 6 - non-compiling test # TODO leave is not implemented yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 212
not ok 7 - non-compiling test # TODO leave is not implemented yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 212
not ok 8 - non-compiling test # TODO leave is not implemented yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 212
not ok 9 - non-compiling test # TODO leave is not implemented yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 212
not ok 10 - non-compiling test # TODO leave is not implemented yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 212
not ok 11 - non-compiling test # TODO leave is not implemented yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 212
not ok 12 - non-compiling test # TODO leave is not implemented yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 212
not ok 13 - non-compiling test # TODO leave is not implemented yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 212
not ok 14 - non-compiling test # TODO leave is not implemented yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 212
not ok 15 - non-compiling test # TODO leave is not implemented yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 212
not ok 16 - non-compiling test # TODO leave is not implemented yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 212
not ok 17 - non-compiling test # TODO leave is not implemented yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 212
not ok 18 - non-compiling test # TODO leave is not implemented yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 212
not ok 19 - non-compiling test # TODO leave is not implemented yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 212
not ok 20 - non-compiling test # TODO leave is not implemented yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 212
not ok 21 - non-compiling test # TODO leave is not implemented yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 212
not ok 22 - non-compiling test # TODO leave is not implemented yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 212
not ok 23 - non-compiling test # TODO leave is not implemented yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 212
# FUDGED!
1..32
ok 1 - Hypothetical variable capture
ok 2 - Hypothetical variable captured
ok 3 - # SKIP Package variable capture RT  \#125122
ok 4 - # SKIP Package variable capture RT  \#125122
ok 5 - Reverse capture
ok 6 - $0 captured
ok 7 - $1 captured
ok 8 - Compound hypothetical capture
ok 9 - Implicit hypothetical variable captured
ok 10 - Explicit hypothetical variable captured
not ok 11 - Mixed capture # TODO Package variable capture RT #125122
# Failed test 'Mixed capture'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-capture/alias.rakudo line 45
not ok 12 - Implicit hypothetical variable captured # TODO Package variable capture RT #125122
# Failed test 'Implicit hypothetical variable captured'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-capture/alias.rakudo line 46
# expected: 'bc'
#      got: ''
not ok 13 - Explicit package variable captured # TODO Package variable capture RT #125122
# Failed test 'Explicit package variable captured'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-capture/alias.rakudo line 47
# expected: 'bc'
#      got: ''
ok 14 - Standard captures
ok 15 - Captured <?alpha>
ok 16 - Captured <?ident>
ok 17 - Repeated standard captures
ok 18 - Captured $first
ok 19 - Captured $family
ok 20 - Captured <ident>
ok 21 - Pair match
ok 22 - Key match
ok 23 - Value match
ok 24 - Pair match
ok 25 - Reverse key match
ok 26 - Reverse value match
ok 27 - Capture starting at non-zero
ok 28 - Capture starting at non-zero, explicit
ok 29 - Capture starting at non-zero, incremented once
ok 30 - Capture starting at non-zero, incremented twice
ok 31 - Correct match of $<cat>=@(...) construct
ok 32 - Correct capture of $<cat>=@(...) construct
# FUDGED!
1..50
ok 1 - Named simple array capture
ok 2 - Captured strings
ok 3 - Sequential simple array capture
ok 4 - First captured strings
ok 5 - Last captured strings
ok 6 - Repeated hypothetical array capture
ok 7 - Hypothetical variable captured
ok 8 - No extra captures
ok 9 - Hypothetical array capture
ok 10 - Hypothetical variable captured
ok 11 - # SKIP capturing to lexical variable NYI RT  \#126243
ok 12 - # SKIP capturing to lexical variable NYI RT  \#126243
ok 13 - # SKIP capturing to lexical variable NYI RT  \#126243
ok 14 - # SKIP capturing to lexical variable NYI RT  \#126243
ok 15 - # SKIP capturing to lexical variable NYI RT  \#126243
ok 16 - Compound hypothetical capture
ok 17 - Implicit hypothetical variable captured -- lives-ok
ok 18 - Implicit hypothetical variable captured -- retval is correct
ok 19 - Explicit hypothetical variable captured
ok 20 - Nested array capture
ok 21 - Outer array capture
ok 22 - Inner array capture
ok 23 - Subrule array capture
ok 24 - Outer rule array capture
ok 25 - Final subrule array capture
ok 26 - Nested subrule array capture
ok 27 - Outer rule nested array capture
ok 28 - Subrule array capture
ok 29 - Nested multiple array capture
ok 30 - Multiple capture to nested array
ok 31 - Multiple capture count
ok 32 - Multiple capture to nested AoA[0]
ok 33 - Multiple capture to nested AoA[2]
ok 34 - Multiple capture to nested AoA[3]
ok 35 - Multiple capture value of nested AoA[0][0]
ok 36 - Multiple capture value of nested AoA[0][1]
ok 37 - Multiple capture value of nested AoA[1][0]
ok 38 - Multiple capture value of nested AoA[1][1]
ok 39 - Multiple capture value of nested AoA[2][0]
ok 40 - Multiple capture value of nested AoA[2][1]
ok 41 - # SKIP capturing to lexical variable NYI RT  \#126243
ok 42 - # SKIP capturing to lexical variable NYI RT  \#126243
ok 43 - # SKIP capturing to lexical variable NYI RT  \#126243
ok 44 - # SKIP capturing to lexical variable NYI RT  \#126243
ok 45 - # SKIP capturing to lexical variable NYI RT  \#126243
ok 46 - no error with array alias and list-quantified subpattern (1)
ok 47 - ... and correct result
ok 48 - no error with array alias and list-quantified subpattern (2)
ok 49 - ... and correct result
ok 50 - array alias works with quantified non-capturing structure
# FUDGED!
1..61
ok 1 - Match
ok 2 - Matched
ok 3 - Captured
ok 4 - $/[0]
ok 5 - $0
ok 6 - $/[1]
ok 7 - $1
ok 8 - no $/[2]
ok 9 - no $2
ok 10 - no $/<dotdot>
ok 11 - Match
ok 12 - Matched
ok 13 - Captured
ok 14 - $/[0]
ok 15 - $0
ok 16 - $/[1]
ok 17 - $1
ok 18 - $/[2]
ok 19 - $2
ok 20 - $/<dotdot>
ok 21 - $/<dotdot>[0]
ok 22 - $/<dotdot>[1]
ok 23 - $/<dotdot>[2]
ok 24 - Nested captured
ok 25 - Nested $0
ok 26 - Nested $1
ok 27 - Nested $2
ok 28 - Nested $3
ok 29 - Backreference
ok 30 - Captured
ok 31 - Captured
ok 32 - Correct semantics of contiguous captures in backref
ok 33 - Backtracking and backref interaction resulted in correct capture
not ok 34 - Named backref # TODO dubious test RT #125004
# Failed test 'Named backref'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-capture/dot.rakudo line 71
not ok 35 - Named capture # TODO dubious test RT #125004
# Failed test 'Named capture'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-capture/dot.rakudo line 72
# expected: 'o'
#      got: ''
not ok 36 - Backref capture # TODO dubious test RT #125004
# Failed test 'Backref capture'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-capture/dot.rakudo line 73
# expected: 'o'
#      got: ''
not ok 37 - Positional backref # TODO dubious test RT #125005
# Failed test 'Positional backref'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-capture/dot.rakudo line 77
not ok 38 - Named capture # TODO dubious test RT #125005
# Failed test 'Named capture'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-capture/dot.rakudo line 78
# expected: 'o'
#      got: ''
not ok 39 - Backref capture # TODO dubious test RT #125005
# Failed test 'Backref capture'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-capture/dot.rakudo line 79
# expected: 'o'
#      got: ''
ok 40 - Failed positional backref
ok 41 - Failed named backref
ok 42 - Non-translation of non-interpolated "\$0"
ok 43 - Non-translation of non-interpolated '$0'
ok 44 - Non-translation of non-interpolated q{$0}
ok 45 - Non-translation of non-interpolated q[$0]
ok 46 - Non-translation of non-interpolated q<$0>
ok 47 - Non-translation of non-interpolated q/$0/
ok 48 - Non-translation of non-interpolated q!$0!
ok 49 - Non-translation of non-interpolated q|$0|
ok 50 - English name
ok 51 - Match is john
ok 52 - Match isn't jean
ok 53 - French name
ok 54 - Match is jean
ok 55 - Russian name
ok 56 - Match is ivan
ok 57 - English metaname
ok 58 - Metaname match is john
ok 59 - Metaname match isn't jean
ok 60 - Metaname is john
ok 61 - Can refer to very high numbered capture variable without exploding
# FUDGED!
1..47
ok 1 - match successful
ok 2 - got right type
ok 3 - .Bool
ok 4 - .defined
ok 5 - .Str
ok 6 - .from
ok 7 - .to
ok 8 - .prematch
ok 9 - .postmatch
ok 10 - .list (empty)
ok 11 - .hash (empty)
ok 12 - .keys (empty)
ok 13 - .values (empty)
ok 14 - .pairs (empty)
ok 15 - .kv (empty)
ok 16 - .Int with small value
ok 17 - .Int with big value
ok 18 - sanity 1
ok 19 - sanity 2
ok 20 - .prematch for zero-width matches
ok 21 - .postmatch for zero-width matches
ok 22 - .prematch produces a Str
ok 23 - .postmatch produces a Str
ok 24 - no match
ok 25 - failed match is False
ok 26 - false match stringifies to empty string
ok 27 - === of different match objects
ok 28 - === of different but similar match objects
ok 29 - === of one and the same match object
ok 30 - eqv of different match objects
ok 31 - eqv of different but similar match objects
ok 32 - :$<foo> returns a pair
ok 33 - its key is "foo"
ok 34 - the pairs value is a defined match object
ok 35 - current match state
ok 36 - got right type
ok 37 - .pos
ok 38 - $/.keys returns both positional and associative captures
    1..2
    ok 1 - return value is a Match object
    ok 2 - return value contains right result
ok 39 - can smartmatch against regexes stored in variables
ok 40 - sanity
ok 41 - non-Str orig
ok 42 - .prematch on non-Str
ok 43 - .postmatch on non-Str
ok 44 - sanity
not ok 45 - .orig retains the type (NFD) # TODO $/.orig on NFD matches
# Failed test '.orig retains the type (NFD)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-capture/match-object.rakudo line 98
# Actual type: Str
ok 46 - NFD: $/ is set in Regex.ACCEPTS
    1..8
    ok 1 - &infix:<~~>
    ok 2 - Str.match
    ok 3 - Cool.match
    ok 4 - Str.subst
    ok 5 - Cool.subst
    ok 6 - Grammar.parse
    ok 7 - Grammar.subparse
    ok 8 - Grammar.parse-file
ok 47 - $/ is set when matching in a loop
# FUDGED!
1..11
ok 1 - named rule ordinal capture
ok 2 - named rule ordinal capture with abbreviated variable
ok 3 - $/.orig works
ok 4 - named rule named capture
ok 5 - named rule named capture with abbreviated variable
ok 6 - # SKIP assigning to match object
ok 7 - # SKIP assigning to match object
ok 8 - grammar sanity
ok 9 - right keys in top level match
ok 10 - $<b> has no captures
ok 11 - can capture inside a || alternation even if previous capture was quantified (RT  \#107746)
# FUDGED!
1..8
ok 1 - call rule with positional argument
ok 2 - call rule with positional argument
ok 3 - call rule with named argument
ok 4 - call rule with named argument
ok 5 - read token from grammar namespace
ok 6 - # SKIP Method "speaker" not found for invocant of class "Cursor"
ok 7 - # SKIP Method "speaker" not found for invocant of class "Cursor"
ok 8 - lookbehind that should not match does not match
# FUDGED!
1..35
not ok 1 - don't let a Mu based action method fail the parse # TODO RT #77350
# Failed test 'don't let a Mu based action method fail the parse'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-grammar/inheritance.rakudo line 17
# expected: 'so'
#      got: (Nil)
ok 2 - got right match (foo)
ok 3 - got the right match through .parse TOP
ok 4 - got the right match through .parse foo
ok 5 - grammar isa Grammar
ok 6 - inherited grammar still isa Grammar
ok 7 - child isa parent
ok 8 - got right match (bar)
ok 9 - got right match (foo)
ok 10 - got right match (any)
ok 11 - got right match (any)
ok 12 - can parse foo through .parsed and inherited subrule
ok 13 - got right match (bar)
ok 14 - got right match (foo)
ok 15 - got right match (any)
ok 16 - got right match (any)
ok 17 - No match for bad input (any)
ok 18 - got right match
ok 19 - got right match
ok 20 - got right match
ok 21 - got right match
ok 22 - got right match
ok 23 - got right match
ok 24 - got right match (baz)
ok 25 - got right match (foo)
ok 26 - got right match (bar)
ok 27 - got right match (any)
ok 28 - got right match (any)
ok 29 - got right match (any)
ok 30 - No match for bad input (any)
not ok 31 - A grammar isa Grammar, even if inherting from a class # TODO automatic Grammar superclass
# Failed test 'A grammar isa Grammar, even if inherting from a class'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-grammar/inheritance.rakudo line 70
# Actual type: B
ok 32 - Grammar.WHAT.gist = Grammar()
ok 33 - did the array initialize ok
ok 34 - does it have the right type
ok 35 - does it type check ok
# FUDGED!
1..31
ok 1 - can parse with proto regexes (1)
ok 2 - and matched the full string
ok 3 - got the right name of the capture
ok 4 - also works with $/
ok 5 - can parse with second alternative
ok 6 - can parse third second alternative
ok 7 - does not match sym of third alternative
ok 8 - does not match completely unrelated string
ok 9 - does not match empty string
ok 10 - can parse symbol inside double-angles
ok 11 - can parse with action methods
ok 12 - action method got called, make() worked
ok 13 - LTM picks longest literal
ok 14 - LTM picks longest with char classes
ok 15 - ...and it not just luck with ordering
ok 16 - LTM works with things like \d
ok 17 - ...and negated ones like \W
ok 18 - LTM and ? quantifier
ok 19 - LTM, ? and + quantifiers
ok 20 - LTM and * quantifier
ok 21 - :my declarations do not terminate LTM
ok 22 - Positional captures do not terminate LTM
ok 23 - Named captures do not terminate LTM
ok 24 - <?{...}> does not terminate LTM
ok 25 - <!{...}> does not terminate LTM
ok 26 - However, code blocks do terminate LTM
ok 27 - num parse
ok 28 - id parse
ok 29 - term parse
not ok 30 - <ident> override # TODO RT #120146
# Failed test '<ident> override'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-grammar/protoregex.rakudo line 146
# expected: '-my_id'
#      got: ''
not ok 31 - <ident> alias # TODO RT #120146
# Failed test '<ident> alias'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-grammar/protoregex.rakudo line 147
# expected: '-my_id'
#      got: ''
# FUDGED!
1..12
ok 1 - basic sanity with custom <ws> rules
ok 2 - correct text captured
ok 3 - implicit <.ws> is overridden
ok 4 - implicit <.ws> did not capture
ok 5 - explicit <.ws> is overridden
ok 6 - explicit <.ws> did not capture
ok 7 - explicit  <ws> is overridden
ok 8 - explicit  <ws> did capture
ok 9 - match <ws>  against empty string
ok 10 - match <ws>? against empty string
ok 11 - # SKIP infinite loop: RT  \#64094 (noauto)
ok 12 - # SKIP infinite loop: RT  \#64094 (noauto)
# FUDGED!
1..65
ok 1 - Simple scalar match 1
ok 2 - Simple scalar match 2
ok 3 - Simple scalar match 3
ok 4 - Nested scalar match 1
ok 5 - Nested scalar match 2
ok 6 - Nested scalar match 3
ok 7 - Rulish scalar match 1
ok 8 - Rulish scalar match 2
ok 9 - Rulish scalar match 3
ok 10 - Rulish scalar match 4
ok 11 - Rulish scalar match 5
ok 12 - Rulish scalar match 6
ok 13 - Rulish scalar match 7
ok 14 - match with string as rx works
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::SecurityPolicy)
ok 15 - particular garbage-in recognized as being garbage (see RT)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::SecurityPolicy)
ok 16 - dynamic lookups are restricted regex syntax
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 17 - dynamic longname lookups are restricted regex syntax
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 18 - dynamic longname lookups are restricted regex syntax (::)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 19 - dynamic longname lookups are restricted regex syntax (2)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 20 - dynamic regex aliases fail somehow
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Syntax::Regex::Alias::LongName)
ok 21 - dynamic regex longname aliases fail specifically
ok 22 - returns true
ok 23 - returns a valid Match
ok 24 - returns correct Match
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::SecurityPolicy)
ok 25 - should handle this too
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::SecurityPolicy)
ok 26 - should handle this too
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::SecurityPolicy)
ok 27 - should handle this too
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::SecurityPolicy)
ok 28 - should handle this too
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::SecurityPolicy)
ok 29 - should handle this too
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::SecurityPolicy)
ok 30 - should handle this too
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::SecurityPolicy)
ok 31 - should handle this too
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::SecurityPolicy)
ok 32 - should handle this too
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::SecurityPolicy)
ok 33 - should handle this too
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::SecurityPolicy)
ok 34 - should handle this too
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::SecurityPolicy)
ok 35 - should handle this too
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::SecurityPolicy)
ok 36 - should handle this too
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::SecurityPolicy)
ok 37 - should handle this too
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::SecurityPolicy)
ok 38 - should handle this too
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Syntax::Regex::Alias::LongName)
ok 39 - longname aliases fail specifically (unrestricted ::)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Syntax::Regex::Alias::LongName)
ok 40 - dynamic longname aliases fail specifically (unrestricted ::)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Syntax::Regex::Alias::LongName)
ok 41 - longname aliases fail specifically (unrestricted)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Syntax::Regex::Alias::LongName)
ok 42 - dynamic longname aliases fail specifically (unrestricted)
ok 43 - Simple array match (a)
ok 44 - Simple array match (b)
ok 45 - Simple array match (c)
ok 46 - Simple array match (d)
ok 47 - Simple array match (!)
ok 48 - Nested array match (a)
ok 49 - Nested array match (e)
ok 50 - Match from correct position
ok 51 - Multiple array matching
ok 52 - Multiple array non-matching
ok 53 - Multiple array non-compiling
ok 54 - Multiple array compiling
ok 55 - Multiple array non-compiling
ok 56 - Multiple array compiling
    1..2
    ok 1 - '/%var/' died
    ok 2 - right exception type (X::Syntax::Reserved)
ok 57 - cannot interpolate hashes into regexes
    1..2
    ok 1 - 'm/%var/' died
    ok 2 - right exception type (X::Syntax::Reserved)
ok 58 - cannot interpolate hashes into regexes
    1..2
    ok 1 - 'my $x = { a => 1 }; "a" ~~ m/$x/' died
    ok 2 - right exception type (X::Syntax::Reserved)
ok 59 - cannot interpolate hashes into regexes, runtime
    1..2
    ok 1 - 'my $x := { a => 1 }; "a" ~~ m/$x/' died
    ok 2 - right exception type (X::Syntax::Reserved)
ok 60 - cannot interpolate hashes into regexes, runtime (binding)
ok 61 - undefined variable does not match
not ok 62 - interpolating undefined into a regex warns # TODO warn on undef
# Failed test 'interpolating undefined into a regex warns'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-interpolation/regex-in-variable.rakudo line 136
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Attribute::Regex)
    ok 3 - .symbol matches $!a
ok 63 - Cannot interpolate attribute in a regex
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Attribute::Regex)
    ok 3 - .symbol matches $!b
ok 64 - Cannot interpolate attribute in a regex in angle construct
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Attribute::Regex)
    ok 3 - .symbol matches $!c
ok 65 - Cannot interpolate attribute in a closure in a regex
# FUDGED!
1..19
ok 1 - Can match in an if block
ok 2 - ... and can use the match var
ok 3 - $/ is a dynamic lexical, so it is set outside that block.
ok 4 - Can match in a while block
ok 5 - ... and can use the match var
ok 6 - Can match in a bare block
ok 7 - ... and can use the match var
ok 8 - Can match in a do block
ok 9 - ... and can use the match var
ok 10 - Can match in the condition of a while loop
ok 11 - ... and can use $/ in the block
not ok 12 - ... and can use $/ outside the block # TODO Assignment to matched string affects earlier match objects
# Failed test '... and can use $/ outside the block'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-match/blocks.rakudo line 54
# expected: 'b'
#      got: ''
ok 13 - Can match in the condition of an if statement
ok 14 - ... and can use $/ outside the block
ok 15 - $/ is properly set with explicit $_ in a given { } block
ok 16 - $/ is properly set in a given { } block
ok 17 - /foo/ matched against $_ (successfully)
ok 18 - /not/ matched against $_ (no match)
ok 19 - match in /if/;
# FUDGED!
1..64
ok 1 - Match object returned
ok 2 - Match object assigned to $/
ok 3 - Same match objects
ok 4 - Failed match returns Nil
ok 5 - positional capture accessible
ok 6 - array context - correct number of positional captures
ok 7 - array context - correct number of positional captures
ok 8 - the .list methods returns a list object
ok 9 - named capture accessible
ok 10 - hash context - correct number of named captures
ok 11 - hash context - named capture accessible
ok 12 - the .hash method returns a hash object
ok 13 - get rule result
ok 14 - match copy should be same as match
ok 15 - match list stringifies like a normal list
ok 16 - ... and it is Positional
ok 17 - match list stringifies like a normal list AFTER "isa"
ok 18 - match element [0][0] from /(.)+/
ok 19 - match element [0][1] from /(.)+/
ok 20 - match element [0][0] from /(.)+/ coerced
ok 21 - match element [0][1] from /(.)+/ coerced
ok 22 - Match coerced to Hash says match exists
ok 23 - undefined capture does not match
not ok 24 - match with undefined capture emits a warning # TODO referring to non-existing capture
# Failed test 'match with undefined capture emits a warning'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-match/capturing-contexts.rakudo line 94
ok 25 - Match object in $/ after match in void context
ok 26 - Matched as intended in void context
ok 27 - rindex() works on $/.orig
ok 28 - rindex() works on $/.orig
ok 29 - can bind $/
ok 30 - $0 works like $/[0], even for non-Match objects
ok 31 - $1 is not defined
ok 32 - $0 accessible when $/ is undefined
ok 33 - $0 is Any when $/ is undefined
ok 34 - $0 is undefined
ok 35 - regex sanity
ok 36 - $/.list does not flatten quantified subcaptures
ok 37 - regex sanity
ok 38 - $/.list does not flattens subcaptures
ok 39 - alphabetic characters can follow digits in $0 variable in interpolation
ok 40 - alphabetic characters follows $0 interpolated value
ok 41 - match multiple lines with '.'
ok 42 - Match has a .lines method
ok 43 - Correct number of lines
ok 44 - Match is Cool
ok 45 - quantifier ? matching 0 values returns Nil
ok 46 - quantifier * matching 0 values returns empty list
ok 47 - (non-)capturing subrules advance cursor position (1)
ok 48 - (non-)capturing subrules advance cursor position (2)
ok 49 - (non-)capturing subrules advance cursor position (3)
ok 50 - (non-)capturing subrules advance cursor position (4)
ok 51 - result of match assigned to variable matched against works
ok 52 - Reassigning to matched-against string and then accessing submatches works
ok 53 - Correct number of captures when backtracking (1)
ok 54 - Correct number of captures when backtracking (2)
ok 55 - LTM alternation does not capture the wrong stuff when backtracking (1)
ok 56 - LTM alternation does not capture the wrong stuff when backtracking (2)
    1..3
    not ok 1 - postfix -- # TODO parse error with --
    # Failed test 'postfix --'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-match/capturing-contexts.rakudo line 227
    # expected: '5--'
    #      got: '5x3[0]--'
    not ok 2 - postfix ++ # TODO parse error with --
    # Failed test 'postfix ++'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-match/capturing-contexts.rakudo line 228
    # expected: '5++'
    #      got: '5x3[0]++'
    not ok 3 - custom postfix `foo` # TODO parse error with --
    # Failed test 'custom postfix `foo`'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-match/capturing-contexts.rakudo line 231
    # expected: '5foo'
    #      got: '5x3[0]foo'
ok 57 - postfix operators do not interfere with interpolation of $/[0]
ok 58 - non-ascii tokens in a grammar work
ok 59 - non-ascii token in a subcapture work
ok 60 - Unicode digit match variables work
ok 61 - .Bool on failed Match returns False
ok 62 - .Bool on succesful Match returns True
ok 63 - .Bool on Match:U is False
    1..12
    ok 1 - 1
    ok 2 - 2
    ok 3 - 3
    ok 4 - 4
    ok 5 - 5
    ok 6 - 6
    ok 7 - <foo> (grammar 1)
    ok 8 - <bar> (grammar 1)
    ok 9 - <ber> (grammar 1)
    ok 10 - <foo> (grammar 2)
    ok 11 - <bar> (grammar 2)
    ok 12 - <ber> (grammar 2)
ok 64 - capture markers work correctly
# FUDGED!
1..10
ok 1 - Regex matches (1)
ok 2 - $/.raku lives (with named captures
ok 3 - ... and it reproduces the right thing (1)
ok 4 -  right result (2)
ok 5 - Regex matches (2)
ok 6 - lives on quantified named captures
ok 7 - # SKIP <foo::bar>
ok 8 - # SKIP <foo::bar>
ok 9 - # SKIP <foo::bar>
ok 10 - # SKIP <foo::bar>
# FUDGED!
1..12
ok 1 - can match and execute a closure
ok 2 - could access and update outer lexicals
ok 3 - # SKIP assignment to match variables (dubious)
ok 4 - # SKIP assignment to match variables (dubious)
ok 5 - Outer match
ok 6 - Outer caught
ok 7 - # SKIP assignment to match variables (dubious)
ok 8 - # SKIP assignment to match variables (dubious)
ok 9 - # SKIP assignment to match variables (dubious)
ok 10 - Zero match
not ok 11 - Zero matched # TODO make() inside closure
# Failed test 'Zero matched'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-metachars/closure.rakudo line 47
# expected: 'BC'
#      got: 'abc'
ok 12 - One matched
# FUDGED!
1..95
ok 1 - leading whitespace quotes words (space)
ok 2 - leading whitespace quotes words (tab)
    1..2
    ok 1 - '"aaaa" ~~ /<a aa>/' died
    ok 2 - right exception type (X::Method::NotFound)
ok 3 - <...> without whitespace calls a method (not quote words)
ok 4 - degenerate case of quote list
ok 5 - capturing grammatical assertion (1)
ok 6 - capturing grammatical assertion (2)
ok 7 - can call regexes which dashes (positive)
ok 8 - can call regexes which dashes (negative)
ok 9 - can call regex with hypen (positive)
ok 10 - can call regex with hypen (negative)
ok 11 - # SKIP <test()> NYI
ok 12 - # SKIP <test()> NYI
ok 13 - basic <foo=bar> aliasing
ok 14 - alias works
ok 15 - alias does not throw away original name
ok 16 - basic <foo=.bar> aliasing
ok 17 - alias works
ok 18 - alias does throw away original name
ok 19 - <foo=.bar>
ok 20 - =. renaming worked
ok 21 - =. removed the old capture name
ok 22 - <foo=[bao]>
ok 23 - =[...] renaming worked
ok 24 - <bar=-[bao]>
ok 25 - =[...] renaming worked
ok 26 - <foo=:Letter>
ok 27 - =:UniProp renaming worked
ok 28 - <bar=:!Letter>
ok 29 - =:!UniProp renaming worked
ok 30 - <baz=-:Letter>
ok 31 - =-:UniProp renaming worked
ok 32 - # SKIP angle quotes in regexes
ok 33 - # SKIP angle quotes in regexes
ok 34 - # SKIP colon arguments NYI
    1..2
    ok 1 - '"foo" ~~ /<test*>/' died
    ok 2 - right exception type (Exception)
ok 35 - no other characters are allowed (*)
    1..2
    ok 1 - '"foo" ~~ /<test|>/' died
    ok 2 - right exception type (Exception)
ok 36 - no other characters are allowed (|)
    1..2
    ok 1 - '"foo" ~~ /<test&>/' died
    ok 2 - right exception type (Exception)
ok 37 - no other characters are allowed (&)
    1..2
    ok 1 - '"foo" ~~ /<test:>/' died
    ok 2 - right exception type (Exception)
ok 38 - no other characters are allowed (:)
ok 39 - leading . prevents capturing
ok 40 - <.$foo> syntax placeholder
ok 41 - <$whatever> subrule (Regex, 1)
ok 42 - <$whatever> subrule (String, 1)
ok 43 - <$whatever> subrule (Regex, 2)
ok 44 - <$whatever> subrule (String, 2)
ok 45 - <::($name)> symbolic indirect subrule
ok 46 - strings are treated as a subrule in <@foo>
ok 47 - Regexes are left alone in <@foo> subrule
ok 48 - # SKIP The use of a hash as an assertion is reserved.
ok 49 - # SKIP The use of a hash as an assertion is reserved.
ok 50 - code interpolation
ok 51 - # SKIP <&foo()> NYI
ok 52 - code inside string was executed
not ok 53 - string value was cached # TODO <$subrule> NYI
# Failed test 'string value was cached'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-metasyntax/angle-brackets.rakudo line 215
# expected: '1'
#      got: '2'
ok 54 - <?{...}> works
ok 55 - <?{...}> works
ok 56 - <!{...}> works
ok 57 - <!{...}> works
ok 58 - Can use contextuals with <?{...}>
ok 59 - <!alpha> matches non-letter characters
ok 60 - <!alpha> does not match letter characters
ok 61 - <!before>
ok 62 - <!before 2> does not capture
ok 63 - positive zero-width assertion
    1..2
    ok 1 - '"foo" ~~ /<...>/' died
    ok 2 - right exception type (Exception)
ok 64 - <...> dies in regex match
ok 65 - <???> lives in regex match
    1..2
    not ok 1 - '"foo" ~~ /<!!!>/' died # TODO !!! in regexes
    # Failed test ''"foo" ~~ /<!!!>/' died'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-metasyntax/angle-brackets.rakudo line 259
    ok 2 - # SKIP Code did not die, can not check exception
not ok 66 - <!!!> dies in regex match # TODO !!! in regexes
# Failed test '<!!!> dies in regex match'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-metasyntax/angle-brackets.rakudo line 259
ok 67 - # SKIP <*literal>
ok 68 - # SKIP <*literal>
ok 69 - # SKIP <*literal>
ok 70 - # SKIP <*literal>
ok 71 - # SKIP <*literal>
ok 72 - # SKIP <*literal>
ok 73 - # SKIP <*literal>
ok 74 - # SKIP <*literal>
ok 75 - # SKIP <*literal>
ok 76 - # SKIP <*literal>
ok 77 - # SKIP <*literal>
ok 78 - recursive regex using whole pattern
ok 79 - # SKIP <~~ ... >
ok 80 - <(...)> pair
ok 81 - <( match
ok 82 - )> match
ok 83 - non-matching <(...)>
ok 84 - <( in backtracking
ok 85 - multiple <(
ok 86 - multiple <( backtracking
ok 87 - .comb works well with <( )> (1)
ok 88 - .comb works well with <( )> (2)
ok 89 - .match :as(Str) works with <( )>
ok 90 - left word boundary (string beginning)
ok 91 - left word boundary (\W character)
ok 92 - right word boundary (string end)
ok 93 - right word boundary (\W character)
ok 94 - both word boundaries (\W character)
ok 95 - Interaction of quantifier, <(, )>, and action method ok
# FUDGED!
1..10
ok 1 - Rule block second
ok 2 - Rule block first
not ok 3 - Rule block fail # TODO dunno rule block fail
# Failed test 'Rule block fail'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-metasyntax/interpolating-closure.rakudo line 29
ok 4 - Rule block interp
ok 5 - interpolating string with meta characters
ok 6 - ... gives the right match
ok 7 - sequence in a closure interpolates ok
ok 8 - scoping of variable in regex generated from <{}> metasyntax
ok 9 - stage of variable in regex generated from <{}> metasyntax
ok 10 - stage of variable in regex generated from <{}> metasyntax (2)
# FUDGED!
1..62
ok 1 - basic sanity with |
ok 2 - Longest alternative wins 1
ok 3 - Second match still works
ok 4 - Longest alternative wins 2
ok 5 - Third match still works
ok 6 - Only one alternative left
ok 7 - No fourth match
ok 8 - basic sanity with |, different order
ok 9 - Longest alternative wins 1, different order
ok 10 - Second match still works, different order
ok 11 - Longest alternative wins 2, different order
ok 12 - Third match still works, different order
ok 13 - Only one alternative left, different order
ok 14 - No fourth match, different order
ok 15 - basic sanity with interpolated arrays
ok 16 - Longest alternative wins 1
ok 17 - Second match still works
ok 18 - Longest alternative wins 2
ok 19 - Third match still works
ok 20 - Only one alternative left
ok 21 - No fourth match
ok 22 - LTM - literals in tokens
ok 23 - LTM - literals in nested torkens
ok 24 - LTM - longer quantified charclass wins against shorter literal
ok 25 - LTM - longer quantified atom wins against shorter literal (subrules)
ok 26 - LTM - literal wins tie against \w*
ok 27 - # SKIP :: LTM stopper
ok 28 - implicit <.ws> stops LTM
ok 29 - LTM grammar - matched
ok 30 - LTM grammar - matched full string
ok 31 - was in the appropriate action methods
ok 32 - longer non-matcher parses
ok 33 - longer non-matching literal doesn't falsify shorter
ok 34 - Galt parses
ok 35 - literal from non-matching alternating subrule doesn't interfere
ok 36 - Gproto parses
ok 37 - literal from non-matching proto subrule doesn't interfere
ok 38 - subrule alternation with recombo matches
ok 39 - subrule alternation recombination doesn't confuse fates
ok 40 - IETF::RFC_Grammar::URI matches
ok 41 - IETF::RFC_Grammar::URI gets ltm and longlit right
ok 42 - token with huge number of alternations does not explode when used many times
ok 43 - alternation with :i matches
ok 44 - got longest alternative with :i
ok 45 - alternation with :m matches
ok 46 - got longest alternative with :m
ok 47 - alternation with :i:m matches
ok 48 - got longest alternative with :i:m
ok 49 - got longest alternative with constant
ok 50 - non constants don't count toward LTM
ok 51 - sequential alternation first branch involved in longest alternative (1)
ok 52 - sequential alternation first branch involved in longest alternative (2)
ok 53 - sequential alternation first branch failure after LTM tries next best option
ok 54 - sequential alternation branches after first not involved in LTM
ok 55 - \r\n grapheme in an alternation matches correctly
not ok 56 - negative lookahead does LTM properly # TODO negative lookahead does not LTM properly
# Failed test 'negative lookahead does LTM properly'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-metasyntax/longest-alternative.rakudo line 461
# expected: 'abcde'
#      got: 'abcd'
ok 57 - LTM with :i, <[0..9]>, and repetition works
ok 58 - LTM with quantifier ** 1..2 followed by something else matches correctly
ok 59 - backtrack into |
ok 60 - don't backtrack into [ | ]:
ok 61 - don't backtrack into | under :r
ok 62 - backtrack into [ | ]:! despite :r
# FUDGED!
1..13
    1..2
    ok 1 - '"aa!" ~~ /!/' died
    ok 2 - right exception type (X::Syntax::Regex::UnrecognizedMetachar)
ok 1 - "!" is not valid metasyntax
ok 2 - escaped "!" is valid
ok 3 - quoted "!" is valid
    1..2
    ok 1 - '"aa!" ~~ /\a/' died
    ok 2 - right exception type (Exception)
ok 4 - escaped "a" is not valid metasyntax
ok 5 - "a" is valid
ok 6 - quoted "a" is valid
ok 7 - \{ in a rule (+)
ok 8 - \{ in a rule (-)
ok 9 - Cannot parse regex a+ +
not ok 10 - error message mentions quantif{y,ier} # TODO faulty regex error
# Failed test 'error message mentions quantif{y,ier}'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-metasyntax/unknown.rakudo line 28
    1..3
    ok 1 - '$_ = "0"; s/-/1/' died
    ok 2 - right exception type (X::Syntax::Regex::UnrecognizedMetachar)
    ok 3 - .metachar matches -
ok 11 - did we throws-like X::Syntax::Regex::UnrecognizedMetachar?
ok 12 - can parse /$'x'/
    1..3
    ok 1 - '/00:11:22/' died
    ok 2 - right exception type (X::Syntax::Regex::UnrecognizedModifier)
    ok 3 - .modifier matches 11
ok 13 - did we throws-like X::Syntax::Regex::UnrecognizedModifier?
# FUDGED!
1..24
ok 1 - substitute regexp works
ok 2 - substitute regexp works with :g modifier
ok 3 - substitute regexp works with :g modifier
ok 4 - substitute regexp with capturing variables works
ok 5 - substitute regexp with capturing variables works with :g
ok 6 - Zero width replace works with :g
ok 7 - s/// in boolean context properly defaults to $_
ok 8 - test the regular expression escape
not ok 9 - returned two values in the match # TODO NYI
# Failed test 'returned two values in the match'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_0.rakudo line 55
# expected: '2'
#      got: 'hello world'
ok 10 - returned two values in the match
ok 11 - returned correct first value in the match
ok 12 - returned correct second value in the match
ok 13 - An unmatched capture should be undefined.
ok 14 - 
not ok 15 - interpolated rule applied successfully # TODO NYI
# Failed test 'interpolated rule applied successfully'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_0.rakudo line 71
not ok 16 - interpolated rule applied successfully # TODO NYI
# Failed test 'interpolated rule applied successfully'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_0.rakudo line 75
not ok 17 - variable interpolation in substitute regexp works with :g modifier # TODO NYI
# Failed test 'variable interpolation in substitute regexp works with :g modifier'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_0.rakudo line 82
# expected: 'baz'
#      got: 'barrrr'
ok 18 - closure interpolation with qq[] as delimiter
ok 19 - closure interpolation with no delimiter
ok 20 - Test the status of non-matched number match variable (1)
ok 21 - Test the status of non-matched number match variable (2)
ok 22 - The object is-a '"Regex"'
ok 23 - ... applying rule object returns true
ok 24 - ... applying rule object returns false (correctly)
# FUDGED!
1..102
ok 1 - re_tests 609/1 (793)
ok 2 - re_tests 611/1 (795)
ok 3 - re_tests 613/1 (797)
ok 4 - re_tests 615/1 (799)
ok 5 - re_tests 617/1 (801)
ok 6 - re_tests 619/1 (803)
ok 7 - re_tests 621/1 (805)
ok 8 - re_tests 623/1 (807)
ok 9 - re_tests 625/1 (809)
ok 10 - re_tests 627/1 (811)
ok 11 - re_tests 629/1 (813)
ok 12 - re_tests 631/0 (815)
ok 13 - re_tests 633/1 (817)
ok 14 - re_tests 635  (819)
ok 15 - re_tests 637  (821)
not ok 16 - re_tests 639/1 (823) # TODO unknown issue
# Failed test 're_tests 639/1 (823)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_5.rakudo line 33
# expected: 'aaaa'
#      got: (Nil)
ok 17 - re_tests 641  (825)
ok 18 - re_tests 643  (827)
ok 19 - re_tests 645/1 (829)
ok 20 - re_tests 647/1 (831)
ok 21 - re_tests 649/1 (833)
ok 22 - re_tests 651/0 (835)
ok 23 - re_tests 653  (837)
ok 24 - re_tests 655  (839)
ok 25 - re_tests 657/0 (841)
ok 26 - re_tests 659  (843)
ok 27 - re_tests 661  (845)
ok 28 - re_tests 663/0 (847)
ok 29 - re_tests 665/0 (849)
ok 30 - re_tests 667/0 (851)
not ok 31 - re_tests 669/0 (853) # TODO unknown issue
# Failed test 're_tests 669/0 (853)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_5.rakudo line 50
# expected: 'ab'
#      got: (Nil)
ok 32 - re_tests 671/1 (855)
ok 33 - re_tests 673/1 (857)
ok 34 - re_tests 675/1 (859)
ok 35 - re_tests 677/0 (861)
ok 36 - re_tests 679/0 (863)
ok 37 - re_tests 679/1 (864)
ok 38 - re_tests 681/0 (867)
ok 39 - re_tests 683/0 (869)
ok 40 - re_tests 683/1 (870)
ok 41 - re_tests 685  (873)
ok 42 - re_tests 687  (875)
ok 43 - re_tests 689/0 (877)
ok 44 - re_tests 691/0 (879)
ok 45 - re_tests 691/1 (880)
ok 46 - re_tests 693/0 (883)
ok 47 - re_tests 695/0 (885)
ok 48 - re_tests 695/1 (886)
ok 49 - re_tests 697  (889)
ok 50 - re_tests 699  (891)
ok 51 - re_tests 701/0 (893)
ok 52 - re_tests 702/0 (894)
ok 53 - re_tests 702/1 (895)
ok 54 - re_tests 703/0 (896)
ok 55 - re_tests 704/0 (897)
ok 56 - re_tests 704/1 (898)
ok 57 - re_tests 705  (899)
ok 58 - re_tests 706  (900)
ok 59 - re_tests 707/0 (901)
ok 60 - re_tests 708/1 (902)
ok 61 - re_tests 709  (903)
ok 62 - re_tests 710  (904)
ok 63 - re_tests 711/0 (905)
ok 64 - re_tests 712/0 (906)
ok 65 - re_tests 712/1 (907)
ok 66 - re_tests 713/0 (908)
ok 67 - re_tests 714/0 (909)
ok 68 - re_tests 714/1 (910)
ok 69 - re_tests 715  (911)
ok 70 - re_tests 716  (912)
ok 71 - re_tests 717/0 (913)
ok 72 - re_tests 718/1 (914)
ok 73 - re_tests 719  (915)
ok 74 - re_tests 720  (916)
ok 75 - re_tests 721  (917)
ok 76 - re_tests 722/1 (918)
ok 77 - re_tests 723  (919)
ok 78 - re_tests 724/0 (920)
ok 79 - re_tests 726/0 (922)
not ok 80 - re_tests 728/1 (924) # TODO (?i) and backreferences
# Failed test 're_tests 728/1 (924)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_5.rakudo line 100
# expected: 'Ab'
#      got: (Nil)
not ok 81 - re_tests 730/1 (926) # TODO (?i) and backreferences
# Failed test 're_tests 730/1 (926)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_5.rakudo line 101
# expected: 'ab'
#      got: (Nil)
ok 82 - re_tests 732/0 (928)
ok 83 - re_tests 734/0 (930)
ok 84 - re_tests 735/0 (931)
ok 85 - re_tests 736  (932)
ok 86 - re_tests 738/0 (934)
ok 87 - re_tests 739/0 (935)
ok 88 - re_tests 740  (936)
ok 89 - re_tests 742/0 (938)
ok 90 - re_tests 744  (940)
ok 91 - re_tests 746/0 (942)
ok 92 - re_tests 748/0 (944)
ok 93 - # SKIP hangs
ok 94 - re_tests 752/1 (948)
ok 95 - re_tests 753/0 (949)
ok 96 - re_tests 754/1 (950)
ok 97 - re_tests 755/1 (951)
ok 98 - re_tests 756/1 (952)
ok 99 - re_tests 757/1 (953)
ok 100 - re_tests 758/1 (954)
ok 101 - re_tests 759  (955)
ok 102 - re_tests 761  (957)
# FUDGED!
1..104
ok 1 - re_tests 763/1 (959)
ok 2 - re_tests 764  (960)
ok 3 - re_tests 766/0 (962)
ok 4 - re_tests 768  (964)
ok 5 - re_tests 770/0 (966)
ok 6 - re_tests 772/0 (968)
not ok 7 - re_tests 774  (970) # TODO needs RT
# Failed test 're_tests 774  (970)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_6.rakudo line 24
not ok 8 - re_tests 776/0 (972) # TODO needs RT
# Failed test 're_tests 776/0 (972)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_6.rakudo line 25
# expected: 'a'
#      got: (Nil)
not ok 9 - re_tests 778/2 (974) # TODO needs RT
# Failed test 're_tests 778/2 (974)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_6.rakudo line 26
# expected: ')'
#      got: (Nil)
ok 10 - re_tests 780  (976)
ok 11 - re_tests 782  (978)
not ok 12 - re_tests 784/2 (980) # TODO needs RT
# Failed test 're_tests 784/2 (980)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_6.rakudo line 30
# expected: ')'
#      got: (Nil)
ok 13 - re_tests 786  (982)
ok 14 - re_tests 788  (984)
ok 15 - re_tests 790  (986)
ok 16 - re_tests 791/0 (987)
not ok 17 - re_tests 792  (988) # TODO needs RT
# Failed test 're_tests 792  (988)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_6.rakudo line 36
not ok 18 - re_tests 793/0 (989) # TODO needs RT
# Failed test 're_tests 793/0 (989)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_6.rakudo line 37
# expected: 'a'
#      got: (Nil)
ok 19 - re_tests 794  (990)
ok 20 - re_tests 795/0 (991)
not ok 21 - re_tests 796  (992) # TODO needs RT
# Failed test 're_tests 796  (992)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_6.rakudo line 41
not ok 22 - re_tests 797/0 (993) # TODO needs RT
# Failed test 're_tests 797/0 (993)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_6.rakudo line 42
# expected: 'a'
#      got: (Nil)
not ok 23 - re_tests 798/2 (994) # TODO needs RT
# Failed test 're_tests 798/2 (994)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_6.rakudo line 43
# expected: 'aab'
#      got: (Nil)
ok 24 - re_tests 800  (996)
ok 25 - re_tests 802/1 (998)
not ok 26 - re_tests 804/1 (1000) # TODO needs RT
# Failed test 're_tests 804/1 (1000)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_6.rakudo line 47
# expected: 'a'
#      got: (Nil)
not ok 27 - re_tests 806/2 (1002) # TODO needs RT
# Failed test 're_tests 806/2 (1002)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_6.rakudo line 48
# expected: 'aab'
#      got: (Nil)
ok 28 - re_tests 808  (1004)
ok 29 - re_tests 810  (1006)
ok 30 - re_tests 812/1 (1008)
ok 31 - re_tests 812/2 (1009)
ok 32 - re_tests 814/1 (1012)
ok 33 - re_tests 814/2 (1013)
ok 34 - re_tests 816/1 (1016)
ok 35 - re_tests 818/1 (1018)
ok 36 - re_tests 820  (1020)
ok 37 - re_tests 822/1 (1022)
ok 38 - re_tests 822/2 (1023)
ok 39 - re_tests 824/1 (1026)
ok 40 - re_tests 824/2 (1027)
ok 41 - re_tests 826/1 (1030)
ok 42 - re_tests 828  (1032)
not ok 43 - re_tests 829  (1033) # TODO needs RT
# Failed test 're_tests 829  (1033)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_6.rakudo line 65
ok 44 - re_tests 831/1 (1035)
ok 45 - re_tests 832/1 (1036)
ok 46 - re_tests 833/1 (1037)
ok 47 - re_tests 834/0 (1038)
ok 48 - re_tests 835/0 (1039)
not ok 49 - re_tests 836/1 (1040) # TODO needs RT
# Failed test 're_tests 836/1 (1040)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_6.rakudo line 72
# expected: 'aaab'
#      got: (Nil)
not ok 50 - re_tests 838/1 (1042) # TODO needs RT
# Failed test 're_tests 838/1 (1042)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_6.rakudo line 73
# expected: 'aaa'
#      got: (Nil)
not ok 51 - re_tests 840/0 (1044) # TODO needs RT
# Failed test 're_tests 840/0 (1044)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_6.rakudo line 74
# expected: 'abc(ade)ufh()()x'
#      got: '(ade)'
ok 52 - re_tests 842/0 (1046)
ok 53 - re_tests 844/0 (1048)
ok 54 - re_tests 846/0 (1050)
ok 55 - re_tests 847/0 (1051)
ok 56 - re_tests 849/0 (1053)
ok 57 - re_tests 851/0 (1055)
ok 58 - re_tests 852/0 (1056)
ok 59 - re_tests 854/0 (1058)
ok 60 - re_tests 856/0 (1060)
ok 61 - re_tests 857/0 (1061)
ok 62 - re_tests 858/0 (1062)
ok 63 - re_tests 859/0 (1063)
ok 64 - re_tests 860/0 (1064)
ok 65 - re_tests 861/0 (1065)
ok 66 - re_tests 862/0 (1066)
ok 67 - re_tests 863/0 (1067)
ok 68 - re_tests 864/0 (1068)
ok 69 - re_tests 865/0 (1069)
ok 70 - re_tests 866  (1070)
ok 71 - re_tests 868  (1072)
ok 72 - re_tests 870  (1074)
ok 73 - re_tests 871/0 (1075)
ok 74 - re_tests 873  (1077)
ok 75 - re_tests 875/0 (1079)
ok 76 - re_tests 876/0 (1080)
ok 77 - re_tests 878/0 (1082)
ok 78 - re_tests 880/0 (1084)
ok 79 - re_tests 881  (1085)
ok 80 - re_tests 882  (1086)
ok 81 - re_tests 883/0 (1087)
ok 82 - re_tests 884/0 (1088)
ok 83 - re_tests 885  (1089)
ok 84 - re_tests 886/0 (1090)
ok 85 - re_tests 887/0 (1091)
ok 86 - re_tests 888/0 (1092)
ok 87 - re_tests 889/0 (1093)
ok 88 - re_tests 890  (1094)
ok 89 - re_tests 892  (1096)
ok 90 - re_tests 894  (1098)
ok 91 - re_tests 895/0 (1099)
ok 92 - re_tests 897  (1101)
ok 93 - re_tests 899/0 (1103)
ok 94 - re_tests 900/0 (1104)
ok 95 - re_tests 902/0 (1106)
ok 96 - re_tests 904/0 (1108)
ok 97 - re_tests 905  (1109)
ok 98 - re_tests 906  (1110)
ok 99 - re_tests 907/0 (1111)
ok 100 - re_tests 908/0 (1112)
ok 101 - re_tests 909  (1113)
ok 102 - re_tests 910/0 (1114)
ok 103 - re_tests 911/0 (1115)
ok 104 - re_tests 912/0 (1116)
# FUDGED!
1..103
ok 1 - re_tests 1049  (1253)
ok 2 - re_tests 1050  (1254)
ok 3 - re_tests 1051/0 (1255)
ok 4 - re_tests 1052/0 (1256)
ok 5 - re_tests 1053  (1257)
ok 6 - re_tests 1054/0 (1258)
ok 7 - re_tests 1055/0 (1259)
ok 8 - re_tests 1056/0 (1260)
ok 9 - re_tests 1057/0 (1261)
ok 10 - re_tests 1058  (1262)
ok 11 - re_tests 1060  (1264)
ok 12 - re_tests 1062  (1266)
ok 13 - re_tests 1063  (1267)
ok 14 - re_tests 1065  (1269)
ok 15 - re_tests 1067  (1271)
ok 16 - re_tests 1068  (1272)
ok 17 - re_tests 1070  (1274)
ok 18 - re_tests 1072  (1276)
ok 19 - re_tests 1073  (1277)
ok 20 - re_tests 1074  (1278)
ok 21 - re_tests 1075  (1279)
ok 22 - re_tests 1076  (1280)
ok 23 - re_tests 1077  (1281)
ok 24 - re_tests 1078  (1282)
ok 25 - re_tests 1079  (1283)
ok 26 - re_tests 1080  (1284)
ok 27 - re_tests 1081  (1285)
ok 28 - re_tests 1082  (1286)
ok 29 - re_tests 1084  (1288)
ok 30 - re_tests 1086  (1290)
ok 31 - re_tests 1087  (1291)
ok 32 - re_tests 1089  (1293)
ok 33 - re_tests 1091  (1295)
ok 34 - re_tests 1092  (1296)
ok 35 - re_tests 1094  (1298)
ok 36 - re_tests 1096  (1300)
ok 37 - re_tests 1097  (1301)
ok 38 - re_tests 1098  (1302)
ok 39 - re_tests 1099  (1303)
ok 40 - re_tests 1100  (1304)
ok 41 - re_tests 1101  (1305)
ok 42 - re_tests 1102  (1306)
ok 43 - re_tests 1103  (1307)
ok 44 - re_tests 1104  (1308)
ok 45 - re_tests 1105  (1309)
ok 46 - re_tests 1106/2 (1310)
ok 47 - re_tests 1108  (1312)
not ok 48 - re_tests 1110/1 (1314) # TODO (?>...) NYI
# Failed test 're_tests 1110/1 (1314)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_8.rakudo line 67
# expected: 'xs * sz'
#      got: (Nil)
ok 49 - re_tests 1112  (1316)
ok 50 - re_tests 1114  (1318)
ok 51 - # SKIP expensive quantifier
ok 52 - # SKIP expensive quantifier
ok 53 - # SKIP expensive quantifier
ok 54 - # SKIP expensive quantifier
ok 55 - # SKIP expensive quantifier
ok 56 - # SKIP expensive quantifier
ok 57 - # SKIP expensive quantifier
ok 58 - # SKIP expensive quantifier
ok 59 - # SKIP expensive quantifier
ok 60 - # SKIP expensive quantifier
ok 61 - # SKIP expensive quantifier
ok 62 - # SKIP expensive quantifier
ok 63 - # SKIP expensive quantifier
ok 64 - # SKIP expensive quantifier
ok 65 - # SKIP expensive quantifier
ok 66 - # SKIP expensive quantifier
ok 67 - # SKIP expensive quantifier
ok 68 - # SKIP expensive quantifier
ok 69 - re_tests 1151  (1355)
ok 70 - # SKIP character classes in enumerated range
ok 71 - # SKIP character classes in enumerated range
ok 72 - # SKIP character classes in enumerated range
ok 73 - # SKIP character classes in enumerated range
ok 74 - # SKIP character classes in enumerated range
ok 75 - # SKIP character classes in enumerated range
ok 76 - # SKIP \G
ok 77 - re_tests 1163/1 (1367)
ok 78 - re_tests 1165/1 (1369)
ok 79 - re_tests 1167  (1371)
ok 80 - re_tests 1169  (1373)
ok 81 - re_tests 1171/1 (1375)
ok 82 - re_tests 1173  (1377)
ok 83 - re_tests 1175  (1379)
ok 84 - re_tests 1176  (1380)
ok 85 - re_tests 1178  (1382)
ok 86 - re_tests 1180  (1384)
ok 87 - re_tests 1182/1 (1386)
ok 88 - re_tests 1184  (1388)
ok 89 - re_tests 1186/1 (1390)
ok 90 - re_tests 1188/1 (1392)
ok 91 - re_tests 1190/1 (1394)
ok 92 - re_tests 1192/1 (1396)
ok 93 - re_tests 1194/1 (1398)
ok 94 - re_tests 1196/1 (1400)
ok 95 - re_tests 1198/1 (1402)
ok 96 - re_tests 1200/1 (1404)
ok 97 - re_tests 1202/1 (1406)
ok 98 - re_tests 1204/1 (1408)
ok 99 - re_tests 1206/1 (1410)
ok 100 - re_tests 1208/1 (1412)
ok 101 - re_tests 1210/1 (1414)
ok 102 - re_tests 1212  (1416)
ok 103 - re_tests 1214  (1418)
# FUDGED!
1..84
ok 1 - re_tests 1215  (1419)
ok 2 - re_tests 1216  (1420)
ok 3 - re_tests 1218/1 (1422)
ok 4 - re_tests 1220  (1424)
ok 5 - re_tests 1222  (1426)
ok 6 - re_tests 1224/1 (1428)
ok 7 - re_tests 1226/1 (1430)
ok 8 - re_tests 1228  (1432)
ok 9 - re_tests 1230  (1434)
ok 10 - re_tests 1232/1 (1436)
ok 11 - re_tests 1232/2 (1437)
ok 12 - re_tests 1234/1 (1440)
ok 13 - re_tests 1234/2 (1441)
ok 14 - re_tests 1236/1 (1444)
ok 15 - re_tests 1236/2 (1445)
ok 16 - re_tests 1238  (1448)
ok 17 - re_tests 1239  (1449)
ok 18 - re_tests 1241/2 (1451)
ok 19 - re_tests 1242  (1452)
not ok 20 - re_tests 1244  (1454) # TODO test file needs review
# Failed test 're_tests 1244  (1454)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_9.rakudo line 38
not ok 21 - re_tests 1246/2 (1456) # TODO test file needs review
# Failed test 're_tests 1246/2 (1456)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_9.rakudo line 39
# expected: ''
#      got: 'CD'
not ok 22 - re_tests 1246/3 (1457) # TODO test file needs review
# Failed test 're_tests 1246/3 (1457)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_9.rakudo line 40
# expected: 'CD'
#      got: (Nil)
ok 23 - re_tests 1248/2 (1460)
not ok 24 - re_tests 1248/3 (1461) # TODO test file needs review
# Failed test 're_tests 1248/3 (1461)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_9.rakudo line 44
# expected: ''
#      got: (Nil)
not ok 25 - re_tests 1250/2 (1464) # TODO test file needs review
# Failed test 're_tests 1250/2 (1464)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_9.rakudo line 45
# expected: ''
#      got: 'CD'
not ok 26 - re_tests 1250/3 (1465) # TODO test file needs review
# Failed test 're_tests 1250/3 (1465)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_9.rakudo line 46
# expected: 'CD'
#      got: (Nil)
ok 27 - re_tests 1252/2 (1468)
not ok 28 - re_tests 1252/3 (1469) # TODO test file needs review
# Failed test 're_tests 1252/3 (1469)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_9.rakudo line 50
# expected: ''
#      got: (Nil)
not ok 29 - re_tests 1254  (1472) # TODO test file needs review
# Failed test 're_tests 1254  (1472)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_9.rakudo line 51
ok 30 - re_tests 1256/1 (1474)
ok 31 - re_tests 1258/1 (1476)
ok 32 - re_tests 1259/1 (1477)
ok 33 - re_tests 1261/1 (1479)
ok 34 - re_tests 1263/1 (1481)
ok 35 - re_tests 1265/1 (1483)
ok 36 - re_tests 1267/1 (1485)
ok 37 - re_tests 1269/1 (1487)
ok 38 - re_tests 1271/1 (1489)
ok 39 - re_tests 1273/1 (1491)
ok 40 - re_tests 1275/1 (1493)
ok 41 - re_tests 1277/1 (1495)
ok 42 - re_tests 1279/1 (1497)
ok 43 - re_tests 1281/1 (1499)
ok 44 - re_tests 1283/1 (1501)
ok 45 - re_tests 1285/1 (1503)
ok 46 - re_tests 1287/1 (1505)
ok 47 - re_tests 1289/1 (1507)
ok 48 - re_tests 1291/1 (1509)
ok 49 - re_tests 1293/1 (1511)
ok 50 - re_tests 1295/1 (1513)
ok 51 - re_tests 1297/1 (1515)
ok 52 - re_tests 1299/1 (1517)
ok 53 - re_tests 1301/1 (1519)
ok 54 - re_tests 1303/1 (1521)
ok 55 - re_tests 1305/1 (1523)
ok 56 - re_tests 1307/1 (1525)
ok 57 - re_tests 1309/1 (1527)
ok 58 - re_tests 1311/1 (1529)
ok 59 - re_tests 1313/1 (1531)
ok 60 - re_tests 1315/1 (1533)
ok 61 - re_tests 1317/1 (1535)
ok 62 - re_tests 1319/1 (1537)
ok 63 - re_tests 1321/1 (1539)
ok 64 - re_tests 1323/1 (1541)
ok 65 - re_tests 1325/1 (1543)
ok 66 - re_tests 1327/0 (1545)
not ok 67 - re_tests 1329  (1547) # TODO test file needs review
# Failed test 're_tests 1329  (1547)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_9.rakudo line 91
ok 68 - re_tests 1330/1 (1548)
ok 69 - re_tests 1332/1 (1550)
ok 70 - re_tests 1334/1 (1552)
ok 71 - re_tests 1336/1 (1554)
ok 72 - re_tests 1338/1 (1556)
ok 73 - re_tests 1340/1 (1558)
ok 74 - re_tests 1342/1 (1560)
ok 75 - re_tests 1344/1 (1562)
ok 76 - re_tests 1346/1 (1564)
ok 77 - re_tests 1348/1 (1566)
ok 78 - re_tests 1350/1 (1568)
ok 79 - re_tests 1352/1 (1570)
ok 80 - re_tests 1354/1 (1572)
ok 81 - re_tests 1356/1 (1574)
ok 82 - re_tests 1358/1 (1576)
ok 83 - re_tests 1360/1 (1578)
ok 84 - re_tests 1362  (1580)
# FUDGED!
1..23
ok 1 - :ii modifier: Hello ~~ s:ii/.*/foo/ => Foo
ok 2 - :ii modifier: hEllo ~~ s:ii/.*/foo/ => fOo
ok 3 - :ii modifier: A ~~ s:ii/.*/foo/ => FOO
ok 4 - :ii modifier: AA ~~ s:ii/.*/foo/ => FOO
ok 5 - :ii modifier: a b ~~ s:ii/.*/FOO/ => fOo
ok 6 - :ii modifier: a b ~~ s:ii/.*/FOOB/ => fOob
ok 7 - :ii modifier: Ab  ~~ s:ii/.*/ABCDE/ => AbCDE
ok 8 - :ii modifier: aB  ~~ s:ii/.*/abcde/ => aBcde
ok 9 - :ii modifier: aB  ~~ s:ii/.*/ABCDE/ => aBCDE
ok 10 - :i:ii:sigspace modifier: HELLO ~~ s:ii:s/.*/foo/ => FOO
ok 11 - :i:ii:sigspace modifier: hello ~~ s:ii:s/.*/fOo/ => foo
ok 12 - :i:ii:sigspace modifier: he lo ~~ s:ii:s/.*/FOOOoO/ => fooooo
ok 13 - :i:ii:sigspace modifier: He lo ~~ s:ii:s/.*/FOOO/ => Fooo
ok 14 - :i:ii:sigspace modifier: hE LO ~~ s:ii:s/.*/fooo/ => fOOO
ok 15 - :i:ii:sigspace modifier: hE LO ~~ s:ii:s/.*/foobar/ => fOOBAR
ok 16 - :i:ii:sigspace modifier: HE LO ~~ s:ii:s/.*/foo/ => FOO
ok 17 - :i:ii:sigspace modifier: Ab Cd E ~~ s:ii:s/.*/abc de ghi j/ => Abc De GHI J
ok 18 - :i:ii:sigspace modifier: Ab CD ~~ s:ii:s/.*/abc de ghi j/ => Abc DE GHI J
ok 19 - :i:ii:sigspace modifier: Ab Cd ~~ s:ii:s/.*/abc de ghi j/ => Abc De Ghi J
ok 20 - :ii implies :i
ok 21 - duplicated before-regexp modifier ":i" allowed (1)
ok 22 - duplicated before-regexp modifier ":i" allowed (2)
ok 23 - duplicated before-regexp modifier ":i" allowed (3)
# FUDGED!
1..24
ok 1 - can declare :constant in regex
ok 2 - ... and it matched the constant
ok 3 - does not work with wrong text
ok 4 - can declare :my in regex
ok 5 - correct match with "my" variable
ok 6 - does not work with wrong text
ok 7 - :state in regex (match) (1)
ok 8 - :state in regex ($/) (1)
ok 9 - :state in regex (match) (2)
ok 10 - :state in regex ($/) (2)
ok 11 - :state in regex (no match)
ok 12 - :our in regex
not ok 13 - can access our variable from the outside # TODO :our variables in regexes
# Failed test 'can access our variable from the outside'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/my.rakudo line 49
# expected: 'zho'
#      got: (Any)
ok 14 - can access variables in regex (not temp'ed)
ok 15 - (-) not temp'ed
ok 16 - temp'ed variable still 1
ok 17 - can access temp'ed variable in regex (+)
ok 18 - (-) temp'ed
ok 19 - temp'ed variable again 1
ok 20 - can detect a non-match with :let
not ok 21 - unsuccessful match did not affect :let variable # TODO unsuccessful match preserves :let value
# Failed test 'unsuccessful match did not affect :let variable'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/my.rakudo line 71
# expected: '1'
#      got: '5'
ok 22 - can match changed :let variable
ok 23 - successful match preserves new :let value
ok 24 - :my terminates upon }\n
# FUDGED!
1..40
ok 1 - Matched 1: 'abc'
ok 2 - Interim position correct
ok 3 - Matched 2: 'def'
ok 4 - Final position correct
ok 5 - Globally contiguous substitution
not ok 6 - Correctly substituted contiguously # TODO s:pos/// NYI
# Failed test 'Correctly substituted contiguously'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/pos.rakudo line 26
# expected: 'FOOFOOFOO foofoofoo'
#      got: 'FOOFOOFOO FOOFOOFOO'
ok 7 - Continued match
ok 8 - Continued match pos
ok 9 - Insensitive continued match pos
ok 10 - Insensitive recontinued match pos
not ok 11 - Insensitive repeated continued match # TODO m:g
# Failed test 'Insensitive repeated continued match'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/pos.rakudo line 50
# expected: 'abc abc abc'
#      got: '@x'
ok 12 - Insensitive repeated continued match pos
ok 13 - 
not ok 14 - Insensitive scalar repeated continued match pos # TODO m:p:i:g// NYI
# Failed test 'Insensitive scalar repeated continued match pos'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/pos.rakudo line 61
# expected: '3'
#      got: '9'
ok 15 - Match anchored to 0
ok 16 - and the match is in the correct position
ok 17 - No match anchored to 1
ok 18 - No match anchored to 2
ok 19 - Match anchored to 3
ok 20 - and the match is in the correct position
ok 21 - No match anchored to 4
ok 22 - Match anchored to 6
ok 23 - and the match is in the correct position
ok 24 - No match anchored to 7
ok 25 - No match anchored to 8
ok 26 - No match anchored to 9
ok 27 - No match anchored to 10
ok 28 - Match anchored to 0
ok 29 - and the match is in the correct position
ok 30 - No match anchored to 1
ok 31 - No match anchored to 2
ok 32 - Match anchored to 3
ok 33 - and the match is in the correct position
ok 34 - No match anchored to 4
ok 35 - Match anchored to 6
ok 36 - and the match is in the correct position
ok 37 - No match anchored to 7
ok 38 - No match anchored to 8
ok 39 - No match anchored to 9
ok 40 - No match anchored to 10
# FUDGED!
1..5
ok 1 - normal regexes backtrack into subrules
ok 2 -  ... but not with :ratchet
not ok 3 - if the failing atom is outside the :!ratchet group: no backtracking # TODO Dubios test. Does it have to be this way?
# Failed test 'if the failing atom is outside the :!ratchet group: no backtracking'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/ratchet.rakudo line 19
ok 4 - if the failing atom is inside the :!ratchet group: backtracking
ok 5 - Same if not grouped
# FUDGED!
1..5
ok 1 - Simple combination of :x(2) and :exhaustive
not ok 2 - First entry of prev. genenerated $/ # TODO exhaustive capture too greedy RT #125133
# Failed test 'First entry of prev. genenerated $/'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/repetition-exhaustive.rakudo line 24
# expected: 'ab'
#      got: 'abbb'
ok 3 - Second entry of prev. genenerated $/
ok 4 - Simple combination of :x(3) and :exhaustive
ok 5 - Simple combination of :x(4) and :exhaustive
# FUDGED!
1..190
ok 1 - We can use subst
ok 2 - .. withouth side effect
ok 3 - .. or using Str as pattern
ok 4 - .. with literal string matching
ok 5 - We can have a closure as replacement
ok 6 - .. and with the .= modifier
ok 7 - .. it changes the receiver
ok 8 - non-Str replacement works for string form too
ok 9 - .. bare strings cannot see $/ because they are evaluated first
ok 10 - .. you must wrap it in a closure to delay evaluation
ok 11 - .. and do nifty things in closures
ok 12 - "a".subst("a", "b") is "b"
ok 13 - $/ is left untouched
ok 14 - "a".subst(/a/, "b") is "b"
ok 15 - $/ matched "a"
ok 16 - "a".subst(/x/, "y") is "a"
ok 17 - $/ is a falsey
ok 18 - $_ = "a"; s/a/b/ is "a"
ok 19 - $/ matched "a"
ok 20 - $_ = "a"; s/x/y/ is a falsey
ok 21 - $/ is a falsey
ok 22 - .subst and :g
ok 23 - .subst and :global
ok 24 - .subst and :x(0)
ok 25 - .subst and :x(1)
ok 26 - .subst and :x(2)
ok 27 - .subst and :x(3)
ok 28 - .subst and :x(4)
ok 29 - .subst and :x(5)
ok 30 - .subst and :x(*)
ok 31 - .subst and :x(0..1)
ok 32 - .subst and :x(0..3)
ok 33 - .subst and :x(3..5)
ok 34 - .subst and :x(5..6)
ok 35 - .subst and :x(3..2)
ok 36 - .subst (str pattern) and :g
ok 37 - .subst (str pattern) and :x(0)
ok 38 - .subst (str pattern) and :x(1)
ok 39 - .subst (str pattern) and :x(2)
ok 40 - .subst (str pattern) and :x(3)
ok 41 - .subst (str pattern) and :x(4)
ok 42 - .subst (str pattern) and :x(5)
ok 43 - .subst (str pattern) and :x(*)
ok 44 - .subst (str pattern) and :x(0..1)
ok 45 - .subst (str pattern) and :x(0..3)
ok 46 - .subst (str pattern) and :x(3..5)
ok 47 - .subst (str pattern) and :x(5..6)
ok 48 - .subst (str pattern) and :x(3..2)
    1..3
    ok 1 - '"a b c d".subst(/\w/, "x", :nth(0))' died
    ok 2 - right exception type (Exception)
    ok 3 - .message matches rx/nth/
ok 49 - did we throws-like Exception?
ok 50 - .subst and :nth(1)
ok 51 - .subst and :nth(2)
ok 52 - .subst and :nth(3)
ok 53 - .subst and :nth(4)
ok 54 - .subst and :nth(5)
    1..3
    ok 1 - '"a a a a".subst("a", "x", :nth(0))' died
    ok 2 - right exception type (Exception)
    ok 3 - .message matches rx/nth/
ok 55 - did we throws-like Exception?
ok 56 - .subst (str pattern) and :nth(1)
ok 57 - .subst (str pattern) and :nth(2)
ok 58 - .subst (str pattern) and :nth(3)
ok 59 - .subst (str pattern) and :nth(4)
ok 60 - .subst (str pattern) and :nth(5)
ok 61 - .subst with :nth(1,2,3,4)) and :x(3)
ok 62 - .subst with :nth(2,4,6,8) and :x(2)
    1..2
    ok 1 - '"a b c d e f g h".subst(/\w/, "x", :nth(2, 4, 1, 6), :x(3))' died
    ok 2 - right exception type (Exception)
ok 63 - .subst with :nth(2) and :x(3)
ok 64 - .subst with :p(0)
ok 65 - .subst with :p(1)
ok 66 - .subst with :p(2)
ok 67 - .subst with :p(0) and :g
ok 68 - .subst with :p(1) and :g
ok 69 - .subst with :p(2) and :g
ok 70 - .subst with :c(0)
ok 71 - .subst with :c(1)
ok 72 - .subst with :c(2)
ok 73 - .subst with :c(0) and :g
ok 74 - .subst with :c(1) and :g
ok 75 - .subst with :c(2) and :g
ok 76 - .subst with :c(0) and :nth(3, 4)
ok 77 - .subst with :c(1) and :nth(3, 4)
ok 78 - .subst with :c(2) and :nth(3, 4)
ok 79 - Constant substitution succeeds and returns correct count
ok 80 - Constant substitution produces correct result
ok 81 - Global scalar substitution succeeds and returns a List
ok 82 - Scalar substitution produces correct result
ok 83 - Single list replacement succeeds and returns a Match
ok 84 - List replacement produces correct result
ok 85 - can't modify string literal (only variables)
ok 86 - Cannot ss/// string literal
ok 87 - successful s:ss substitution returns truthy
ok 88 - s:ss/.../.../ preserves whitespace
ok 89 - successful ss substitution returns truthy
ok 90 - ss/.../.../ preserves whitespace
ok 91 - successful s:s substitution returns truthy
ok 92 - s:s/.../.../ does not preserve whitespace
ok 93 - successful s:ss:ii substitution returns truthy
ok 94 - s:ss:ii/.../.../ preserves whitespace and case
ok 95 - successful ss:i substitution returns truthy
ok 96 - ss:i/.../.../ preserves whitespace
ok 97 - successful s:s:ii substitution returns truthy
ok 98 - s:s:ii/.../.../ does not preserve whitespace but preserves case
ok 99 - successful s:ss:ii:mm substitution returns truthy
ok 100 - s:ss:ii:mm/.../.../ preserves whitespace, case, and marks
ok 101 - successful ss substitution returns truthy
ok 102 - ss/.../.../ preserves whitespace
ok 103 - successful s:s substitution returns truthy
ok 104 - s:s/.../.../ does not preserve whitespace but preserves case and marks
ok 105 - s[...] = ... returns true on success
ok 106 - substitution worked
ok 107 - s[...] = ... returns false on failure
ok 108 - failed substitutions leaves string unchanged
    1..2
    ok 1 - '$_ = "a"; s:unkonwn/a/b/' died
    ok 2 - right exception type (X::Syntax::Regex::Adverb)
ok 109 - s/// dies on unknown adverb
    1..2
    ok 1 - '$_ = "a"; s:overlap/a/b/' died
    ok 2 - right exception type (X::Syntax::Regex::Adverb)
ok 110 - :overlap does not make sense on s///
ok 111 - s[...] = ... returns true on success
ok 112 - substitution worked
ok 113 - failed substitutions leaves string unchanged
ok 114 - s:global[..] = returns correct count
ok 115 - and the substition worked
ok 116 - can use $/ on the RHS
ok 117 - can use $0 on the RHS
ok 118 - s:g[] returns proper count of matches
ok 119 - s:g[...] and captures work together well
ok 120 - s:x(2)
ok 121 - s:1st return value
ok 122 - s:1st side effect
ok 123 - s:2nd return value
ok 124 - s:2nd side effect
ok 125 - s:3rd return value
ok 126 - s:3rd side effect
ok 127 - s:4th return value
ok 128 - s:4th side effect
ok 129 - s:nth(5) return value
ok 130 - s:nth(5) side effect
ok 131 - s:nth(6) return value
ok 132 - s:nth(6) no side effect
ok 133 - s:x(2):nth(1,3) works in combination
ok 134 - s:2x:nth(1,3) works in combination
ok 135 - ! separator
ok 136 - s[...] += 5 returns True
ok 137 - s[...] += 5 gave right result
ok 138 - s:g[..] x= 2 worked
ok 139 - s:g[...] customop= returned True
ok 140 - ... and got right result
ok 141 - s with colon is always substitution
ok 142 - can call sub s as "s()"
ok 143 - can call sub s as "s"
ok 144 - bare ss is substitution before whitespace then parens
ok 145 - .substr and :samecase (1)
ok 146 - .substr and :samecase (2)
ok 147 - .substr (string pattern) and :    samecase (1)
ok 148 - .substr (string pattern) and :    samecase (2)
ok 149 - .substr (string pattern)     and :g and :samecase (1)
ok 150 - .substr (string pattern)     and :g and :samecase (2)
ok 151 - .substr and samecase, worked with block replacement
ok 152 - .substr and :g and :samecase, worked with block replacement
ok 153 - :ii implies :i
ok 154 - :samecase implies :i
ok 155 - Zero-width substitution does not make the GC recurse
    1..2
    ok 1 - ' $_ = "abc"; my $i = 1; s:i($i)/a/b/ ' died
    ok 2 - right exception type (X::Value::Dynamic)
ok 156 - Value of :i must be known at compile time
not ok 157 - :i(1) is OK # TODO be smarter about constant detection
# Failed test ':i(1) is OK'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-substitution/subst.rakudo line 444
# Error: Adverb i value must be known at compile time
ok 158 - can use $0 in RHS of s///
ok 159 - (sanely) dies when trying to s/// a read-only variable
ok 160 - s[f] is parsed as a substitution op
    1..2
    ok 1 - '$_ = "foo"; s[] = "bar";' died
    ok 2 - right exception type (X::Syntax::Regex::NullRegex)
ok 161 - did we throws-like X::Syntax::Regex::NullRegex?
ok 162 - get match variable in replacement of subst-mutator
ok 163 - $ anchor directly at the end of the search pattern works
ok 164 - s{}="" plus statement mod if is not parsed as /i
ok 165 - s/// returns a Match object on non-strings
ok 166 - s/// can modify a container that contains a non-string
ok 167 - s{}="" can modify a container that contains a non-string
ok 168 - s[]="" works when $_ is set
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Syntax::Regex::NullRegex)
ok 169 - did we throws-like X::Syntax::Regex::NullRegex?
not ok 170 - can use s[]="" when $_ is not set # TODO RT #114388 -- expected: '', got: (Any)
# Failed test 'can use s[]="" when $_ is not set'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-substitution/subst.rakudo line 521
# expected: ''
#      got: (Any)
ok 171 - non-mutating single substitution works ()
ok 172 - non-mutating single substitution works (o)
ok 173 - non-mutating global substitution works (o o)
ok 174 - non-mutating single substitution assignment works (o)
ok 175 - non-mutating global substitution assignment works (o o)
ok 176 - non-mutating single substitution works (o)
ok 177 - non-mutating global substitution works (o)
ok 178 - non-mutating single substitution assignment works (o)
ok 179 - non-mutating global substitution assignment works (o)
ok 180 - code in replacement part of s/// has correct scoping
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Str::Match::x)
ok 181 - giving .subst invalid args throws
ok 182 - S:g/// returns original string on failure to match
ok 183 - S/// can be used in map (does not reuse a container)
    1..3
        1..2
            1..3
            ok 1 - return value
            ok 2 - $/ is Match
            ok 3 - $/.Str
        ok 1 - S///
            1..4
            ok 1 - result
            ok 2 - return value
            ok 3 - $/ is Match
            ok 4 - $/.Str
        ok 2 - s///
    ok 1 - :2nd:g
        1..2
            1..3
            ok 1 - return value
            ok 2 - $/ is List
            ok 3 - $/».Str
        ok 1 - S///
            1..4
            ok 1 - result
            ok 2 - return value
            ok 3 - $/ is List
            ok 4 - $/».Str
        ok 2 - s///
    ok 2 - :x(1..3)
        1..2
            1..3
            ok 1 - return value
            ok 2 - $/ is List
            ok 3 - $/».Str
        ok 1 - S///
            1..4
            ok 1 - result
            ok 2 - return value
            ok 3 - $/ is List
            ok 4 - $/».Str
        ok 2 - s///
    ok 3 - :th(1, 3)
ok 184 - List/Match result adverb handling
    1..6
    ok 1 - replace with longer
    ok 2 - replace with shorter
    ok 3 - replace with samelength
    ok 4 - replace with longer (2)
    ok 5 - replace with shorter (2)
    ok 6 - replace with samelength (2)
ok 185 - .subst(Str:D, Str:D)
    1..14
        1..4
        ok 1 - $/ is a List…
        ok 2 - …with 3 items…
        ok 3 - …all are Match…
        ok 4 - …all have right values
    ok 1 - Int.subst: :g
        1..4
        ok 1 - $/ is a List…
        ok 2 - …with 2 items…
        ok 3 - …all are Match…
        ok 4 - …all have right values
    ok 2 - .subst: :x
        1..4
        ok 1 - $/ is a List…
        ok 2 - …with 3 items…
        ok 3 - …all are Match…
        ok 4 - …all have right values
    ok 3 - .subst: :nth
        1..4
        ok 1 - $/ is a List…
        ok 2 - …with 3 items…
        ok 3 - …all are Match…
        ok 4 - …all have right values
    ok 4 - .subst: :st
        1..4
        ok 1 - $/ is a List…
        ok 2 - …with 3 items…
        ok 3 - …all are Match…
        ok 4 - …all have right values
    ok 5 - .subst: :nd
        1..4
        ok 1 - $/ is a List…
        ok 2 - …with 3 items…
        ok 3 - …all are Match…
        ok 4 - …all have right values
    ok 6 - .subst: :rd
        1..4
        ok 1 - $/ is a List…
        ok 2 - …with 3 items…
        ok 3 - …all are Match…
        ok 4 - …all have right values
    ok 7 - .subst: :th
        1..4
        ok 1 - $/ is a List…
        ok 2 - …with 3 items…
        ok 3 - …all are Match…
        ok 4 - …all have right values
    ok 8 - Str.subst: :g
        1..4
        ok 1 - $/ is a List…
        ok 2 - …with 2 items…
        ok 3 - …all are Match…
        ok 4 - …all have right values
    ok 9 - .subst: :x
        1..4
        ok 1 - $/ is a List…
        ok 2 - …with 3 items…
        ok 3 - …all are Match…
        ok 4 - …all have right values
    ok 10 - .subst: :nth
        1..4
        ok 1 - $/ is a List…
        ok 2 - …with 3 items…
        ok 3 - …all are Match…
        ok 4 - …all have right values
    ok 11 - .subst: :st
        1..4
        ok 1 - $/ is a List…
        ok 2 - …with 3 items…
        ok 3 - …all are Match…
        ok 4 - …all have right values
    ok 12 - .subst: :nd
        1..4
        ok 1 - $/ is a List…
        ok 2 - …with 3 items…
        ok 3 - …all are Match…
        ok 4 - …all have right values
    ok 13 - .subst: :rd
        1..4
        ok 1 - $/ is a List…
        ok 2 - …with 3 items…
        ok 3 - …all are Match…
        ok 4 - …all have right values
    ok 14 - .subst: :th
ok 186 - .subst with multi-match args set $/ to a List of matches
ok 187 - Placeholder parameter in substitution assignment
ok 188 - Placeholder parameter in substitution quoted
ok 189 - Placeholder parameter in substitution regex ({} quoter)
ok 190 - Placeholder parameter in substitution regex (// quoter)
# FUDGED!
1..8
ok 1 - # SKIP RT  \#126142 - NYI
ok 2 - # SKIP RT  \#126142 - NYI
ok 3 - # SKIP RT  \#126142 - NYI
ok 4 - # SKIP RT  \#126142 - NYI
ok 5 - # SKIP RT  \#126142 - NYI
ok 6 - # SKIP RT  \#126142 - NYI
ok 7 - # SKIP RT  \#126142 - NYI
ok 8 - # SKIP RT  \#126142 - NYI
# FUDGED!
1..65
ok 1 - Each side can be individual characters
ok 2 - The two sides of the any pair can be strings interpreted as tr/// would multichar
ok 3 - The two sides of the any pair can be strings interpreted as tr/// would range
ok 4 - If the first character is a dash it isn't part of a range
ok 5 - If the last character is a dash it isn't part of a range
ok 6 - The two sides can consists of both chars and ranges
ok 7 - The two sides can consist of multiple ranges
ok 8 - The two sides of each pair may also be array references
ok 9 - Using string range on one side and array reference on the other
ok 10 - Using array reference on one side and string range on the other
ok 11 - The array version can map one characters to one-or-more characters
ok 12 - The array version can map one-or-more characters to one-or-more characters
ok 13 - The array version can map one characters to one-or-more characters, using leftmost longest match
ok 14 - Ranges can be grouped
ok 15 - Multiple ranges interpreted in string
ok 16 - Spaces in interpreted ranges are not skipped (all spaces are important)
ok 17 - Spaces in interpreted ranges are not skipped (all spaces are important)
ok 18 - 
ok 19 - 
ok 20 - 
ok 21 - 
ok 22 - 
ok 23 - ambiguous ranges combined
ok 24 - leading ranges interpreted as string
ok 25 - trailing ranges interpreted as string
ok 26 - leading, trailing ranges interpreted as string
ok 27 - can replace with empty string
ok 28 - :s flag (squash)
ok 29 - :d flag (delete)
ok 30 - no flags
ok 31 - ... with :c
ok 32 - ... with :s
ok 33 - ... with :s and :c
ok 34 - ... with :d and :c
ok 35 - no flags
ok 36 - squashing depends on replacement repeat, not searchlist repeat
ok 37 - squashing depends on replacement repeat, not searchlist repeat
ok 38 - array, many-to-many transliteration, complement
ok 39 - fence-post issue (make sure to replace end bits as well)
ok 40 - ... and now complement and squash
ok 41 - basic regex works
ok 42 - regexes pairs work
ok 43 - basic closure
ok 44 - closure pairs work
ok 45 - closure and regex
ok 46 - pairs of regexes and closures
ok 47 - # SKIP feed operator NYI
ok 48 - tr/// on $_ with explicit character lists
ok 49 - tr||| on $_ with character range
ok 50 - tr[][] on lexical var via ~~
ok 51 - tr/// on $_ with explicit character lists
    1..2
    ok 1 - '$_ = "axbycz"; y/abc/def/' died
    ok 2 - right exception type (X::Obsolete)
ok 52 - y/// does not exist any longer
ok 53 - trans on subst output lives
ok 54 - longest constant token preferred, regardless of declaration order
ok 55 - longest regex token preferred, regardless of declaration order
ok 56 - in case of a tie between regex lengths, prefer the first one
ok 57 - longest token still holds, even between constant strings and regexes
ok 58 - trans with anchored regex
ok 59 - trans with look-around regex
ok 60 - trans works with Cool signature
ok 61 - .trans with a pair of lists using postfix hypermetaoperator works
ok 62 - same with explicit for
ok 63 - StrDistance stringifies to $!after
    1..4
    ok 1 - :complement
    ok 2 - :delete
    ok 3 - :squash
    ok 4 - :complement, :squash
ok 64 - Adverbs on Cool.trans work the same as on Str.trans
ok 65 - .trans with complement regex pair does not produce spurious warnings
# FUDGED!
1..18
ok 1 - Can use a closure on the RHS
ok 2 - Closure executed three times
ok 3 - Can use a closure on the RHS with :c
ok 4 - Closure executed three times with :c
ok 5 - Can use two closures in trans
ok 6 - Source string unchanged
ok 7 - can use closures in pairs of arrays
ok 8 - Source string unchanged
ok 9 - can use closures in pairs of arrays
ok 10 - Source string unchanged
ok 11 - Closure not invoked (only longest match used)
ok 12 - Closure invoked twice (once per replacement)
ok 13 - regex and closure mix
not ok 14 - regex and closure mix (with $/ as topic) # TODO nom regression
# Failed test 'regex and closure mix (with $/ as topic)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-transliteration/with-closure.rakudo line 44
# expected: 'hellllo'
#      got: 'heo'
not ok 15 - regex and closure mix (with $/ as topic and capture) # TODO nom regression
# Failed test 'regex and closure mix (with $/ as topic and capture)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-transliteration/with-closure.rakudo line 47
# expected: 'hellllo'
#      got: 'heo'
ok 16 - Original string not modified
ok 17 - # SKIP Unable to resolve method ord in class Any
ok 18 - original string unchanged
# FUDGED!
1..21
ok 1 - callframe() returns a CallFrame
not ok 2 - callframe().line
ok 3 - .file
ok 4 - # SKIP Unable to resolve method inline in type CallFrame
ok 5 - can access outer lexicals via .my
ok 6 - can access outer lexicals via .my
ok 7 - cannot mutate without is dynamic
ok 8 - callframe(0).code returns this Sub
ok 9 - callframe(1).code returns the calling Sub
ok 10 - 
ok 11 - 
ok 12 - $x successfully modified
ok 13 - $y not modified
ok 14 - CallFrame.raku works
ok 15 - CallFrame.gist works
ok 16 - .raku on callframe in a sub does not crash
ok 17 - No crash when using callframe(1).file many times in a loop
ok 18 - No crash when using callframe.gist in a hot loop
ok 19 - .annotations does not crash
ok 20 - Exploring call frames until no code object does not crash
ok 21 - did we get the right callframe each time?
# FUDGED!
1..6
not ok 1 - Int is dispatched # TODO This is canary test. If this TODO passes then it's probably the time to unfudge the main tests
# Failed test 'Int is dispatched'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-advanced/dispatching.rakudo line 24
# expected: '42'
#      got: (Nil)
not ok 2 - Str is dispatched # TODO This is canary test. If this TODO passes then it's probably the time to unfudge the main tests
# Failed test 'Str is dispatched'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-advanced/dispatching.rakudo line 25
# expected: '22'
#      got: (Nil)
ok 3 - # SKIP Until 2020 dispatcher proposal is implemented
ok 4 - # SKIP Until 2020 dispatcher proposal is implemented
ok 5 - # SKIP Until 2020 dispatcher proposal is implemented
ok 6 - # SKIP Until 2020 dispatcher proposal is implemented
# FUDGED!
1..101
ok 1 - A bare return is Nil
ok 2 - An implicit bare return is Nil
ok 3 - A bare return returns Nil --> Any in array/list context
ok 4 - An implicit bare return Nil --> Any in array/list context
ok 5 - An empty return is false
ok 6 - An empty return is 0
ok 7 - An empty return interpolates nothing in array/list context
ok 8 - A slip return is false
ok 9 - A slip return is 0
ok 10 - A slip return interpolates nothing in array/list context
ok 11 - A bare return is a false value
ok 12 - An implicit bare return is a false value
ok 13 - A returned empty list is an empty list in array/list context
ok 14 - An implicit returned empty list is an empty list in array/list context
ok 15 - A bare return is undefined in scalar context
ok 16 - got the right return value
ok 17 - got the right return value
ok 18 - got the right return value
ok 19 - got the right return value
ok 20 - The object is-a 'Array'
ok 21 - got the right number of return value
ok 22 - got the right return value
ok 23 - got the right return value
ok 24 - got the right return value
ok 25 - The object is-a 'Array'
ok 26 - got the right number of return value
ok 27 - got the right return value
ok 28 - got the right return value
ok 29 - got the right return value
ok 30 - The object is-a 'Array'
ok 31 - got the right number of return value
ok 32 - got the right return value
ok 33 - got the right return value
ok 34 - got the right return value
ok 35 - The object is-a 'Array'
ok 36 - got the right number of return value
ok 37 - got the right return value
ok 38 - got the right return value
ok 39 - got the right return value
ok 40 - The object is-a 'Array'
ok 41 - got the right number of return value
ok 42 - got the right return value
ok 43 - got the right return value
ok 44 - got the right return value
ok 45 - The object is-a 'Array'
ok 46 - got the right number of return value
ok 47 - got the right return value
ok 48 - got the right return value
ok 49 - got the right return value
ok 50 - The object is-a 'Array'
ok 51 - got the right number of return value
ok 52 - got the right return value
ok 53 - got the right return value
ok 54 - got the right return value
ok 55 - The object is-a 'Array'
ok 56 - got the right number of return value
ok 57 - got the right return value
ok 58 - got the right return value
ok 59 - got the right return value
ok 60 - 
ok 61 - got the right number of return value
ok 62 - got the right return value
ok 63 - got the right return value
ok 64 - got the right return value
ok 65 - can call method on return value (hashitem)
ok 66 - got right result
ok 67 - can hash de-ref return value (hashitem)
ok 68 - 
ok 69 - got the right number of return value
ok 70 - got the right return value
ok 71 - got the right return value
ok 72 - got the right return value
ok 73 - can call method on return value (hashitem)
ok 74 - got right result
ok 75 - can hash de-ref return value (hashitem)
ok 76 - bare blocks are invisible to return
ok 77 - nested bare blocks are invisible to return
ok 78 - pointy blocks are invisible to return
ok 79 - subcalls in user-defined control flow are invisible to return
ok 80 - return correctly from official method only
ok 81 - return correctly from official submethod only
ok 82 - return correctly from official sub only
ok 83 - return with named arguments
ok 84 -  ... correct key
ok 85 -  ... correct value
not ok 86 - sub with empty catch block returns value before block # TODO RT #61732
# Failed test 'sub with empty catch block returns value before block'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-advanced/return.rakudo line 353
# expected: '1'
#      got: (Nil)
ok 87 - get right value from sub with double ;
ok 88 - can call sub that returns two things (no parens)
ok 89 - can use value returned from empty routine
ok 90 - 
ok 91 - 
    1..2
    ok 1 - 'my class A { has Str method foo(--> Int) { "hi" } }' died
    ok 2 - right exception type (X::Redeclaration)
ok 92 - did we throws-like X::Redeclaration?
    1..2
    ok 1 - 'my class A { has Int method foo() { return "hi" } }; A.foo' died
    ok 2 - right exception type (X::TypeCheck::Return)
ok 93 - did we throws-like X::TypeCheck::Return?
ok 94 - Can return 42 through Int typecheck
ok 95 - Can return Nil through Int typecheck
ok 96 - Can return Failure through Int typecheck
ok 97 - Can't return 42.0 through Int typecheck
ok 98 - Can't return Cool through Int typecheck
ok 99 - Sub doing 42.return works
ok 100 - can return from parameter defaults
ok 101 - Containerized Nil passes Callable:D constraint
# FUDGED!
1..13
ok 1 - sub foo {...} works
    1..2
    ok 1 - 'sub foo;' died
    ok 2 - right exception type (X::UnitScope::Invalid)
ok 2 - old Perl "sub foo;" syntax is dead
    1..2
    ok 1 - 'lightning()' died
    ok 2 - right exception type (X::StubCode)
ok 3 - executing stub subroutine dies
ok 4 - redefining stub subroutine works without extra syntax
ok 5 - executing stub subroutine lives (should warn here)
ok 6 - redefining stub subroutine works without extra syntax
    1..2
    ok 1 - 'wind()' died
    ok 2 - right exception type (X::StubCode)
ok 7 - executing stub subroutine dies
ok 8 - redefining stub subroutine works without extra syntax
    1..2
    ok 1 - 'sub hail {26}; sub hail {10}' died
    ok 2 - right exception type (X::Redeclaration)
ok 9 - redefining existing subroutine dies
ok 10 - # SKIP supersede NYI
ok 11 - not execued stub code is fine
ok 12 - execued stub code goes BOOM when used
ok 13 - exeucted stub code goes BOOM under fatal
# FUDGED!
1..90
ok 1 - one event logged
ok 2 - it's foo
ok 3 - cannot upwrap a never-wrapped sub.
ok 4 - two events logged
ok 5 - wrapper before
ok 6 - wrapper after
ok 7 - logged the correct events
ok 8 - four events
ok 9 - additional wrapping takes effect
ok 10 - ... on top of initial wrapping
ok 11 - old wrapped sub was not destroyed
ok 12 - the original wrapper is still in effect
ok 13 - one events for unwrapped (should be back to original now)
ok 14 - got execpted value
ok 15 - out of order unwrapping gave right number of results
ok 16 - got execpted value from remaining wrapper
ok 17 - got execpted value from original sub
ok 18 - can't re-unwrap an already unwrapped sub
ok 19 - Basic sub.
ok 20 - Basic wrapping works 
ok 21 - Recieved handle for unwrapping.
ok 22 - Function produces expected output after wrapping
ok 23 - unwrap the function
ok 24 - Function is no longer wrapped.
ok 25 - Sanity test.
ok 26 - Sanity test.
not ok 27 - Check that functions have a 'callwith' that works.  # TODO callwith
# Failed test 'Check that functions have a 'callwith' that works. '
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-advanced/wrap.rakudo line 117
# No such method 'callwith' for invocant of type 'Sub+{SoftRoutine}'
ok 28 - wrapping 1
ok 29 - Checking 1 level wrapping
ok 30 - wrapping 2
ok 31 - Checking 2 level wrapping
ok 32 - wrapping 3
ok 33 - Checking 3 level wrapping
ok 34 - wrapping 4
ok 35 - Checking 4 level wrapping
ok 36 - wrapping 5
ok 37 - Checking 5 level wrapping
ok 38 - wrapping 6
ok 39 - Checking 6 level wrapping
ok 40 - wrapping 7
ok 41 - Checking 7 level wrapping
ok 42 - wrapping 8
ok 43 - Checking 8 level wrapping
ok 44 - wrapping 9
ok 45 - Checking 9 level wrapping
ok 46 - wrapping 10
ok 47 - Checking 10 level wrapping
ok 48 - Sanity.
ok 49 - First wrapping lived
ok 50 - Middle wrapper sanity.
ok 51 - Second wraping lived
ok 52 - three wrappers sanity.
ok 53 - unwrap the middle wrapper.
ok 54 - First wrapper and final function only, middle removed.
ok 55 - Sanity
ok 56 - Check that function is wrapped.
not ok 57 - Wrap is now out of scope, should be back to normal. # TODO temp and wrap
# Failed test 'Wrap is now out of scope, should be back to normal.'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-advanced/wrap.rakudo line 161
# expected: 'xxx'
#      got: 'yyy'
not ok 58 - Wrap is now out of scope, should be back to normal. # TODO temp and wrap
# Failed test 'Wrap is now out of scope, should be back to normal.'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-advanced/wrap.rakudo line 164
# expected: 'xxx'
#      got: 'yyy'
ok 59 - {nextsame}() dies properly
ok 60 - right exception type (X::NoDispatcher)
ok 61 - wrapper test variable is undefined
ok 62 - wrapped greet() works
ok 63 - wrapper sees lexical from time of wrap (greet)
ok 64 - wrapper test variable is undefined
ok 65 - wrapped meet() works
ok 66 - wrapper sees lexical from time of wrap (meet)
ok 67 - wrap worked (sanity)
ok 68 - could unwrap by calling .restore on the handle
ok 69 - multiple wrappings in a loop
ok 70 - can wrap a multi
ok 71 - Did foo, capture return
ok 72 - default works with wrapped accessor, capture return
ok 73 - BUILD binding works with wrapped accessor, capture return
ok 74 - assignment works with wrapped accessor, capture return
ok 75 - Did foo, return callsame
ok 76 - default works with wrapped accessor, return callsame
ok 77 - BUILD binding works with wrapped accessor, return callsame
ok 78 - assignment works with wrapped accessor, return callsame
ok 79 - Did foo, callsame
ok 80 - default works with wrapped accessor, callsame
ok 81 - BUILD binding works with wrapped accessor, callsame
ok 82 - assignment works with wrapped accessor, callsame
ok 83 - Did foo, nextsame
ok 84 - default works with wrapped accessor, nextsame
ok 85 - BUILD binding works with wrapped accessor, nextsame
ok 86 - assignment works with wrapped accessor, nextsame
ok 87 - methods are in order
ok 88 - multi methods with no wraps are in order
ok 89 - multi methods with a wrapped one are in order
ok 90 - methods are in order with the first method wrapped
# FUDGED!
1..13
ok 1 - Priming :(::T  $a, $b, :$c) with \(1) gave :($b, :$c)
ok 2 - Priming :(::T  $a, T $b, T :$c) with \(1) gave :($b, :$c)
ok 3 - Priming :(::T  $a, T @b, T :@c) with \(1) gave :(@b, :@c)
ok 4 - Priming :(::T  $a, T $b, T :$c) with \(1, 1) gave :(:$c)
ok 5 - Priming :(::T  $a, T @b, T :@c) with \(1, $[1]) gave :(:@c)
ok 6 - Priming :(::T  $a, Array[T] $b, Array[Int] :$c) with \(1) gave :($b, Array[Int] :$c)
ok 7 - Priming :(::T  $a, Array[T] $b, Array[Int] :$c) with \(1, Array[Int].new()) gave :(Array[Int] :$c)
ok 8 - Priming :(::T  $a, Array[Array[T]] $b, Array[Array[Int]] :$c) with \(1) gave :($b, Array[Array[Int]] :$c)
ok 9 - Priming :(::T  $a, Array[Positional[T]] $b, Array[Positional[Int]] :$c) with \(1) gave :($b, Array[Positional[Int]] :$c)
ok 10 - # SKIP We could do better here
ok 11 - Priming :() with \(*) gave :()
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck::Binding)
    ok 3 - .backtrace matches rx:i/.*in\s+\S+\s+\S*curr{fail}||prim/
ok 12 - Backtrace mentions priming and does not mention currying
ok 13 - &abc123.assuming(("a", "b", "c").Seq)((1, 2, 3).Seq) returned expected value ["a", "b", "c", 1, 2, 3]
# FUDGED!
1..7
ok 1 - macro returning quasi
ok 2 - # SKIP :COMPILING flag
ok 3 - # SKIP :COMPILING flag
ok 4 - # SKIP :COMPILING flag
ok 5 - Macros can return noops
ok 6 - lexical vars in macros are not visible to the AST vars
ok 7 - # SKIP return from macro
# FUDGED!
1..14
ok 1 - calls to macro are at parse time
ok 2 - macro call with arguments works
ok 3 - macro calls without parens work
ok 4 - macro call with arguments works
ok 5 - can define an entirely new operator
ok 6 - can shadow an existing operator
ok 7 - lexical lookup from quasi to macro works
ok 8 - # SKIP Cannot resolve caller prefix:<++>(Mu)
ok 9 - # SKIP Cannot resolve caller prefix:<++>(Mu)
ok 10 - lexical lookup from quasi to macro params works
ok 11 - macro can return its param
ok 12 - Nil from an empty block turns into no code
ok 13 - addition of two quasis with arithmetical expressions works (1)
ok 14 - addition of two quasis with arithmetical expressions works (2)
# FUDGED!
1..15
ok 1 - can call lexically scoped multi
    1..2
    ok 1 - ' foo() ' died
    ok 2 - right exception type (X::Undeclared::Symbols)
ok 2 - lexical multi not callable outside of lexical scope
ok 3 - outer lexical multi callable
ok 4 - new inner lexical multi callable
ok 5 - in outer scope, can call the multi that is in scope
ok 6 - multi variant from inner scope not callable in outer
ok 7 - no multi variants callable outside of lexical scope
ok 8 - no multi variants callable outside of lexical scope
not ok 9 - inner multi conflicts with outer one # TODO lexical scope as tie breaker
# Failed test 'inner multi conflicts with outer one'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-multi/lexical-multis.rakudo line 42
# Ambiguous call to 'baz(...)'; these signatures all match:
#   ()
#   ()
ok 10 - in outer scope, no inner multi, so no conflict
ok 11 - got multi from package
ok 12 - lexical multi also callable
ok 13 - multi from package still callable outside the inner scope...
ok 14 - ...but lexical multi no longer callable
ok 15 - die in numification of proto
# FUDGED!
1..27
ok 1 - dispatch on class worked
ok 2 - dispatch on class worked
ok 3 - dispatch with no possible candidates fell back to proto
not ok 4 - [+] overloaded by proto definition # TODO operator protos
# Failed test '[+] overloaded by proto definition'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-multi/proto.rakudo line 24
# expected: '12'
#      got: '2 2 3'
ok 5 - proto definition of prefix:<moose> works
ok 6 - multi definition of prefix:<elk> works
ok 7 - dispatch on class worked (anon cap)
ok 8 - dispatch on class worked (anon cap)
ok 9 - dispatch with no possible candidates fell back to proto (anon cap)
    1..2
    ok 1 - 'bar(41)' died
    ok 2 - right exception type (Exception)
ok 10 - impossible dispatch failed (anon cap)
    1..2
    ok 1 - 'EVAL $rt65322' died
    ok 2 - right exception type (X::Redeclaration)
ok 11 - Can't define sub and multi sub without proto
    1..2
    ok 1 - '
    #         multi sub i1(Int $x) {}
    #         sub i1(Int $x, Str $y) {} 
    #     ' died
    ok 2 - right exception type (X::Redeclaration)
ok 12 - declaring a multi and a single routine dies
    1..2
    ok 1 - '
    #         sub i2(Int $x, Str $y) {1}
    #         sub i2(Int $x, Str $y) {2}
    #     ' died
    ok 2 - right exception type (X::Redeclaration)
ok 13 - declaring two only-subs with same name dies
    1..2
    ok 1 - 'proto rt68242($a){};proto rt68242($c,$d){};' died
    ok 2 - right exception type (X::Redeclaration)
ok 14 - attempt to define two proto subs with the same name dies
ok 15 - our proto can be accessed from the ouside
ok 16 - can use {*} in an expression in a proto (1)
ok 17 - can use {*} in an expression in a proto (2)
ok 18 - caching proto (1)
ok 19 - caching proto (2)
ok 20 - caching proto (3)
ok 21 - cached value did not cause extra call
ok 22 - sanity
ok 23 - It's ok not to dispatch to the multis
ok 24 - proto method after same-named attribute
ok 25 - proto method before same-named attribute
    1..2
    ok 1 - '
    #         proto f(Int $x) {*}; multi f($) { 'default' }; f 'foo'
    #     ' died
    ok 2 - right exception type (X::TypeCheck::Argument)
ok 26 - proto signature is checked, not just that of the candidates
    1..2
    ok 1 - 'my &x; sub x {}' died
    ok 2 - right exception type (X::Redeclaration)
ok 27 - my &x; sub x {} throws useful error
# FUDGED!
1..95
ok 1 - multi works with constant
ok 2 - read-only multi was called
ok 3 - multi works with variable
not ok 4 - variable was modified # TODO Calls wrong candidate
# Failed test 'variable was modified'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-multi/subsignature.rakudo line 23
# expected: '100'
#      got: '99'
not ok 5 - read-write multi was called # TODO Calls wrong candidate
# Failed test 'read-write multi was called'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-multi/subsignature.rakudo line 25
# expected: '1'
#      got: '0'
ok 6 - got multi from package
ok 7 - lexical multi also callable
ok 8 - multi from package still callable outside the inner scope...
ok 9 - ...but lexical multi no longer callable
ok 10 - named me
ok 11 - named you
ok 12 - named me, named him
ok 13 - named him, named me
ok 14 - named me named him named her
ok 15 - named him named me named her
ok 16 - named her named me named him
ok 17 - named her named him named me
ok 18 - pos, named you
ok 19 - pos, named her
ok 20 - pos, pos
ok 21 - pos, pos, named
ok 22 - named me
ok 23 - named you
ok 24 - named me, named him
ok 25 - named him, named me
ok 26 - named me named him named her
ok 27 - named him named me named her
ok 28 - named her named me named him
ok 29 - named her named him named me
ok 30 - pos, named you
ok 31 - pos, named her
ok 32 - pos, pos
ok 33 - pos, pos, named
ok 34 - slurpy and named interact well (1)
ok 35 - slurpy and named interact well (2)
ok 36 - slurpy and named interact well (1)
ok 37 - slurpy and named interact well (2)
ok 38 - presence of mandatory named multi does not corrupt calling a nullary
ok 39 - presence of mandatory named multi does not corrupt calling a nullary
ok 40 - dispatch on class worked
ok 41 - dispatch on class worked
ok 42 - dispatch with no possible candidates fell back to proto
not ok 43 - [+] overloaded by proto definition # TODO operator protos
# Failed test '[+] overloaded by proto definition'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-multi/subsignature.rakudo line 156
# expected: '12'
#      got: '2 2 3'
ok 44 - proto definition of prefix:<moose> works
ok 45 - multi definition of prefix:<elk> works
    1..2
    ok 1 - 'proto rt68242(|c($a)){};proto rt68242(|c($c,$d)){};' died
    ok 2 - right exception type (X::Redeclaration)
ok 46 - attempt to define two proto subs with the same name dies
    1..2
    ok 1 - 'EVAL $rt65322' died
    ok 2 - right exception type (X::Redeclaration)
ok 47 - Can't define sub and multi sub without proto
ok 48 - our proto can be accessed from the ouside
ok 49 - can use {*} in an expression in a proto (1)
ok 50 - can use {*} in an expression in a proto (2)
ok 51 - caching proto (1)
ok 52 - caching proto (2)
ok 53 - caching proto (3)
ok 54 - cached value did not cause extra call
ok 55 - sanity
ok 56 - It's ok not to dispatch to the multis
    1..2
    ok 1 - '
    #         proto f(|c(Int $x)) {*}; multi f(|c($)) { 'default' }; f 'foo'
    #     ' died
    ok 2 - right exception type (Exception)
ok 57 - proto signature is checked, not just that of the candidates
ok 58 - can call nextsame inside a multi sub
not ok 59 - called in the right order # TODO Multimethod sort does not descend into subsignatures
# Failed test 'called in the right order'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-multi/subsignature.rakudo line 241
# expected: 'IntAny'
#      got: 'Any'
ok 60 - can call callsame inside a multi sub
not ok 61 - called in the right order # TODO Multimethod sort does not descend into subsignatures
# Failed test 'called in the right order'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-multi/subsignature.rakudo line 252
# expected: 'IntAnyInt'
#      got: 'Any'
ok 62 - can call nextwith inside a multi sub
not ok 63 - called in the right order # TODO Multimethod sort does not descend into subsignatures
# Failed test 'called in the right order'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-multi/subsignature.rakudo line 263
# expected: 'IntAny4'
#      got: 'Any3'
ok 64 - can call callwith inside a multi sub
not ok 65 - called in the right order # TODO Multimethod sort does not descend into subsignatures
# Failed test 'called in the right order'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-multi/subsignature.rakudo line 274
# expected: 'IntAny4Int'
#      got: 'Any3'
ok 66 - It's ok to call nextsame in the last/only candidate
ok 67 - samewith $a stringified in sub
ok 68 - samewith $b stringified for C
ok 69 - samewith $b stringified for C.new
ok 70 - samewith works from inside a nested closure
ok 71 - multi sub with empty signature
ok 72 - multi sub with parameter list
ok 73 - multi with empty signature
ok 74 - multi with parameter list
ok 75 - dispatch tied as expected
ok 76 - not tied as only first type in the dispatch
ok 77 - use multi method to override builtin lives
ok 78 - use multi method to override builtin
ok 79 - interaction between named and slurpy (1)
ok 80 - interaction between named and slurpy (2)
ok 81 - interaction between named and slurpy (3)
ok 82 - interaction between named and slurpy (4)
ok 83 - can find multi method with key
ok 84 - can find multi method with slurpy
ok 85 - non-slurpy wins over slurpy
ok 86 - slurpy called when non-slurpy can not bind
ok 87 - optional parameter does not break type-based candidate sorting
not ok 88 - optional parameter does not break type-based candidate sorting # TODO Multimethod sort does not descend into subsignatures
# Failed test 'optional parameter does not break type-based candidate sorting'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-multi/subsignature.rakudo line 379
# expected: '2'
#      got: '1'
ok 89 - multi can be passed as callable
ok 90 - multi sub declaration returns just the current candidate
ok 91 - and that candidate works
ok 92 - ... and does not contain the full multiness
ok 93 - captures in multi sigs work
ok 94 - ordered multi subs
ok 95 - first defined wins the tie
# FUDGED!
1..65
ok 1 - dispatched to the constant sub
ok 2 - dispatched to the Int sub
ok 3 - dispatched to the Str sub
ok 4 - dispatched to the Num sub
ok 5 - dispatched to the Bool sub
ok 6 - dispatched to the Rule sub
ok 7 - dispatched to the Sub sub
ok 8 - dispatched to the Positional sub
ok 9 - dispatched to the Associative sub
ok 10 - dispatched to the Numeric sub
ok 11 - dispatched to the Inf sub
ok 12 - dispatched to the NaN sub
ok 13 - omitting 'sub' when declaring 'multi sub's works (1)
ok 14 - omitting 'sub' when declaring 'multi sub's works (2)
ok 15 - Slurpy MMD to nullary
ok 16 - Slurpy MMD to listop via args
ok 17 - Slurpy MMD to listop via list
ok 18 - Sigil-based dispatch (Any)
ok 19 - Sigil-based dispatch (Callable)
ok 20 - Sigil-based dispatch (Arrays)
ok 21 - Sigil-based dispatch (Associative)
ok 22 - Basic sanity
ok 23 - multi dispatch with ::T generics
ok 24 - fallback if there is a ::T variant
ok 25 - Type captures and containers mix
ok 26 - Basic sanity 2
ok 27 - multi dispatch with faked generics
ok 28 - fallback if there is a faked generic
ok 29 - MMD with anonymous parameters (1)
ok 30 - MMD with anonymous parameters (2)
ok 31 - MMD with anonymous parameters (3)
ok 32 - subset types involving multiple parameters (fallback)
ok 33 - subset types involving multiple parameters (success)
ok 34 - arity-based dispatch to ($)
ok 35 - arity-based dispatch to ($, $)
ok 36 - arity-based dispatch to ($, $, $)
ok 37 - arity-based dispatch to ($, $, @)
ok 38 - can dispatch to "$ where 0"
ok 39 - ... and the ordinary dispatch still works
ok 40 - can dispatch on typed Hash (Int)
ok 41 - can dispatch on typed Hash (Str)
ok 42 - can dispatch on typed Hash (Array)
ok 43 - can dispatch on typed Array (Int)
ok 44 - can dispatch on typed Array (Str)
ok 45 - can dispatch on typed Array (Array)
ok 46 - can dispatch on typed routine (Str)
ok 47 - can dispatch on typed routine (Int)
    1..2
    ok 1 - '
    #         class RT65674 {
    #             our multi sub a(Int $x) { 'Int ' ~ $x }
    #             our multi sub a(Str $x) { 'Str ' ~ $x }
    #         }
    #     ' died
    ok 2 - right exception type (X::Declaration::Scope::Multi)
ok 48 - no individual multi candidates in "our" scope
ok 49 - multis in classes (1)
ok 50 - multis in classes (2)
    1..2
    ok 1 - 'A::a([4, 5])' died
    ok 2 - right exception type (X::Multi::NoMatch)
ok 51 - multis in classes (3)
ok 52 - where-clause that uses multiple params (1)
ok 53 - where-clause that uses multiple params (1)
ok 54 - generics in multis (+)
ok 55 - generics in multis (-)
ok 56 - Int hits Int() candidate as if it were an Int candidate
ok 57 - Str hits Cool candidate
ok 58 - Set hits Int() candidate due to it accepting Any and coercing
not ok 59 - can distinguish Rat-like string in main # TODO coercions need to fail like constraints
# Failed test 'can distinguish Rat-like string in main'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-multi/type-based.rakudo line 239
not ok 60 - can distinguish Num-like string in main # TODO coercions need to fail like constraints
# Failed test 'can distinguish Num-like string in main'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-multi/type-based.rakudo line 240
not ok 61 - can distinguish Int-like string in main # TODO coercions need to fail like constraints
# Failed test 'can distinguish Int-like string in main'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-multi/type-based.rakudo line 241
not ok 62 - can distinguish Complex-like string in main # TODO coercions need to fail like constraints
# Failed test 'can distinguish Complex-like string in main'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-multi/type-based.rakudo line 242
ok 63 - Combination of where clause plus default parses correctly
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Multi::Ambiguous)
ok 64 - arguments after ;; not considered by multi-dispatch
ok 65 - Can pass a Seq to an @-sigil arg in a multi
# FUDGED!
1..16
ok 1 - # SKIP macros
ok 2 - # SKIP macros
ok 3 - slurpy circumfix:<<...>> works
ok 4 - slurpy circumfix:<<...>> works, allows spaces
ok 5 - lexically defined circumfix works inside EVAL
ok 6 - circumfix with non-Latin1 bracketing characters
ok 7 - circumfix with non-Latin1 bracketing characters, allows spaces
ok 8 - sub postcircumfix:<...> works
ok 9 - lexically defined postcircumfix works inside EVAL
ok 10 - can define circumfix using << >> and both delimiters from the same constant
ok 11 - can define and use circumfix using << >> and both delimiters from the same constant (1)
ok 12 - can define circumfix using << >> and both delimiters from the same constant
ok 13 - can define and use circumfix using << >> and both delimiters from the same constant (2)
ok 14 - can define circumfix using << {sym} >> and both delimiters from the same constant
ok 15 - can define and use circumfix using << >> and both delimiters from the same constant
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Syntax::AddCategorical::TooManyParts)
ok 16 - constants containing too many parts throw correctly
# FUDGED!
1..47
ok 1 - infix Unicode operator (actual overloading)
ok 2 - infix operator overloading for new operator
ok 3 - infix operator overloading for new operator (unicode)
ok 4 - infix operator overloading for new operator (nasty)
ok 5 - frenchquoted infix sub
ok 6 - # SKIP cannot bind with this LHS
ok 7 - operator overloading using symbolic dereferentiation
ok 8 - accessing a builtin operator using its subroutine name
ok 9 - accessing a userdefined operator using its subroutine name
ok 10 - accessing a hyperoperator using its subroutine name
not ok 11 -  # TODO infix:<;>
# Failed test at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-operator-overloading/infix.rakudo line 71
# expected: '5'
#      got: '2'
ok 12 - instantiation of a prefix:<...> and infix:<as> overloading class worked
ok 13 - our object can be stringified
ok 14 - our object was stringified correctly
ok 15 - our object was coerced correctly
ok 16 - # SKIP infix Z will never work; no lexical Z RT  \#124983
ok 17 - # SKIP no lexical Z RT  \#124983
ok 18 - # SKIP no lexical Z RT  \#124983
ok 19 - # SKIP no lexical Z RT  \#124983
ok 20 - # SKIP no lexical Z RT  \#124983
ok 21 - Non-associative works for just tow operands.
ok 22 - Non-associative works when used with parens.
    1..2
    ok 1 - '2 our_non_assoc_infix 3 our_non_assoc_infix 4' died
    ok 2 - right exception type (X::Syntax::NonAssociative)
ok 23 - Non-associative should not parsed when used chainly.
ok 24 - old == still works on integers (+)
ok 25 - old == still works on integers (-)
ok 26 - infix:<==> on A objects works (+)
ok 27 - infix:<==> on A objects works (-)
ok 28 - infix redefinition of += works
ok 29 - can overload exiting operators (here: infix:<+>)
ok 30 - New multis don't disturb old ones
ok 31 - infix:<,>($a, $b)
ok 32 - very specific infix:<,>
not ok 33 - infix:<comment char>($a, $b) # TODO RT #65638
# Failed test 'infix:<comment char>($a, $b)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-operator-overloading/infix.rakudo line 194
# expected: '42'
#      got: '5'
ok 34 - infix:<+>()
ok 35 - infix:<+>($a, $b)
ok 36 - foo= works for custom operators
ok 37 - foo= works for custom operators
ok 38 - bar= works for custom operators
ok 39 - overloading an operator does not hide other candidates
ok 40 - longest operator wins (RT  \#111418)
ok 41 - longest operator wins (RT  \#112870)
ok 42 - assignment to code variable works.
ok 43 - can call existing infix via compile-time string lookup
ok 44 - can call autogen infix via compile-time string lookup
ok 45 - &infix:<<$foo>> works
ok 46 - &infix:«$foo» works
ok 47 - &infix:[$foo] works
# FUDGED!
1..3
not ok 1 - custom postcircumfix{ } is tied to the right class # TODO nom regression
# Failed test 'custom postcircumfix{ } is tied to the right class'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-operator-overloading/methods.rakudo line 15
# expected: 'bar'
#      got: (Failure)
ok 2 - custom postcircumfix{ } does not lead to warnings
ok 3 - custom postcircumfix{ } with weird whitespacing does not require ;
# FUDGED!
1..29
ok 1 - postfix operator overloading for new operator
ok 2 - postfix operator overloading for new operator (weird)
ok 3 - sum prefix operator
ok 4 - factorial postfix operator
ok 5 - correct overloaded method called
ok 6 - # SKIP missing block, apparently "if" not an op
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Syntax::AddCategorical::TooFewParts)
    ok 3 - .message matches Not enough symbols provided for categorical of type circumfix; needs 2
ok 7 - circumfix definition without whitespace between starter and stopper fails with X::Syntax::AddCategorical::TooFewParts
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Syntax::AddCategorical::TooManyParts)
    ok 3 - .message matches Too many symbols provided for categorical of type circumfix; needs only 2
ok 8 - circumfix definition with three parts fails with X::Syntax::AddCategorical::TooManyParts
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Syntax::AddCategorical::TooManyParts)
    ok 3 - .message matches Too many symbols provided for categorical of type infix; needs only 1
ok 9 - infix definition with two parts fails with X::Syntax::AddCategorical::TooManyParts
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Syntax::AddCategorical::TooManyParts)
    ok 3 - .message matches Too many symbols provided for categorical of type term; needs only 1
ok 10 - term definition with two parts fails with X::Syntax::AddCategorical::TooManyParts
ok 11 - ... basic prefix operator overloading worked
ok 12 - ... class methods work for class
ok 13 - ... basic infix operator overloading worked
ok 14 - stringification didn't die
ok 15 - stringification overloading worked in array stringification
ok 16 - can declare operator with a backslash (1)
ok 17 - can declare operator with a backslash (2)
ok 18 - can declare and use operator with a backslash
ok 19 - can define circumfix operator with a double quote (")
ok 20 - can define and use circumfix operator with a double quote (")
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Syntax::Extension::TooComplex)
    ok 3 - .message matches Colon pair value '/./' too complex to use in name
ok 21 - infix definition for /./ fails with X::Syntax::Extension::TooComplex
ok 22 - can define infix with brackets as delimiter
ok 23 - can define and use infix with brackets as delimiter
ok 24 - can define circumfix with brackets as delimiter
ok 25 - can define and use circumfix with brackets as delimiter
ok 26 - can define and use operator with a sigilless constant as symbol
ok 27 - can define and use operator with a sigiled constant as symbol
    1..2
    ok 1 - 'sub meow:<bar> {}' died
    ok 2 - right exception type (X::Syntax::Extension::Category)
ok 28 - defining custom op in non-exitent category throws
ok 29 - can use colon-name extended sub name
# FUDGED!
1..43
ok 1 - a user-defined USAGE sub is called if MAIN dispatch fails
ok 2 - a user-defined USAGE sub is not called if MAIN dispatch succeeds
ok 3 - if the MAIN dispatch results in an error, that error should be printed, not USAGE
ok 4 - auto-generated USAGE message goes to $*ERR and contains parameter name
ok 5 - auto-generated USAGE should handle sigilles parameters
ok 6 - --help option sends auto-generated USAGE message to $*OUT
ok 7 - boolean option +
ok 8 - boolean option -
ok 9 - option with value
ok 10 - named alias (inner name)
ok 11 - named alias (outer name)
ok 12 - Non Bool option last with no value
ok 13 - Bool option followed by positional value
    ok 1 - 
    ok 2 - 
    1..2
ok 14 - Valid arg with zero length value
    ok 1 - 
    ok 2 - 
    1..2
ok 15 - Valid arg with single space value
    ok 1 - 
    ok 2 - 
    1..2
ok 16 - Valid arg with two space value
    ok 1 - 
    ok 2 - 
    1..2
ok 17 - Valid arg with newline value
    ok 1 - 
    ok 2 - 
    1..2
ok 18 - Valid arg with tab value
    ok 1 - 
    ok 2 - 
    1..2
ok 19 - Valid arg with tab then space value
    ok 1 - 
    ok 2 - 
    1..2
ok 20 - Extra arg with zero length value
    ok 1 - 
    ok 2 - 
    1..2
ok 21 - Extra arg with single space value
    ok 1 - 
    ok 2 - 
    1..2
ok 22 - Extra arg with two space value
    ok 1 - 
    ok 2 - 
    1..2
ok 23 - Extra arg with newline value
    ok 1 - 
    ok 2 - 
    1..2
ok 24 - Extra arg with tab value
    ok 1 - 
    ok 2 - 
    1..2
ok 25 - Extra arg with newline value
not ok 26 - option with spacey value # TODO nom regression
# Failed test 'option with spacey value'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-other/main-usage.rakudo line 136
not ok 27 - long option with spacey value # TODO nom regression
# Failed test 'long option with spacey value'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-other/main-usage.rakudo line 141
not ok 28 - named alias (inner name) with spacey value # TODO nom regression
# Failed test 'named alias (inner name) with spacey value'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-other/main-usage.rakudo line 146
not ok 29 - named alias (outer name) with spacey value # TODO nom regression
# Failed test 'named alias (outer name) with spacey value'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-other/main-usage.rakudo line 151
not ok 30 - short option with spacey value # TODO nom regression
# Failed test 'short option with spacey value'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-other/main-usage.rakudo line 156
ok 31 - 
ok 32 - best multi matches (not just first one)
ok 33 - superfluous options trigger usage message
ok 34 - Stopping option processing
ok 35 - Boolean argument with --
ok 36 - single occurence for named array param
ok 37 - multiple occurence for named array param
ok 38 - correctly select Scalar candidate from Scalar and Array candidates.
not ok 39 - correct select Array candidate from Scalar and Array candidates. # TODO NYI
# Failed test 'correct select Array candidate from Scalar and Array candidates.'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-other/main-usage.rakudo line 197
ok 40 - passing an integer matches MAIN(Str)
ok 41 - failed constraint check doesn't leak internal exception out to the user
ok 42 - use of anon slurpy hash does not cause a crash
    1..4
    ok 1 - default $*USAGE is available inside `sub USAGE`
    ok 2 - default $*USAGE is available inside `sub MAIN`
    ok 3 - trying to assign to $*USAGE inside sub MAIN throws
    ok 4 - trying to assign to $*USAGE inside sub MAIN throws
ok 43 - $*USAGE tests
# FUDGED!
1..39
ok 1 - can Int   take an Int:U
ok 2 - can Int   take an Int:D
ok 3 - can Int:_ take an Int:U
ok 4 - can Int:_ take an Int:D
ok 5 - can Int:U take an Int:U
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 6 - can Int:U take an Int:D
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 7 - can Int:D take an Int:U
ok 8 - can Int:D take an Int:D
    1..2
    ok 1 - 'sub a(Int:foo $a) { $a }' died
    ok 2 - right exception type (X::InvalidTypeSmiley)
ok 9 - does Int:foo fail
ok 10 - can --> Int   return an Int:U
ok 11 - can --> Int   return an Int:D
ok 12 - can --> Int:_ return an Int:U
ok 13 - can --> Int:_ return an Int:D
ok 14 - can --> Int:U return an Int:U
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck::Return)
ok 15 - can --> Int:U return an Int:D
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck::Return)
ok 16 - can --> Int:D return an Int:U
ok 17 - can --> Int:D return an Int:D
    1..2
    ok 1 - 'sub a(--> Int:foo) { }' died
    ok 2 - right exception type (X::InvalidTypeSmiley)
ok 18 - does --> Int:foo fail
ok 19 - # SKIP use parameters is NYI until further notice
ok 20 - # SKIP use parameters is NYI until further notice
ok 21 - # SKIP use parameters is NYI until further notice
ok 22 - # SKIP use parameters is NYI until further notice
ok 23 - # SKIP use parameters is NYI until further notice
ok 24 - # SKIP use parameters is NYI until further notice
ok 25 - # SKIP use parameters is NYI until further notice
ok 26 - # SKIP use parameters is NYI until further notice
ok 27 - # SKIP use parameters is NYI until further notice
ok 28 - # SKIP use parameters is NYI until further notice
ok 29 - # SKIP use parameters is NYI until further notice
ok 30 - # SKIP use parameters is NYI until further notice
ok 31 - # SKIP use parameters is NYI until further notice
ok 32 - # SKIP use parameters is NYI until further notice
ok 33 - # SKIP use parameters is NYI until further notice
ok 34 - # SKIP use parameters is NYI until further notice
ok 35 - # SKIP use parameters is NYI until further notice
ok 36 - .gist on :U smileys
ok 37 - .gist on :U smileys uses shortname
ok 38 - .gist on :D smileys
ok 39 - .gist on :D smileys uses shortname
# FUDGED!
1..21
ok 1 - code executes as testsub({...})
ok 2 - code executes as testsub($closure)
ok 3 - code executes as testsub(&subroutine)
ok 4 - code runs with proper signature (1)
    1..2
    ok 1 - 'testit(&teststr)' died
    ok 2 - right exception type (Exception)
ok 5 - code dies with invalid signature (1)
ok 6 - code runs with proper signature (1)
    1..2
    ok 1 - 'test-but-dont-call(&teststr)' died
    ok 2 - right exception type (Exception)
ok 7 - code dies with invalid signature (1)
ok 8 - code runs with proper signature (2)
    1..2
    ok 1 - 'testit(&testintint)' died
    ok 2 - right exception type (Exception)
ok 9 - code dies with invalid signature (2)
    1..2
    ok 1 - 'testit(&teststrbool)' died
    ok 2 - right exception type (Exception)
ok 10 - code dies with invalid signature (3)
    1..2
    ok 1 - 'testit(&teststrint)' died
    ok 2 - right exception type (Exception)
ok 11 - code dies with invalid signature (4)
ok 12 - # SKIP subsignatures dont factor into multi candidates yet
ok 13 - Multi dispatch based on closure parameter syntax (2)
ok 14 - Multi dispatch based on closure parameter syntax (3)
ok 15 - Multi dispatch based on closure parameter syntax (4)
ok 16 - Multi dispatch based on closure parameter syntax (5)
ok 17 - can use &a as a named parameter
    1..2
    ok 1 - 'sub f (Int &b:(--> Bool)) { }' died
    ok 2 - right exception type (X::Redeclaration)
ok 18 - only one way of specifying sub-signature return type allowed
ok 19 - called sub in unpacking Callable signature with colon
ok 20 - unpacking Callable signature with colon
    1..2
    ok 1 - can call with right signature
        1..2
        ok 1 - '-> &:(Int) {}({;})' died
        ok 2 - right exception type (X::TypeCheck::Binding::Parameter)
    ok 2 - typcheck correctly fails with wrong arg
ok 21 - can use signature unpacking with anonymous parameters
# FUDGED!
1..8
ok 1 - Can call my_sub() if &my_sub was a parameter
ok 2 - same with anonymous sub
ok 3 - can't pass thing that doesn't do Callable
ok 4 - can't pass thing that doesn't do Callable
ok 5 - Can pass a block to a &parameter
ok 6 - Can't pass something that isn't typed as returning Callable
not ok 7 - can call a sub with a code object defaulting to something of its own name # TODO RT #67932
# Failed test 'can call a sub with a code object defaulting to something of its own name'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-signature/code.rakudo line 46
# Type check failed in binding to parameter '&foo'; expected Callable but got Nil (Nil)
ok 8 - the inner &foo is undefined (scoping)
# FUDGED!
1..19
ok 1 - A function with a definite return value should ignore the result of its last statement
ok 2 - A function with a non-Nil definite return value should ignore the result of its last statement
    1..2
    ok 1 - '
    #         my sub return-nil(--> Nil) {
    #             return 1
    #         }
    #     ' died
    ok 2 - right exception type (Exception)
ok 3 - A function with a definite return value may not use return with a value
    1..2
    ok 1 - '
    #         my sub return-failure(--> Nil) {
    #             return Failure.new(X::AdHoc.new(4))
    #         }
    #     ' died
    ok 2 - right exception type (X::AdHoc)
ok 4 - A function with a definite return value may not use return with a value, even a Failure
ok 5 - Failures bypass the return value of function with a definite return value in the signature
ok 6 - Failures bypass the return value of function with a definite return value in the signature
ok 7 - Value-less returns are allowed in functions with definite return value in their signatures
ok 8 - # SKIP variables as return specifications dont parse yet
ok 9 - # SKIP variables as return specifications dont parse yet
ok 10 - We can return strings
ok 11 - We can return from statement-less blocks
ok 12 - We can return Empty
ok 13 - and the last statement of the function was sunk
ok 14 - can return True
ok 15 - can return False
ok 16 - can return pi
ok 17 - can return indiana-pi
ok 18 - pointy can have definite return type that is an integer
ok 19 - pointy can have definite return type of Nil
# FUDGED!
1..151
ok 1 - .params does Positional
ok 2 - And all items are Parameters
ok 3 - we have three of them
ok 4 - can get the names with sigils
ok 5 - Could get first type
ok 6 - Could get second type
ok 7 - they are all read-only
ok 8 - ... none rw
ok 9 - ... none copy
ok 10 - ... none raw
ok 11 - ... none slurpy
ok 12 - ... some optional
ok 13 - ... none invocant
ok 14 - ... one named
ok 15 - (second sig) none are all read-only
ok 16 - ... one rw
ok 17 - ... one raw
ok 18 - ... one copy
ok 19 - ... none slurpy
ok 20 - ... some optional
ok 21 - ... none invocant
ok 22 - ... all named
ok 23 - named_names work
ok 24 - .name works for renamed params
ok 25 - .named for slurpies
ok 26 - .slurpy
ok 27 - .name for slurpies
ok 28 - multi named_names
ok 29 - ... and .name still works
not ok 30 - ... and .raku abbreviates separated name/named_name # TODO needs/find RT: Logic to make :a($a) into :$a makes :a(:b($a) into ::b(:$a)
# Failed test '... and .raku abbreviates separated name/named_name'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-signature/introspection.rakudo line 63
# expected: ':(:b($a))'
#      got: ':(:b(:$a))'
ok 31 - .default returns closure
ok 32 - first closure works
ok 33 - # SKIP expected Any but got Mu instead
ok 34 - .constraints (+)
ok 35 - .constraints (-)
ok 36 - .constraints on unconstraint param should still smartmatch truely
ok 37 - smartmach against non-closure constraint (+)
ok 38 - smartmach against non-closure constraint (-)
ok 39 - :(3) contains the 3
ok 40 - :(3) has a parameter of type Int
ok 41 - .type_captures
ok 42 - can access a type_capture'd type
ok 43 - .raku on a nested signature contains variables of the subsignature (1)
ok 44 - .raku on a nested signature contains variables of the subsignature (2)
ok 45 - prefix | makes .capture true
ok 46 - prefix | appears in .raku output
ok 47 - prefix \ makes .raw true
ok 48 - prefix \ appears in .raku output
ok 49 - .raku of a signature with anonymous named parameter
ok 50 - .name of |c is "c"
ok 51 - .positional on Capture param is False
ok 52 - .capture on Capture param is True
ok 53 - .named on Capture param is True
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 54 - .raku of ($a, :$b) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 55 - .raku of (@a, :@b) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 56 - .raku of (%a, :%b) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 57 - .raku of (:a(:b($c))) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 58 - .raku of (|a) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 59 - .raku of (&a, :&b) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 60 - .raku of (\a) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 61 - .raku of (\a, $b, &c, %d, |e) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 62 - .raku of ($a = 2, :$b = 2) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 63 - .raku of (@a = Code.new, :@b = Code.new) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 64 - .raku of (%a = Code.new, :%b = Code.new) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 65 - .raku of (&a = Code.new, :&b = Code.new) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 66 - .raku of ($a is raw = 2) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 67 - .raku of (@a is raw = Code.new) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 68 - .raku of (%a is raw = Code.new) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 69 - .raku of (&a is raw = Code.new) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 70 - .raku of (\a = 2) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 71 - .raku of (Int $a, Int :$b) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 72 - .raku of (Int @a, Int :@b) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 73 - .raku of (Int %a, Int :%b) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 74 - .raku of (Int :a(:b($c))) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 75 - .raku of (|a ($a)) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 76 - .raku of (Sub &a, Sub :&b) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 77 - .raku of (Int \a) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 78 - .raku of (Int \a, Int $b, Sub &c, Int :$d, |e) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 79 - .raku of (Int $a = 2, Int :$b = 2) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 80 - .raku of (Int @a = Code.new, Int :@b = Code.new) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 81 - .raku of (Int %a = Code.new, Int :%b = Code.new) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 82 - .raku of (Sub &a = Code.new, Sub :&b = Code.new) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 83 - .raku of (@a ($a) = Code.new) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 84 - .raku of (%a (:a($b)) = Code.new, %b (:c(:d($e))) = Code.new) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 85 - .raku of ($, :a($)) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 86 - .raku of (@, :a(@)) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 87 - .raku of (%, :a(%)) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 88 - .raku of (:a(:b($))) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 89 - .raku of (|) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 90 - .raku of (&, :a(&)) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 91 - .raku of ($ is raw) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 92 - .raku of ($ is raw, $, &, %, |) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 93 - .raku of ($ = 2, :a($) = 2) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 94 - .raku of (@ = Code.new, :a(@) = Code.new) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 95 - .raku of (% = Code.new, :a(%) = Code.new) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 96 - .raku of (& = Code.new, :a(&) = Code.new) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 97 - .raku of ($ is raw = 2) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 98 - .raku of (@ is raw = Code.new) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 99 - .raku of (% is raw = Code.new) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 100 - .raku of (& is raw = Code.new) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 101 - .raku of (Int, Int :a($)) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 102 - .raku of (Int @, Int :a(@)) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 103 - .raku of (Int %, Int :a(%)) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 104 - .raku of (Int :a(:b($))) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 105 - .raku of (|a ($)) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 106 - .raku of (Sub &, Sub :a(&)) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 107 - .raku of (Int $ is raw) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 108 - .raku of (Int $ is raw, Int, Sub &, Int %, |) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 109 - .raku of (Int $ = 2, Int :a($) = 2) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 110 - .raku of (Int @ = Code.new, Int :a(@) = Code.new) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 111 - .raku of (Int % = Code.new, Int :a(%) = Code.new) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 112 - .raku of (Sub & = Code.new, Sub :a(&) = Code.new) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 113 - .raku of (@ ($a) = Code.new) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 114 - .raku of (% (:a($)) = Code.new, % (:c(:d($))) = Code.new) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 115 - .raku of ($ is raw, & is raw, % is raw, |) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 116 - .raku of (::T  $a, T $b) is idempotent
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 117 - .raku of (::T T $a, T $b) is idempotent
    1..2
    ok 1 - Same .raku output
    ok 2 - ...and no failures.
ok 118 - .raku of -> $a {  \#`(Block|140633631713400) ... } is idempotent
    1..2
    ok 1 - Same .raku output
    ok 2 - ...and no failures.
ok 119 - .raku of ->  {  \#`(Block|140633631719664) ... } is idempotent
    1..2
    ok 1 - Same .raku output
    ok 2 - ...and no failures.
ok 120 - .raku of -> $ ($a) {  \#`(Block|140633631720456) ... } is idempotent
    1..2
    ok 1 - Same .raku output
    ok 2 - ...and no failures.
ok 121 - .raku of -> $ {  \#`(Block|140633631721248) ... } is idempotent
    1..2
    ok 1 - Same .raku output
    ok 2 - ...and no failures.
ok 122 - .raku of -> $a ($b) {  \#`(Block|140633651459320) ... } is idempotent
ok 123 - .raku of a sigature that has ::?CLASS
ok 124 - .raku on unnamed | parameters doesn't err
ok 125 - .raku on unnamed \ parameters doesn't err
ok 126 - ";;" in signature stringifies correctly using .gist
ok 127 - ";;" in signature stringifies correctly using .raku
ok 128 - Callable in signature stringifies correctly using .raku
ok 129 - Callable in signature stringifies correctly using .gist
ok 130 - perl on :(Callable)
ok 131 - .raku on :(Array of Callable)
ok 132 - .raku on :(Hash of Callable)
ok 133 - .gist does not strip typeless anon sigils
ok 134 - does a dynamic Parameter have a * twigil
ok 135 - does a private attribute Parameter have a ! twigil
ok 136 - does a public attribute Parameter have a . twigil
ok 137 - parameters do not give any prefix by default
ok 138 - slurpy positional parameters give a * prefix
ok 139 - slurpy LoL parameters give a ** prefix
ok 140 - slurpy named parameters give a * prefix
ok 141 - slurpy onearg parameters give a + prefix
ok 142 - positional parameters do not give any suffix by default
ok 143 - named parameters do not give any suffix by default
ok 144 - optional positional parameters give a ? suffix
ok 145 - required named parameters give a ! suffix
ok 146 - default values for positional parameters do not give a ? suffix
ok 147 - default values for named parameters do not give a ! suffix
ok 148 - an unnamed raw parameter should have the '$' sigil
ok 149 - private attribute parameters have the correct name
ok 150 - public attribute parameters have the correct name
ok 151 - OUTER defaults have the correct .raku
# FUDGED!
1..100
ok 1 - Can pass positional arguments
ok 2 - Dies on passing superfluous arguments
ok 3 - Named argument passes an integer, not a Pair
ok 4 - can use :$x colonpair syntax to call named arg
ok 5 - colonpair with wrong variable name dies
ok 6 - colonpair with a private variable
ok 7 - colonpair with a public variable
ok 8 - colonpair with a positional variable
ok 9 - simple named param
ok 10 - not specifying named params that aren't mandatory works
ok 11 - using a named as a positional fails
ok 12 - naming named param also works
ok 13 - naming named param adverb-style also works
ok 14 - not specifying named params that aren't mandatory works (foo2)
ok 15 - using a named as a positional fails (foo2)
ok 16 - using a named as a positional fails (foo2)
ok 17 - naming named param x also works (foo2)
ok 18 - naming named param y also works (foo2)
ok 19 - naming named param x & y also works (foo2)
ok 20 - naming named param x adverb-style also works (foo2)
ok 21 - naming named param y adverb-style also works (foo2)
ok 22 - naming named params x & y adverb-style also works (foo2)
ok 23 - mixing fat-comma and adverb naming styles also works for named params (foo2)
ok 24 - mixing adverb and fat-comma naming styles also works for named params (foo2)
ok 25 - When we don't explicitly specify, we get the original value
ok 26 - When we explicitly specify, we get our value
ok 27 - When we explicitly specify, we get our value
ok 28 - When we explicitly specify, we get our value
ok 29 - # SKIP multiple same-named arguments NYI
ok 30 - # SKIP multiple same-named arguments NYI
ok 31 - # SKIP multiple same-named arguments NYI
ok 32 - # SKIP multiple same-named arguments NYI
ok 33 - # SKIP multiple same-named arguments NYI
ok 34 - # SKIP multiple same-named arguments NYI
ok 35 - # SKIP multiple same-named arguments NYI
ok 36 - # SKIP multiple same-named arguments NYI
ok 37 - # SKIP multiple same-named arguments NYI
ok 38 - # SKIP multiple same-named arguments NYI
ok 39 - # SKIP multiple same-named arguments NYI
ok 40 - # SKIP multiple same-named arguments NYI
ok 41 - # SKIP multiple same-named arguments NYI
ok 42 - # SKIP multiple same-named arguments NYI
ok 43 - # SKIP multiple same-named arguments NYI
ok 44 - # SKIP multiple same-named arguments NYI
ok 45 - named mandatory parameter is returned
ok 46 - not specifying a mandatory parameter fails
ok 47 - named mandatory parameter is returned
ok 48 - not specifying a mandatory parameter fails
ok 49 - text param was positional
ok 50 - justification param was not given
ok 51 - case param was named, and in justification param's position
ok 52 - text param was positional
ok 53 - justify param was named
ok 54 - case was not given at all
ok 55 - title param was positional
ok 56 - justify param was named with funny syntax
ok 57 - case param was named with funny syntax
ok 58 - parameters don't bind incorrectly
ok 59 - hobbit arg was slurped
ok 60 - wizard arg was slurped
ok 61 - exactly 2 arguments were slurped
ok 62 - dwarf arg was not given
ok 63 - explicit named arg received despite slurpy hash
ok 64 - exactly 2 arguments were slurped
ok 65 - sky argument was slurped
ok 66 - fire argument was slurped
ok 67 - grass argument was NOT slurped
ok 68 - aref actually implemented
ok 69 - ref is the same as aref
ok 70 - typed named parameters work...
ok 71 - ...when value not supplied also...
ok 72 - and the type check is enforced
ok 73 - renaming of parameters works
ok 74 - renaming of parameters works
ok 75 - old name is not available
    1..2
    ok 1 - 'sub rt68086( $a, $a ) { }' died
    ok 2 - right exception type (X::Redeclaration)
ok 76 - two sub params with the same name
    1..2
    ok 1 - 'sub svn28865( :$a, :@a ) {}' died
    ok 2 - right exception type (X::Signature::NameClash)
ok 77 - sub params with the same name and different types
ok 78 - call to sub with position params of same name and different type
ok 79 - .signature.raku with required parameter includes requirement
ok 80 - parameter rename appears in .signature.raku
ok 81 - passing in three named arguments
ok 82 - $a was bound before $b
ok 83 - $a was bound before $c
ok 84 - $b was bound before $c
    1..2
    ok 1 - 'sub a(:$x, :foo($x) = $x) { $x }' died
    ok 2 - right exception type (X::Redeclaration)
ok 85 - Cannot rename a parameter to an already existing positional
ok 86 - Can fill named parameter with default from other named
ok 87 - Can fill in directly even it has a default value
ok 88 - direct fill takes precedence
ok 89 - :a(1, 2, 3) can be passed to a :@a parameter
ok 90 - :a[1, 2, 3] can be passed to a :@a parameter
ok 91 - :a<1 2 3> can be passed to a :@a parameter
ok 92 - quoted pair key => positional parameter
ok 93 - can call function with empty named argument
ok 94 - can pass in several same-named arguments to sub, sigils other than "@" bind to last argument (1)
ok 95 - can pass in several same-named arguments to sub, sigils other than "@" bind to last argument (2)
ok 96 - rightmost named argument wins (1)
ok 97 - rightmost named argument wins (2)
ok 98 - rightmost named argument wins (3)
ok 99 - rightmost named argument wins (4)
ok 100 - Hot looping making call with aliased named parameter works
# FUDGED!
1..4
    1..2
    ok 1 - f eq 2 after binding
    ok 2 - o eq 3 after binding
ok 1 - signature binding outside of routine calls
    1..5
        1..5
        ok 1 - :D ~~ :D (false)
        ok 2 - :D ~~ :D (true)
        ok 3 - :U ~~ :D
        ok 4 - :D x 2 ~~ :D x2 (false)
        ok 5 - :D x 2 ~~ :D x2 (true)
    ok 1 - strings
        1..5
        ok 1 - :D ~~ :D (false)
        ok 2 - :D ~~ :D (true)
        ok 3 - :U ~~ :D
        ok 4 - :D x 2 ~~ :D x2 (false)
        ok 5 - :D x 2 ~~ :D x2 (true)
    ok 2 - Complex
        1..5
        ok 1 - # SKIP crashes
        ok 2 - # SKIP crashes
        ok 3 - # SKIP crashes
        ok 4 - # SKIP crashes
        ok 5 - # SKIP crashes
    ok 3 - Rat
        1..5
        ok 1 - :D ~~ :D (false)
        ok 2 - :D ~~ :D (true)
        ok 3 - :U ~~ :D
        ok 4 - :D x 2 ~~ :D x2 (false)
        ok 5 - :D x 2 ~~ :D x2 (true)
    ok 4 - Num
        1..5
        ok 1 - :D ~~ :D (false)
        ok 2 - :D ~~ :D (true)
        ok 3 - :U ~~ :D
        ok 4 - :D x 2 ~~ :D x2 (false)
        ok 5 - :D x 2 ~~ :D x2 (true)
    ok 5 - Int
ok 2 - smartmatch on signatures with literals
ok 3 - invocant marker is allowed in bare signature
ok 4 - smartmatch with no slurpy on right side
# FUDGED!
1..34
ok 1 - The object is-a 'Code'
ok 2 - The object is-a 'Routine'
ok 3 - The object is-a 'Sub'
ok 4 - basic invocation of an anonymous sub
ok 5 - invocation of a parameterless anonymous sub with a parameter dies
ok 6 - The object is-a 'Code'
ok 7 - The object is-a 'Block'
ok 8 - basic invocation of a pointy block
ok 9 - invocation of a parameterless pointy block with a parameter dies
ok 10 - The object is-a 'Code'
ok 11 - The object is-a 'Block'
ok 12 - basic invocation of a pointy block with a param
ok 13 - invocation of a parameterized block expecting a param without a param dies
not ok 14 - $_ got right value for code ref # TODO RT #63974
# Failed test '$_ got right value for code ref'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-signature/sub-ref.rakudo line 59
# expected: '2'
#      got: (Any)
not ok 15 - @_ got right value in code ref # TODO RT #63974
# Failed test '@_ got right value in code ref'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-signature/sub-ref.rakudo line 60
# expected: '3 4 5'
#      got: '2 3 4 5'
ok 16 - The object is-a 'Code'
ok 17 - The object is-a 'Routine'
ok 18 - The object is-a 'Sub'
ok 19 - basic invocation of a Perl-like anonymous sub (1)
ok 20 - basic invocation of a Perl-like anonymous sub (2)
ok 21 - The object is-a 'Code'
ok 22 - The object is-a 'Routine'
ok 23 - The object is-a 'Sub'
ok 24 - calling an anonymous sub with a positional param
ok 25 - calling an anonymous sub expecting a param without a param dies
ok 26 - calling an anonymous sub expecting one param with two params dies
ok 27 - # SKIP macros, compile time binding
ok 28 - # SKIP macros, compile time binding
ok 29 - # SKIP macros, compile time binding
ok 30 - # SKIP macros, compile time binding
ok 31 - closures: inc1 == 0
ok 32 - closures: inc1 == 1
ok 33 - closures: inc2 == 0
ok 34 - closures: inc2 == 1
# FUDGED!
1..20
ok 1 - left value is correct: basic hash
ok 2 - right value is correct: basic hash
ok 3 - left value is correct: hash with extra values
ok 4 - right value is correct: hash with extra values
ok 5 - left value is correct: hash with values that are hashes
ok 6 - right value is correct: hash with values that are hashes
ok 7 - east value is correct: custom hash values work
ok 8 - west value is correct: custom hash values work
ok 9 - east value is correct: custom hash, extra values
ok 10 - west value is correct: custom hash, extra values
ok 11 - east value is correct: custom hash with values that are hashes
ok 12 - west value is correct: custom hash with values that are hashes
ok 13 - left object value is correct: simple object
ok 14 - right object value is correct: simple object
ok 15 - left object value is correct: nested object tree
ok 16 - right object value is correct: nested object tree
ok 17 - # SKIP signature binding of return values NYI
ok 18 - # SKIP signature binding of return values NYI
ok 19 - # SKIP signature binding of return values NYI
ok 20 - # SKIP signature binding of return values NYI
# FUDGED!
1..7
ok 1 - assoc<left>
ok 2 - assoc<right>
ok 3 - assoc<list>
ok 4 - assoc<non>
ok 5 - # SKIP RT  \#116244
ok 6 - # SKIP RT  \#116244
ok 7 - User-defined chaining operators with assoc<chain> work
# FUDGED!
1..23
    1..2
    ok 1 - '
    #     my $tmp = 1;
    #     sub mods_param ($x) { $x++; }
    #     mods_param($tmp)
    #     ' died
    ok 2 - right exception type (X::Multi::NoMatch)
ok 1 - can't modify parameter, constant by default
    1..2
    ok 1 - '
    #     my $tmp = 1;
    #     sub mods_param ($x) { $x = 1; }
    #     mods_param($tmp)
    #     ' died
    ok 2 - right exception type (Exception)
ok 2 - can't modify parameter, constant by default
    1..2
    ok 1 - 'sub mods_param_constant ($x is readonly) { $x++; };
    #              mods_param_constant($foo);' died
    ok 2 - right exception type (X::Multi::NoMatch)
ok 3 - can't modify constant parameter, constant by default
ok 4 - can't modify constant even if we claim it's rw
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Parameter::RW)
ok 5 - is rw dies in signature binding if passed a literal Int
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Parameter::RW)
ok 6 - is rw dies in signature binding if passed an itemized array
ok 7 - pass by "is rw" doesn't die
ok 8 - pass by reference works
ok 9 - trait "is rw" used to narrow multi-dispatch
ok 10 - trait "is rw" used to narrow multi-dispatch (converse)
ok 11 - is copy
ok 12 - pass by value works
ok 13 - can modify a copy
ok 14 - is raw with non-lvalue
ok 15 - is raw with non-lvalue
ok 16 - is raw works
ok 17 - <-> does not override explicit traints (sanity)
not ok 18 - <-> does not override explicit traints # TODO is readonly does not override
# Failed test '<-> does not override explicit traints'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-traits/misc.rakudo line 91
not ok 19 - <-> does not override explicit traints (sanity) # TODO is readonly does not override
# Failed test '<-> does not override explicit traints (sanity)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-traits/misc.rakudo line 92
# expected: '2'
#      got: '3'
ok 20 - Can't use an unknown trait
ok 21 - error message mentions trait
ok 22 - error message mentions the name of the trait
ok 23 - duplicate traits warn
# FUDGED!
1..15
not ok 1 - 'is tighter' on prefix works # TODO changing precedence of already declared op
# Failed test ''is tighter' on prefix works'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-traits/precedence.rakudo line 19
# expected: '9'
#      got: '3'
ok 2 - 'is looser' on prefix works
ok 3 - 'is tighter' on postfix works
ok 4 - 'is looser(&infix:<+>' works 1
ok 5 - 'is looser(&infix:<+>' works 2
ok 6 - 'is looser<+>' infix works 1
ok 7 - 'is looser<+>' infix works 2
ok 8 - 'is tighter<*>' infix works 1
ok 9 - 'is tighter<*>' infix works 2
ok 10 - 'is equiv(&infix:<*>)' works
ok 11 - 'is equiv<*>' works
ok 12 - Postifix declared looser than prefix
ok 13 - Postfix declared tighter than prefix
ok 14 - Should be parsed as '-(1!)'
ok 15 - Whitespace not allowed before user-defined postfix
# FUDGED!
1..87
ok 1 - can hyper-map a simple code block
ok 2 - hyper over a big-ish list of Ints
ok 3 - two-stage hyper map over big-ish Int list
ok 4 - two-stage hyper map over some strings
ok 5 - hyper + grep
ok 6 - hyper + grep + map
    1..2
    ok 1 - hyper + map
    ok 2 - hyper + grep
ok 7 - hyper + map/grep in reverse
    1..5
    ok 1 - code dies
    ok 2 - right exception type (X::Invalid::Value)
    ok 3 - .method matches hyper
    ok 4 - .value matches -1
    ok 5 - .name matches batch
ok 8 - cannot have a batch of -1 for hyper
    1..5
    ok 1 - code dies
    ok 2 - right exception type (X::Invalid::Value)
    ok 3 - .value matches 0
    ok 4 - .method matches hyper
    ok 5 - .name matches batch
ok 9 - cannot have a batch of 0 for hyper
    1..5
    ok 1 - code dies
    ok 2 - right exception type (X::Invalid::Value)
    ok 3 - .name matches degree
    ok 4 - .value matches -1
    ok 5 - .method matches hyper
ok 10 - cannot have a degree of -1 for hyper
    1..5
    ok 1 - code dies
    ok 2 - right exception type (X::Invalid::Value)
    ok 3 - .method matches hyper
    ok 4 - .name matches degree
    ok 5 - .value matches 0
ok 11 - cannot have a degree of 0 for hyper
ok 12 - Exception thrown in hyper for is not lost (1..1)
ok 13 - Exception thrown in hyper for is not lost (1..1000)
ok 14 - Exception thrown in hyper map is not lost (1..1)
ok 15 - Exception thrown in hyper map is not lost (1..1000)
ok 16 - Exception thrown in hyper grep is not lost (1..1)
ok 17 - Exception thrown in hyper grep is not lost (1..1000)
    1..10
    ok 1 - .hyper(:3batch, :5degree) [0]
    ok 2 - .hyper(:3batch, :5degree) [1]
    ok 3 - .hyper(:3batch, :5degree) [2]
    ok 4 - .hyper(:3batch, :5degree) [3]
    ok 5 - .hyper(:3batch, :5degree) [4]
    ok 6 - .hyper(:1batch) [0]
    ok 7 - .hyper(:1batch) [1]
    ok 8 - .hyper(:1batch) [2]
    ok 9 - .hyper(:1batch) [3]
    ok 10 - .hyper(:1batch) [4]
ok 18 - .hyper with .map that sleep()s
ok 19 - hyper map with a multi sub works
ok 20 - for <a b c>.hyper { } actually iterates
ok 21 - Correct result for [+] (1..100).hyper
ok 22 - Correct result for [+] (1..100).hyper.grep(* != 22)
ok 23 - Correct result for [+] (1..100).grep(* != 22).hyper
ok 24 - .hyper.elems works
ok 25 - hyper map in sink context iterates
ok 26 - .is-lazy on HyperSeq returns False
ok 27 - .Numeric on HyperSeq
ok 28 - Correct result of .hyper.map(*+1) (try 0)
ok 29 - Correct result of .hyper.map(*+1) (try 1)
ok 30 - Correct result of .hyper.map(*+1) (try 2)
ok 31 - Correct result of .hyper.map(*+1) (try 3)
ok 32 - Correct result of .hyper.map(*+1) (try 4)
ok 33 - .hyper.map({.fmt(...)}) on a Buf slice works
ok 34 - .hyper.map({.fmt(...)}) on a Buf slice works
ok 35 - .hyper.map({.fmt(...)}) on a Buf slice works
ok 36 - .hyper.map({.fmt(...)}) on a Buf slice works
ok 37 - .hyper.map({.fmt(...)}) on a Buf slice works
ok 38 - can race-map a simple code block
ok 39 - race over a big-ish list of Ints
ok 40 - two-stage race map over big-ish Int list
ok 41 - two-stage race map over some strings
ok 42 - race + grep
ok 43 - race + grep + map
    1..2
    ok 1 - race + map
    ok 2 - race + grep
ok 44 - race + map/grep in reverse
    1..5
    ok 1 - code dies
    ok 2 - right exception type (X::Invalid::Value)
    ok 3 - .value matches -1
    ok 4 - .name matches batch
    ok 5 - .method matches race
ok 45 - cannot have a batch of -1 for race
    1..5
    ok 1 - code dies
    ok 2 - right exception type (X::Invalid::Value)
    ok 3 - .name matches batch
    ok 4 - .method matches race
    ok 5 - .value matches 0
ok 46 - cannot have a batch of 0 for race
    1..5
    ok 1 - code dies
    ok 2 - right exception type (X::Invalid::Value)
    ok 3 - .value matches -1
    ok 4 - .method matches race
    ok 5 - .name matches degree
ok 47 - cannot have a degree of -1 for race
    1..5
    ok 1 - code dies
    ok 2 - right exception type (X::Invalid::Value)
    ok 3 - .name matches degree
    ok 4 - .method matches race
    ok 5 - .value matches 0
ok 48 - cannot have a degree of 0 for race
ok 49 - Exception thrown in race for is not lost (1..1)
ok 50 - Exception thrown in race for is not lost (1..1000)
ok 51 - Exception thrown in race map is not lost (1..1)
ok 52 - Exception thrown in race map is not lost (1..1000)
ok 53 - Exception thrown in race grep is not lost (1..1)
ok 54 - Exception thrown in race grep is not lost (1..1000)
    1..10
    ok 1 - .race(:3batch, :5degree) [0]
    ok 2 - .race(:3batch, :5degree) [1]
    ok 3 - .race(:3batch, :5degree) [2]
    ok 4 - .race(:3batch, :5degree) [3]
    ok 5 - .race(:3batch, :5degree) [4]
    ok 6 - .race(:1batch) [0]
    ok 7 - .race(:1batch) [1]
    ok 8 - .race(:1batch) [2]
    ok 9 - .race(:1batch) [3]
    ok 10 - .race(:1batch) [4]
ok 55 - .race with .map that sleep()s
ok 56 - race map with a multi sub works
ok 57 - for <a b c>.race { } actually iterates
ok 58 - Correct result for [+] (1..100).race
ok 59 - Correct result for [+] (1..100).race.grep(* != 22)
ok 60 - Correct result for [+] (1..100).grep(* != 22).race
ok 61 - .race.elems works
ok 62 - race map in sink context iterates
ok 63 - .is-lazy on RaceSeq returns False
ok 64 - .Numeric on RaceSeq
ok 65 - Correct result of .race.map(*+1) (try 0)
ok 66 - Correct result of .race.map(*+1) (try 1)
ok 67 - Correct result of .race.map(*+1) (try 2)
ok 68 - Correct result of .race.map(*+1) (try 3)
ok 69 - Correct result of .race.map(*+1) (try 4)
ok 70 - .race.map({.fmt(...)}) on a Buf slice works
ok 71 - .race.map({.fmt(...)}) on a Buf slice works
ok 72 - .race.map({.fmt(...)}) on a Buf slice works
ok 73 - .race.map({.fmt(...)}) on a Buf slice works
ok 74 - .race.map({.fmt(...)}) on a Buf slice works
ok 75 - Can switch from race to hyper mode
ok 76 - Switching from race to hyper mode does not break results
ok 77 - Can switch from race to sequential Seq
ok 78 - Switching from race to sequential Seq does not break results
ok 79 - Can switch from hyper to race mode
ok 80 - Switching from hyper to race mode does not break results
ok 81 - Can switch from hyper to sequential Seq
ok 82 - hyper to sequential Seq switch does not break results or disorder
ok 83 - .hyper preserves order
ok 84 - hyperized s/…/…/;
ok 85 - # SKIP reliably hangs / segfaults on at least MacOS
ok 86 - die in a race nested in a race propagates exception
ok 87 - die in a hyper nested in a hyper propagates exception
# FUDGED!
1..103
ok 1 - $r is an Iterator
ok 2 - $r.count-only works
ok 3 - $r.pull-one == 1 and Range Iterator kept place
ok 4 - $r.pull-one == 2
ok 5 - $r.pull-one == 3
ok 6 - $r.pull-one == 4
ok 7 - $r.pull-one == 5
ok 8 - $r.pull-one is done
ok 9 - $r is an Iterator
ok 10 - # SKIP Method 'count-only' not found for invocant of class
ok 11 - $r.pull-one == -1.5 and Range Iterator kept place
ok 12 - $r.pull-one == -0.5
ok 13 - $r.pull-one == .5
ok 14 - $r.pull-one == 1.5
ok 15 - $r.pull-one == 2.5
ok 16 - $r.pull-one is done
ok 17 - $r is an Iterator
ok 18 - # SKIP Method 'count-only' not found for invocant of class
ok 19 - $r.pull-one == -1.5 and Range Iterator kept place
ok 20 - $r.pull-one == -0.5
ok 21 - $r.pull-one == .5
ok 22 - $r.pull-one == 1.5
ok 23 - $r.pull-one == 2.5
ok 24 - $r.pull-one is done
ok 25 - $r is an Iterator
ok 26 - # SKIP Method 'count-only' not found for invocant of class
ok 27 - $r.pull-one == -0.5 and Range Iterator kept place
ok 28 - $r.pull-one == .5
ok 29 - $r.pull-one == 1.5
ok 30 - $r.pull-one == 2.5
ok 31 - $r.pull-one is done
ok 32 - $r is an Iterator
ok 33 - $r.is-lazy works
ok 34 - $r.pull-one == -1 and Range Iterator kept place
ok 35 - $r.pull-one == 0
ok 36 - $r.pull-one == 1
ok 37 - $r.pull-one == 2
ok 38 - $r.pull-one == 3
ok 39 - $r.pull-one == 4
ok 40 - $r.pull-one == 5
ok 41 - $r.pull-one == 106
ok 42 - $r is an Iterator
ok 43 - $r.is-lazy works
ok 44 - $r.pull-one == -1.5 and Range Iterator kept place
ok 45 - $r.pull-one == -0.5
ok 46 - $r.pull-one == .5
ok 47 - $r.pull-one == 1.5
ok 48 - $r.pull-one == 2.5
ok 49 - $r.pull-one == 3.5
ok 50 - $r.pull-one == 4.5
ok 51 - $r is an Iterator
ok 52 - $r.is-lazy works
ok 53 - $r.pull-one == -1.5 and Range Iterator kept place
ok 54 - $r.pull-one == -0.5
ok 55 - $r.pull-one == .5
ok 56 - $r.pull-one == 1.5
ok 57 - $r.pull-one == 2.5
ok 58 - $r.pull-one == 3.5
ok 59 - $r.pull-one == 4.5
ok 60 - $r1 is an Iterator
ok 61 - $r2 is an Iterator
ok 62 - $r1.pull-one == -1
ok 63 - $r2.pull-one == 42
ok 64 - $r1.pull-one == 0
ok 65 - $r2.pull-one == 43
ok 66 - $r1.pull-one == 1
ok 67 - $r2.pull-one == 44
ok 68 - $r1.pull-one == 2
ok 69 - $r2.pull-one == 45
ok 70 - $r1.pull-one == 3
ok 71 - $r2.pull-one == 46
ok 72 - $r1.pull-one == 4
ok 73 - $r2.pull-one == 47
ok 74 - $r1.pull-one == 5
ok 75 - $r2.pull-one == 48
ok 76 - $r is an Iterator
ok 77 - # SKIP Method 'count-only' not found for invocant of class
ok 78 - $r.pull-one == d and Range Iterator kept place
ok 79 - $r.pull-one == e
ok 80 - $r.pull-one == f
ok 81 - $r.pull-one == g
ok 82 - $r.pull-one is done
ok 83 - $r is an Iterator
ok 84 - $r.is-lazy works
ok 85 - $r.pull-one == d and Range Iterator kept place
ok 86 - $r.pull-one == e
ok 87 - $r.pull-one == f
ok 88 - $r.pull-one == g
ok 89 - $r.pull-one == h
ok 90 - $r.pull-one == i
ok 91 - $r is an Iterator
ok 92 - $r.pull-one == 0
ok 93 - $r.pull-one == 1
ok 94 - $r.pull-one == 2
ok 95 - $r.pull-one == 3
ok 96 - # SKIP Method 'count-only' not found for invocant of class
ok 97 - $r.pull-one == 4 and Range Iterator kept place
ok 98 - $r.pull-one == 5
ok 99 - $r.pull-one == 6
ok 100 - $r.pull-one == 7
    1..6
    ok 1 - .skip-one returns truthy value on successfull skip
    ok 2 - .pull-one after .skip-one gives correct value
    ok 3 - .skip-one (1)
    ok 4 - .skip-one (2)
    ok 5 - .pull-one after 2 .skip-one gives correct value
    ok 6 - .skip-one returns falsy value when there is nothing to skip
ok 101 - Iterator.skip-one
    1..3
    ok 1 - skipping 3 values succeeds
    ok 2 - next value after skip is correct
    ok 3 - skipping more values than we have is falsy
ok 102 - Iterator.skip-at-least
    1..3
    ok 1 - method returns correct value
    ok 2 - value after skip is correct
    ok 3 - when not enough values to skip, returns IterationEnd
ok 103 - Iterator.skip-at-least-pull-one
# FUDGED!
1..44
ok 1 - just mentioning a hash value should not autovivify it
ok 2 - autovivification of a hash element to an arrayitem worked
ok 3 - Created one hash item
ok 4 - autovivification of a hash element to a hashitem worked
ok 5 - Inner hash item is really a Hash
ok 6 - autovivification to an array by &push
ok 7 - autovivified to Array
ok 8 - autovivification to an array by &unshift
ok 9 - autovivification of an array element to an array by &push
ok 10 - autovivification of an hash element to an array by &push
ok 11 - uninitialized variable is not a Hash (1)
ok 12 - hash element assignment worked
ok 13 - # SKIP isa multi variant
ok 14 - uninitialized variable is not a Hash (2)
ok 15 - accessing a not existing hash element of an uninitialized variable works
ok 16 - uninitialized variable is not autovivified to a hash (2)
ok 17 - accessing a not existing hash element of an uninitialized variable works (2)
ok 18 - uninitialized variable is not autovivified to a hash (3)
ok 19 - uninitialized variable is not autovivified to a hash (4)
ok 20 - uninitialized variable is not a Hash (3)
ok 21 - binding a not existing hash element of an uninitialized variable works
not ok 22 - uninitialized variable is autovivified to a hash (4) # TODO autoviv, binding
# Failed test 'uninitialized variable is autovivified to a hash (4)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-autovivification/autovivification.rakudo line 102
ok 23 - binding a not existing hash element of an uninitialized variable works (2)
not ok 24 - uninitialized variable is autovivified to a hash (5) # TODO autoviv, binding
# Failed test 'uninitialized variable is autovivified to a hash (5)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-autovivification/autovivification.rakudo line 107
ok 25 - uninitialized variable is not an Array (1)
ok 26 - uninitialized variable was autovivified to an array (1)
ok 27 - array element assignment worked
ok 28 - uninitialized variable is not an Array (2)
ok 29 - accessing a not existing array element of an uninitialized variable works
ok 30 - uninitialized variable was not autovivified to an array (2)
ok 31 - accessing a not existing array element of an uninitialized variable works
ok 32 - uninitialized variable was not autovivified to an array (3)
ok 33 - uninitialized variable was not autovivified to an array (4)
ok 34 - uninitialized variable is not an Array (3)
ok 35 - binding a not existing array element of an uninitialized variable works (1)
not ok 36 - uninitialized variable is autovivified to an array (1) # TODO unknown
# Failed test 'uninitialized variable is autovivified to an array (1)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-autovivification/autovivification.rakudo line 145
ok 37 - binding a not existing array element of an uninitialized variable works (2)
not ok 38 - uninitialized variable is autovivified to an array (2) # TODO unknown
# Failed test 'uninitialized variable is autovivified to an array (2)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-autovivification/autovivification.rakudo line 150
ok 39 - autovivification of an array element to an arrayitem worked
ok 40 - autovivification of an array element to a hashitem worked
ok 41 - using an undeclared globaly qualified code variable in void context is ok
ok 42 - ...but invoking undeclared globally qualifed code variable should die
ok 43 - autovivificaion of arrays works via multidim syntax
ok 44 - autovivification of hashes works via multidim syntax
# FUDGED!
1..55
ok 1 - Any-typed hash access (+)
ok 2 - and the hash really uses ===-semantics
ok 3 - Any-typed hash does not like Mu keys
ok 4 - returned key is correct
ok 5 - value-type semantics
ok 6 - non-conformant type dies
ok 7 - key type mismatch
ok 8 - value type mismatch
ok 9 - key and value type mismatch
ok 10 - .keys
ok 11 - .values
ok 12 - .kv types (1)
ok 13 - .kv types (2)
ok 14 - .pairs.key type
ok 15 - .pairs.value type
ok 16 - .elems
ok 17 - binding to typed objecthash elements
ok 18 - updated .elems
ok 19 - binding key type check failure
ok 20 - binding value type check failure
ok 21 - Hash.push fails when the resulting array conflicts with the type check
ok 22 - Hash.push without array creation is OK
ok 23 - Hash.push key type check failure
ok 24 - Hash.push value type check failure
ok 25 - list assignment + object hashes
not ok 26 - using Mu as a key (1) # TODO oh noes, it dies
# Failed test 'using Mu as a key (1)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-hashes/objecthash.rakudo line 59
# Type check failed in binding to parameter '<anon>'; expected Any but got Mu (Mu)
ok 27 - # SKIP oh noes, it dies
ok 28 - using Any as a key
ok 29 - # SKIP oh noes, it dies
not ok 30 - check whatever access with Mu as key # TODO oh noes, it dies
# Failed test 'check whatever access with Mu as key'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-hashes/objecthash.rakudo line 69
# expected: '2,3'
#      got: '3'
ok 31 - .exists returns True on a %h{Any} in a TypedHash
ok 32 - declaring empty object hash on rhs of assignment to hash does not die with "Cannot look up attributes in a type object"
ok 33 - empty hash listifies to empty list
ok 34 - empty object hash listifies to empty list
ok 35 - New on an object hash instance produces an object hash
ok 36 - Clone of an object hash instance is an object hash
ok 37 - Can use mixin objects as keys
ok 38 - 
ok 39 - 
ok 40 - 
ok 41 - 
ok 42 - 
ok 43 - 
ok 44 - 
ok 45 - 
ok 46 - 
ok 47 - 
ok 48 - 
ok 49 - 
ok 50 - 
ok 51 - 
ok 52 - 
ok 53 - 
ok 54 - 
ok 55 - Accept dynamic object hash
# FUDGED!
1..35
ok 1 - basic slice
ok 2 - basic slice, explicit list
ok 3 - basic slice, duplicate indices
ok 4 - slice from array, part 2
ok 5 - slice from array slice, part 1
ok 6 - slice from array slice, part 2
ok 7 - range from array
ok 8 - nested slice
ok 9 - slice plus range from array
ok 10 - range plus slice from array
ok 11 - finite sequence slice
ok 12 - infinite sequence slice
ok 13 - infinite even sequence slice
ok 14 - infinite even sequence slice
ok 15 - assigning a slice too many items yields a correct return value
ok 16 - slice on array literal
ok 17 - slice on arrayitem literal
ok 18 - values from hash keys, part 1
ok 19 - values from hash keys, part 2
ok 20 - calculated slice: hyperop
ok 21 - @array[2..1] is an empty slice
ok 22 - # SKIP *..* does not slice
ok 23 - # SKIP *..* does not slice
ok 24 - The object is-a 'Array'
ok 25 - 
ok 26 - slice with one element is a list
ok 27 - slice with one element specified by variables
ok 28 - can use 1..^@a for subscripting
ok 29 - # SKIP .= with non-identifier postfixes
ok 30 - # SKIP .= with non-identifier postfixes
ok 31 - can assign to a Buf slice
ok 32 - [*] slice returns all elements of a list of hash value
    1..3
    ok 1 - more indexes than els
    ok 2 - fewer indexes than els
    ok 3 - lazy iterable with iterator starting non-lazy
ok 33 - no "drift" when re-using lazy iterable for indexing
    1..6
    ok 1 - Inf range inclusive
    ok 2 - Inf range exclusive
    ok 3 - Whatever range inclusive
    ok 4 - Whatever range exclusive
    ok 5 - Whatever callable
    ok 6 - Callable
ok 34 - infinite ranges and whatever stars
    1..62
    ok 1 - Nested slice, no adverbs
    ok 2 - Nested slice, p adverb
    ok 3 - Nested slice, negated p adverb
    ok 4 - Nested slice, k adverb
    ok 5 - Nested slice, negated k adverb
    ok 6 - Nested slice, v adverb
    ok 7 - Nested slice, negated v adverb
    ok 8 - Nested slice, kv adverb
    ok 9 - Nested slice, negated kv adverb
    ok 10 - Nested slice, exists adverb 1
    ok 11 - Nested slice, exists adverb 2
    ok 12 - Nested slice, exists adverb 3
    ok 13 - Nested slice, delete adverb 1-1
    ok 14 - Nested slice, delete adverb 1-2
    ok 15 - Nested slice, delete adverb 2-1
    ok 16 - Nested slice, delete adverb 2-2
    ok 17 - Nested slice, negated delete adverb 3-1
    ok 18 - Nested slice, negated delete adverb 3-2
    ok 19 - Nested slice, delete + kv adverbs
    ok 20 - Nested slice, delete + kv adverbs 2
    ok 21 - Nested slice, delete + !kv adverbs
    ok 22 - Nested slice, delete + !kv adverbs 2
    ok 23 - Nested slice, delete + p adverbs
    ok 24 - Nested slice, delete + p adverbs 2
    ok 25 - Nested slice, delete + !p adverbs
    ok 26 - Nested slice, delete + !p adverbs 2
    ok 27 - Nested slice, delete + k adverbs
    ok 28 - Nested slice, delete + k adverbs 2
    ok 29 - Nested slice, delete + !k adverbs
    ok 30 - Nested slice, delete + !k adverbs 2
    ok 31 - Nested slice, delete + v adverbs
    ok 32 - Nested slice, delete + v adverbs 2
    ok 33 - Nested slice, delete + !v adverbs
    ok 34 - Nested slice, delete + !v adverbs 2
    ok 35 - Nested slice, delete + exists adverbs
    ok 36 - Nested slice, delete + exists adverbs 2
    ok 37 - Nested slice, delete + !exists adverbs
    ok 38 - Nested slice, delete + !exists adverbs 2
    ok 39 - Nested slice, delete + exists + kv adverbs
    ok 40 - Nested slice, delete + exists + kv adverbs 2
    ok 41 - Nested slice, delete + !exists + kv adverbs
    ok 42 - Nested slice, delete + !exists + kv adverbs 2
    ok 43 - Nested slice, delete + exists + !kv adverbs
    ok 44 - Nested slice, delete + exists + !kv adverbs 2
    ok 45 - Nested slice, delete + !exists + !kv adverbs
    ok 46 - Nested slice, delete + !exists + !kv adverbs 2
    ok 47 - Nested slice, delete + exists + p adverbs
    ok 48 - Nested slice, delete + exists + p adverbs 2
    ok 49 - Nested slice, delete + !exists + p adverbs
    ok 50 - Nested slice, delete + !exists + p adverbs 2
    ok 51 - Nested slice, delete + exists + !p adverbs
    ok 52 - Nested slice, delete + exists + !p adverbs 2
    ok 53 - Nested slice, delete + !exists + !p adverbs
    ok 54 - Nested slice, delete + !exists + !p adverbs 2
    ok 55 - Nested slice, exists + kv adverbs
    ok 56 - Nested slice, !exists + kv adverbs
    ok 57 - Nested slice, exists + !kv adverbs
    ok 58 - Nested slice, !exists + !kv adverbs
    ok 59 - Nested slice, exists + p adverbs
    ok 60 - Nested slice, !exists + p adverbs
    ok 61 - Nested slice, exists + !p adverbs
    ok 62 - Nested slice, !exists + !p adverbs
ok 35 - nested slices
# FUDGED!
1..84
ok 1 - @x.VAR.of of typed array (my Int @x)
ok 2 - .WHAT.gist of the type object makes sense
ok 3 - can assign values of the right type
ok 4 - can assign range of the right type
ok 5 - can push values of the right type
ok 6 - can unshift values of the right type
ok 7 - can assign values to a slice
ok 8 - can pop from typed array
ok 9 - can unshift from typed array
ok 10 - @x.VAR.of of typed array (my Int @x)
ok 11 - can assign values of the right type (Int @x)
ok 12 - can assign range of the right type (Int @x)
ok 13 - can push values of the right type (Int @x)
ok 14 - can unshift values of the right type (Int @x)
ok 15 - can assign values to a slice (Int @x)
ok 16 - can pop from typed array (Int @x)
ok 17 - can unshift from typed array (Int @x)
ok 18 - initialization of typed array
ok 19 - initialization of typed array from range
ok 20 - @x.VAR.of of typed array (my @x of Int)
ok 21 - can assign values of the right type (@x of Int)
ok 22 - can assign range of the right type (@x of Int)
ok 23 - can push values of the right type (@x of Int)
ok 24 - can unshift values of the right type (@x of Int)
ok 25 - can assign values to a slice (@x of Int)
ok 26 - can pop from typed array (@x of Int)
ok 27 - can unshift from typed array (@x of Int)
ok 28 - @x.VAR.of of typed array (my Array @x)
ok 29 - can not assign values of the wrong type
ok 30 - can not assign range of the wrong type
ok 31 - can not push values of the wrong type
ok 32 - can not unshift values of the wrong type
ok 33 - can not assign values of wrong type to a slice
ok 34 - ... but assigning values of the right type is OK
ok 35 - @x.VAR.of of typed array (my @x of Array)
ok 36 - can not assign values of the wrong type
ok 37 - can not assign range of the wrong type
ok 38 - can not push values of the wrong type
ok 39 - can not unshift values of the wrong type
ok 40 - can not assign values of wrong type to a slice
ok 41 - ... but assigning values of the right type is OK
ok 42 - my Array of Int @x declares a nested array
not ok 43 - assignment works # TODO nested typechecks are borked
# Failed test 'assignment works'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/arrays.rakudo line 85
# Type check failed in assignment to @x; expected Array[Int] but got Array ([2, 3])
not ok 44 - pushing works # TODO nested typechecks are borked
# Failed test 'pushing works'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/arrays.rakudo line 87
# Type check failed in assignment to @x; expected Array[Int] but got Array ([8, 9])
ok 45 - type constraint is enforced
ok 46 - pushing to the inner array is OK
ok 47 - inner array enforces the type constraint
ok 48 - can assign typed array to typed array
ok 49 - # SKIP need parameterized Lists
ok 50 - @a.values is typed (2)
ok 51 - # SKIP initialization
ok 52 - type check Positional of Int allows correctly typed array to be returned explicitly
ok 53 - type check Positional of Int allows correctly typed array to be returned implicitly
ok 54 - type check Positional of Int prevents untyped array to be returned explicitly
ok 55 - type check Positional of Int prevents untyped array to be returned implicitly
ok 56 - type check Positional of Int prevents incorrectly typed array to be returned explicitly
ok 57 - type check Positional of Int prevents incorrectly typed array to be returned implicitly
ok 58 - type check Positional of Num allows subtyped Int array to be returned explicitly
ok 59 - type check Positional of Num allows subtyped Int array to be returned implicitly
ok 60 - # SKIP type on our-variables
ok 61 - can assign to untyped array in presence of typed array
    1..2
    ok 1 - 'my Int @a = "ab", "cd"' died
    ok 2 - right exception type (X::TypeCheck::Assignment)
ok 62 - typed arrays do check type during list assignment
    1..2
    ok 1 - 'my Int @a = "ab", "cd"; 42.Str;' died
    ok 2 - right exception type (X::TypeCheck::Assignment)
ok 63 - typed arrays do check type during list assignment in sink
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck::Assignment)
ok 64 - assignment checks for types
    1..2
    ok 1 - '@x[0]++' died
    ok 2 - right exception type (X::TypeCheck)
ok 65 - pushed value to typed array (using "subset") is type checked
ok 66 - does the roundtrip preserve typedness
ok 67 - do typed arrays with empty elements roundtrip
ok 68 - Array of Str works as return constraint
ok 69 - Get back the typed array correctly (1)
ok 70 - Get back the typed array correctly (2)
ok 71 - Can feed Arrays of Type to .new of Array[Array[Type]] (binding)
ok 72 - Type is maintained (binding)
ok 73 - Can feed Arrays of Type to .new of Array[Array[Type]] (assignment)
ok 74 - Type is maintained (assignment)
ok 75 - Can assign to and return Array[Hash] from type-constrained sub
ok 76 - can bind element of typed array to scalar container of same type
ok 77 - can bind element of typed array to scalar container of same type (but not explicitly typed)
ok 78 - Binding literal to typed array checks types
ok 79 - Binding variablle to typed array checks type
ok 80 - deleted element of typed arrays does not lose type info inside .map
ok 81 - .gist on typed array shows real type objects
ok 82 - @a of Foo accepted by sub (Foo @a)
ok 83 - using `of` does not affect arrays defined later
ok 84 - using `of` does not affect arrays with `of` defined later
# FUDGED!
1..1833
ok 1 - int array type is Positional
ok 2 - int array type is Positional[int]
ok 3 - int array type .of is int
ok 4 - int array is Positional
ok 5 - int array is Positional[int]
ok 6 - int array .of is int
ok 7 - int array is Positional
ok 8 - int array is Positional[int]
ok 9 - int array .of is int
ok 10 - .new from int array is Positional
ok 11 - .new from int array Positional[int]
ok 12 - .new from int array .of is int
ok 13 - New int array has no elems
ok 14 - New int array has end of -1
ok 15 - New int array Int-ifies to 0
ok 16 - New int array numifies to 0
ok 17 - New int array is falsey
ok 18 - Empty int array is not lazy
ok 19 - Accessing non-existing on int array gives 0
ok 20 - Elems do not grow just from an access on int array
ok 21 - Can store integer in an int array
ok 22 - Can get value from int array
ok 23 - The elems grew as expected on int array
ok 24 - int array becomes truthy when it has an element
ok 25 - Can slice-assign to an int array
ok 26 - Can get slice-assigned value from int array (1)
ok 27 - Can get slice-assigned value from int array (2)
ok 28 - The elems grew as expected on int array
ok 29 - The end value matches grown elems on int array
ok 30 - Int-ifies to grown number of elems on int array
ok 31 - Numifies to grown number of elems on int array
ok 32 - int array with values is not lazy
ok 33 - Can assign non-contiguously to int array
ok 34 - Elems behind non-contiguous assign are 0 on int array
ok 35 - Non-contiguous assignment works on int array
ok 36 - Can also get last element on int array
ok 37 - Can clear int array by assigning empty list
ok 38 - Cleared int array has no elems
ok 39 - Cleared int array has end of -1
ok 40 - Cleared int array Int-ifies to 0
ok 41 - Cleared int array numifies to 0
ok 42 - Cleared int array is falsey
ok 43 - Can assign integer range to int array
ok 44 - Got correct elems from range assign on int array
ok 45 - Got correct element from range assign on int array (1)
ok 46 - Got correct element from range assign on int array (2)
ok 47 - :exists works on int array (1)
ok 48 - :exists works on int array (2)
ok 49 - :exists works on int array (3)
ok 50 - Can call int array constructor with a single value
ok 51 - Correct number of elems set in constructor of int array
ok 52 - Correct element value set by constructor of int array
ok 53 - Can call int array constructor with values
ok 54 - Correct number of elems set in constructor of int array
ok 55 - Correct elem value set by constructor of int array (1)
ok 56 - Correct elem value set by constructor of int array (2)
ok 57 - Correct elem value set by constructor of int array (3)
ok 58 - Correct elem value set by constructor of int array (4)
ok 59 - Can also get last 2 elements on int array
ok 60 - int array .flat returns a Seq
ok 61 - int array .eager returns identity
ok 62 - Can iterate over int array
ok 63 - Mutating for loop on int array works (1)
ok 64 - Mutating for loop on int array works (2)
ok 65 - Mutating for loop on int array works (3)
ok 66 - Mutating for loop on int array works (4)
ok 67 - Can map over int array
ok 68 - Mutating map on int array works (1)
ok 69 - Mutating map on int array works (2)
ok 70 - Mutating map on int array works (3)
ok 71 - Mutating map on int array works (4)
ok 72 - grep a int array
ok 73 - int array.grep(Int)
ok 74 - int array.grep(Int, :k)
ok 75 - int array.grep(Int, :kv)
ok 76 - int array.grep(Int, :p)
ok 77 - int array.grep(Int, :v)
ok 78 - int array.grep(Int)
ok 79 - int array.grep(Int, :k)
ok 80 - int array.grep(Int, :kv)
ok 81 - int array.grep(Int, :p)
ok 82 - int array.grep(Int, :v)
ok 83 - Can use reduce meta-op on a int array
ok 84 - .values from a int array
ok 85 - .pairup from a int array
ok 86 - .keys from a int array
ok 87 - .pairs from a int array
ok 88 - .antipairs from a int array
ok 89 - .kv from a int array
ok 90 - .pick from a int array
ok 91 - .roll from a int array
ok 92 - int array.unique
ok 93 - int array.repeated
ok 94 - int array.squish
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Empty)
    ok 3 - .what matches array[int]
    ok 4 - .action matches pop
ok 95 - Trying to pop an empty int array dies
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Empty)
    ok 3 - .what matches array[int]
    ok 4 - .action matches shift
ok 96 - Trying to shift an empty int array dies
ok 97 - can push to int array
ok 98 - push to int array works (1)
ok 99 - push to int array works (2)
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck)
    ok 3 - .got matches (Str)
ok 100 - Cannot push non-int/Int to int array
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 101 - Cannot bind to int array
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 102 - Cannot delete from int array
ok 103 - can push multiple to int array
ok 104 - push multiple to int array works (1)
ok 105 - push multiple to int array works (2)
ok 106 - push multiple to int array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 107 - Cannot push non-int/Int to int array (multiple push)
ok 108 - can append to int array
ok 109 - append to int array works (1)
ok 110 - append to int array works (2)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 111 - Cannot append non-int/Int to int array
ok 112 - can append multiple to int array
ok 113 - append multiple to int array works (1)
ok 114 - append multiple to int array works (2)
ok 115 - append multiple to int array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 116 - Cannot append non-int/Int to int array (multiple append)
ok 117 - pop from int array works (1)
ok 118 - pop from int array works (2)
ok 119 - can unshift to int array
ok 120 - unshift to int array works (1)
ok 121 - unshift to int array works (2)
ok 122 - unshift to int array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 123 - Cannot unshift non-int/Int to int array
ok 124 - can unshift multiple to int array
ok 125 - unshift multiple to int array works (1)
ok 126 - unshift multiple to int array works (2)
ok 127 - unshift multiple to int array works (3)
ok 128 - unshift multiple to int array works (4)
ok 129 - unshift multiple to int array works (5)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 130 - Cannot unshift non-int/Int to int array (multiple unshift)
ok 131 - can prepend to int array
ok 132 - prepend to int array works (1)
ok 133 - prepend to int array works (2)
ok 134 - prepend to int array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 135 - Cannot prepend non-int/Int to int array
ok 136 - can prepend multiple to int array
ok 137 - unshift multiple to int array works (1)
ok 138 - prepend multiple to int array works (2)
ok 139 - prepend multiple to int array works (3)
ok 140 - prepend multiple to int array works (4)
ok 141 - prepend multiple to int array works (5)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 142 - Cannot prepend non-int/Int to int array (multiple unshift)
ok 143 - shift from int array works (1)
ok 144 - shift from int array works (2)
ok 145 - can initialize int from Range
ok 146 - Number of elems after splice int array
ok 147 - Splice on int array did the right thing (1)
ok 148 - Splice on int array did the right thing (2)
ok 149 - Splice on int array did the right thing (3)
ok 150 - Splice on int array did the right thing (4)
ok 151 - Splice on int array did the right thing (5)
ok 152 - Number of returned spliced values from int array
ok 153 - Correct value in splice returned from int array (1)
ok 154 - Correct value in splice returned from int array (2)
ok 155 - .Str space-separates on int array
ok 156 - .gist space-separates on int array
ok 157 - .raku includes type and int values on int array
ok 158 - does slice return same type
ok 159 - does slice handle containerized range
ok 160 - Flattening int array in call works
ok 161 - does join a int array
ok 162 - does emptying a int array really empty
ok 163 - does join handle holes in a int array
ok 164 - List-assigning int array to untyped works (1)
ok 165 - List-assigning int array to untyped works (2)
ok 166 - List-assigning int array to untyped works (3)
ok 167 - List-assign int array surrounded by literals (1)
ok 168 - List-assign int array surrounded by literals (2)
ok 169 - List-assign int array surrounded by literals (3)
ok 170 - List-assign int array surrounded by literals (4)
ok 171 - List-assign int array surrounded by literals (5)
ok 172 - List-assign untyped array of Int to int array (1)
ok 173 - List-assign untyped array of Int to int array (2)
ok 174 - List-assign untyped array of Int to int array (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 175 - List-assigning incompatible untyped array to int array dies
ok 176 - Smartmatching same int arrays works
ok 177 - Smartmatching different int arrays works
ok 178 - Can we sort int array
ok 179 - Can we sort 2-element sorted int array
ok 180 - Can we sort 2-element unsorted int array
ok 181 - Can we sort 1-element int array
ok 182 - Can we sort 0-element int array
ok 183 - int8 array type is Positional
ok 184 - int8 array type is Positional[int8]
ok 185 - int8 array type .of is int8
ok 186 - int8 array is Positional
ok 187 - int8 array is Positional[int8]
ok 188 - int8 array .of is int8
ok 189 - int8 array is Positional
ok 190 - int8 array is Positional[int8]
ok 191 - int8 array .of is int8
ok 192 - .new from int8 array is Positional
ok 193 - .new from int8 array Positional[int8]
ok 194 - .new from int8 array .of is int8
ok 195 - New int8 array has no elems
ok 196 - New int8 array has end of -1
ok 197 - New int8 array Int-ifies to 0
ok 198 - New int8 array numifies to 0
ok 199 - New int8 array is falsey
ok 200 - Empty int8 array is not lazy
ok 201 - Accessing non-existing on int8 array gives 0
ok 202 - Elems do not grow just from an access on int8 array
ok 203 - Can store integer in an int8 array
ok 204 - Can get value from int8 array
ok 205 - The elems grew as expected on int8 array
ok 206 - int8 array becomes truthy when it has an element
ok 207 - Can slice-assign to an int8 array
ok 208 - Can get slice-assigned value from int8 array (1)
ok 209 - Can get slice-assigned value from int8 array (2)
ok 210 - The elems grew as expected on int8 array
ok 211 - The end value matches grown elems on int8 array
ok 212 - Int-ifies to grown number of elems on int8 array
ok 213 - Numifies to grown number of elems on int8 array
ok 214 - int8 array with values is not lazy
ok 215 - Can assign non-contiguously to int8 array
ok 216 - Elems behind non-contiguous assign are 0 on int8 array
ok 217 - Non-contiguous assignment works on int8 array
ok 218 - Can also get last element on int8 array
ok 219 - Can clear int8 array by assigning empty list
ok 220 - Cleared int8 array has no elems
ok 221 - Cleared int8 array has end of -1
ok 222 - Cleared int8 array Int-ifies to 0
ok 223 - Cleared int8 array numifies to 0
ok 224 - Cleared int8 array is falsey
ok 225 - Can assign integer range to int8 array
ok 226 - Got correct elems from range assign on int8 array
ok 227 - Got correct element from range assign on int8 array (1)
ok 228 - Got correct element from range assign on int8 array (2)
ok 229 - :exists works on int8 array (1)
ok 230 - :exists works on int8 array (2)
ok 231 - :exists works on int8 array (3)
ok 232 - Can call int8 array constructor with a single value
ok 233 - Correct number of elems set in constructor of int8 array
ok 234 - Correct element value set by constructor of int8 array
ok 235 - Can call int8 array constructor with values
ok 236 - Correct number of elems set in constructor of int8 array
ok 237 - Correct elem value set by constructor of int8 array (1)
ok 238 - Correct elem value set by constructor of int8 array (2)
ok 239 - Correct elem value set by constructor of int8 array (3)
ok 240 - Correct elem value set by constructor of int8 array (4)
ok 241 - Can also get last 2 elements on int8 array
ok 242 - int8 array .flat returns a Seq
ok 243 - int8 array .eager returns identity
ok 244 - Can iterate over int8 array
ok 245 - Mutating for loop on int8 array works (1)
ok 246 - Mutating for loop on int8 array works (2)
ok 247 - Mutating for loop on int8 array works (3)
ok 248 - Mutating for loop on int8 array works (4)
ok 249 - Can map over int8 array
ok 250 - Mutating map on int8 array works (1)
ok 251 - Mutating map on int8 array works (2)
ok 252 - Mutating map on int8 array works (3)
ok 253 - Mutating map on int8 array works (4)
ok 254 - grep a int8 array
ok 255 - int8 array.grep(Int)
ok 256 - int8 array.grep(Int, :k)
ok 257 - int8 array.grep(Int, :kv)
ok 258 - int8 array.grep(Int, :p)
ok 259 - int8 array.grep(Int, :v)
ok 260 - int8 array.grep(Int)
ok 261 - int8 array.grep(Int, :k)
ok 262 - int8 array.grep(Int, :kv)
ok 263 - int8 array.grep(Int, :p)
ok 264 - int8 array.grep(Int, :v)
ok 265 - Can use reduce meta-op on a int8 array
ok 266 - .values from a int8 array
ok 267 - .pairup from a int8 array
ok 268 - .keys from a int8 array
ok 269 - .pairs from a int8 array
ok 270 - .antipairs from a int8 array
ok 271 - .kv from a int8 array
ok 272 - .pick from a int8 array
ok 273 - .roll from a int8 array
ok 274 - int8 array.unique
ok 275 - int8 array.repeated
ok 276 - int8 array.squish
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Empty)
    ok 3 - .action matches pop
    ok 4 - .what matches array[int8]
ok 277 - Trying to pop an empty int8 array dies
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Empty)
    ok 3 - .what matches array[int8]
    ok 4 - .action matches shift
ok 278 - Trying to shift an empty int8 array dies
ok 279 - can push to int8 array
ok 280 - push to int8 array works (1)
ok 281 - push to int8 array works (2)
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck)
    ok 3 - .got matches (Str)
ok 282 - Cannot push non-int/Int to int8 array
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 283 - Cannot bind to int8 array
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 284 - Cannot delete from int8 array
ok 285 - can push multiple to int8 array
ok 286 - push multiple to int8 array works (1)
ok 287 - push multiple to int8 array works (2)
ok 288 - push multiple to int8 array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 289 - Cannot push non-int/Int to int8 array (multiple push)
ok 290 - can append to int8 array
ok 291 - append to int8 array works (1)
ok 292 - append to int8 array works (2)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 293 - Cannot append non-int/Int to int8 array
ok 294 - can append multiple to int8 array
ok 295 - append multiple to int8 array works (1)
ok 296 - append multiple to int8 array works (2)
ok 297 - append multiple to int8 array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 298 - Cannot append non-int/Int to int8 array (multiple append)
ok 299 - pop from int8 array works (1)
ok 300 - pop from int8 array works (2)
ok 301 - can unshift to int8 array
ok 302 - unshift to int8 array works (1)
ok 303 - unshift to int8 array works (2)
ok 304 - unshift to int8 array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 305 - Cannot unshift non-int/Int to int8 array
ok 306 - can unshift multiple to int8 array
ok 307 - unshift multiple to int8 array works (1)
ok 308 - unshift multiple to int8 array works (2)
ok 309 - unshift multiple to int8 array works (3)
ok 310 - unshift multiple to int8 array works (4)
ok 311 - unshift multiple to int8 array works (5)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 312 - Cannot unshift non-int/Int to int8 array (multiple unshift)
ok 313 - can prepend to int8 array
ok 314 - prepend to int8 array works (1)
ok 315 - prepend to int8 array works (2)
ok 316 - prepend to int8 array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 317 - Cannot prepend non-int/Int to int8 array
ok 318 - can prepend multiple to int8 array
ok 319 - unshift multiple to int8 array works (1)
ok 320 - prepend multiple to int8 array works (2)
ok 321 - prepend multiple to int8 array works (3)
ok 322 - prepend multiple to int8 array works (4)
ok 323 - prepend multiple to int8 array works (5)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 324 - Cannot prepend non-int/Int to int8 array (multiple unshift)
ok 325 - shift from int8 array works (1)
ok 326 - shift from int8 array works (2)
ok 327 - can initialize int8 from Range
ok 328 - Number of elems after splice int8 array
ok 329 - Splice on int8 array did the right thing (1)
ok 330 - Splice on int8 array did the right thing (2)
ok 331 - Splice on int8 array did the right thing (3)
ok 332 - Splice on int8 array did the right thing (4)
ok 333 - Splice on int8 array did the right thing (5)
ok 334 - Number of returned spliced values from int8 array
ok 335 - Correct value in splice returned from int8 array (1)
ok 336 - Correct value in splice returned from int8 array (2)
ok 337 - .Str space-separates on int8 array
ok 338 - .gist space-separates on int8 array
ok 339 - .raku includes type and int values on int8 array
ok 340 - does slice return same type
ok 341 - does slice handle containerized range
ok 342 - Flattening int8 array in call works
ok 343 - does join a int8 array
ok 344 - does emptying a int8 array really empty
ok 345 - does join handle holes in a int8 array
ok 346 - List-assigning int8 array to untyped works (1)
ok 347 - List-assigning int8 array to untyped works (2)
ok 348 - List-assigning int8 array to untyped works (3)
ok 349 - List-assign int8 array surrounded by literals (1)
ok 350 - List-assign int8 array surrounded by literals (2)
ok 351 - List-assign int8 array surrounded by literals (3)
ok 352 - List-assign int8 array surrounded by literals (4)
ok 353 - List-assign int8 array surrounded by literals (5)
ok 354 - List-assign untyped array of Int to int8 array (1)
ok 355 - List-assign untyped array of Int to int8 array (2)
ok 356 - List-assign untyped array of Int to int8 array (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 357 - List-assigning incompatible untyped array to int8 array dies
ok 358 - Smartmatching same int8 arrays works
ok 359 - Smartmatching different int8 arrays works
ok 360 - Can we sort int8 array
ok 361 - Can we sort 2-element sorted int8 array
ok 362 - Can we sort 2-element unsorted int8 array
ok 363 - Can we sort 1-element int8 array
ok 364 - Can we sort 0-element int8 array
ok 365 - int16 array type is Positional
ok 366 - int16 array type is Positional[int16]
ok 367 - int16 array type .of is int16
ok 368 - int16 array is Positional
ok 369 - int16 array is Positional[int16]
ok 370 - int16 array .of is int16
ok 371 - int16 array is Positional
ok 372 - int16 array is Positional[int16]
ok 373 - int16 array .of is int16
ok 374 - .new from int16 array is Positional
ok 375 - .new from int16 array Positional[int16]
ok 376 - .new from int16 array .of is int16
ok 377 - New int16 array has no elems
ok 378 - New int16 array has end of -1
ok 379 - New int16 array Int-ifies to 0
ok 380 - New int16 array numifies to 0
ok 381 - New int16 array is falsey
ok 382 - Empty int16 array is not lazy
ok 383 - Accessing non-existing on int16 array gives 0
ok 384 - Elems do not grow just from an access on int16 array
ok 385 - Can store integer in an int16 array
ok 386 - Can get value from int16 array
ok 387 - The elems grew as expected on int16 array
ok 388 - int16 array becomes truthy when it has an element
ok 389 - Can slice-assign to an int16 array
ok 390 - Can get slice-assigned value from int16 array (1)
ok 391 - Can get slice-assigned value from int16 array (2)
ok 392 - The elems grew as expected on int16 array
ok 393 - The end value matches grown elems on int16 array
ok 394 - Int-ifies to grown number of elems on int16 array
ok 395 - Numifies to grown number of elems on int16 array
ok 396 - int16 array with values is not lazy
ok 397 - Can assign non-contiguously to int16 array
ok 398 - Elems behind non-contiguous assign are 0 on int16 array
ok 399 - Non-contiguous assignment works on int16 array
ok 400 - Can also get last element on int16 array
ok 401 - Can clear int16 array by assigning empty list
ok 402 - Cleared int16 array has no elems
ok 403 - Cleared int16 array has end of -1
ok 404 - Cleared int16 array Int-ifies to 0
ok 405 - Cleared int16 array numifies to 0
ok 406 - Cleared int16 array is falsey
ok 407 - Can assign integer range to int16 array
ok 408 - Got correct elems from range assign on int16 array
ok 409 - Got correct element from range assign on int16 array (1)
ok 410 - Got correct element from range assign on int16 array (2)
ok 411 - :exists works on int16 array (1)
ok 412 - :exists works on int16 array (2)
ok 413 - :exists works on int16 array (3)
ok 414 - Can call int16 array constructor with a single value
ok 415 - Correct number of elems set in constructor of int16 array
ok 416 - Correct element value set by constructor of int16 array
ok 417 - Can call int16 array constructor with values
ok 418 - Correct number of elems set in constructor of int16 array
ok 419 - Correct elem value set by constructor of int16 array (1)
ok 420 - Correct elem value set by constructor of int16 array (2)
ok 421 - Correct elem value set by constructor of int16 array (3)
ok 422 - Correct elem value set by constructor of int16 array (4)
ok 423 - Can also get last 2 elements on int16 array
ok 424 - int16 array .flat returns a Seq
ok 425 - int16 array .eager returns identity
ok 426 - Can iterate over int16 array
ok 427 - Mutating for loop on int16 array works (1)
ok 428 - Mutating for loop on int16 array works (2)
ok 429 - Mutating for loop on int16 array works (3)
ok 430 - Mutating for loop on int16 array works (4)
ok 431 - Can map over int16 array
ok 432 - Mutating map on int16 array works (1)
ok 433 - Mutating map on int16 array works (2)
ok 434 - Mutating map on int16 array works (3)
ok 435 - Mutating map on int16 array works (4)
ok 436 - grep a int16 array
ok 437 - int16 array.grep(Int)
ok 438 - int16 array.grep(Int, :k)
ok 439 - int16 array.grep(Int, :kv)
ok 440 - int16 array.grep(Int, :p)
ok 441 - int16 array.grep(Int, :v)
ok 442 - int16 array.grep(Int)
ok 443 - int16 array.grep(Int, :k)
ok 444 - int16 array.grep(Int, :kv)
ok 445 - int16 array.grep(Int, :p)
ok 446 - int16 array.grep(Int, :v)
ok 447 - Can use reduce meta-op on a int16 array
ok 448 - .values from a int16 array
ok 449 - .pairup from a int16 array
ok 450 - .keys from a int16 array
ok 451 - .pairs from a int16 array
ok 452 - .antipairs from a int16 array
ok 453 - .kv from a int16 array
ok 454 - .pick from a int16 array
ok 455 - .roll from a int16 array
ok 456 - int16 array.unique
ok 457 - int16 array.repeated
ok 458 - int16 array.squish
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Empty)
    ok 3 - .action matches pop
    ok 4 - .what matches array[int16]
ok 459 - Trying to pop an empty int16 array dies
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Empty)
    ok 3 - .action matches shift
    ok 4 - .what matches array[int16]
ok 460 - Trying to shift an empty int16 array dies
ok 461 - can push to int16 array
ok 462 - push to int16 array works (1)
ok 463 - push to int16 array works (2)
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck)
    ok 3 - .got matches (Str)
ok 464 - Cannot push non-int/Int to int16 array
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 465 - Cannot bind to int16 array
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 466 - Cannot delete from int16 array
ok 467 - can push multiple to int16 array
ok 468 - push multiple to int16 array works (1)
ok 469 - push multiple to int16 array works (2)
ok 470 - push multiple to int16 array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 471 - Cannot push non-int/Int to int16 array (multiple push)
ok 472 - can append to int16 array
ok 473 - append to int16 array works (1)
ok 474 - append to int16 array works (2)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 475 - Cannot append non-int/Int to int16 array
ok 476 - can append multiple to int16 array
ok 477 - append multiple to int16 array works (1)
ok 478 - append multiple to int16 array works (2)
ok 479 - append multiple to int16 array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 480 - Cannot append non-int/Int to int16 array (multiple append)
ok 481 - pop from int16 array works (1)
ok 482 - pop from int16 array works (2)
ok 483 - can unshift to int16 array
ok 484 - unshift to int16 array works (1)
ok 485 - unshift to int16 array works (2)
ok 486 - unshift to int16 array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 487 - Cannot unshift non-int/Int to int16 array
ok 488 - can unshift multiple to int16 array
ok 489 - unshift multiple to int16 array works (1)
ok 490 - unshift multiple to int16 array works (2)
ok 491 - unshift multiple to int16 array works (3)
ok 492 - unshift multiple to int16 array works (4)
ok 493 - unshift multiple to int16 array works (5)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 494 - Cannot unshift non-int/Int to int16 array (multiple unshift)
ok 495 - can prepend to int16 array
ok 496 - prepend to int16 array works (1)
ok 497 - prepend to int16 array works (2)
ok 498 - prepend to int16 array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 499 - Cannot prepend non-int/Int to int16 array
ok 500 - can prepend multiple to int16 array
ok 501 - unshift multiple to int16 array works (1)
ok 502 - prepend multiple to int16 array works (2)
ok 503 - prepend multiple to int16 array works (3)
ok 504 - prepend multiple to int16 array works (4)
ok 505 - prepend multiple to int16 array works (5)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 506 - Cannot prepend non-int/Int to int16 array (multiple unshift)
ok 507 - shift from int16 array works (1)
ok 508 - shift from int16 array works (2)
ok 509 - can initialize int16 from Range
ok 510 - Number of elems after splice int16 array
ok 511 - Splice on int16 array did the right thing (1)
ok 512 - Splice on int16 array did the right thing (2)
ok 513 - Splice on int16 array did the right thing (3)
ok 514 - Splice on int16 array did the right thing (4)
ok 515 - Splice on int16 array did the right thing (5)
ok 516 - Number of returned spliced values from int16 array
ok 517 - Correct value in splice returned from int16 array (1)
ok 518 - Correct value in splice returned from int16 array (2)
ok 519 - .Str space-separates on int16 array
ok 520 - .gist space-separates on int16 array
ok 521 - .raku includes type and int values on int16 array
ok 522 - does slice return same type
ok 523 - does slice handle containerized range
ok 524 - Flattening int16 array in call works
ok 525 - does join a int16 array
ok 526 - does emptying a int16 array really empty
ok 527 - does join handle holes in a int16 array
ok 528 - List-assigning int16 array to untyped works (1)
ok 529 - List-assigning int16 array to untyped works (2)
ok 530 - List-assigning int16 array to untyped works (3)
ok 531 - List-assign int16 array surrounded by literals (1)
ok 532 - List-assign int16 array surrounded by literals (2)
ok 533 - List-assign int16 array surrounded by literals (3)
ok 534 - List-assign int16 array surrounded by literals (4)
ok 535 - List-assign int16 array surrounded by literals (5)
ok 536 - List-assign untyped array of Int to int16 array (1)
ok 537 - List-assign untyped array of Int to int16 array (2)
ok 538 - List-assign untyped array of Int to int16 array (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 539 - List-assigning incompatible untyped array to int16 array dies
ok 540 - Smartmatching same int16 arrays works
ok 541 - Smartmatching different int16 arrays works
ok 542 - Can we sort int16 array
ok 543 - Can we sort 2-element sorted int16 array
ok 544 - Can we sort 2-element unsorted int16 array
ok 545 - Can we sort 1-element int16 array
ok 546 - Can we sort 0-element int16 array
ok 547 - int32 array type is Positional
ok 548 - int32 array type is Positional[int32]
ok 549 - int32 array type .of is int32
ok 550 - int32 array is Positional
ok 551 - int32 array is Positional[int32]
ok 552 - int32 array .of is int32
ok 553 - int32 array is Positional
ok 554 - int32 array is Positional[int32]
ok 555 - int32 array .of is int32
ok 556 - .new from int32 array is Positional
ok 557 - .new from int32 array Positional[int32]
ok 558 - .new from int32 array .of is int32
ok 559 - New int32 array has no elems
ok 560 - New int32 array has end of -1
ok 561 - New int32 array Int-ifies to 0
ok 562 - New int32 array numifies to 0
ok 563 - New int32 array is falsey
ok 564 - Empty int32 array is not lazy
ok 565 - Accessing non-existing on int32 array gives 0
ok 566 - Elems do not grow just from an access on int32 array
ok 567 - Can store integer in an int32 array
ok 568 - Can get value from int32 array
ok 569 - The elems grew as expected on int32 array
ok 570 - int32 array becomes truthy when it has an element
ok 571 - Can slice-assign to an int32 array
ok 572 - Can get slice-assigned value from int32 array (1)
ok 573 - Can get slice-assigned value from int32 array (2)
ok 574 - The elems grew as expected on int32 array
ok 575 - The end value matches grown elems on int32 array
ok 576 - Int-ifies to grown number of elems on int32 array
ok 577 - Numifies to grown number of elems on int32 array
ok 578 - int32 array with values is not lazy
ok 579 - Can assign non-contiguously to int32 array
ok 580 - Elems behind non-contiguous assign are 0 on int32 array
ok 581 - Non-contiguous assignment works on int32 array
ok 582 - Can also get last element on int32 array
ok 583 - Can clear int32 array by assigning empty list
ok 584 - Cleared int32 array has no elems
ok 585 - Cleared int32 array has end of -1
ok 586 - Cleared int32 array Int-ifies to 0
ok 587 - Cleared int32 array numifies to 0
ok 588 - Cleared int32 array is falsey
ok 589 - Can assign integer range to int32 array
ok 590 - Got correct elems from range assign on int32 array
ok 591 - Got correct element from range assign on int32 array (1)
ok 592 - Got correct element from range assign on int32 array (2)
ok 593 - :exists works on int32 array (1)
ok 594 - :exists works on int32 array (2)
ok 595 - :exists works on int32 array (3)
ok 596 - Can call int32 array constructor with a single value
ok 597 - Correct number of elems set in constructor of int32 array
ok 598 - Correct element value set by constructor of int32 array
ok 599 - Can call int32 array constructor with values
ok 600 - Correct number of elems set in constructor of int32 array
ok 601 - Correct elem value set by constructor of int32 array (1)
ok 602 - Correct elem value set by constructor of int32 array (2)
ok 603 - Correct elem value set by constructor of int32 array (3)
ok 604 - Correct elem value set by constructor of int32 array (4)
ok 605 - Can also get last 2 elements on int32 array
ok 606 - int32 array .flat returns a Seq
ok 607 - int32 array .eager returns identity
ok 608 - Can iterate over int32 array
ok 609 - Mutating for loop on int32 array works (1)
ok 610 - Mutating for loop on int32 array works (2)
ok 611 - Mutating for loop on int32 array works (3)
ok 612 - Mutating for loop on int32 array works (4)
ok 613 - Can map over int32 array
ok 614 - Mutating map on int32 array works (1)
ok 615 - Mutating map on int32 array works (2)
ok 616 - Mutating map on int32 array works (3)
ok 617 - Mutating map on int32 array works (4)
ok 618 - grep a int32 array
ok 619 - int32 array.grep(Int)
ok 620 - int32 array.grep(Int, :k)
ok 621 - int32 array.grep(Int, :kv)
ok 622 - int32 array.grep(Int, :p)
ok 623 - int32 array.grep(Int, :v)
ok 624 - int32 array.grep(Int)
ok 625 - int32 array.grep(Int, :k)
ok 626 - int32 array.grep(Int, :kv)
ok 627 - int32 array.grep(Int, :p)
ok 628 - int32 array.grep(Int, :v)
ok 629 - Can use reduce meta-op on a int32 array
ok 630 - .values from a int32 array
ok 631 - .pairup from a int32 array
ok 632 - .keys from a int32 array
ok 633 - .pairs from a int32 array
ok 634 - .antipairs from a int32 array
ok 635 - .kv from a int32 array
ok 636 - .pick from a int32 array
ok 637 - .roll from a int32 array
ok 638 - int32 array.unique
ok 639 - int32 array.repeated
ok 640 - int32 array.squish
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Empty)
    ok 3 - .action matches pop
    ok 4 - .what matches array[int32]
ok 641 - Trying to pop an empty int32 array dies
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Empty)
    ok 3 - .what matches array[int32]
    ok 4 - .action matches shift
ok 642 - Trying to shift an empty int32 array dies
ok 643 - can push to int32 array
ok 644 - push to int32 array works (1)
ok 645 - push to int32 array works (2)
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck)
    ok 3 - .got matches (Str)
ok 646 - Cannot push non-int/Int to int32 array
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 647 - Cannot bind to int32 array
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 648 - Cannot delete from int32 array
ok 649 - can push multiple to int32 array
ok 650 - push multiple to int32 array works (1)
ok 651 - push multiple to int32 array works (2)
ok 652 - push multiple to int32 array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 653 - Cannot push non-int/Int to int32 array (multiple push)
ok 654 - can append to int32 array
ok 655 - append to int32 array works (1)
ok 656 - append to int32 array works (2)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 657 - Cannot append non-int/Int to int32 array
ok 658 - can append multiple to int32 array
ok 659 - append multiple to int32 array works (1)
ok 660 - append multiple to int32 array works (2)
ok 661 - append multiple to int32 array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 662 - Cannot append non-int/Int to int32 array (multiple append)
ok 663 - pop from int32 array works (1)
ok 664 - pop from int32 array works (2)
ok 665 - can unshift to int32 array
ok 666 - unshift to int32 array works (1)
ok 667 - unshift to int32 array works (2)
ok 668 - unshift to int32 array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 669 - Cannot unshift non-int/Int to int32 array
ok 670 - can unshift multiple to int32 array
ok 671 - unshift multiple to int32 array works (1)
ok 672 - unshift multiple to int32 array works (2)
ok 673 - unshift multiple to int32 array works (3)
ok 674 - unshift multiple to int32 array works (4)
ok 675 - unshift multiple to int32 array works (5)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 676 - Cannot unshift non-int/Int to int32 array (multiple unshift)
ok 677 - can prepend to int32 array
ok 678 - prepend to int32 array works (1)
ok 679 - prepend to int32 array works (2)
ok 680 - prepend to int32 array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 681 - Cannot prepend non-int/Int to int32 array
ok 682 - can prepend multiple to int32 array
ok 683 - unshift multiple to int32 array works (1)
ok 684 - prepend multiple to int32 array works (2)
ok 685 - prepend multiple to int32 array works (3)
ok 686 - prepend multiple to int32 array works (4)
ok 687 - prepend multiple to int32 array works (5)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 688 - Cannot prepend non-int/Int to int32 array (multiple unshift)
ok 689 - shift from int32 array works (1)
ok 690 - shift from int32 array works (2)
ok 691 - can initialize int32 from Range
ok 692 - Number of elems after splice int32 array
ok 693 - Splice on int32 array did the right thing (1)
ok 694 - Splice on int32 array did the right thing (2)
ok 695 - Splice on int32 array did the right thing (3)
ok 696 - Splice on int32 array did the right thing (4)
ok 697 - Splice on int32 array did the right thing (5)
ok 698 - Number of returned spliced values from int32 array
ok 699 - Correct value in splice returned from int32 array (1)
ok 700 - Correct value in splice returned from int32 array (2)
ok 701 - .Str space-separates on int32 array
ok 702 - .gist space-separates on int32 array
ok 703 - .raku includes type and int values on int32 array
ok 704 - does slice return same type
ok 705 - does slice handle containerized range
ok 706 - Flattening int32 array in call works
ok 707 - does join a int32 array
ok 708 - does emptying a int32 array really empty
ok 709 - does join handle holes in a int32 array
ok 710 - List-assigning int32 array to untyped works (1)
ok 711 - List-assigning int32 array to untyped works (2)
ok 712 - List-assigning int32 array to untyped works (3)
ok 713 - List-assign int32 array surrounded by literals (1)
ok 714 - List-assign int32 array surrounded by literals (2)
ok 715 - List-assign int32 array surrounded by literals (3)
ok 716 - List-assign int32 array surrounded by literals (4)
ok 717 - List-assign int32 array surrounded by literals (5)
ok 718 - List-assign untyped array of Int to int32 array (1)
ok 719 - List-assign untyped array of Int to int32 array (2)
ok 720 - List-assign untyped array of Int to int32 array (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 721 - List-assigning incompatible untyped array to int32 array dies
ok 722 - Smartmatching same int32 arrays works
ok 723 - Smartmatching different int32 arrays works
ok 724 - Can we sort int32 array
ok 725 - Can we sort 2-element sorted int32 array
ok 726 - Can we sort 2-element unsorted int32 array
ok 727 - Can we sort 1-element int32 array
ok 728 - Can we sort 0-element int32 array
ok 729 - int64 array type is Positional
ok 730 - int64 array type is Positional[int64]
ok 731 - int64 array type .of is int64
ok 732 - int64 array is Positional
ok 733 - int64 array is Positional[int64]
ok 734 - int64 array .of is int64
ok 735 - int64 array is Positional
ok 736 - int64 array is Positional[int64]
ok 737 - int64 array .of is int64
ok 738 - .new from int64 array is Positional
ok 739 - .new from int64 array Positional[int64]
ok 740 - .new from int64 array .of is int64
ok 741 - New int64 array has no elems
ok 742 - New int64 array has end of -1
ok 743 - New int64 array Int-ifies to 0
ok 744 - New int64 array numifies to 0
ok 745 - New int64 array is falsey
ok 746 - Empty int64 array is not lazy
ok 747 - Accessing non-existing on int64 array gives 0
ok 748 - Elems do not grow just from an access on int64 array
ok 749 - Can store integer in an int64 array
ok 750 - Can get value from int64 array
ok 751 - The elems grew as expected on int64 array
ok 752 - int64 array becomes truthy when it has an element
ok 753 - Can slice-assign to an int64 array
ok 754 - Can get slice-assigned value from int64 array (1)
ok 755 - Can get slice-assigned value from int64 array (2)
ok 756 - The elems grew as expected on int64 array
ok 757 - The end value matches grown elems on int64 array
ok 758 - Int-ifies to grown number of elems on int64 array
ok 759 - Numifies to grown number of elems on int64 array
ok 760 - int64 array with values is not lazy
ok 761 - Can assign non-contiguously to int64 array
ok 762 - Elems behind non-contiguous assign are 0 on int64 array
ok 763 - Non-contiguous assignment works on int64 array
ok 764 - Can also get last element on int64 array
ok 765 - Can clear int64 array by assigning empty list
ok 766 - Cleared int64 array has no elems
ok 767 - Cleared int64 array has end of -1
ok 768 - Cleared int64 array Int-ifies to 0
ok 769 - Cleared int64 array numifies to 0
ok 770 - Cleared int64 array is falsey
ok 771 - Can assign integer range to int64 array
ok 772 - Got correct elems from range assign on int64 array
ok 773 - Got correct element from range assign on int64 array (1)
ok 774 - Got correct element from range assign on int64 array (2)
ok 775 - :exists works on int64 array (1)
ok 776 - :exists works on int64 array (2)
ok 777 - :exists works on int64 array (3)
ok 778 - Can call int64 array constructor with a single value
ok 779 - Correct number of elems set in constructor of int64 array
ok 780 - Correct element value set by constructor of int64 array
ok 781 - Can call int64 array constructor with values
ok 782 - Correct number of elems set in constructor of int64 array
ok 783 - Correct elem value set by constructor of int64 array (1)
ok 784 - Correct elem value set by constructor of int64 array (2)
ok 785 - Correct elem value set by constructor of int64 array (3)
ok 786 - Correct elem value set by constructor of int64 array (4)
ok 787 - Can also get last 2 elements on int64 array
ok 788 - int64 array .flat returns a Seq
ok 789 - int64 array .eager returns identity
ok 790 - Can iterate over int64 array
ok 791 - Mutating for loop on int64 array works (1)
ok 792 - Mutating for loop on int64 array works (2)
ok 793 - Mutating for loop on int64 array works (3)
ok 794 - Mutating for loop on int64 array works (4)
ok 795 - Can map over int64 array
ok 796 - Mutating map on int64 array works (1)
ok 797 - Mutating map on int64 array works (2)
ok 798 - Mutating map on int64 array works (3)
ok 799 - Mutating map on int64 array works (4)
ok 800 - grep a int64 array
ok 801 - int64 array.grep(Int)
ok 802 - int64 array.grep(Int, :k)
ok 803 - int64 array.grep(Int, :kv)
ok 804 - int64 array.grep(Int, :p)
ok 805 - int64 array.grep(Int, :v)
ok 806 - int64 array.grep(Int)
ok 807 - int64 array.grep(Int, :k)
ok 808 - int64 array.grep(Int, :kv)
ok 809 - int64 array.grep(Int, :p)
ok 810 - int64 array.grep(Int, :v)
ok 811 - Can use reduce meta-op on a int64 array
ok 812 - .values from a int64 array
ok 813 - .pairup from a int64 array
ok 814 - .keys from a int64 array
ok 815 - .pairs from a int64 array
ok 816 - .antipairs from a int64 array
ok 817 - .kv from a int64 array
ok 818 - .pick from a int64 array
ok 819 - .roll from a int64 array
ok 820 - int64 array.unique
ok 821 - int64 array.repeated
ok 822 - int64 array.squish
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Empty)
    ok 3 - .action matches pop
    ok 4 - .what matches array[int64]
ok 823 - Trying to pop an empty int64 array dies
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Empty)
    ok 3 - .what matches array[int64]
    ok 4 - .action matches shift
ok 824 - Trying to shift an empty int64 array dies
ok 825 - can push to int64 array
ok 826 - push to int64 array works (1)
ok 827 - push to int64 array works (2)
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck)
    ok 3 - .got matches (Str)
ok 828 - Cannot push non-int/Int to int64 array
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 829 - Cannot bind to int64 array
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 830 - Cannot delete from int64 array
ok 831 - can push multiple to int64 array
ok 832 - push multiple to int64 array works (1)
ok 833 - push multiple to int64 array works (2)
ok 834 - push multiple to int64 array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 835 - Cannot push non-int/Int to int64 array (multiple push)
ok 836 - can append to int64 array
ok 837 - append to int64 array works (1)
ok 838 - append to int64 array works (2)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 839 - Cannot append non-int/Int to int64 array
ok 840 - can append multiple to int64 array
ok 841 - append multiple to int64 array works (1)
ok 842 - append multiple to int64 array works (2)
ok 843 - append multiple to int64 array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 844 - Cannot append non-int/Int to int64 array (multiple append)
ok 845 - pop from int64 array works (1)
ok 846 - pop from int64 array works (2)
ok 847 - can unshift to int64 array
ok 848 - unshift to int64 array works (1)
ok 849 - unshift to int64 array works (2)
ok 850 - unshift to int64 array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 851 - Cannot unshift non-int/Int to int64 array
ok 852 - can unshift multiple to int64 array
ok 853 - unshift multiple to int64 array works (1)
ok 854 - unshift multiple to int64 array works (2)
ok 855 - unshift multiple to int64 array works (3)
ok 856 - unshift multiple to int64 array works (4)
ok 857 - unshift multiple to int64 array works (5)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 858 - Cannot unshift non-int/Int to int64 array (multiple unshift)
ok 859 - can prepend to int64 array
ok 860 - prepend to int64 array works (1)
ok 861 - prepend to int64 array works (2)
ok 862 - prepend to int64 array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 863 - Cannot prepend non-int/Int to int64 array
ok 864 - can prepend multiple to int64 array
ok 865 - unshift multiple to int64 array works (1)
ok 866 - prepend multiple to int64 array works (2)
ok 867 - prepend multiple to int64 array works (3)
ok 868 - prepend multiple to int64 array works (4)
ok 869 - prepend multiple to int64 array works (5)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 870 - Cannot prepend non-int/Int to int64 array (multiple unshift)
ok 871 - shift from int64 array works (1)
ok 872 - shift from int64 array works (2)
ok 873 - can initialize int64 from Range
ok 874 - Number of elems after splice int64 array
ok 875 - Splice on int64 array did the right thing (1)
ok 876 - Splice on int64 array did the right thing (2)
ok 877 - Splice on int64 array did the right thing (3)
ok 878 - Splice on int64 array did the right thing (4)
ok 879 - Splice on int64 array did the right thing (5)
ok 880 - Number of returned spliced values from int64 array
ok 881 - Correct value in splice returned from int64 array (1)
ok 882 - Correct value in splice returned from int64 array (2)
ok 883 - .Str space-separates on int64 array
ok 884 - .gist space-separates on int64 array
ok 885 - .raku includes type and int values on int64 array
ok 886 - does slice return same type
ok 887 - does slice handle containerized range
ok 888 - Flattening int64 array in call works
ok 889 - does join a int64 array
ok 890 - does emptying a int64 array really empty
ok 891 - does join handle holes in a int64 array
ok 892 - List-assigning int64 array to untyped works (1)
ok 893 - List-assigning int64 array to untyped works (2)
ok 894 - List-assigning int64 array to untyped works (3)
ok 895 - List-assign int64 array surrounded by literals (1)
ok 896 - List-assign int64 array surrounded by literals (2)
ok 897 - List-assign int64 array surrounded by literals (3)
ok 898 - List-assign int64 array surrounded by literals (4)
ok 899 - List-assign int64 array surrounded by literals (5)
ok 900 - List-assign untyped array of Int to int64 array (1)
ok 901 - List-assign untyped array of Int to int64 array (2)
ok 902 - List-assign untyped array of Int to int64 array (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 903 - List-assigning incompatible untyped array to int64 array dies
ok 904 - Smartmatching same int64 arrays works
ok 905 - Smartmatching different int64 arrays works
ok 906 - Can we sort int64 array
ok 907 - Can we sort 2-element sorted int64 array
ok 908 - Can we sort 2-element unsorted int64 array
ok 909 - Can we sort 1-element int64 array
ok 910 - Can we sort 0-element int64 array
ok 911 - uint array type is Positional
ok 912 - uint array type is Positional[uint]
ok 913 - uint array type .of is uint
ok 914 - uint array is Positional
ok 915 - uint array is Positional[uint]
ok 916 - uint array .of is uint
ok 917 - uint array is Positional
ok 918 - uint array is Positional[uint]
ok 919 - uint array .of is uint
ok 920 - .new from uint array is Positional
ok 921 - .new from uint array Positional[uint]
ok 922 - .new from uint array .of is uint
ok 923 - New uint array has no elems
ok 924 - New uint array has end of -1
ok 925 - New uint array Int-ifies to 0
ok 926 - New uint array numifies to 0
ok 927 - New uint array is falsey
ok 928 - Empty uint array is not lazy
ok 929 - Accessing non-existing on uint array gives 0
ok 930 - Elems do not grow just from an access on uint array
ok 931 - Can store integer in an uint array
ok 932 - Can get value from uint array
ok 933 - The elems grew as expected on uint array
ok 934 - uint array becomes truthy when it has an element
ok 935 - Can slice-assign to an uint array
ok 936 - Can get slice-assigned value from uint array (1)
ok 937 - Can get slice-assigned value from uint array (2)
ok 938 - The elems grew as expected on uint array
ok 939 - The end value matches grown elems on uint array
ok 940 - Int-ifies to grown number of elems on uint array
ok 941 - Numifies to grown number of elems on uint array
ok 942 - uint array with values is not lazy
ok 943 - Can assign non-contiguously to uint array
ok 944 - Elems behind non-contiguous assign are 0 on uint array
ok 945 - Non-contiguous assignment works on uint array
ok 946 - Can also get last element on uint array
ok 947 - Can clear uint array by assigning empty list
ok 948 - Cleared uint array has no elems
ok 949 - Cleared uint array has end of -1
ok 950 - Cleared uint array Int-ifies to 0
ok 951 - Cleared uint array numifies to 0
ok 952 - Cleared uint array is falsey
ok 953 - Can assign integer range to uint array
ok 954 - Got correct elems from range assign on uint array
ok 955 - Got correct element from range assign on uint array (1)
ok 956 - Got correct element from range assign on uint array (2)
ok 957 - :exists works on uint array (1)
ok 958 - :exists works on uint array (2)
ok 959 - :exists works on uint array (3)
ok 960 - Can call uint array constructor with a single value
ok 961 - Correct number of elems set in constructor of uint array
ok 962 - Correct element value set by constructor of uint array
ok 963 - Can call uint array constructor with values
ok 964 - Correct number of elems set in constructor of uint array
ok 965 - Correct elem value set by constructor of uint array (1)
ok 966 - Correct elem value set by constructor of uint array (2)
ok 967 - Correct elem value set by constructor of uint array (3)
ok 968 - Correct elem value set by constructor of uint array (4)
ok 969 - Can also get last 2 elements on uint array
ok 970 - uint array .flat returns a Seq
ok 971 - uint array .eager returns identity
ok 972 - Can iterate over uint array
ok 973 - Mutating for loop on uint array works (1)
ok 974 - Mutating for loop on uint array works (2)
ok 975 - Mutating for loop on uint array works (3)
ok 976 - Mutating for loop on uint array works (4)
ok 977 - Can map over uint array
ok 978 - Mutating map on uint array works (1)
ok 979 - Mutating map on uint array works (2)
ok 980 - Mutating map on uint array works (3)
ok 981 - Mutating map on uint array works (4)
ok 982 - grep a uint array
ok 983 - uint array.grep(Int)
ok 984 - uint array.grep(Int, :k)
ok 985 - uint array.grep(Int, :kv)
ok 986 - uint array.grep(Int, :p)
ok 987 - uint array.grep(Int, :v)
ok 988 - uint array.grep(Int)
ok 989 - uint array.grep(Int, :k)
ok 990 - uint array.grep(Int, :kv)
ok 991 - uint array.grep(Int, :p)
ok 992 - uint array.grep(Int, :v)
ok 993 - Can use reduce meta-op on a uint array
ok 994 - .values from a uint array
ok 995 - .pairup from a uint array
ok 996 - .keys from a uint array
ok 997 - .pairs from a uint array
ok 998 - .antipairs from a uint array
ok 999 - .kv from a uint array
ok 1000 - .pick from a uint array
ok 1001 - .roll from a uint array
ok 1002 - uint array.unique
ok 1003 - uint array.repeated
ok 1004 - uint array.squish
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Empty)
    ok 3 - .what matches array[uint]
    ok 4 - .action matches pop
ok 1005 - Trying to pop an empty uint array dies
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Empty)
    ok 3 - .what matches array[uint]
    ok 4 - .action matches shift
ok 1006 - Trying to shift an empty uint array dies
ok 1007 - can push to uint array
ok 1008 - push to uint array works (1)
ok 1009 - push to uint array works (2)
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck)
    ok 3 - .got matches (Str)
ok 1010 - Cannot push non-int/Int to uint array
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1011 - Cannot bind to uint array
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1012 - Cannot delete from uint array
ok 1013 - can push multiple to uint array
ok 1014 - push multiple to uint array works (1)
ok 1015 - push multiple to uint array works (2)
ok 1016 - push multiple to uint array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1017 - Cannot push non-int/Int to uint array (multiple push)
ok 1018 - can append to uint array
ok 1019 - append to uint array works (1)
ok 1020 - append to uint array works (2)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1021 - Cannot append non-int/Int to uint array
ok 1022 - can append multiple to uint array
ok 1023 - append multiple to uint array works (1)
ok 1024 - append multiple to uint array works (2)
ok 1025 - append multiple to uint array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1026 - Cannot append non-int/Int to uint array (multiple append)
ok 1027 - pop from uint array works (1)
ok 1028 - pop from uint array works (2)
ok 1029 - can unshift to uint array
ok 1030 - unshift to uint array works (1)
ok 1031 - unshift to uint array works (2)
ok 1032 - unshift to uint array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1033 - Cannot unshift non-int/Int to uint array
ok 1034 - can unshift multiple to uint array
ok 1035 - unshift multiple to uint array works (1)
ok 1036 - unshift multiple to uint array works (2)
ok 1037 - unshift multiple to uint array works (3)
ok 1038 - unshift multiple to uint array works (4)
ok 1039 - unshift multiple to uint array works (5)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1040 - Cannot unshift non-int/Int to uint array (multiple unshift)
ok 1041 - can prepend to uint array
ok 1042 - prepend to uint array works (1)
ok 1043 - prepend to uint array works (2)
ok 1044 - prepend to uint array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1045 - Cannot prepend non-int/Int to uint array
ok 1046 - can prepend multiple to uint array
ok 1047 - unshift multiple to uint array works (1)
ok 1048 - prepend multiple to uint array works (2)
ok 1049 - prepend multiple to uint array works (3)
ok 1050 - prepend multiple to uint array works (4)
ok 1051 - prepend multiple to uint array works (5)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1052 - Cannot prepend non-int/Int to uint array (multiple unshift)
ok 1053 - shift from uint array works (1)
ok 1054 - shift from uint array works (2)
ok 1055 - can initialize uint from Range
ok 1056 - Number of elems after splice uint array
ok 1057 - Splice on uint array did the right thing (1)
ok 1058 - Splice on uint array did the right thing (2)
ok 1059 - Splice on uint array did the right thing (3)
ok 1060 - Splice on uint array did the right thing (4)
ok 1061 - Splice on uint array did the right thing (5)
ok 1062 - Number of returned spliced values from uint array
ok 1063 - Correct value in splice returned from uint array (1)
ok 1064 - Correct value in splice returned from uint array (2)
ok 1065 - .Str space-separates on uint array
ok 1066 - .gist space-separates on uint array
ok 1067 - .raku includes type and int values on uint array
ok 1068 - does slice return same type
ok 1069 - does slice handle containerized range
ok 1070 - Flattening uint array in call works
ok 1071 - does join a uint array
ok 1072 - does emptying a uint array really empty
ok 1073 - does join handle holes in a uint array
ok 1074 - List-assigning uint array to untyped works (1)
ok 1075 - List-assigning uint array to untyped works (2)
ok 1076 - List-assigning uint array to untyped works (3)
ok 1077 - List-assign uint array surrounded by literals (1)
ok 1078 - List-assign uint array surrounded by literals (2)
ok 1079 - List-assign uint array surrounded by literals (3)
ok 1080 - List-assign uint array surrounded by literals (4)
ok 1081 - List-assign uint array surrounded by literals (5)
ok 1082 - List-assign untyped array of Int to uint array (1)
ok 1083 - List-assign untyped array of Int to uint array (2)
ok 1084 - List-assign untyped array of Int to uint array (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1085 - List-assigning incompatible untyped array to uint array dies
ok 1086 - Smartmatching same uint arrays works
ok 1087 - Smartmatching different uint arrays works
ok 1088 - Can we sort uint array
ok 1089 - Can we sort 2-element sorted uint array
ok 1090 - Can we sort 2-element unsorted uint array
ok 1091 - Can we sort 1-element uint array
ok 1092 - Can we sort 0-element uint array
ok 1093 - uint8 array type is Positional
ok 1094 - uint8 array type is Positional[uint8]
ok 1095 - uint8 array type .of is uint8
ok 1096 - uint8 array is Positional
ok 1097 - uint8 array is Positional[uint8]
ok 1098 - uint8 array .of is uint8
ok 1099 - uint8 array is Positional
ok 1100 - uint8 array is Positional[uint8]
ok 1101 - uint8 array .of is uint8
ok 1102 - .new from uint8 array is Positional
ok 1103 - .new from uint8 array Positional[uint8]
ok 1104 - .new from uint8 array .of is uint8
ok 1105 - New uint8 array has no elems
ok 1106 - New uint8 array has end of -1
ok 1107 - New uint8 array Int-ifies to 0
ok 1108 - New uint8 array numifies to 0
ok 1109 - New uint8 array is falsey
ok 1110 - Empty uint8 array is not lazy
ok 1111 - Accessing non-existing on uint8 array gives 0
ok 1112 - Elems do not grow just from an access on uint8 array
ok 1113 - Can store integer in an uint8 array
ok 1114 - Can get value from uint8 array
ok 1115 - The elems grew as expected on uint8 array
ok 1116 - uint8 array becomes truthy when it has an element
ok 1117 - Can slice-assign to an uint8 array
ok 1118 - Can get slice-assigned value from uint8 array (1)
ok 1119 - Can get slice-assigned value from uint8 array (2)
ok 1120 - The elems grew as expected on uint8 array
ok 1121 - The end value matches grown elems on uint8 array
ok 1122 - Int-ifies to grown number of elems on uint8 array
ok 1123 - Numifies to grown number of elems on uint8 array
ok 1124 - uint8 array with values is not lazy
ok 1125 - Can assign non-contiguously to uint8 array
ok 1126 - Elems behind non-contiguous assign are 0 on uint8 array
ok 1127 - Non-contiguous assignment works on uint8 array
ok 1128 - Can also get last element on uint8 array
ok 1129 - Can clear uint8 array by assigning empty list
ok 1130 - Cleared uint8 array has no elems
ok 1131 - Cleared uint8 array has end of -1
ok 1132 - Cleared uint8 array Int-ifies to 0
ok 1133 - Cleared uint8 array numifies to 0
ok 1134 - Cleared uint8 array is falsey
ok 1135 - Can assign integer range to uint8 array
ok 1136 - Got correct elems from range assign on uint8 array
ok 1137 - Got correct element from range assign on uint8 array (1)
ok 1138 - Got correct element from range assign on uint8 array (2)
ok 1139 - :exists works on uint8 array (1)
ok 1140 - :exists works on uint8 array (2)
ok 1141 - :exists works on uint8 array (3)
ok 1142 - Can call uint8 array constructor with a single value
ok 1143 - Correct number of elems set in constructor of uint8 array
ok 1144 - Correct element value set by constructor of uint8 array
ok 1145 - Can call uint8 array constructor with values
ok 1146 - Correct number of elems set in constructor of uint8 array
ok 1147 - Correct elem value set by constructor of uint8 array (1)
ok 1148 - Correct elem value set by constructor of uint8 array (2)
ok 1149 - Correct elem value set by constructor of uint8 array (3)
ok 1150 - Correct elem value set by constructor of uint8 array (4)
ok 1151 - Can also get last 2 elements on uint8 array
ok 1152 - uint8 array .flat returns a Seq
ok 1153 - uint8 array .eager returns identity
ok 1154 - Can iterate over uint8 array
ok 1155 - Mutating for loop on uint8 array works (1)
ok 1156 - Mutating for loop on uint8 array works (2)
ok 1157 - Mutating for loop on uint8 array works (3)
ok 1158 - Mutating for loop on uint8 array works (4)
ok 1159 - Can map over uint8 array
ok 1160 - Mutating map on uint8 array works (1)
ok 1161 - Mutating map on uint8 array works (2)
ok 1162 - Mutating map on uint8 array works (3)
ok 1163 - Mutating map on uint8 array works (4)
ok 1164 - grep a uint8 array
ok 1165 - uint8 array.grep(Int)
ok 1166 - uint8 array.grep(Int, :k)
ok 1167 - uint8 array.grep(Int, :kv)
ok 1168 - uint8 array.grep(Int, :p)
ok 1169 - uint8 array.grep(Int, :v)
ok 1170 - uint8 array.grep(Int)
ok 1171 - uint8 array.grep(Int, :k)
ok 1172 - uint8 array.grep(Int, :kv)
ok 1173 - uint8 array.grep(Int, :p)
ok 1174 - uint8 array.grep(Int, :v)
ok 1175 - Can use reduce meta-op on a uint8 array
ok 1176 - .values from a uint8 array
ok 1177 - .pairup from a uint8 array
ok 1178 - .keys from a uint8 array
ok 1179 - .pairs from a uint8 array
ok 1180 - .antipairs from a uint8 array
ok 1181 - .kv from a uint8 array
ok 1182 - .pick from a uint8 array
ok 1183 - .roll from a uint8 array
ok 1184 - uint8 array.unique
ok 1185 - uint8 array.repeated
ok 1186 - uint8 array.squish
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Empty)
    ok 3 - .action matches pop
    ok 4 - .what matches array[uint8]
ok 1187 - Trying to pop an empty uint8 array dies
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Empty)
    ok 3 - .what matches array[uint8]
    ok 4 - .action matches shift
ok 1188 - Trying to shift an empty uint8 array dies
ok 1189 - can push to uint8 array
ok 1190 - push to uint8 array works (1)
ok 1191 - push to uint8 array works (2)
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck)
    ok 3 - .got matches (Str)
ok 1192 - Cannot push non-int/Int to uint8 array
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1193 - Cannot bind to uint8 array
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1194 - Cannot delete from uint8 array
ok 1195 - can push multiple to uint8 array
ok 1196 - push multiple to uint8 array works (1)
ok 1197 - push multiple to uint8 array works (2)
ok 1198 - push multiple to uint8 array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1199 - Cannot push non-int/Int to uint8 array (multiple push)
ok 1200 - can append to uint8 array
ok 1201 - append to uint8 array works (1)
ok 1202 - append to uint8 array works (2)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1203 - Cannot append non-int/Int to uint8 array
ok 1204 - can append multiple to uint8 array
ok 1205 - append multiple to uint8 array works (1)
ok 1206 - append multiple to uint8 array works (2)
ok 1207 - append multiple to uint8 array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1208 - Cannot append non-int/Int to uint8 array (multiple append)
ok 1209 - pop from uint8 array works (1)
ok 1210 - pop from uint8 array works (2)
ok 1211 - can unshift to uint8 array
ok 1212 - unshift to uint8 array works (1)
ok 1213 - unshift to uint8 array works (2)
ok 1214 - unshift to uint8 array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1215 - Cannot unshift non-int/Int to uint8 array
ok 1216 - can unshift multiple to uint8 array
ok 1217 - unshift multiple to uint8 array works (1)
ok 1218 - unshift multiple to uint8 array works (2)
ok 1219 - unshift multiple to uint8 array works (3)
ok 1220 - unshift multiple to uint8 array works (4)
ok 1221 - unshift multiple to uint8 array works (5)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1222 - Cannot unshift non-int/Int to uint8 array (multiple unshift)
ok 1223 - can prepend to uint8 array
ok 1224 - prepend to uint8 array works (1)
ok 1225 - prepend to uint8 array works (2)
ok 1226 - prepend to uint8 array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1227 - Cannot prepend non-int/Int to uint8 array
ok 1228 - can prepend multiple to uint8 array
ok 1229 - unshift multiple to uint8 array works (1)
ok 1230 - prepend multiple to uint8 array works (2)
ok 1231 - prepend multiple to uint8 array works (3)
ok 1232 - prepend multiple to uint8 array works (4)
ok 1233 - prepend multiple to uint8 array works (5)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1234 - Cannot prepend non-int/Int to uint8 array (multiple unshift)
ok 1235 - shift from uint8 array works (1)
ok 1236 - shift from uint8 array works (2)
ok 1237 - can initialize uint8 from Range
ok 1238 - Number of elems after splice uint8 array
ok 1239 - Splice on uint8 array did the right thing (1)
ok 1240 - Splice on uint8 array did the right thing (2)
ok 1241 - Splice on uint8 array did the right thing (3)
ok 1242 - Splice on uint8 array did the right thing (4)
ok 1243 - Splice on uint8 array did the right thing (5)
ok 1244 - Number of returned spliced values from uint8 array
ok 1245 - Correct value in splice returned from uint8 array (1)
ok 1246 - Correct value in splice returned from uint8 array (2)
ok 1247 - .Str space-separates on uint8 array
ok 1248 - .gist space-separates on uint8 array
ok 1249 - .raku includes type and int values on uint8 array
ok 1250 - does slice return same type
ok 1251 - does slice handle containerized range
ok 1252 - Flattening uint8 array in call works
ok 1253 - does join a uint8 array
ok 1254 - does emptying a uint8 array really empty
ok 1255 - does join handle holes in a uint8 array
ok 1256 - List-assigning uint8 array to untyped works (1)
ok 1257 - List-assigning uint8 array to untyped works (2)
ok 1258 - List-assigning uint8 array to untyped works (3)
ok 1259 - List-assign uint8 array surrounded by literals (1)
ok 1260 - List-assign uint8 array surrounded by literals (2)
ok 1261 - List-assign uint8 array surrounded by literals (3)
ok 1262 - List-assign uint8 array surrounded by literals (4)
ok 1263 - List-assign uint8 array surrounded by literals (5)
ok 1264 - List-assign untyped array of Int to uint8 array (1)
ok 1265 - List-assign untyped array of Int to uint8 array (2)
ok 1266 - List-assign untyped array of Int to uint8 array (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1267 - List-assigning incompatible untyped array to uint8 array dies
ok 1268 - Smartmatching same uint8 arrays works
ok 1269 - Smartmatching different uint8 arrays works
ok 1270 - Can we sort uint8 array
ok 1271 - Can we sort 2-element sorted uint8 array
ok 1272 - Can we sort 2-element unsorted uint8 array
ok 1273 - Can we sort 1-element uint8 array
ok 1274 - Can we sort 0-element uint8 array
ok 1275 - uint16 array type is Positional
ok 1276 - uint16 array type is Positional[uint16]
ok 1277 - uint16 array type .of is uint16
ok 1278 - uint16 array is Positional
ok 1279 - uint16 array is Positional[uint16]
ok 1280 - uint16 array .of is uint16
ok 1281 - uint16 array is Positional
ok 1282 - uint16 array is Positional[uint16]
ok 1283 - uint16 array .of is uint16
ok 1284 - .new from uint16 array is Positional
ok 1285 - .new from uint16 array Positional[uint16]
ok 1286 - .new from uint16 array .of is uint16
ok 1287 - New uint16 array has no elems
ok 1288 - New uint16 array has end of -1
ok 1289 - New uint16 array Int-ifies to 0
ok 1290 - New uint16 array numifies to 0
ok 1291 - New uint16 array is falsey
ok 1292 - Empty uint16 array is not lazy
ok 1293 - Accessing non-existing on uint16 array gives 0
ok 1294 - Elems do not grow just from an access on uint16 array
ok 1295 - Can store integer in an uint16 array
ok 1296 - Can get value from uint16 array
ok 1297 - The elems grew as expected on uint16 array
ok 1298 - uint16 array becomes truthy when it has an element
ok 1299 - Can slice-assign to an uint16 array
ok 1300 - Can get slice-assigned value from uint16 array (1)
ok 1301 - Can get slice-assigned value from uint16 array (2)
ok 1302 - The elems grew as expected on uint16 array
ok 1303 - The end value matches grown elems on uint16 array
ok 1304 - Int-ifies to grown number of elems on uint16 array
ok 1305 - Numifies to grown number of elems on uint16 array
ok 1306 - uint16 array with values is not lazy
ok 1307 - Can assign non-contiguously to uint16 array
ok 1308 - Elems behind non-contiguous assign are 0 on uint16 array
ok 1309 - Non-contiguous assignment works on uint16 array
ok 1310 - Can also get last element on uint16 array
ok 1311 - Can clear uint16 array by assigning empty list
ok 1312 - Cleared uint16 array has no elems
ok 1313 - Cleared uint16 array has end of -1
ok 1314 - Cleared uint16 array Int-ifies to 0
ok 1315 - Cleared uint16 array numifies to 0
ok 1316 - Cleared uint16 array is falsey
ok 1317 - Can assign integer range to uint16 array
ok 1318 - Got correct elems from range assign on uint16 array
ok 1319 - Got correct element from range assign on uint16 array (1)
ok 1320 - Got correct element from range assign on uint16 array (2)
ok 1321 - :exists works on uint16 array (1)
ok 1322 - :exists works on uint16 array (2)
ok 1323 - :exists works on uint16 array (3)
ok 1324 - Can call uint16 array constructor with a single value
ok 1325 - Correct number of elems set in constructor of uint16 array
ok 1326 - Correct element value set by constructor of uint16 array
ok 1327 - Can call uint16 array constructor with values
ok 1328 - Correct number of elems set in constructor of uint16 array
ok 1329 - Correct elem value set by constructor of uint16 array (1)
ok 1330 - Correct elem value set by constructor of uint16 array (2)
ok 1331 - Correct elem value set by constructor of uint16 array (3)
ok 1332 - Correct elem value set by constructor of uint16 array (4)
ok 1333 - Can also get last 2 elements on uint16 array
ok 1334 - uint16 array .flat returns a Seq
ok 1335 - uint16 array .eager returns identity
ok 1336 - Can iterate over uint16 array
ok 1337 - Mutating for loop on uint16 array works (1)
ok 1338 - Mutating for loop on uint16 array works (2)
ok 1339 - Mutating for loop on uint16 array works (3)
ok 1340 - Mutating for loop on uint16 array works (4)
ok 1341 - Can map over uint16 array
ok 1342 - Mutating map on uint16 array works (1)
ok 1343 - Mutating map on uint16 array works (2)
ok 1344 - Mutating map on uint16 array works (3)
ok 1345 - Mutating map on uint16 array works (4)
ok 1346 - grep a uint16 array
ok 1347 - uint16 array.grep(Int)
ok 1348 - uint16 array.grep(Int, :k)
ok 1349 - uint16 array.grep(Int, :kv)
ok 1350 - uint16 array.grep(Int, :p)
ok 1351 - uint16 array.grep(Int, :v)
ok 1352 - uint16 array.grep(Int)
ok 1353 - uint16 array.grep(Int, :k)
ok 1354 - uint16 array.grep(Int, :kv)
ok 1355 - uint16 array.grep(Int, :p)
ok 1356 - uint16 array.grep(Int, :v)
ok 1357 - Can use reduce meta-op on a uint16 array
ok 1358 - .values from a uint16 array
ok 1359 - .pairup from a uint16 array
ok 1360 - .keys from a uint16 array
ok 1361 - .pairs from a uint16 array
ok 1362 - .antipairs from a uint16 array
ok 1363 - .kv from a uint16 array
ok 1364 - .pick from a uint16 array
ok 1365 - .roll from a uint16 array
ok 1366 - uint16 array.unique
ok 1367 - uint16 array.repeated
ok 1368 - uint16 array.squish
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Empty)
    ok 3 - .what matches array[uint16]
    ok 4 - .action matches pop
ok 1369 - Trying to pop an empty uint16 array dies
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Empty)
    ok 3 - .what matches array[uint16]
    ok 4 - .action matches shift
ok 1370 - Trying to shift an empty uint16 array dies
ok 1371 - can push to uint16 array
ok 1372 - push to uint16 array works (1)
ok 1373 - push to uint16 array works (2)
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck)
    ok 3 - .got matches (Str)
ok 1374 - Cannot push non-int/Int to uint16 array
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1375 - Cannot bind to uint16 array
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1376 - Cannot delete from uint16 array
ok 1377 - can push multiple to uint16 array
ok 1378 - push multiple to uint16 array works (1)
ok 1379 - push multiple to uint16 array works (2)
ok 1380 - push multiple to uint16 array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1381 - Cannot push non-int/Int to uint16 array (multiple push)
ok 1382 - can append to uint16 array
ok 1383 - append to uint16 array works (1)
ok 1384 - append to uint16 array works (2)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1385 - Cannot append non-int/Int to uint16 array
ok 1386 - can append multiple to uint16 array
ok 1387 - append multiple to uint16 array works (1)
ok 1388 - append multiple to uint16 array works (2)
ok 1389 - append multiple to uint16 array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1390 - Cannot append non-int/Int to uint16 array (multiple append)
ok 1391 - pop from uint16 array works (1)
ok 1392 - pop from uint16 array works (2)
ok 1393 - can unshift to uint16 array
ok 1394 - unshift to uint16 array works (1)
ok 1395 - unshift to uint16 array works (2)
ok 1396 - unshift to uint16 array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1397 - Cannot unshift non-int/Int to uint16 array
ok 1398 - can unshift multiple to uint16 array
ok 1399 - unshift multiple to uint16 array works (1)
ok 1400 - unshift multiple to uint16 array works (2)
ok 1401 - unshift multiple to uint16 array works (3)
ok 1402 - unshift multiple to uint16 array works (4)
ok 1403 - unshift multiple to uint16 array works (5)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1404 - Cannot unshift non-int/Int to uint16 array (multiple unshift)
ok 1405 - can prepend to uint16 array
ok 1406 - prepend to uint16 array works (1)
ok 1407 - prepend to uint16 array works (2)
ok 1408 - prepend to uint16 array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1409 - Cannot prepend non-int/Int to uint16 array
ok 1410 - can prepend multiple to uint16 array
ok 1411 - unshift multiple to uint16 array works (1)
ok 1412 - prepend multiple to uint16 array works (2)
ok 1413 - prepend multiple to uint16 array works (3)
ok 1414 - prepend multiple to uint16 array works (4)
ok 1415 - prepend multiple to uint16 array works (5)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1416 - Cannot prepend non-int/Int to uint16 array (multiple unshift)
ok 1417 - shift from uint16 array works (1)
ok 1418 - shift from uint16 array works (2)
ok 1419 - can initialize uint16 from Range
ok 1420 - Number of elems after splice uint16 array
ok 1421 - Splice on uint16 array did the right thing (1)
ok 1422 - Splice on uint16 array did the right thing (2)
ok 1423 - Splice on uint16 array did the right thing (3)
ok 1424 - Splice on uint16 array did the right thing (4)
ok 1425 - Splice on uint16 array did the right thing (5)
ok 1426 - Number of returned spliced values from uint16 array
ok 1427 - Correct value in splice returned from uint16 array (1)
ok 1428 - Correct value in splice returned from uint16 array (2)
ok 1429 - .Str space-separates on uint16 array
ok 1430 - .gist space-separates on uint16 array
ok 1431 - .raku includes type and int values on uint16 array
ok 1432 - does slice return same type
ok 1433 - does slice handle containerized range
ok 1434 - Flattening uint16 array in call works
ok 1435 - does join a uint16 array
ok 1436 - does emptying a uint16 array really empty
ok 1437 - does join handle holes in a uint16 array
ok 1438 - List-assigning uint16 array to untyped works (1)
ok 1439 - List-assigning uint16 array to untyped works (2)
ok 1440 - List-assigning uint16 array to untyped works (3)
ok 1441 - List-assign uint16 array surrounded by literals (1)
ok 1442 - List-assign uint16 array surrounded by literals (2)
ok 1443 - List-assign uint16 array surrounded by literals (3)
ok 1444 - List-assign uint16 array surrounded by literals (4)
ok 1445 - List-assign uint16 array surrounded by literals (5)
ok 1446 - List-assign untyped array of Int to uint16 array (1)
ok 1447 - List-assign untyped array of Int to uint16 array (2)
ok 1448 - List-assign untyped array of Int to uint16 array (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1449 - List-assigning incompatible untyped array to uint16 array dies
ok 1450 - Smartmatching same uint16 arrays works
ok 1451 - Smartmatching different uint16 arrays works
ok 1452 - Can we sort uint16 array
ok 1453 - Can we sort 2-element sorted uint16 array
ok 1454 - Can we sort 2-element unsorted uint16 array
ok 1455 - Can we sort 1-element uint16 array
ok 1456 - Can we sort 0-element uint16 array
ok 1457 - uint32 array type is Positional
ok 1458 - uint32 array type is Positional[uint32]
ok 1459 - uint32 array type .of is uint32
ok 1460 - uint32 array is Positional
ok 1461 - uint32 array is Positional[uint32]
ok 1462 - uint32 array .of is uint32
ok 1463 - uint32 array is Positional
ok 1464 - uint32 array is Positional[uint32]
ok 1465 - uint32 array .of is uint32
ok 1466 - .new from uint32 array is Positional
ok 1467 - .new from uint32 array Positional[uint32]
ok 1468 - .new from uint32 array .of is uint32
ok 1469 - New uint32 array has no elems
ok 1470 - New uint32 array has end of -1
ok 1471 - New uint32 array Int-ifies to 0
ok 1472 - New uint32 array numifies to 0
ok 1473 - New uint32 array is falsey
ok 1474 - Empty uint32 array is not lazy
ok 1475 - Accessing non-existing on uint32 array gives 0
ok 1476 - Elems do not grow just from an access on uint32 array
ok 1477 - Can store integer in an uint32 array
ok 1478 - Can get value from uint32 array
ok 1479 - The elems grew as expected on uint32 array
ok 1480 - uint32 array becomes truthy when it has an element
ok 1481 - Can slice-assign to an uint32 array
ok 1482 - Can get slice-assigned value from uint32 array (1)
ok 1483 - Can get slice-assigned value from uint32 array (2)
ok 1484 - The elems grew as expected on uint32 array
ok 1485 - The end value matches grown elems on uint32 array
ok 1486 - Int-ifies to grown number of elems on uint32 array
ok 1487 - Numifies to grown number of elems on uint32 array
ok 1488 - uint32 array with values is not lazy
ok 1489 - Can assign non-contiguously to uint32 array
ok 1490 - Elems behind non-contiguous assign are 0 on uint32 array
ok 1491 - Non-contiguous assignment works on uint32 array
ok 1492 - Can also get last element on uint32 array
ok 1493 - Can clear uint32 array by assigning empty list
ok 1494 - Cleared uint32 array has no elems
ok 1495 - Cleared uint32 array has end of -1
ok 1496 - Cleared uint32 array Int-ifies to 0
ok 1497 - Cleared uint32 array numifies to 0
ok 1498 - Cleared uint32 array is falsey
ok 1499 - Can assign integer range to uint32 array
ok 1500 - Got correct elems from range assign on uint32 array
ok 1501 - Got correct element from range assign on uint32 array (1)
ok 1502 - Got correct element from range assign on uint32 array (2)
ok 1503 - :exists works on uint32 array (1)
ok 1504 - :exists works on uint32 array (2)
ok 1505 - :exists works on uint32 array (3)
ok 1506 - Can call uint32 array constructor with a single value
ok 1507 - Correct number of elems set in constructor of uint32 array
ok 1508 - Correct element value set by constructor of uint32 array
ok 1509 - Can call uint32 array constructor with values
ok 1510 - Correct number of elems set in constructor of uint32 array
ok 1511 - Correct elem value set by constructor of uint32 array (1)
ok 1512 - Correct elem value set by constructor of uint32 array (2)
ok 1513 - Correct elem value set by constructor of uint32 array (3)
ok 1514 - Correct elem value set by constructor of uint32 array (4)
ok 1515 - Can also get last 2 elements on uint32 array
ok 1516 - uint32 array .flat returns a Seq
ok 1517 - uint32 array .eager returns identity
ok 1518 - Can iterate over uint32 array
ok 1519 - Mutating for loop on uint32 array works (1)
ok 1520 - Mutating for loop on uint32 array works (2)
ok 1521 - Mutating for loop on uint32 array works (3)
ok 1522 - Mutating for loop on uint32 array works (4)
ok 1523 - Can map over uint32 array
ok 1524 - Mutating map on uint32 array works (1)
ok 1525 - Mutating map on uint32 array works (2)
ok 1526 - Mutating map on uint32 array works (3)
ok 1527 - Mutating map on uint32 array works (4)
ok 1528 - grep a uint32 array
ok 1529 - uint32 array.grep(Int)
ok 1530 - uint32 array.grep(Int, :k)
ok 1531 - uint32 array.grep(Int, :kv)
ok 1532 - uint32 array.grep(Int, :p)
ok 1533 - uint32 array.grep(Int, :v)
ok 1534 - uint32 array.grep(Int)
ok 1535 - uint32 array.grep(Int, :k)
ok 1536 - uint32 array.grep(Int, :kv)
ok 1537 - uint32 array.grep(Int, :p)
ok 1538 - uint32 array.grep(Int, :v)
ok 1539 - Can use reduce meta-op on a uint32 array
ok 1540 - .values from a uint32 array
ok 1541 - .pairup from a uint32 array
ok 1542 - .keys from a uint32 array
ok 1543 - .pairs from a uint32 array
ok 1544 - .antipairs from a uint32 array
ok 1545 - .kv from a uint32 array
ok 1546 - .pick from a uint32 array
ok 1547 - .roll from a uint32 array
ok 1548 - uint32 array.unique
ok 1549 - uint32 array.repeated
ok 1550 - uint32 array.squish
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Empty)
    ok 3 - .what matches array[uint32]
    ok 4 - .action matches pop
ok 1551 - Trying to pop an empty uint32 array dies
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Empty)
    ok 3 - .what matches array[uint32]
    ok 4 - .action matches shift
ok 1552 - Trying to shift an empty uint32 array dies
ok 1553 - can push to uint32 array
ok 1554 - push to uint32 array works (1)
ok 1555 - push to uint32 array works (2)
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck)
    ok 3 - .got matches (Str)
ok 1556 - Cannot push non-int/Int to uint32 array
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1557 - Cannot bind to uint32 array
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1558 - Cannot delete from uint32 array
ok 1559 - can push multiple to uint32 array
ok 1560 - push multiple to uint32 array works (1)
ok 1561 - push multiple to uint32 array works (2)
ok 1562 - push multiple to uint32 array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1563 - Cannot push non-int/Int to uint32 array (multiple push)
ok 1564 - can append to uint32 array
ok 1565 - append to uint32 array works (1)
ok 1566 - append to uint32 array works (2)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1567 - Cannot append non-int/Int to uint32 array
ok 1568 - can append multiple to uint32 array
ok 1569 - append multiple to uint32 array works (1)
ok 1570 - append multiple to uint32 array works (2)
ok 1571 - append multiple to uint32 array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1572 - Cannot append non-int/Int to uint32 array (multiple append)
ok 1573 - pop from uint32 array works (1)
ok 1574 - pop from uint32 array works (2)
ok 1575 - can unshift to uint32 array
ok 1576 - unshift to uint32 array works (1)
ok 1577 - unshift to uint32 array works (2)
ok 1578 - unshift to uint32 array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1579 - Cannot unshift non-int/Int to uint32 array
ok 1580 - can unshift multiple to uint32 array
ok 1581 - unshift multiple to uint32 array works (1)
ok 1582 - unshift multiple to uint32 array works (2)
ok 1583 - unshift multiple to uint32 array works (3)
ok 1584 - unshift multiple to uint32 array works (4)
ok 1585 - unshift multiple to uint32 array works (5)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1586 - Cannot unshift non-int/Int to uint32 array (multiple unshift)
ok 1587 - can prepend to uint32 array
ok 1588 - prepend to uint32 array works (1)
ok 1589 - prepend to uint32 array works (2)
ok 1590 - prepend to uint32 array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1591 - Cannot prepend non-int/Int to uint32 array
ok 1592 - can prepend multiple to uint32 array
ok 1593 - unshift multiple to uint32 array works (1)
ok 1594 - prepend multiple to uint32 array works (2)
ok 1595 - prepend multiple to uint32 array works (3)
ok 1596 - prepend multiple to uint32 array works (4)
ok 1597 - prepend multiple to uint32 array works (5)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1598 - Cannot prepend non-int/Int to uint32 array (multiple unshift)
ok 1599 - shift from uint32 array works (1)
ok 1600 - shift from uint32 array works (2)
ok 1601 - can initialize uint32 from Range
ok 1602 - Number of elems after splice uint32 array
ok 1603 - Splice on uint32 array did the right thing (1)
ok 1604 - Splice on uint32 array did the right thing (2)
ok 1605 - Splice on uint32 array did the right thing (3)
ok 1606 - Splice on uint32 array did the right thing (4)
ok 1607 - Splice on uint32 array did the right thing (5)
ok 1608 - Number of returned spliced values from uint32 array
ok 1609 - Correct value in splice returned from uint32 array (1)
ok 1610 - Correct value in splice returned from uint32 array (2)
ok 1611 - .Str space-separates on uint32 array
ok 1612 - .gist space-separates on uint32 array
ok 1613 - .raku includes type and int values on uint32 array
ok 1614 - does slice return same type
ok 1615 - does slice handle containerized range
ok 1616 - Flattening uint32 array in call works
ok 1617 - does join a uint32 array
ok 1618 - does emptying a uint32 array really empty
ok 1619 - does join handle holes in a uint32 array
ok 1620 - List-assigning uint32 array to untyped works (1)
ok 1621 - List-assigning uint32 array to untyped works (2)
ok 1622 - List-assigning uint32 array to untyped works (3)
ok 1623 - List-assign uint32 array surrounded by literals (1)
ok 1624 - List-assign uint32 array surrounded by literals (2)
ok 1625 - List-assign uint32 array surrounded by literals (3)
ok 1626 - List-assign uint32 array surrounded by literals (4)
ok 1627 - List-assign uint32 array surrounded by literals (5)
ok 1628 - List-assign untyped array of Int to uint32 array (1)
ok 1629 - List-assign untyped array of Int to uint32 array (2)
ok 1630 - List-assign untyped array of Int to uint32 array (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1631 - List-assigning incompatible untyped array to uint32 array dies
ok 1632 - Smartmatching same uint32 arrays works
ok 1633 - Smartmatching different uint32 arrays works
ok 1634 - Can we sort uint32 array
ok 1635 - Can we sort 2-element sorted uint32 array
ok 1636 - Can we sort 2-element unsorted uint32 array
ok 1637 - Can we sort 1-element uint32 array
ok 1638 - Can we sort 0-element uint32 array
ok 1639 - uint64 array type is Positional
ok 1640 - uint64 array type is Positional[uint64]
ok 1641 - uint64 array type .of is uint64
ok 1642 - uint64 array is Positional
ok 1643 - uint64 array is Positional[uint64]
ok 1644 - uint64 array .of is uint64
ok 1645 - uint64 array is Positional
ok 1646 - uint64 array is Positional[uint64]
ok 1647 - uint64 array .of is uint64
ok 1648 - .new from uint64 array is Positional
ok 1649 - .new from uint64 array Positional[uint64]
ok 1650 - .new from uint64 array .of is uint64
ok 1651 - New uint64 array has no elems
ok 1652 - New uint64 array has end of -1
ok 1653 - New uint64 array Int-ifies to 0
ok 1654 - New uint64 array numifies to 0
ok 1655 - New uint64 array is falsey
ok 1656 - Empty uint64 array is not lazy
ok 1657 - Accessing non-existing on uint64 array gives 0
ok 1658 - Elems do not grow just from an access on uint64 array
ok 1659 - Can store integer in an uint64 array
ok 1660 - Can get value from uint64 array
ok 1661 - The elems grew as expected on uint64 array
ok 1662 - uint64 array becomes truthy when it has an element
ok 1663 - Can slice-assign to an uint64 array
ok 1664 - Can get slice-assigned value from uint64 array (1)
ok 1665 - Can get slice-assigned value from uint64 array (2)
ok 1666 - The elems grew as expected on uint64 array
ok 1667 - The end value matches grown elems on uint64 array
ok 1668 - Int-ifies to grown number of elems on uint64 array
ok 1669 - Numifies to grown number of elems on uint64 array
ok 1670 - uint64 array with values is not lazy
ok 1671 - Can assign non-contiguously to uint64 array
ok 1672 - Elems behind non-contiguous assign are 0 on uint64 array
ok 1673 - Non-contiguous assignment works on uint64 array
ok 1674 - Can also get last element on uint64 array
ok 1675 - Can clear uint64 array by assigning empty list
ok 1676 - Cleared uint64 array has no elems
ok 1677 - Cleared uint64 array has end of -1
ok 1678 - Cleared uint64 array Int-ifies to 0
ok 1679 - Cleared uint64 array numifies to 0
ok 1680 - Cleared uint64 array is falsey
ok 1681 - Can assign integer range to uint64 array
ok 1682 - Got correct elems from range assign on uint64 array
ok 1683 - Got correct element from range assign on uint64 array (1)
ok 1684 - Got correct element from range assign on uint64 array (2)
ok 1685 - :exists works on uint64 array (1)
ok 1686 - :exists works on uint64 array (2)
ok 1687 - :exists works on uint64 array (3)
ok 1688 - Can call uint64 array constructor with a single value
ok 1689 - Correct number of elems set in constructor of uint64 array
ok 1690 - Correct element value set by constructor of uint64 array
ok 1691 - Can call uint64 array constructor with values
ok 1692 - Correct number of elems set in constructor of uint64 array
ok 1693 - Correct elem value set by constructor of uint64 array (1)
ok 1694 - Correct elem value set by constructor of uint64 array (2)
ok 1695 - Correct elem value set by constructor of uint64 array (3)
ok 1696 - Correct elem value set by constructor of uint64 array (4)
ok 1697 - Can also get last 2 elements on uint64 array
ok 1698 - uint64 array .flat returns a Seq
ok 1699 - uint64 array .eager returns identity
ok 1700 - Can iterate over uint64 array
ok 1701 - Mutating for loop on uint64 array works (1)
ok 1702 - Mutating for loop on uint64 array works (2)
ok 1703 - Mutating for loop on uint64 array works (3)
ok 1704 - Mutating for loop on uint64 array works (4)
ok 1705 - Can map over uint64 array
ok 1706 - Mutating map on uint64 array works (1)
ok 1707 - Mutating map on uint64 array works (2)
ok 1708 - Mutating map on uint64 array works (3)
ok 1709 - Mutating map on uint64 array works (4)
ok 1710 - grep a uint64 array
ok 1711 - uint64 array.grep(Int)
ok 1712 - uint64 array.grep(Int, :k)
ok 1713 - uint64 array.grep(Int, :kv)
ok 1714 - uint64 array.grep(Int, :p)
ok 1715 - uint64 array.grep(Int, :v)
ok 1716 - uint64 array.grep(Int)
ok 1717 - uint64 array.grep(Int, :k)
ok 1718 - uint64 array.grep(Int, :kv)
ok 1719 - uint64 array.grep(Int, :p)
ok 1720 - uint64 array.grep(Int, :v)
ok 1721 - Can use reduce meta-op on a uint64 array
ok 1722 - .values from a uint64 array
ok 1723 - .pairup from a uint64 array
ok 1724 - .keys from a uint64 array
ok 1725 - .pairs from a uint64 array
ok 1726 - .antipairs from a uint64 array
ok 1727 - .kv from a uint64 array
ok 1728 - .pick from a uint64 array
ok 1729 - .roll from a uint64 array
ok 1730 - uint64 array.unique
ok 1731 - uint64 array.repeated
ok 1732 - uint64 array.squish
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Empty)
    ok 3 - .action matches pop
    ok 4 - .what matches array[uint64]
ok 1733 - Trying to pop an empty uint64 array dies
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Empty)
    ok 3 - .what matches array[uint64]
    ok 4 - .action matches shift
ok 1734 - Trying to shift an empty uint64 array dies
ok 1735 - can push to uint64 array
ok 1736 - push to uint64 array works (1)
ok 1737 - push to uint64 array works (2)
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck)
    ok 3 - .got matches (Str)
ok 1738 - Cannot push non-int/Int to uint64 array
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1739 - Cannot bind to uint64 array
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1740 - Cannot delete from uint64 array
ok 1741 - can push multiple to uint64 array
ok 1742 - push multiple to uint64 array works (1)
ok 1743 - push multiple to uint64 array works (2)
ok 1744 - push multiple to uint64 array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1745 - Cannot push non-int/Int to uint64 array (multiple push)
ok 1746 - can append to uint64 array
ok 1747 - append to uint64 array works (1)
ok 1748 - append to uint64 array works (2)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1749 - Cannot append non-int/Int to uint64 array
ok 1750 - can append multiple to uint64 array
ok 1751 - append multiple to uint64 array works (1)
ok 1752 - append multiple to uint64 array works (2)
ok 1753 - append multiple to uint64 array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1754 - Cannot append non-int/Int to uint64 array (multiple append)
ok 1755 - pop from uint64 array works (1)
ok 1756 - pop from uint64 array works (2)
ok 1757 - can unshift to uint64 array
ok 1758 - unshift to uint64 array works (1)
ok 1759 - unshift to uint64 array works (2)
ok 1760 - unshift to uint64 array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1761 - Cannot unshift non-int/Int to uint64 array
ok 1762 - can unshift multiple to uint64 array
ok 1763 - unshift multiple to uint64 array works (1)
ok 1764 - unshift multiple to uint64 array works (2)
ok 1765 - unshift multiple to uint64 array works (3)
ok 1766 - unshift multiple to uint64 array works (4)
ok 1767 - unshift multiple to uint64 array works (5)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1768 - Cannot unshift non-int/Int to uint64 array (multiple unshift)
ok 1769 - can prepend to uint64 array
ok 1770 - prepend to uint64 array works (1)
ok 1771 - prepend to uint64 array works (2)
ok 1772 - prepend to uint64 array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1773 - Cannot prepend non-int/Int to uint64 array
ok 1774 - can prepend multiple to uint64 array
ok 1775 - unshift multiple to uint64 array works (1)
ok 1776 - prepend multiple to uint64 array works (2)
ok 1777 - prepend multiple to uint64 array works (3)
ok 1778 - prepend multiple to uint64 array works (4)
ok 1779 - prepend multiple to uint64 array works (5)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1780 - Cannot prepend non-int/Int to uint64 array (multiple unshift)
ok 1781 - shift from uint64 array works (1)
ok 1782 - shift from uint64 array works (2)
ok 1783 - can initialize uint64 from Range
ok 1784 - Number of elems after splice uint64 array
ok 1785 - Splice on uint64 array did the right thing (1)
ok 1786 - Splice on uint64 array did the right thing (2)
ok 1787 - Splice on uint64 array did the right thing (3)
ok 1788 - Splice on uint64 array did the right thing (4)
ok 1789 - Splice on uint64 array did the right thing (5)
ok 1790 - Number of returned spliced values from uint64 array
ok 1791 - Correct value in splice returned from uint64 array (1)
ok 1792 - Correct value in splice returned from uint64 array (2)
ok 1793 - .Str space-separates on uint64 array
ok 1794 - .gist space-separates on uint64 array
ok 1795 - .raku includes type and int values on uint64 array
ok 1796 - does slice return same type
ok 1797 - does slice handle containerized range
ok 1798 - Flattening uint64 array in call works
ok 1799 - does join a uint64 array
ok 1800 - does emptying a uint64 array really empty
ok 1801 - does join handle holes in a uint64 array
ok 1802 - List-assigning uint64 array to untyped works (1)
ok 1803 - List-assigning uint64 array to untyped works (2)
ok 1804 - List-assigning uint64 array to untyped works (3)
ok 1805 - List-assign uint64 array surrounded by literals (1)
ok 1806 - List-assign uint64 array surrounded by literals (2)
ok 1807 - List-assign uint64 array surrounded by literals (3)
ok 1808 - List-assign uint64 array surrounded by literals (4)
ok 1809 - List-assign uint64 array surrounded by literals (5)
ok 1810 - List-assign untyped array of Int to uint64 array (1)
ok 1811 - List-assign untyped array of Int to uint64 array (2)
ok 1812 - List-assign untyped array of Int to uint64 array (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1813 - List-assigning incompatible untyped array to uint64 array dies
ok 1814 - Smartmatching same uint64 arrays works
ok 1815 - Smartmatching different uint64 arrays works
ok 1816 - Can we sort uint64 array
ok 1817 - Can we sort 2-element sorted uint64 array
ok 1818 - Can we sort 2-element unsorted uint64 array
ok 1819 - Can we sort 1-element uint64 array
ok 1820 - Can we sort 0-element uint64 array
ok 1821 - assigning -1 on uint array passes value on through?
not ok 1822 - negative value on uint array becomes positive # TODO highest bit length stays negative, RT #124088
# Failed test 'negative value on uint array becomes positive'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-int.rakudo line 322
ok 1823 - assigning -1 on uint8 array passes value on through?
ok 1824 - negative value on uint8 array becomes positive
ok 1825 - assigning -1 on uint16 array passes value on through?
ok 1826 - negative value on uint16 array becomes positive
ok 1827 - assigning -1 on uint32 array passes value on through?
ok 1828 - negative value on uint32 array becomes positive
ok 1829 - assigning -1 on uint64 array passes value on through?
not ok 1830 - negative value on uint64 array becomes positive # TODO highest bit length stays negative, RT #124088
# Failed test 'negative value on uint64 array becomes positive'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-int.rakudo line 322
ok 1831 - Trying to assign ^Inf to an int array dies
ok 1832 - is 1999999000000 == 1999999000000
ok 1833 - did we survive the hole
# FUDGED!
1..511
ok 1 - num array type is Positional
ok 2 - num array type is Positional[num]
ok 3 - num array type .of is num
ok 4 - num array is Positional
ok 5 - num array is Positional[num]
ok 6 - num array .of is num
ok 7 - num array is Positional
ok 8 - num array is Positional[num]
ok 9 - num array .of is num
ok 10 - .new from num array is Positional
ok 11 - .new from num array Positional[num]
ok 12 - .new from num array .of is num
ok 13 - New num array has no elems
ok 14 - New num array has end of -1
ok 15 - New num array Int-ifies to 0
ok 16 - New num array numifies to 0
ok 17 - New num array is falsey
ok 18 - Empty num array is not lazy
ok 19 - Accessing non-existing on num array gives 0
ok 20 - Elems do not grow just from an access on num array
ok 21 - Can store num in an num array
ok 22 - Can get value from num array
ok 23 - The elems grew as expected on num array
ok 24 - num array becomes truthy when it has an element
ok 25 - Can get slice-assigned value from num array (1)
ok 26 - Can get slice-assigned value from num array (2)
ok 27 - The elems grew as expected on num array
ok 28 - The end value matches grown elems on num array
ok 29 - Int-ifies to grown number of elems on num array
ok 30 - Numifies to grown number of elems on num array
ok 31 - num array with values is not lazy
ok 32 - are special IEEE values supported on num array
ok 33 - Can assign non-contiguously to num array
ok 34 - Elems non-contiguous assign 0 on num array
ok 35 - Non-contiguous assignment works on num array
ok 36 - Can also get last element on num array
ok 37 - Can clear num array by assigning empty list
ok 38 - Cleared num array has no elems
ok 39 - Cleared num array has end of -1
ok 40 - Cleared num array Int-ifies to 0
ok 41 - Cleared num array numifies to 0
ok 42 - Cleared num array is falsey
ok 43 - Got correct elems from range assign on num array
ok 44 - Correct elem from range assign on num array (1)
ok 45 - Correct elem from range assign on num array (2)
ok 46 - :exists works on num array (1)
ok 47 - :exists works on num array (2)
ok 48 - :exists works on num array (3)
ok 49 - Correct number of elems set in constructor of num array
ok 50 - Correct elem set by constructor of num array
ok 51 - Correct number of elems set in constructor of num array
ok 52 - Correct elem set by constructor of num array (1)
ok 53 - Correct elem set by constructor of num array (2)
ok 54 - Correct elem set by constructor of num array (3)
ok 55 - Correct elem set by constructor of num array (4)
ok 56 - num array .flat returns a Seq
ok 57 - num array .eager returns identity
ok 58 - # SKIP borkedness with num and iteration
ok 59 - Mutating for loop on num array works (1)
ok 60 - Mutating for loop on num array works (2)
ok 61 - Mutating for loop on num array works (3)
ok 62 - Mutating for loop on num array works (4)
ok 63 - Mutating map on num array works (1)
ok 64 - Mutating map on num array works (2)
ok 65 - Mutating map on num array works (3)
ok 66 - Mutating map on num array works (4)
ok 67 - Can grep a num array
ok 68 - num array.grep(Num)
ok 69 - num array.grep(Num, :k)
ok 70 - num array.grep(Num, :kv)
ok 71 - num array.grep(Num, :p)
ok 72 - num array.grep(Num, :v)
ok 73 - num array.grep(Num)
ok 74 - num array.grep(Num, :k)
ok 75 - num array.grep(Num, :kv)
ok 76 - num array.grep(Num, :p)
ok 77 - num array.grep(Num, :v)
ok 78 - Can use reduce meta-op on a num array
ok 79 - # SKIP cannot approx test Parcels
ok 80 - # SKIP cannot approx test Parcels
ok 81 - # SKIP nativeint.list loops on itself
ok 82 - # SKIP nativeint.list loops on itself
ok 83 - # SKIP nativeint.list loops on itself
ok 84 - # SKIP nativeint.list loops on itself
ok 85 - # SKIP nativeint.list loops on itself
ok 86 - # SKIP nativeint.list loops on itself
ok 87 - num array.unique
ok 88 - num array.repeated
ok 89 - num array.squish
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Empty)
    ok 3 - .what matches array[num]
    ok 4 - .action matches pop
ok 90 - Trying to pop an empty num array dies
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Empty)
    ok 3 - .action matches shift
    ok 4 - .what matches array[num]
ok 91 - Trying to shift an empty num array dies
    1..3
    ok 1 - code dies
    ok 2 - right exception type (Exception)
    ok 3 - .message matches Cannot bind to a native num array
ok 92 - Cannot push non-int/Int to num array
    1..3
    ok 1 - code dies
    ok 2 - right exception type (Exception)
    ok 3 - .message matches Cannot delete from a native num array
ok 93 - Cannot push non-int/Int to num array
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Lazy)
    ok 3 - .action matches initialize
    ok 4 - .what matches array[num]
ok 94 - Trying to initialize a num array with a right infinite list
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Lazy)
    ok 3 - .action matches initialize
    ok 4 - .what matches array[num]
ok 95 - Trying to initialize a num array with a left infinite list
ok 96 - push to num array works (1)
ok 97 - push to num array works (2)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 98 - Cannot push non-num/Num to num array
ok 99 - push multiple to num array works (1)
ok 100 - push multiple to num array works (2)
ok 101 - push multiple to num array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 102 - Cannot push non-num/Num to num array (multiple push)
ok 103 - append to num array works (1)
ok 104 - append to num array works (2)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 105 - Cannot append non-num/Num to num array
ok 106 - append multiple to num array works (1)
ok 107 - append multiple to num array works (2)
ok 108 - append multiple to num array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 109 - Cannot push non-num/Num to num array (multiple push)
ok 110 - pop from num array works (1)
ok 111 - pop from num array works (2)
ok 112 - unshift to num array works (1)
ok 113 - unshift to num array works (2)
ok 114 - unshift to num array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 115 - Cannot unshift non-num/Num to num array
ok 116 - unshift multiple to num array works (1)
ok 117 - unshift multiple to num array works (2)
ok 118 - unshift multiple to num array works (3)
ok 119 - unshift multiple to num array works (4)
ok 120 - unshift multiple to num array works (5)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 121 - Cannot unshift non-num/Num to num array (multiple unshift)
ok 122 - prepend to num array works (1)
ok 123 - prepend to num array works (2)
ok 124 - prepend to num array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 125 - Cannot prepend non-num/Num to num array
ok 126 - prepend multiple to num array works (1)
ok 127 - prepend multiple to num array works (2)
ok 128 - prepend multiple to num array works (3)
ok 129 - prepend multiple to num array works (4)
ok 130 - prepend multiple to num array works (5)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 131 - Cannot prepend non-num/Num to num array (multiple unshift)
ok 132 - shift from num array works (1)
ok 133 - shift from num array works (2)
ok 134 - Number of elems after splice num array
ok 135 - Splice on num array did the right thing (1)
ok 136 - Splice on num array did the right thing (2)
ok 137 - Splice on num array did the right thing (3)
ok 138 - Splice on num array did the right thing (4)
ok 139 - Splice on num array did the right thing (5)
ok 140 - Number of returned spliced values from num array
ok 141 - Correct value in splice from num array (1)
ok 142 - Correct value in splice from num array (2)
ok 143 - .Str space-separates on num array
ok 144 - .gist space-separates on num array
ok 145 - .raku includes type and num values on num array
ok 146 - does slice return same type
ok 147 - does slice handle containerized range
ok 148 - Flattening num array in call works
ok 149 - does join a num array
ok 150 - does emptying a num array really empty
ok 151 - does join handle holes in a num array
ok 152 - List-assign num array to untyped works (1)
ok 153 - List-assign num array to untyped works (2)
ok 154 - List-assign num array to untyped works (3)
ok 155 - List-assign num array surrounded by lits (1)
ok 156 - List-assign num array surrounded by lits (2)
ok 157 - List-assign num array surrounded by lits (3)
ok 158 - List-assign num array surrounded by lits (4)
ok 159 - List-assign num array surrounded by lits (5)
ok 160 - List-assign array of Num to num array (1)
ok 161 - List-assign array of Num to num array (2)
ok 162 - List-assign array of Num to num array (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 163 - List-assigning incompatible untyped array to num array dies
ok 164 - Smartmatching same num arrays works
ok 165 - Smartmatching different num arrays works
ok 166 - Can we sort num array
ok 167 - Can we sort 2-element sorted num array
ok 168 - Can we sort 2-element unsorted num array
ok 169 - Can we sort 1-element num array
ok 170 - Can we sort 0-element num array
ok 171 - num32 array type is Positional
ok 172 - num32 array type is Positional[num32]
ok 173 - num32 array type .of is num32
ok 174 - num32 array is Positional
ok 175 - num32 array is Positional[num32]
ok 176 - num32 array .of is num32
ok 177 - num32 array is Positional
ok 178 - num32 array is Positional[num32]
ok 179 - num32 array .of is num32
ok 180 - .new from num32 array is Positional
ok 181 - .new from num32 array Positional[num32]
ok 182 - .new from num32 array .of is num32
ok 183 - New num32 array has no elems
ok 184 - New num32 array has end of -1
ok 185 - New num32 array Int-ifies to 0
ok 186 - New num32 array numifies to 0
ok 187 - New num32 array is falsey
ok 188 - Empty num32 array is not lazy
ok 189 - Accessing non-existing on num32 array gives 0
ok 190 - Elems do not grow just from an access on num32 array
ok 191 - Can store num in an num32 array
ok 192 - Can get value from num32 array
ok 193 - The elems grew as expected on num32 array
ok 194 - num32 array becomes truthy when it has an element
ok 195 - Can get slice-assigned value from num32 array (1)
ok 196 - Can get slice-assigned value from num32 array (2)
ok 197 - The elems grew as expected on num32 array
ok 198 - The end value matches grown elems on num32 array
ok 199 - Int-ifies to grown number of elems on num32 array
ok 200 - Numifies to grown number of elems on num32 array
ok 201 - num32 array with values is not lazy
ok 202 - are special IEEE values supported on num32 array
ok 203 - Can assign non-contiguously to num32 array
ok 204 - Elems non-contiguous assign 0 on num32 array
ok 205 - Non-contiguous assignment works on num32 array
ok 206 - Can also get last element on num32 array
ok 207 - Can clear num32 array by assigning empty list
ok 208 - Cleared num32 array has no elems
ok 209 - Cleared num32 array has end of -1
ok 210 - Cleared num32 array Int-ifies to 0
ok 211 - Cleared num32 array numifies to 0
ok 212 - Cleared num32 array is falsey
ok 213 - Got correct elems from range assign on num32 array
ok 214 - Correct elem from range assign on num32 array (1)
ok 215 - Correct elem from range assign on num32 array (2)
ok 216 - :exists works on num32 array (1)
ok 217 - :exists works on num32 array (2)
ok 218 - :exists works on num32 array (3)
ok 219 - Correct number of elems set in constructor of num32 array
ok 220 - Correct elem set by constructor of num32 array
ok 221 - Correct number of elems set in constructor of num32 array
ok 222 - Correct elem set by constructor of num32 array (1)
ok 223 - Correct elem set by constructor of num32 array (2)
ok 224 - Correct elem set by constructor of num32 array (3)
ok 225 - Correct elem set by constructor of num32 array (4)
ok 226 - num32 array .flat returns a Seq
ok 227 - num32 array .eager returns identity
ok 228 - # SKIP borkedness with num and iteration
ok 229 - Mutating for loop on num32 array works (1)
ok 230 - Mutating for loop on num32 array works (2)
ok 231 - Mutating for loop on num32 array works (3)
ok 232 - Mutating for loop on num32 array works (4)
ok 233 - Mutating map on num32 array works (1)
ok 234 - Mutating map on num32 array works (2)
ok 235 - Mutating map on num32 array works (3)
ok 236 - Mutating map on num32 array works (4)
ok 237 - Can grep a num32 array
ok 238 - skipping .grep/.first test for num32 as they will fail
ok 239 - skipping .grep/.first test for num32 as they will fail
ok 240 - skipping .grep/.first test for num32 as they will fail
ok 241 - skipping .grep/.first test for num32 as they will fail
ok 242 - skipping .grep/.first test for num32 as they will fail
ok 243 - skipping .grep/.first test for num32 as they will fail
ok 244 - skipping .grep/.first test for num32 as they will fail
ok 245 - skipping .grep/.first test for num32 as they will fail
ok 246 - skipping .grep/.first test for num32 as they will fail
ok 247 - skipping .grep/.first test for num32 as they will fail
ok 248 - Can use reduce meta-op on a num32 array
ok 249 - # SKIP cannot approx test Parcels
ok 250 - # SKIP cannot approx test Parcels
ok 251 - # SKIP nativeint.list loops on itself
ok 252 - # SKIP nativeint.list loops on itself
ok 253 - # SKIP nativeint.list loops on itself
ok 254 - # SKIP nativeint.list loops on itself
ok 255 - # SKIP nativeint.list loops on itself
ok 256 - # SKIP nativeint.list loops on itself
ok 257 - num32 array.unique
ok 258 - num32 array.repeated
ok 259 - num32 array.squish
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Empty)
    ok 3 - .action matches pop
    ok 4 - .what matches array[num32]
ok 260 - Trying to pop an empty num32 array dies
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Empty)
    ok 3 - .what matches array[num32]
    ok 4 - .action matches shift
ok 261 - Trying to shift an empty num32 array dies
    1..3
    ok 1 - code dies
    ok 2 - right exception type (Exception)
    ok 3 - .message matches Cannot bind to a native num array
ok 262 - Cannot push non-int/Int to num32 array
    1..3
    ok 1 - code dies
    ok 2 - right exception type (Exception)
    ok 3 - .message matches Cannot delete from a native num array
ok 263 - Cannot push non-int/Int to num32 array
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Lazy)
    ok 3 - .what matches array[num32]
    ok 4 - .action matches initialize
ok 264 - Trying to initialize a num32 array with a right infinite list
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Lazy)
    ok 3 - .what matches array[num32]
    ok 4 - .action matches initialize
ok 265 - Trying to initialize a num32 array with a left infinite list
ok 266 - push to num32 array works (1)
ok 267 - push to num32 array works (2)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 268 - Cannot push non-num/Num to num32 array
ok 269 - push multiple to num32 array works (1)
ok 270 - push multiple to num32 array works (2)
ok 271 - push multiple to num32 array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 272 - Cannot push non-num/Num to num32 array (multiple push)
ok 273 - append to num32 array works (1)
ok 274 - append to num32 array works (2)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 275 - Cannot append non-num/Num to num32 array
ok 276 - append multiple to num32 array works (1)
ok 277 - append multiple to num32 array works (2)
ok 278 - append multiple to num32 array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 279 - Cannot push non-num/Num to num32 array (multiple push)
ok 280 - pop from num32 array works (1)
ok 281 - pop from num32 array works (2)
ok 282 - unshift to num32 array works (1)
ok 283 - unshift to num32 array works (2)
ok 284 - unshift to num32 array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 285 - Cannot unshift non-num/Num to num32 array
ok 286 - unshift multiple to num32 array works (1)
ok 287 - unshift multiple to num32 array works (2)
ok 288 - unshift multiple to num32 array works (3)
ok 289 - unshift multiple to num32 array works (4)
ok 290 - unshift multiple to num32 array works (5)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 291 - Cannot unshift non-num/Num to num32 array (multiple unshift)
ok 292 - prepend to num32 array works (1)
ok 293 - prepend to num32 array works (2)
ok 294 - prepend to num32 array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 295 - Cannot prepend non-num/Num to num32 array
ok 296 - prepend multiple to num32 array works (1)
ok 297 - prepend multiple to num32 array works (2)
ok 298 - prepend multiple to num32 array works (3)
ok 299 - prepend multiple to num32 array works (4)
ok 300 - prepend multiple to num32 array works (5)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 301 - Cannot prepend non-num/Num to num32 array (multiple unshift)
ok 302 - shift from num32 array works (1)
ok 303 - shift from num32 array works (2)
ok 304 - Number of elems after splice num32 array
ok 305 - Splice on num32 array did the right thing (1)
ok 306 - Splice on num32 array did the right thing (2)
ok 307 - Splice on num32 array did the right thing (3)
ok 308 - Splice on num32 array did the right thing (4)
ok 309 - Splice on num32 array did the right thing (5)
ok 310 - Number of returned spliced values from num32 array
ok 311 - Correct value in splice from num32 array (1)
ok 312 - Correct value in splice from num32 array (2)
ok 313 - .Str space-separates on num32 array
ok 314 - .gist space-separates on num32 array
ok 315 - .raku includes type and num values on num32 array
ok 316 - does slice return same type
ok 317 - does slice handle containerized range
ok 318 - Flattening num32 array in call works
ok 319 - does join a num32 array
ok 320 - does emptying a num32 array really empty
ok 321 - does join handle holes in a num32 array
ok 322 - List-assign num32 array to untyped works (1)
ok 323 - List-assign num32 array to untyped works (2)
ok 324 - List-assign num32 array to untyped works (3)
ok 325 - List-assign num32 array surrounded by lits (1)
ok 326 - List-assign num32 array surrounded by lits (2)
ok 327 - List-assign num32 array surrounded by lits (3)
ok 328 - List-assign num32 array surrounded by lits (4)
ok 329 - List-assign num32 array surrounded by lits (5)
ok 330 - List-assign array of Num to num32 array (1)
ok 331 - List-assign array of Num to num32 array (2)
ok 332 - List-assign array of Num to num32 array (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 333 - List-assigning incompatible untyped array to num32 array dies
ok 334 - Smartmatching same num32 arrays works
ok 335 - Smartmatching different num32 arrays works
ok 336 - Can we sort num32 array
ok 337 - Can we sort 2-element sorted num32 array
ok 338 - Can we sort 2-element unsorted num32 array
ok 339 - Can we sort 1-element num32 array
ok 340 - Can we sort 0-element num32 array
ok 341 - num64 array type is Positional
ok 342 - num64 array type is Positional[num64]
ok 343 - num64 array type .of is num64
ok 344 - num64 array is Positional
ok 345 - num64 array is Positional[num64]
ok 346 - num64 array .of is num64
ok 347 - num64 array is Positional
ok 348 - num64 array is Positional[num64]
ok 349 - num64 array .of is num64
ok 350 - .new from num64 array is Positional
ok 351 - .new from num64 array Positional[num64]
ok 352 - .new from num64 array .of is num64
ok 353 - New num64 array has no elems
ok 354 - New num64 array has end of -1
ok 355 - New num64 array Int-ifies to 0
ok 356 - New num64 array numifies to 0
ok 357 - New num64 array is falsey
ok 358 - Empty num64 array is not lazy
ok 359 - Accessing non-existing on num64 array gives 0
ok 360 - Elems do not grow just from an access on num64 array
ok 361 - Can store num in an num64 array
ok 362 - Can get value from num64 array
ok 363 - The elems grew as expected on num64 array
ok 364 - num64 array becomes truthy when it has an element
ok 365 - Can get slice-assigned value from num64 array (1)
ok 366 - Can get slice-assigned value from num64 array (2)
ok 367 - The elems grew as expected on num64 array
ok 368 - The end value matches grown elems on num64 array
ok 369 - Int-ifies to grown number of elems on num64 array
ok 370 - Numifies to grown number of elems on num64 array
ok 371 - num64 array with values is not lazy
ok 372 - are special IEEE values supported on num64 array
ok 373 - Can assign non-contiguously to num64 array
ok 374 - Elems non-contiguous assign 0 on num64 array
ok 375 - Non-contiguous assignment works on num64 array
ok 376 - Can also get last element on num64 array
ok 377 - Can clear num64 array by assigning empty list
ok 378 - Cleared num64 array has no elems
ok 379 - Cleared num64 array has end of -1
ok 380 - Cleared num64 array Int-ifies to 0
ok 381 - Cleared num64 array numifies to 0
ok 382 - Cleared num64 array is falsey
ok 383 - Got correct elems from range assign on num64 array
ok 384 - Correct elem from range assign on num64 array (1)
ok 385 - Correct elem from range assign on num64 array (2)
ok 386 - :exists works on num64 array (1)
ok 387 - :exists works on num64 array (2)
ok 388 - :exists works on num64 array (3)
ok 389 - Correct number of elems set in constructor of num64 array
ok 390 - Correct elem set by constructor of num64 array
ok 391 - Correct number of elems set in constructor of num64 array
ok 392 - Correct elem set by constructor of num64 array (1)
ok 393 - Correct elem set by constructor of num64 array (2)
ok 394 - Correct elem set by constructor of num64 array (3)
ok 395 - Correct elem set by constructor of num64 array (4)
ok 396 - num64 array .flat returns a Seq
ok 397 - num64 array .eager returns identity
ok 398 - # SKIP borkedness with num and iteration
ok 399 - Mutating for loop on num64 array works (1)
ok 400 - Mutating for loop on num64 array works (2)
ok 401 - Mutating for loop on num64 array works (3)
ok 402 - Mutating for loop on num64 array works (4)
ok 403 - Mutating map on num64 array works (1)
ok 404 - Mutating map on num64 array works (2)
ok 405 - Mutating map on num64 array works (3)
ok 406 - Mutating map on num64 array works (4)
ok 407 - Can grep a num64 array
ok 408 - num64 array.grep(Num)
ok 409 - num64 array.grep(Num, :k)
ok 410 - num64 array.grep(Num, :kv)
ok 411 - num64 array.grep(Num, :p)
ok 412 - num64 array.grep(Num, :v)
ok 413 - num64 array.grep(Num)
ok 414 - num64 array.grep(Num, :k)
ok 415 - num64 array.grep(Num, :kv)
ok 416 - num64 array.grep(Num, :p)
ok 417 - num64 array.grep(Num, :v)
ok 418 - Can use reduce meta-op on a num64 array
ok 419 - # SKIP cannot approx test Parcels
ok 420 - # SKIP cannot approx test Parcels
ok 421 - # SKIP nativeint.list loops on itself
ok 422 - # SKIP nativeint.list loops on itself
ok 423 - # SKIP nativeint.list loops on itself
ok 424 - # SKIP nativeint.list loops on itself
ok 425 - # SKIP nativeint.list loops on itself
ok 426 - # SKIP nativeint.list loops on itself
ok 427 - num64 array.unique
ok 428 - num64 array.repeated
ok 429 - num64 array.squish
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Empty)
    ok 3 - .action matches pop
    ok 4 - .what matches array[num64]
ok 430 - Trying to pop an empty num64 array dies
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Empty)
    ok 3 - .what matches array[num64]
    ok 4 - .action matches shift
ok 431 - Trying to shift an empty num64 array dies
    1..3
    ok 1 - code dies
    ok 2 - right exception type (Exception)
    ok 3 - .message matches Cannot bind to a native num array
ok 432 - Cannot push non-int/Int to num64 array
    1..3
    ok 1 - code dies
    ok 2 - right exception type (Exception)
    ok 3 - .message matches Cannot delete from a native num array
ok 433 - Cannot push non-int/Int to num64 array
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Lazy)
    ok 3 - .action matches initialize
    ok 4 - .what matches array[num64]
ok 434 - Trying to initialize a num64 array with a right infinite list
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Lazy)
    ok 3 - .what matches array[num64]
    ok 4 - .action matches initialize
ok 435 - Trying to initialize a num64 array with a left infinite list
ok 436 - push to num64 array works (1)
ok 437 - push to num64 array works (2)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 438 - Cannot push non-num/Num to num64 array
ok 439 - push multiple to num64 array works (1)
ok 440 - push multiple to num64 array works (2)
ok 441 - push multiple to num64 array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 442 - Cannot push non-num/Num to num64 array (multiple push)
ok 443 - append to num64 array works (1)
ok 444 - append to num64 array works (2)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 445 - Cannot append non-num/Num to num64 array
ok 446 - append multiple to num64 array works (1)
ok 447 - append multiple to num64 array works (2)
ok 448 - append multiple to num64 array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 449 - Cannot push non-num/Num to num64 array (multiple push)
ok 450 - pop from num64 array works (1)
ok 451 - pop from num64 array works (2)
ok 452 - unshift to num64 array works (1)
ok 453 - unshift to num64 array works (2)
ok 454 - unshift to num64 array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 455 - Cannot unshift non-num/Num to num64 array
ok 456 - unshift multiple to num64 array works (1)
ok 457 - unshift multiple to num64 array works (2)
ok 458 - unshift multiple to num64 array works (3)
ok 459 - unshift multiple to num64 array works (4)
ok 460 - unshift multiple to num64 array works (5)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 461 - Cannot unshift non-num/Num to num64 array (multiple unshift)
ok 462 - prepend to num64 array works (1)
ok 463 - prepend to num64 array works (2)
ok 464 - prepend to num64 array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 465 - Cannot prepend non-num/Num to num64 array
ok 466 - prepend multiple to num64 array works (1)
ok 467 - prepend multiple to num64 array works (2)
ok 468 - prepend multiple to num64 array works (3)
ok 469 - prepend multiple to num64 array works (4)
ok 470 - prepend multiple to num64 array works (5)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 471 - Cannot prepend non-num/Num to num64 array (multiple unshift)
ok 472 - shift from num64 array works (1)
ok 473 - shift from num64 array works (2)
ok 474 - Number of elems after splice num64 array
ok 475 - Splice on num64 array did the right thing (1)
ok 476 - Splice on num64 array did the right thing (2)
ok 477 - Splice on num64 array did the right thing (3)
ok 478 - Splice on num64 array did the right thing (4)
ok 479 - Splice on num64 array did the right thing (5)
ok 480 - Number of returned spliced values from num64 array
ok 481 - Correct value in splice from num64 array (1)
ok 482 - Correct value in splice from num64 array (2)
ok 483 - .Str space-separates on num64 array
ok 484 - .gist space-separates on num64 array
ok 485 - .raku includes type and num values on num64 array
ok 486 - does slice return same type
ok 487 - does slice handle containerized range
ok 488 - Flattening num64 array in call works
ok 489 - does join a num64 array
ok 490 - does emptying a num64 array really empty
ok 491 - does join handle holes in a num64 array
ok 492 - List-assign num64 array to untyped works (1)
ok 493 - List-assign num64 array to untyped works (2)
ok 494 - List-assign num64 array to untyped works (3)
ok 495 - List-assign num64 array surrounded by lits (1)
ok 496 - List-assign num64 array surrounded by lits (2)
ok 497 - List-assign num64 array surrounded by lits (3)
ok 498 - List-assign num64 array surrounded by lits (4)
ok 499 - List-assign num64 array surrounded by lits (5)
ok 500 - List-assign array of Num to num64 array (1)
ok 501 - List-assign array of Num to num64 array (2)
ok 502 - List-assign array of Num to num64 array (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 503 - List-assigning incompatible untyped array to num64 array dies
ok 504 - Smartmatching same num64 arrays works
ok 505 - Smartmatching different num64 arrays works
ok 506 - Can we sort num64 array
ok 507 - Can we sort 2-element sorted num64 array
ok 508 - Can we sort 2-element unsorted num64 array
ok 509 - Can we sort 1-element num64 array
ok 510 - Can we sort 0-element num64 array
ok 511 - did we survive the hole
# FUDGED!
1..1110
ok 1 - int array is Positional
not ok 2 - int array is Positional[int] # TODO apparently it is not a typed Positional
# Failed test 'int array is Positional[int]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 19
ok 3 - int array .of is int
ok 4 - int array is Positional
not ok 5 - int array is Positional[int] # TODO apparently it is not a typed Positional
# Failed test 'int array is Positional[int]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 25
ok 6 - int array .of is int
ok 7 - .new from int array is Positional
not ok 8 - .new from int array Positional[int] # TODO apparently it is not a typed Positional
# Failed test '.new from int array Positional[int]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 29
ok 9 - .new from int array .of is int
ok 10 - New int array has 5 elems
ok 11 - New int array has end of -1
ok 12 - New int array Int-ifies to 5
ok 13 - New int array numifies to 5
ok 14 - Empty int array is not lazy
ok 15 - Accessing non-existing on int array dies
ok 16 - Elems do not grow just from an access on int array
ok 17 - Can store integer in an int array with Int index
ok 18 - Can get value from int array with Int index
ok 19 - can store integer in an $t array with int index
ok 20 - Can get value from int array with int index
ok 21 - Can slice-assign to an int array
ok 22 - Can get slice-assigned value from int array (1)
ok 23 - Can get slice-assigned value from int array (2)
ok 24 - :exists works on int array with int index
ok 25 - :exists works on int array with Int index
ok 26 - :exists works on int array when out of range
ok 27 - :!exists works on int array with int index
ok 28 - :!exists works on int array with Int index
ok 29 - :!exists works on int array when out of range
ok 30 - :delete dies on int array with int index
ok 31 - :delete dies on int array with Int index
ok 32 - :!delete works on int array with int index
ok 33 - :!delete works on int array with Int index
ok 34 - Can call int array constructor with a single value
ok 35 - Correct number of elems set in constructor of int array
ok 36 - Correct element value set by constructor of int array
ok 37 - Can call int array constructor with values
ok 38 - Correct number of elems set in constructor of int array
ok 39 - Correct elem value set by constructor of int array (1)
ok 40 - Correct elem value set by constructor of int array (2)
ok 41 - Correct elem value set by constructor of int array (3)
ok 42 - Correct elem value set by constructor of int array (4)
ok 43 - Can also get last 2 elements on int array
ok 44 - int array .flat returns a Seq
ok 45 - int array .eager returns identity
ok 46 - Mutating for loop on int array works (1)
ok 47 - Mutating for loop on int array works (2)
ok 48 - Mutating for loop on int array works (3)
ok 49 - Mutating for loop on int array works (4)
ok 50 - Can map over int array
ok 51 - Mutating map on int array works (1)
ok 52 - Mutating map on int array works (2)
ok 53 - Mutating map on int array works (3)
ok 54 - Mutating map on int array works (4)
ok 55 - grep a int array
ok 56 - int array.grep(Int)
ok 57 - int array.grep(Int, :k)
ok 58 - int array.grep(Int, :kv)
ok 59 - int array.grep(Int, :p)
ok 60 - int array.grep(Int, :v)
ok 61 - int array.grep(Int)
ok 62 - int array.grep(Int, :k)
ok 63 - int array.grep(Int, :kv)
ok 64 - int array.grep(Int, :p)
ok 65 - int array.grep(Int, :v)
ok 66 - Can use reduce meta-op on a int array
ok 67 - .values from a int array
ok 68 - .pairup from a int array
ok 69 - .keys from a int array
ok 70 - .pairs from a int array
ok 71 - .antipairs from a int array
ok 72 - .kv from a int array
ok 73 - .pick from a int array
ok 74 - .roll from a int array
ok 75 - int array.unique
ok 76 - int array.repeated
ok 77 - int array.squish
ok 78 - Trying to pop a shaped int array dies
ok 79 - Trying to shift a shaped int array dies
ok 80 - Trying to push a shaped int array dies
ok 81 - Trying to unshift a shaped int array dies
ok 82 - Cannot bind to a int array
ok 83 - Cannot delete from a int array
ok 84 - Cannot append to a int array
ok 85 - Cannot prepend to a int array
ok 86 - Cannot splice to a int array
ok 87 - .Str space-separates on int array
ok 88 - .gist space-separates on int array
ok 89 - .raku includes type and int values on int array
ok 90 - # SKIP STORE not working correctly yet)
ok 91 - does slice handle containerized range
ok 92 - does join a int array
ok 93 - Can clear int array by assigning empty list
ok 94 - does emptying a int array reset
ok 95 - does re-initializing a int array work
ok 96 - List-assigning int array to untyped works (1)
ok 97 - List-assigning int array to untyped works (2)
ok 98 - List-assigning int array to untyped works (3)
ok 99 - List-assign int array surrounded by literals (1)
ok 100 - List-assign int array surrounded by literals (2)
ok 101 - List-assign int array surrounded by literals (3)
ok 102 - List-assign int array surrounded by literals (4)
ok 103 - List-assign int array surrounded by literals (5)
ok 104 - List-assign untyped array of Int to int array (1)
ok 105 - List-assign untyped array of Int to int array (2)
ok 106 - List-assign untyped array of Int to int array (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 107 - List-assigning incompatible untyped array to int array dies
ok 108 - Smartmatching same int arrays works
ok 109 - Can we sort int array
ok 110 - Can we sort 2-element sorted int array
ok 111 - Can we sort 1-element sorted int array
ok 112 - int8 array is Positional
not ok 113 - int8 array is Positional[int8] # TODO apparently it is not a typed Positional
# Failed test 'int8 array is Positional[int8]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 19
ok 114 - int8 array .of is int8
ok 115 - int8 array is Positional
not ok 116 - int8 array is Positional[int8] # TODO apparently it is not a typed Positional
# Failed test 'int8 array is Positional[int8]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 25
ok 117 - int8 array .of is int8
ok 118 - .new from int8 array is Positional
not ok 119 - .new from int8 array Positional[int8] # TODO apparently it is not a typed Positional
# Failed test '.new from int8 array Positional[int8]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 29
ok 120 - .new from int8 array .of is int8
ok 121 - New int8 array has 5 elems
ok 122 - New int8 array has end of -1
ok 123 - New int8 array Int-ifies to 5
ok 124 - New int8 array numifies to 5
ok 125 - Empty int8 array is not lazy
ok 126 - Accessing non-existing on int8 array dies
ok 127 - Elems do not grow just from an access on int8 array
ok 128 - Can store integer in an int8 array with Int index
ok 129 - Can get value from int8 array with Int index
ok 130 - can store integer in an $t array with int index
ok 131 - Can get value from int8 array with int index
ok 132 - Can slice-assign to an int8 array
ok 133 - Can get slice-assigned value from int8 array (1)
ok 134 - Can get slice-assigned value from int8 array (2)
ok 135 - :exists works on int8 array with int index
ok 136 - :exists works on int8 array with Int index
ok 137 - :exists works on int8 array when out of range
ok 138 - :!exists works on int8 array with int index
ok 139 - :!exists works on int8 array with Int index
ok 140 - :!exists works on int8 array when out of range
ok 141 - :delete dies on int8 array with int index
ok 142 - :delete dies on int8 array with Int index
ok 143 - :!delete works on int8 array with int index
ok 144 - :!delete works on int8 array with Int index
ok 145 - Can call int8 array constructor with a single value
ok 146 - Correct number of elems set in constructor of int8 array
ok 147 - Correct element value set by constructor of int8 array
ok 148 - Can call int8 array constructor with values
ok 149 - Correct number of elems set in constructor of int8 array
ok 150 - Correct elem value set by constructor of int8 array (1)
ok 151 - Correct elem value set by constructor of int8 array (2)
ok 152 - Correct elem value set by constructor of int8 array (3)
ok 153 - Correct elem value set by constructor of int8 array (4)
ok 154 - Can also get last 2 elements on int8 array
ok 155 - int8 array .flat returns a Seq
ok 156 - int8 array .eager returns identity
ok 157 - Mutating for loop on int8 array works (1)
ok 158 - Mutating for loop on int8 array works (2)
ok 159 - Mutating for loop on int8 array works (3)
ok 160 - Mutating for loop on int8 array works (4)
ok 161 - Can map over int8 array
ok 162 - Mutating map on int8 array works (1)
ok 163 - Mutating map on int8 array works (2)
ok 164 - Mutating map on int8 array works (3)
ok 165 - Mutating map on int8 array works (4)
ok 166 - grep a int8 array
ok 167 - int8 array.grep(Int)
ok 168 - int8 array.grep(Int, :k)
ok 169 - int8 array.grep(Int, :kv)
ok 170 - int8 array.grep(Int, :p)
ok 171 - int8 array.grep(Int, :v)
ok 172 - int8 array.grep(Int)
ok 173 - int8 array.grep(Int, :k)
ok 174 - int8 array.grep(Int, :kv)
ok 175 - int8 array.grep(Int, :p)
ok 176 - int8 array.grep(Int, :v)
ok 177 - Can use reduce meta-op on a int8 array
ok 178 - .values from a int8 array
ok 179 - .pairup from a int8 array
ok 180 - .keys from a int8 array
ok 181 - .pairs from a int8 array
ok 182 - .antipairs from a int8 array
ok 183 - .kv from a int8 array
ok 184 - .pick from a int8 array
ok 185 - .roll from a int8 array
ok 186 - int8 array.unique
ok 187 - int8 array.repeated
ok 188 - int8 array.squish
ok 189 - Trying to pop a shaped int8 array dies
ok 190 - Trying to shift a shaped int8 array dies
ok 191 - Trying to push a shaped int8 array dies
ok 192 - Trying to unshift a shaped int8 array dies
ok 193 - Cannot bind to a int8 array
ok 194 - Cannot delete from a int8 array
ok 195 - Cannot append to a int8 array
ok 196 - Cannot prepend to a int8 array
ok 197 - Cannot splice to a int8 array
ok 198 - .Str space-separates on int8 array
ok 199 - .gist space-separates on int8 array
ok 200 - .raku includes type and int values on int8 array
ok 201 - # SKIP STORE not working correctly yet)
ok 202 - does slice handle containerized range
ok 203 - does join a int8 array
ok 204 - Can clear int8 array by assigning empty list
ok 205 - does emptying a int8 array reset
ok 206 - does re-initializing a int8 array work
ok 207 - List-assigning int8 array to untyped works (1)
ok 208 - List-assigning int8 array to untyped works (2)
ok 209 - List-assigning int8 array to untyped works (3)
ok 210 - List-assign int8 array surrounded by literals (1)
ok 211 - List-assign int8 array surrounded by literals (2)
ok 212 - List-assign int8 array surrounded by literals (3)
ok 213 - List-assign int8 array surrounded by literals (4)
ok 214 - List-assign int8 array surrounded by literals (5)
ok 215 - List-assign untyped array of Int to int8 array (1)
ok 216 - List-assign untyped array of Int to int8 array (2)
ok 217 - List-assign untyped array of Int to int8 array (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 218 - List-assigning incompatible untyped array to int8 array dies
ok 219 - Smartmatching same int8 arrays works
ok 220 - Can we sort int8 array
ok 221 - Can we sort 2-element sorted int8 array
ok 222 - Can we sort 1-element sorted int8 array
ok 223 - int16 array is Positional
not ok 224 - int16 array is Positional[int16] # TODO apparently it is not a typed Positional
# Failed test 'int16 array is Positional[int16]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 19
ok 225 - int16 array .of is int16
ok 226 - int16 array is Positional
not ok 227 - int16 array is Positional[int16] # TODO apparently it is not a typed Positional
# Failed test 'int16 array is Positional[int16]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 25
ok 228 - int16 array .of is int16
ok 229 - .new from int16 array is Positional
not ok 230 - .new from int16 array Positional[int16] # TODO apparently it is not a typed Positional
# Failed test '.new from int16 array Positional[int16]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 29
ok 231 - .new from int16 array .of is int16
ok 232 - New int16 array has 5 elems
ok 233 - New int16 array has end of -1
ok 234 - New int16 array Int-ifies to 5
ok 235 - New int16 array numifies to 5
ok 236 - Empty int16 array is not lazy
ok 237 - Accessing non-existing on int16 array dies
ok 238 - Elems do not grow just from an access on int16 array
ok 239 - Can store integer in an int16 array with Int index
ok 240 - Can get value from int16 array with Int index
ok 241 - can store integer in an $t array with int index
ok 242 - Can get value from int16 array with int index
ok 243 - Can slice-assign to an int16 array
ok 244 - Can get slice-assigned value from int16 array (1)
ok 245 - Can get slice-assigned value from int16 array (2)
ok 246 - :exists works on int16 array with int index
ok 247 - :exists works on int16 array with Int index
ok 248 - :exists works on int16 array when out of range
ok 249 - :!exists works on int16 array with int index
ok 250 - :!exists works on int16 array with Int index
ok 251 - :!exists works on int16 array when out of range
ok 252 - :delete dies on int16 array with int index
ok 253 - :delete dies on int16 array with Int index
ok 254 - :!delete works on int16 array with int index
ok 255 - :!delete works on int16 array with Int index
ok 256 - Can call int16 array constructor with a single value
ok 257 - Correct number of elems set in constructor of int16 array
ok 258 - Correct element value set by constructor of int16 array
ok 259 - Can call int16 array constructor with values
ok 260 - Correct number of elems set in constructor of int16 array
ok 261 - Correct elem value set by constructor of int16 array (1)
ok 262 - Correct elem value set by constructor of int16 array (2)
ok 263 - Correct elem value set by constructor of int16 array (3)
ok 264 - Correct elem value set by constructor of int16 array (4)
ok 265 - Can also get last 2 elements on int16 array
ok 266 - int16 array .flat returns a Seq
ok 267 - int16 array .eager returns identity
ok 268 - Mutating for loop on int16 array works (1)
ok 269 - Mutating for loop on int16 array works (2)
ok 270 - Mutating for loop on int16 array works (3)
ok 271 - Mutating for loop on int16 array works (4)
ok 272 - Can map over int16 array
ok 273 - Mutating map on int16 array works (1)
ok 274 - Mutating map on int16 array works (2)
ok 275 - Mutating map on int16 array works (3)
ok 276 - Mutating map on int16 array works (4)
ok 277 - grep a int16 array
ok 278 - int16 array.grep(Int)
ok 279 - int16 array.grep(Int, :k)
ok 280 - int16 array.grep(Int, :kv)
ok 281 - int16 array.grep(Int, :p)
ok 282 - int16 array.grep(Int, :v)
ok 283 - int16 array.grep(Int)
ok 284 - int16 array.grep(Int, :k)
ok 285 - int16 array.grep(Int, :kv)
ok 286 - int16 array.grep(Int, :p)
ok 287 - int16 array.grep(Int, :v)
ok 288 - Can use reduce meta-op on a int16 array
ok 289 - .values from a int16 array
ok 290 - .pairup from a int16 array
ok 291 - .keys from a int16 array
ok 292 - .pairs from a int16 array
ok 293 - .antipairs from a int16 array
ok 294 - .kv from a int16 array
ok 295 - .pick from a int16 array
ok 296 - .roll from a int16 array
ok 297 - int16 array.unique
ok 298 - int16 array.repeated
ok 299 - int16 array.squish
ok 300 - Trying to pop a shaped int16 array dies
ok 301 - Trying to shift a shaped int16 array dies
ok 302 - Trying to push a shaped int16 array dies
ok 303 - Trying to unshift a shaped int16 array dies
ok 304 - Cannot bind to a int16 array
ok 305 - Cannot delete from a int16 array
ok 306 - Cannot append to a int16 array
ok 307 - Cannot prepend to a int16 array
ok 308 - Cannot splice to a int16 array
ok 309 - .Str space-separates on int16 array
ok 310 - .gist space-separates on int16 array
ok 311 - .raku includes type and int values on int16 array
ok 312 - # SKIP STORE not working correctly yet)
ok 313 - does slice handle containerized range
ok 314 - does join a int16 array
ok 315 - Can clear int16 array by assigning empty list
ok 316 - does emptying a int16 array reset
ok 317 - does re-initializing a int16 array work
ok 318 - List-assigning int16 array to untyped works (1)
ok 319 - List-assigning int16 array to untyped works (2)
ok 320 - List-assigning int16 array to untyped works (3)
ok 321 - List-assign int16 array surrounded by literals (1)
ok 322 - List-assign int16 array surrounded by literals (2)
ok 323 - List-assign int16 array surrounded by literals (3)
ok 324 - List-assign int16 array surrounded by literals (4)
ok 325 - List-assign int16 array surrounded by literals (5)
ok 326 - List-assign untyped array of Int to int16 array (1)
ok 327 - List-assign untyped array of Int to int16 array (2)
ok 328 - List-assign untyped array of Int to int16 array (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 329 - List-assigning incompatible untyped array to int16 array dies
ok 330 - Smartmatching same int16 arrays works
ok 331 - Can we sort int16 array
ok 332 - Can we sort 2-element sorted int16 array
ok 333 - Can we sort 1-element sorted int16 array
ok 334 - int32 array is Positional
not ok 335 - int32 array is Positional[int32] # TODO apparently it is not a typed Positional
# Failed test 'int32 array is Positional[int32]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 19
ok 336 - int32 array .of is int32
ok 337 - int32 array is Positional
not ok 338 - int32 array is Positional[int32] # TODO apparently it is not a typed Positional
# Failed test 'int32 array is Positional[int32]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 25
ok 339 - int32 array .of is int32
ok 340 - .new from int32 array is Positional
not ok 341 - .new from int32 array Positional[int32] # TODO apparently it is not a typed Positional
# Failed test '.new from int32 array Positional[int32]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 29
ok 342 - .new from int32 array .of is int32
ok 343 - New int32 array has 5 elems
ok 344 - New int32 array has end of -1
ok 345 - New int32 array Int-ifies to 5
ok 346 - New int32 array numifies to 5
ok 347 - Empty int32 array is not lazy
ok 348 - Accessing non-existing on int32 array dies
ok 349 - Elems do not grow just from an access on int32 array
ok 350 - Can store integer in an int32 array with Int index
ok 351 - Can get value from int32 array with Int index
ok 352 - can store integer in an $t array with int index
ok 353 - Can get value from int32 array with int index
ok 354 - Can slice-assign to an int32 array
ok 355 - Can get slice-assigned value from int32 array (1)
ok 356 - Can get slice-assigned value from int32 array (2)
ok 357 - :exists works on int32 array with int index
ok 358 - :exists works on int32 array with Int index
ok 359 - :exists works on int32 array when out of range
ok 360 - :!exists works on int32 array with int index
ok 361 - :!exists works on int32 array with Int index
ok 362 - :!exists works on int32 array when out of range
ok 363 - :delete dies on int32 array with int index
ok 364 - :delete dies on int32 array with Int index
ok 365 - :!delete works on int32 array with int index
ok 366 - :!delete works on int32 array with Int index
ok 367 - Can call int32 array constructor with a single value
ok 368 - Correct number of elems set in constructor of int32 array
ok 369 - Correct element value set by constructor of int32 array
ok 370 - Can call int32 array constructor with values
ok 371 - Correct number of elems set in constructor of int32 array
ok 372 - Correct elem value set by constructor of int32 array (1)
ok 373 - Correct elem value set by constructor of int32 array (2)
ok 374 - Correct elem value set by constructor of int32 array (3)
ok 375 - Correct elem value set by constructor of int32 array (4)
ok 376 - Can also get last 2 elements on int32 array
ok 377 - int32 array .flat returns a Seq
ok 378 - int32 array .eager returns identity
ok 379 - Mutating for loop on int32 array works (1)
ok 380 - Mutating for loop on int32 array works (2)
ok 381 - Mutating for loop on int32 array works (3)
ok 382 - Mutating for loop on int32 array works (4)
ok 383 - Can map over int32 array
ok 384 - Mutating map on int32 array works (1)
ok 385 - Mutating map on int32 array works (2)
ok 386 - Mutating map on int32 array works (3)
ok 387 - Mutating map on int32 array works (4)
ok 388 - grep a int32 array
ok 389 - int32 array.grep(Int)
ok 390 - int32 array.grep(Int, :k)
ok 391 - int32 array.grep(Int, :kv)
ok 392 - int32 array.grep(Int, :p)
ok 393 - int32 array.grep(Int, :v)
ok 394 - int32 array.grep(Int)
ok 395 - int32 array.grep(Int, :k)
ok 396 - int32 array.grep(Int, :kv)
ok 397 - int32 array.grep(Int, :p)
ok 398 - int32 array.grep(Int, :v)
ok 399 - Can use reduce meta-op on a int32 array
ok 400 - .values from a int32 array
ok 401 - .pairup from a int32 array
ok 402 - .keys from a int32 array
ok 403 - .pairs from a int32 array
ok 404 - .antipairs from a int32 array
ok 405 - .kv from a int32 array
ok 406 - .pick from a int32 array
ok 407 - .roll from a int32 array
ok 408 - int32 array.unique
ok 409 - int32 array.repeated
ok 410 - int32 array.squish
ok 411 - Trying to pop a shaped int32 array dies
ok 412 - Trying to shift a shaped int32 array dies
ok 413 - Trying to push a shaped int32 array dies
ok 414 - Trying to unshift a shaped int32 array dies
ok 415 - Cannot bind to a int32 array
ok 416 - Cannot delete from a int32 array
ok 417 - Cannot append to a int32 array
ok 418 - Cannot prepend to a int32 array
ok 419 - Cannot splice to a int32 array
ok 420 - .Str space-separates on int32 array
ok 421 - .gist space-separates on int32 array
ok 422 - .raku includes type and int values on int32 array
ok 423 - # SKIP STORE not working correctly yet)
ok 424 - does slice handle containerized range
ok 425 - does join a int32 array
ok 426 - Can clear int32 array by assigning empty list
ok 427 - does emptying a int32 array reset
ok 428 - does re-initializing a int32 array work
ok 429 - List-assigning int32 array to untyped works (1)
ok 430 - List-assigning int32 array to untyped works (2)
ok 431 - List-assigning int32 array to untyped works (3)
ok 432 - List-assign int32 array surrounded by literals (1)
ok 433 - List-assign int32 array surrounded by literals (2)
ok 434 - List-assign int32 array surrounded by literals (3)
ok 435 - List-assign int32 array surrounded by literals (4)
ok 436 - List-assign int32 array surrounded by literals (5)
ok 437 - List-assign untyped array of Int to int32 array (1)
ok 438 - List-assign untyped array of Int to int32 array (2)
ok 439 - List-assign untyped array of Int to int32 array (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 440 - List-assigning incompatible untyped array to int32 array dies
ok 441 - Smartmatching same int32 arrays works
ok 442 - Can we sort int32 array
ok 443 - Can we sort 2-element sorted int32 array
ok 444 - Can we sort 1-element sorted int32 array
ok 445 - int64 array is Positional
not ok 446 - int64 array is Positional[int64] # TODO apparently it is not a typed Positional
# Failed test 'int64 array is Positional[int64]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 19
ok 447 - int64 array .of is int64
ok 448 - int64 array is Positional
not ok 449 - int64 array is Positional[int64] # TODO apparently it is not a typed Positional
# Failed test 'int64 array is Positional[int64]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 25
ok 450 - int64 array .of is int64
ok 451 - .new from int64 array is Positional
not ok 452 - .new from int64 array Positional[int64] # TODO apparently it is not a typed Positional
# Failed test '.new from int64 array Positional[int64]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 29
ok 453 - .new from int64 array .of is int64
ok 454 - New int64 array has 5 elems
ok 455 - New int64 array has end of -1
ok 456 - New int64 array Int-ifies to 5
ok 457 - New int64 array numifies to 5
ok 458 - Empty int64 array is not lazy
ok 459 - Accessing non-existing on int64 array dies
ok 460 - Elems do not grow just from an access on int64 array
ok 461 - Can store integer in an int64 array with Int index
ok 462 - Can get value from int64 array with Int index
ok 463 - can store integer in an $t array with int index
ok 464 - Can get value from int64 array with int index
ok 465 - Can slice-assign to an int64 array
ok 466 - Can get slice-assigned value from int64 array (1)
ok 467 - Can get slice-assigned value from int64 array (2)
ok 468 - :exists works on int64 array with int index
ok 469 - :exists works on int64 array with Int index
ok 470 - :exists works on int64 array when out of range
ok 471 - :!exists works on int64 array with int index
ok 472 - :!exists works on int64 array with Int index
ok 473 - :!exists works on int64 array when out of range
ok 474 - :delete dies on int64 array with int index
ok 475 - :delete dies on int64 array with Int index
ok 476 - :!delete works on int64 array with int index
ok 477 - :!delete works on int64 array with Int index
ok 478 - Can call int64 array constructor with a single value
ok 479 - Correct number of elems set in constructor of int64 array
ok 480 - Correct element value set by constructor of int64 array
ok 481 - Can call int64 array constructor with values
ok 482 - Correct number of elems set in constructor of int64 array
ok 483 - Correct elem value set by constructor of int64 array (1)
ok 484 - Correct elem value set by constructor of int64 array (2)
ok 485 - Correct elem value set by constructor of int64 array (3)
ok 486 - Correct elem value set by constructor of int64 array (4)
ok 487 - Can also get last 2 elements on int64 array
ok 488 - int64 array .flat returns a Seq
ok 489 - int64 array .eager returns identity
ok 490 - Mutating for loop on int64 array works (1)
ok 491 - Mutating for loop on int64 array works (2)
ok 492 - Mutating for loop on int64 array works (3)
ok 493 - Mutating for loop on int64 array works (4)
ok 494 - Can map over int64 array
ok 495 - Mutating map on int64 array works (1)
ok 496 - Mutating map on int64 array works (2)
ok 497 - Mutating map on int64 array works (3)
ok 498 - Mutating map on int64 array works (4)
ok 499 - grep a int64 array
ok 500 - int64 array.grep(Int)
ok 501 - int64 array.grep(Int, :k)
ok 502 - int64 array.grep(Int, :kv)
ok 503 - int64 array.grep(Int, :p)
ok 504 - int64 array.grep(Int, :v)
ok 505 - int64 array.grep(Int)
ok 506 - int64 array.grep(Int, :k)
ok 507 - int64 array.grep(Int, :kv)
ok 508 - int64 array.grep(Int, :p)
ok 509 - int64 array.grep(Int, :v)
ok 510 - Can use reduce meta-op on a int64 array
ok 511 - .values from a int64 array
ok 512 - .pairup from a int64 array
ok 513 - .keys from a int64 array
ok 514 - .pairs from a int64 array
ok 515 - .antipairs from a int64 array
ok 516 - .kv from a int64 array
ok 517 - .pick from a int64 array
ok 518 - .roll from a int64 array
ok 519 - int64 array.unique
ok 520 - int64 array.repeated
ok 521 - int64 array.squish
ok 522 - Trying to pop a shaped int64 array dies
ok 523 - Trying to shift a shaped int64 array dies
ok 524 - Trying to push a shaped int64 array dies
ok 525 - Trying to unshift a shaped int64 array dies
ok 526 - Cannot bind to a int64 array
ok 527 - Cannot delete from a int64 array
ok 528 - Cannot append to a int64 array
ok 529 - Cannot prepend to a int64 array
ok 530 - Cannot splice to a int64 array
ok 531 - .Str space-separates on int64 array
ok 532 - .gist space-separates on int64 array
ok 533 - .raku includes type and int values on int64 array
ok 534 - # SKIP STORE not working correctly yet)
ok 535 - does slice handle containerized range
ok 536 - does join a int64 array
ok 537 - Can clear int64 array by assigning empty list
ok 538 - does emptying a int64 array reset
ok 539 - does re-initializing a int64 array work
ok 540 - List-assigning int64 array to untyped works (1)
ok 541 - List-assigning int64 array to untyped works (2)
ok 542 - List-assigning int64 array to untyped works (3)
ok 543 - List-assign int64 array surrounded by literals (1)
ok 544 - List-assign int64 array surrounded by literals (2)
ok 545 - List-assign int64 array surrounded by literals (3)
ok 546 - List-assign int64 array surrounded by literals (4)
ok 547 - List-assign int64 array surrounded by literals (5)
ok 548 - List-assign untyped array of Int to int64 array (1)
ok 549 - List-assign untyped array of Int to int64 array (2)
ok 550 - List-assign untyped array of Int to int64 array (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 551 - List-assigning incompatible untyped array to int64 array dies
ok 552 - Smartmatching same int64 arrays works
ok 553 - Can we sort int64 array
ok 554 - Can we sort 2-element sorted int64 array
ok 555 - Can we sort 1-element sorted int64 array
ok 556 - uint array is Positional
not ok 557 - uint array is Positional[uint] # TODO apparently it is not a typed Positional
# Failed test 'uint array is Positional[uint]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 19
ok 558 - uint array .of is uint
ok 559 - uint array is Positional
not ok 560 - uint array is Positional[uint] # TODO apparently it is not a typed Positional
# Failed test 'uint array is Positional[uint]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 25
ok 561 - uint array .of is uint
ok 562 - .new from uint array is Positional
not ok 563 - .new from uint array Positional[uint] # TODO apparently it is not a typed Positional
# Failed test '.new from uint array Positional[uint]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 29
ok 564 - .new from uint array .of is uint
ok 565 - New uint array has 5 elems
ok 566 - New uint array has end of -1
ok 567 - New uint array Int-ifies to 5
ok 568 - New uint array numifies to 5
ok 569 - Empty uint array is not lazy
ok 570 - Accessing non-existing on uint array dies
ok 571 - Elems do not grow just from an access on uint array
ok 572 - Can store integer in an uint array with Int index
ok 573 - Can get value from uint array with Int index
ok 574 - can store integer in an $t array with int index
ok 575 - Can get value from uint array with int index
ok 576 - Can slice-assign to an uint array
ok 577 - Can get slice-assigned value from uint array (1)
ok 578 - Can get slice-assigned value from uint array (2)
ok 579 - :exists works on uint array with int index
ok 580 - :exists works on uint array with Int index
ok 581 - :exists works on uint array when out of range
ok 582 - :!exists works on uint array with int index
ok 583 - :!exists works on uint array with Int index
ok 584 - :!exists works on uint array when out of range
ok 585 - :delete dies on uint array with int index
ok 586 - :delete dies on uint array with Int index
ok 587 - :!delete works on uint array with int index
ok 588 - :!delete works on uint array with Int index
ok 589 - Can call uint array constructor with a single value
ok 590 - Correct number of elems set in constructor of uint array
ok 591 - Correct element value set by constructor of uint array
ok 592 - Can call uint array constructor with values
ok 593 - Correct number of elems set in constructor of uint array
ok 594 - Correct elem value set by constructor of uint array (1)
ok 595 - Correct elem value set by constructor of uint array (2)
ok 596 - Correct elem value set by constructor of uint array (3)
ok 597 - Correct elem value set by constructor of uint array (4)
ok 598 - Can also get last 2 elements on uint array
ok 599 - uint array .flat returns a Seq
ok 600 - uint array .eager returns identity
ok 601 - Mutating for loop on uint array works (1)
ok 602 - Mutating for loop on uint array works (2)
ok 603 - Mutating for loop on uint array works (3)
ok 604 - Mutating for loop on uint array works (4)
ok 605 - Can map over uint array
ok 606 - Mutating map on uint array works (1)
ok 607 - Mutating map on uint array works (2)
ok 608 - Mutating map on uint array works (3)
ok 609 - Mutating map on uint array works (4)
ok 610 - grep a uint array
ok 611 - uint array.grep(Int)
ok 612 - uint array.grep(Int, :k)
ok 613 - uint array.grep(Int, :kv)
ok 614 - uint array.grep(Int, :p)
ok 615 - uint array.grep(Int, :v)
ok 616 - uint array.grep(Int)
ok 617 - uint array.grep(Int, :k)
ok 618 - uint array.grep(Int, :kv)
ok 619 - uint array.grep(Int, :p)
ok 620 - uint array.grep(Int, :v)
ok 621 - Can use reduce meta-op on a uint array
ok 622 - .values from a uint array
ok 623 - .pairup from a uint array
ok 624 - .keys from a uint array
ok 625 - .pairs from a uint array
ok 626 - .antipairs from a uint array
ok 627 - .kv from a uint array
ok 628 - .pick from a uint array
ok 629 - .roll from a uint array
ok 630 - uint array.unique
ok 631 - uint array.repeated
ok 632 - uint array.squish
ok 633 - Trying to pop a shaped uint array dies
ok 634 - Trying to shift a shaped uint array dies
ok 635 - Trying to push a shaped uint array dies
ok 636 - Trying to unshift a shaped uint array dies
ok 637 - Cannot bind to a uint array
ok 638 - Cannot delete from a uint array
ok 639 - Cannot append to a uint array
ok 640 - Cannot prepend to a uint array
ok 641 - Cannot splice to a uint array
ok 642 - .Str space-separates on uint array
ok 643 - .gist space-separates on uint array
ok 644 - .raku includes type and int values on uint array
ok 645 - # SKIP STORE not working correctly yet)
ok 646 - does slice handle containerized range
ok 647 - does join a uint array
ok 648 - Can clear uint array by assigning empty list
ok 649 - does emptying a uint array reset
ok 650 - does re-initializing a uint array work
ok 651 - List-assigning uint array to untyped works (1)
ok 652 - List-assigning uint array to untyped works (2)
ok 653 - List-assigning uint array to untyped works (3)
ok 654 - List-assign uint array surrounded by literals (1)
ok 655 - List-assign uint array surrounded by literals (2)
ok 656 - List-assign uint array surrounded by literals (3)
ok 657 - List-assign uint array surrounded by literals (4)
ok 658 - List-assign uint array surrounded by literals (5)
ok 659 - List-assign untyped array of Int to uint array (1)
ok 660 - List-assign untyped array of Int to uint array (2)
ok 661 - List-assign untyped array of Int to uint array (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 662 - List-assigning incompatible untyped array to uint array dies
ok 663 - Smartmatching same uint arrays works
ok 664 - Can we sort uint array
ok 665 - Can we sort 2-element sorted uint array
ok 666 - Can we sort 1-element sorted uint array
ok 667 - uint8 array is Positional
not ok 668 - uint8 array is Positional[uint8] # TODO apparently it is not a typed Positional
# Failed test 'uint8 array is Positional[uint8]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 19
ok 669 - uint8 array .of is uint8
ok 670 - uint8 array is Positional
not ok 671 - uint8 array is Positional[uint8] # TODO apparently it is not a typed Positional
# Failed test 'uint8 array is Positional[uint8]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 25
ok 672 - uint8 array .of is uint8
ok 673 - .new from uint8 array is Positional
not ok 674 - .new from uint8 array Positional[uint8] # TODO apparently it is not a typed Positional
# Failed test '.new from uint8 array Positional[uint8]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 29
ok 675 - .new from uint8 array .of is uint8
ok 676 - New uint8 array has 5 elems
ok 677 - New uint8 array has end of -1
ok 678 - New uint8 array Int-ifies to 5
ok 679 - New uint8 array numifies to 5
ok 680 - Empty uint8 array is not lazy
ok 681 - Accessing non-existing on uint8 array dies
ok 682 - Elems do not grow just from an access on uint8 array
ok 683 - Can store integer in an uint8 array with Int index
ok 684 - Can get value from uint8 array with Int index
ok 685 - can store integer in an $t array with int index
ok 686 - Can get value from uint8 array with int index
ok 687 - Can slice-assign to an uint8 array
ok 688 - Can get slice-assigned value from uint8 array (1)
ok 689 - Can get slice-assigned value from uint8 array (2)
ok 690 - :exists works on uint8 array with int index
ok 691 - :exists works on uint8 array with Int index
ok 692 - :exists works on uint8 array when out of range
ok 693 - :!exists works on uint8 array with int index
ok 694 - :!exists works on uint8 array with Int index
ok 695 - :!exists works on uint8 array when out of range
ok 696 - :delete dies on uint8 array with int index
ok 697 - :delete dies on uint8 array with Int index
ok 698 - :!delete works on uint8 array with int index
ok 699 - :!delete works on uint8 array with Int index
ok 700 - Can call uint8 array constructor with a single value
ok 701 - Correct number of elems set in constructor of uint8 array
ok 702 - Correct element value set by constructor of uint8 array
ok 703 - Can call uint8 array constructor with values
ok 704 - Correct number of elems set in constructor of uint8 array
ok 705 - Correct elem value set by constructor of uint8 array (1)
ok 706 - Correct elem value set by constructor of uint8 array (2)
ok 707 - Correct elem value set by constructor of uint8 array (3)
ok 708 - Correct elem value set by constructor of uint8 array (4)
ok 709 - Can also get last 2 elements on uint8 array
ok 710 - uint8 array .flat returns a Seq
ok 711 - uint8 array .eager returns identity
ok 712 - Mutating for loop on uint8 array works (1)
ok 713 - Mutating for loop on uint8 array works (2)
ok 714 - Mutating for loop on uint8 array works (3)
ok 715 - Mutating for loop on uint8 array works (4)
ok 716 - Can map over uint8 array
ok 717 - Mutating map on uint8 array works (1)
ok 718 - Mutating map on uint8 array works (2)
ok 719 - Mutating map on uint8 array works (3)
ok 720 - Mutating map on uint8 array works (4)
ok 721 - grep a uint8 array
ok 722 - uint8 array.grep(Int)
ok 723 - uint8 array.grep(Int, :k)
ok 724 - uint8 array.grep(Int, :kv)
ok 725 - uint8 array.grep(Int, :p)
ok 726 - uint8 array.grep(Int, :v)
ok 727 - uint8 array.grep(Int)
ok 728 - uint8 array.grep(Int, :k)
ok 729 - uint8 array.grep(Int, :kv)
ok 730 - uint8 array.grep(Int, :p)
ok 731 - uint8 array.grep(Int, :v)
ok 732 - Can use reduce meta-op on a uint8 array
ok 733 - .values from a uint8 array
ok 734 - .pairup from a uint8 array
ok 735 - .keys from a uint8 array
ok 736 - .pairs from a uint8 array
ok 737 - .antipairs from a uint8 array
ok 738 - .kv from a uint8 array
ok 739 - .pick from a uint8 array
ok 740 - .roll from a uint8 array
ok 741 - uint8 array.unique
ok 742 - uint8 array.repeated
ok 743 - uint8 array.squish
ok 744 - Trying to pop a shaped uint8 array dies
ok 745 - Trying to shift a shaped uint8 array dies
ok 746 - Trying to push a shaped uint8 array dies
ok 747 - Trying to unshift a shaped uint8 array dies
ok 748 - Cannot bind to a uint8 array
ok 749 - Cannot delete from a uint8 array
ok 750 - Cannot append to a uint8 array
ok 751 - Cannot prepend to a uint8 array
ok 752 - Cannot splice to a uint8 array
ok 753 - .Str space-separates on uint8 array
ok 754 - .gist space-separates on uint8 array
ok 755 - .raku includes type and int values on uint8 array
ok 756 - # SKIP STORE not working correctly yet)
ok 757 - does slice handle containerized range
ok 758 - does join a uint8 array
ok 759 - Can clear uint8 array by assigning empty list
ok 760 - does emptying a uint8 array reset
ok 761 - does re-initializing a uint8 array work
ok 762 - List-assigning uint8 array to untyped works (1)
ok 763 - List-assigning uint8 array to untyped works (2)
ok 764 - List-assigning uint8 array to untyped works (3)
ok 765 - List-assign uint8 array surrounded by literals (1)
ok 766 - List-assign uint8 array surrounded by literals (2)
ok 767 - List-assign uint8 array surrounded by literals (3)
ok 768 - List-assign uint8 array surrounded by literals (4)
ok 769 - List-assign uint8 array surrounded by literals (5)
ok 770 - List-assign untyped array of Int to uint8 array (1)
ok 771 - List-assign untyped array of Int to uint8 array (2)
ok 772 - List-assign untyped array of Int to uint8 array (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 773 - List-assigning incompatible untyped array to uint8 array dies
ok 774 - Smartmatching same uint8 arrays works
ok 775 - Can we sort uint8 array
ok 776 - Can we sort 2-element sorted uint8 array
ok 777 - Can we sort 1-element sorted uint8 array
ok 778 - uint16 array is Positional
not ok 779 - uint16 array is Positional[uint16] # TODO apparently it is not a typed Positional
# Failed test 'uint16 array is Positional[uint16]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 19
ok 780 - uint16 array .of is uint16
ok 781 - uint16 array is Positional
not ok 782 - uint16 array is Positional[uint16] # TODO apparently it is not a typed Positional
# Failed test 'uint16 array is Positional[uint16]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 25
ok 783 - uint16 array .of is uint16
ok 784 - .new from uint16 array is Positional
not ok 785 - .new from uint16 array Positional[uint16] # TODO apparently it is not a typed Positional
# Failed test '.new from uint16 array Positional[uint16]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 29
ok 786 - .new from uint16 array .of is uint16
ok 787 - New uint16 array has 5 elems
ok 788 - New uint16 array has end of -1
ok 789 - New uint16 array Int-ifies to 5
ok 790 - New uint16 array numifies to 5
ok 791 - Empty uint16 array is not lazy
ok 792 - Accessing non-existing on uint16 array dies
ok 793 - Elems do not grow just from an access on uint16 array
ok 794 - Can store integer in an uint16 array with Int index
ok 795 - Can get value from uint16 array with Int index
ok 796 - can store integer in an $t array with int index
ok 797 - Can get value from uint16 array with int index
ok 798 - Can slice-assign to an uint16 array
ok 799 - Can get slice-assigned value from uint16 array (1)
ok 800 - Can get slice-assigned value from uint16 array (2)
ok 801 - :exists works on uint16 array with int index
ok 802 - :exists works on uint16 array with Int index
ok 803 - :exists works on uint16 array when out of range
ok 804 - :!exists works on uint16 array with int index
ok 805 - :!exists works on uint16 array with Int index
ok 806 - :!exists works on uint16 array when out of range
ok 807 - :delete dies on uint16 array with int index
ok 808 - :delete dies on uint16 array with Int index
ok 809 - :!delete works on uint16 array with int index
ok 810 - :!delete works on uint16 array with Int index
ok 811 - Can call uint16 array constructor with a single value
ok 812 - Correct number of elems set in constructor of uint16 array
ok 813 - Correct element value set by constructor of uint16 array
ok 814 - Can call uint16 array constructor with values
ok 815 - Correct number of elems set in constructor of uint16 array
ok 816 - Correct elem value set by constructor of uint16 array (1)
ok 817 - Correct elem value set by constructor of uint16 array (2)
ok 818 - Correct elem value set by constructor of uint16 array (3)
ok 819 - Correct elem value set by constructor of uint16 array (4)
ok 820 - Can also get last 2 elements on uint16 array
ok 821 - uint16 array .flat returns a Seq
ok 822 - uint16 array .eager returns identity
ok 823 - Mutating for loop on uint16 array works (1)
ok 824 - Mutating for loop on uint16 array works (2)
ok 825 - Mutating for loop on uint16 array works (3)
ok 826 - Mutating for loop on uint16 array works (4)
ok 827 - Can map over uint16 array
ok 828 - Mutating map on uint16 array works (1)
ok 829 - Mutating map on uint16 array works (2)
ok 830 - Mutating map on uint16 array works (3)
ok 831 - Mutating map on uint16 array works (4)
ok 832 - grep a uint16 array
ok 833 - uint16 array.grep(Int)
ok 834 - uint16 array.grep(Int, :k)
ok 835 - uint16 array.grep(Int, :kv)
ok 836 - uint16 array.grep(Int, :p)
ok 837 - uint16 array.grep(Int, :v)
ok 838 - uint16 array.grep(Int)
ok 839 - uint16 array.grep(Int, :k)
ok 840 - uint16 array.grep(Int, :kv)
ok 841 - uint16 array.grep(Int, :p)
ok 842 - uint16 array.grep(Int, :v)
ok 843 - Can use reduce meta-op on a uint16 array
ok 844 - .values from a uint16 array
ok 845 - .pairup from a uint16 array
ok 846 - .keys from a uint16 array
ok 847 - .pairs from a uint16 array
ok 848 - .antipairs from a uint16 array
ok 849 - .kv from a uint16 array
ok 850 - .pick from a uint16 array
ok 851 - .roll from a uint16 array
ok 852 - uint16 array.unique
ok 853 - uint16 array.repeated
ok 854 - uint16 array.squish
ok 855 - Trying to pop a shaped uint16 array dies
ok 856 - Trying to shift a shaped uint16 array dies
ok 857 - Trying to push a shaped uint16 array dies
ok 858 - Trying to unshift a shaped uint16 array dies
ok 859 - Cannot bind to a uint16 array
ok 860 - Cannot delete from a uint16 array
ok 861 - Cannot append to a uint16 array
ok 862 - Cannot prepend to a uint16 array
ok 863 - Cannot splice to a uint16 array
ok 864 - .Str space-separates on uint16 array
ok 865 - .gist space-separates on uint16 array
ok 866 - .raku includes type and int values on uint16 array
ok 867 - # SKIP STORE not working correctly yet)
ok 868 - does slice handle containerized range
ok 869 - does join a uint16 array
ok 870 - Can clear uint16 array by assigning empty list
ok 871 - does emptying a uint16 array reset
ok 872 - does re-initializing a uint16 array work
ok 873 - List-assigning uint16 array to untyped works (1)
ok 874 - List-assigning uint16 array to untyped works (2)
ok 875 - List-assigning uint16 array to untyped works (3)
ok 876 - List-assign uint16 array surrounded by literals (1)
ok 877 - List-assign uint16 array surrounded by literals (2)
ok 878 - List-assign uint16 array surrounded by literals (3)
ok 879 - List-assign uint16 array surrounded by literals (4)
ok 880 - List-assign uint16 array surrounded by literals (5)
ok 881 - List-assign untyped array of Int to uint16 array (1)
ok 882 - List-assign untyped array of Int to uint16 array (2)
ok 883 - List-assign untyped array of Int to uint16 array (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 884 - List-assigning incompatible untyped array to uint16 array dies
ok 885 - Smartmatching same uint16 arrays works
ok 886 - Can we sort uint16 array
ok 887 - Can we sort 2-element sorted uint16 array
ok 888 - Can we sort 1-element sorted uint16 array
ok 889 - uint32 array is Positional
not ok 890 - uint32 array is Positional[uint32] # TODO apparently it is not a typed Positional
# Failed test 'uint32 array is Positional[uint32]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 19
ok 891 - uint32 array .of is uint32
ok 892 - uint32 array is Positional
not ok 893 - uint32 array is Positional[uint32] # TODO apparently it is not a typed Positional
# Failed test 'uint32 array is Positional[uint32]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 25
ok 894 - uint32 array .of is uint32
ok 895 - .new from uint32 array is Positional
not ok 896 - .new from uint32 array Positional[uint32] # TODO apparently it is not a typed Positional
# Failed test '.new from uint32 array Positional[uint32]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 29
ok 897 - .new from uint32 array .of is uint32
ok 898 - New uint32 array has 5 elems
ok 899 - New uint32 array has end of -1
ok 900 - New uint32 array Int-ifies to 5
ok 901 - New uint32 array numifies to 5
ok 902 - Empty uint32 array is not lazy
ok 903 - Accessing non-existing on uint32 array dies
ok 904 - Elems do not grow just from an access on uint32 array
ok 905 - Can store integer in an uint32 array with Int index
ok 906 - Can get value from uint32 array with Int index
ok 907 - can store integer in an $t array with int index
ok 908 - Can get value from uint32 array with int index
ok 909 - Can slice-assign to an uint32 array
ok 910 - Can get slice-assigned value from uint32 array (1)
ok 911 - Can get slice-assigned value from uint32 array (2)
ok 912 - :exists works on uint32 array with int index
ok 913 - :exists works on uint32 array with Int index
ok 914 - :exists works on uint32 array when out of range
ok 915 - :!exists works on uint32 array with int index
ok 916 - :!exists works on uint32 array with Int index
ok 917 - :!exists works on uint32 array when out of range
ok 918 - :delete dies on uint32 array with int index
ok 919 - :delete dies on uint32 array with Int index
ok 920 - :!delete works on uint32 array with int index
ok 921 - :!delete works on uint32 array with Int index
ok 922 - Can call uint32 array constructor with a single value
ok 923 - Correct number of elems set in constructor of uint32 array
ok 924 - Correct element value set by constructor of uint32 array
ok 925 - Can call uint32 array constructor with values
ok 926 - Correct number of elems set in constructor of uint32 array
ok 927 - Correct elem value set by constructor of uint32 array (1)
ok 928 - Correct elem value set by constructor of uint32 array (2)
ok 929 - Correct elem value set by constructor of uint32 array (3)
ok 930 - Correct elem value set by constructor of uint32 array (4)
ok 931 - Can also get last 2 elements on uint32 array
ok 932 - uint32 array .flat returns a Seq
ok 933 - uint32 array .eager returns identity
ok 934 - Mutating for loop on uint32 array works (1)
ok 935 - Mutating for loop on uint32 array works (2)
ok 936 - Mutating for loop on uint32 array works (3)
ok 937 - Mutating for loop on uint32 array works (4)
ok 938 - Can map over uint32 array
ok 939 - Mutating map on uint32 array works (1)
ok 940 - Mutating map on uint32 array works (2)
ok 941 - Mutating map on uint32 array works (3)
ok 942 - Mutating map on uint32 array works (4)
ok 943 - grep a uint32 array
ok 944 - uint32 array.grep(Int)
ok 945 - uint32 array.grep(Int, :k)
ok 946 - uint32 array.grep(Int, :kv)
ok 947 - uint32 array.grep(Int, :p)
ok 948 - uint32 array.grep(Int, :v)
ok 949 - uint32 array.grep(Int)
ok 950 - uint32 array.grep(Int, :k)
ok 951 - uint32 array.grep(Int, :kv)
ok 952 - uint32 array.grep(Int, :p)
ok 953 - uint32 array.grep(Int, :v)
ok 954 - Can use reduce meta-op on a uint32 array
ok 955 - .values from a uint32 array
ok 956 - .pairup from a uint32 array
ok 957 - .keys from a uint32 array
ok 958 - .pairs from a uint32 array
ok 959 - .antipairs from a uint32 array
ok 960 - .kv from a uint32 array
ok 961 - .pick from a uint32 array
ok 962 - .roll from a uint32 array
ok 963 - uint32 array.unique
ok 964 - uint32 array.repeated
ok 965 - uint32 array.squish
ok 966 - Trying to pop a shaped uint32 array dies
ok 967 - Trying to shift a shaped uint32 array dies
ok 968 - Trying to push a shaped uint32 array dies
ok 969 - Trying to unshift a shaped uint32 array dies
ok 970 - Cannot bind to a uint32 array
ok 971 - Cannot delete from a uint32 array
ok 972 - Cannot append to a uint32 array
ok 973 - Cannot prepend to a uint32 array
ok 974 - Cannot splice to a uint32 array
ok 975 - .Str space-separates on uint32 array
ok 976 - .gist space-separates on uint32 array
ok 977 - .raku includes type and int values on uint32 array
ok 978 - # SKIP STORE not working correctly yet)
ok 979 - does slice handle containerized range
ok 980 - does join a uint32 array
ok 981 - Can clear uint32 array by assigning empty list
ok 982 - does emptying a uint32 array reset
ok 983 - does re-initializing a uint32 array work
ok 984 - List-assigning uint32 array to untyped works (1)
ok 985 - List-assigning uint32 array to untyped works (2)
ok 986 - List-assigning uint32 array to untyped works (3)
ok 987 - List-assign uint32 array surrounded by literals (1)
ok 988 - List-assign uint32 array surrounded by literals (2)
ok 989 - List-assign uint32 array surrounded by literals (3)
ok 990 - List-assign uint32 array surrounded by literals (4)
ok 991 - List-assign uint32 array surrounded by literals (5)
ok 992 - List-assign untyped array of Int to uint32 array (1)
ok 993 - List-assign untyped array of Int to uint32 array (2)
ok 994 - List-assign untyped array of Int to uint32 array (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 995 - List-assigning incompatible untyped array to uint32 array dies
ok 996 - Smartmatching same uint32 arrays works
ok 997 - Can we sort uint32 array
ok 998 - Can we sort 2-element sorted uint32 array
ok 999 - Can we sort 1-element sorted uint32 array
ok 1000 - uint64 array is Positional
not ok 1001 - uint64 array is Positional[uint64] # TODO apparently it is not a typed Positional
# Failed test 'uint64 array is Positional[uint64]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 19
ok 1002 - uint64 array .of is uint64
ok 1003 - uint64 array is Positional
not ok 1004 - uint64 array is Positional[uint64] # TODO apparently it is not a typed Positional
# Failed test 'uint64 array is Positional[uint64]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 25
ok 1005 - uint64 array .of is uint64
ok 1006 - .new from uint64 array is Positional
not ok 1007 - .new from uint64 array Positional[uint64] # TODO apparently it is not a typed Positional
# Failed test '.new from uint64 array Positional[uint64]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 29
ok 1008 - .new from uint64 array .of is uint64
ok 1009 - New uint64 array has 5 elems
ok 1010 - New uint64 array has end of -1
ok 1011 - New uint64 array Int-ifies to 5
ok 1012 - New uint64 array numifies to 5
ok 1013 - Empty uint64 array is not lazy
ok 1014 - Accessing non-existing on uint64 array dies
ok 1015 - Elems do not grow just from an access on uint64 array
ok 1016 - Can store integer in an uint64 array with Int index
ok 1017 - Can get value from uint64 array with Int index
ok 1018 - can store integer in an $t array with int index
ok 1019 - Can get value from uint64 array with int index
ok 1020 - Can slice-assign to an uint64 array
ok 1021 - Can get slice-assigned value from uint64 array (1)
ok 1022 - Can get slice-assigned value from uint64 array (2)
ok 1023 - :exists works on uint64 array with int index
ok 1024 - :exists works on uint64 array with Int index
ok 1025 - :exists works on uint64 array when out of range
ok 1026 - :!exists works on uint64 array with int index
ok 1027 - :!exists works on uint64 array with Int index
ok 1028 - :!exists works on uint64 array when out of range
ok 1029 - :delete dies on uint64 array with int index
ok 1030 - :delete dies on uint64 array with Int index
ok 1031 - :!delete works on uint64 array with int index
ok 1032 - :!delete works on uint64 array with Int index
ok 1033 - Can call uint64 array constructor with a single value
ok 1034 - Correct number of elems set in constructor of uint64 array
ok 1035 - Correct element value set by constructor of uint64 array
ok 1036 - Can call uint64 array constructor with values
ok 1037 - Correct number of elems set in constructor of uint64 array
ok 1038 - Correct elem value set by constructor of uint64 array (1)
ok 1039 - Correct elem value set by constructor of uint64 array (2)
ok 1040 - Correct elem value set by constructor of uint64 array (3)
ok 1041 - Correct elem value set by constructor of uint64 array (4)
ok 1042 - Can also get last 2 elements on uint64 array
ok 1043 - uint64 array .flat returns a Seq
ok 1044 - uint64 array .eager returns identity
ok 1045 - Mutating for loop on uint64 array works (1)
ok 1046 - Mutating for loop on uint64 array works (2)
ok 1047 - Mutating for loop on uint64 array works (3)
ok 1048 - Mutating for loop on uint64 array works (4)
ok 1049 - Can map over uint64 array
ok 1050 - Mutating map on uint64 array works (1)
ok 1051 - Mutating map on uint64 array works (2)
ok 1052 - Mutating map on uint64 array works (3)
ok 1053 - Mutating map on uint64 array works (4)
ok 1054 - grep a uint64 array
ok 1055 - uint64 array.grep(Int)
ok 1056 - uint64 array.grep(Int, :k)
ok 1057 - uint64 array.grep(Int, :kv)
ok 1058 - uint64 array.grep(Int, :p)
ok 1059 - uint64 array.grep(Int, :v)
ok 1060 - uint64 array.grep(Int)
ok 1061 - uint64 array.grep(Int, :k)
ok 1062 - uint64 array.grep(Int, :kv)
ok 1063 - uint64 array.grep(Int, :p)
ok 1064 - uint64 array.grep(Int, :v)
ok 1065 - Can use reduce meta-op on a uint64 array
ok 1066 - .values from a uint64 array
ok 1067 - .pairup from a uint64 array
ok 1068 - .keys from a uint64 array
ok 1069 - .pairs from a uint64 array
ok 1070 - .antipairs from a uint64 array
ok 1071 - .kv from a uint64 array
ok 1072 - .pick from a uint64 array
ok 1073 - .roll from a uint64 array
ok 1074 - uint64 array.unique
ok 1075 - uint64 array.repeated
ok 1076 - uint64 array.squish
ok 1077 - Trying to pop a shaped uint64 array dies
ok 1078 - Trying to shift a shaped uint64 array dies
ok 1079 - Trying to push a shaped uint64 array dies
ok 1080 - Trying to unshift a shaped uint64 array dies
ok 1081 - Cannot bind to a uint64 array
ok 1082 - Cannot delete from a uint64 array
ok 1083 - Cannot append to a uint64 array
ok 1084 - Cannot prepend to a uint64 array
ok 1085 - Cannot splice to a uint64 array
ok 1086 - .Str space-separates on uint64 array
ok 1087 - .gist space-separates on uint64 array
ok 1088 - .raku includes type and int values on uint64 array
ok 1089 - # SKIP STORE not working correctly yet)
ok 1090 - does slice handle containerized range
ok 1091 - does join a uint64 array
ok 1092 - Can clear uint64 array by assigning empty list
ok 1093 - does emptying a uint64 array reset
ok 1094 - does re-initializing a uint64 array work
ok 1095 - List-assigning uint64 array to untyped works (1)
ok 1096 - List-assigning uint64 array to untyped works (2)
ok 1097 - List-assigning uint64 array to untyped works (3)
ok 1098 - List-assign uint64 array surrounded by literals (1)
ok 1099 - List-assign uint64 array surrounded by literals (2)
ok 1100 - List-assign uint64 array surrounded by literals (3)
ok 1101 - List-assign uint64 array surrounded by literals (4)
ok 1102 - List-assign uint64 array surrounded by literals (5)
ok 1103 - List-assign untyped array of Int to uint64 array (1)
ok 1104 - List-assign untyped array of Int to uint64 array (2)
ok 1105 - List-assign untyped array of Int to uint64 array (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 1106 - List-assigning incompatible untyped array to uint64 array dies
ok 1107 - Smartmatching same uint64 arrays works
ok 1108 - Can we sort uint64 array
ok 1109 - Can we sort 2-element sorted uint64 array
ok 1110 - Can we sort 1-element sorted uint64 array
# FUDGED!
1..333
ok 1 - num array is Positional
not ok 2 - num array is Positional[num] # TODO apparently it is not a typed Positional
# Failed test 'num array is Positional[num]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-num.rakudo line 17
ok 3 - num array .of is num
ok 4 - num array is Positional
not ok 5 - num array is Positional[num] # TODO apparently it is not a typed Positional
# Failed test 'num array is Positional[num]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-num.rakudo line 23
ok 6 - num array .of is num
ok 7 - .new from num array is Positional
not ok 8 - .new from num array Positional[num] # TODO apparently it is not a typed Positional
# Failed test '.new from num array Positional[num]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-num.rakudo line 27
ok 9 - .new from num array .of is num
ok 10 - New num array has 5 elems
ok 11 - New num array has end of -1
ok 12 - New num array Int-ifies to 5
ok 13 - New num array numifies to 5
ok 14 - Empty num array is not lazy
ok 15 - Accessing non-existing on num array dies
ok 16 - Elems do not grow just from an access on num array
ok 17 - Can store num in an num array with Int index
ok 18 - Can get value from num array with Int index
ok 19 - can store num in an $t array with int index
ok 20 - Can get value from num array with int index
ok 21 - Can slice-assign to num array
ok 22 - Can get slice-assigned value from num array (1)
ok 23 - Can get slice-assigned value from num array (2)
ok 24 - :exists works on num array with int index
ok 25 - :exists works on num array with Int index
ok 26 - :exists works on num array when out of range
ok 27 - :!exists works on num array with int index
ok 28 - :!exists works on num array with Int index
ok 29 - :!exists works on num array when out of range
ok 30 - :delete dies on num array with int index
ok 31 - :delete dies on num array with Int index
ok 32 - :!delete works on num array with int index
ok 33 - :!delete works on num array with Int index
ok 34 - Can call num array constructor with a single value
ok 35 - Correct number of elems set in constructor of num array
ok 36 - Correct element value set by constructor of num array
ok 37 - Can call num array constructor with values
ok 38 - Correct number of elems set in constructor of num array
ok 39 - Correct elem value set by constructor of num array (1)
ok 40 - Correct elem value set by constructor of num array (2)
ok 41 - Correct elem value set by constructor of num array (3)
ok 42 - Correct elem value set by constructor of num array (4)
ok 43 - Can also get last 2 elements on num array
ok 44 - num array .flat returns a Seq
ok 45 - num array .eager returns identity
ok 46 - Mutating for loop on num array works (1)
ok 47 - Mutating for loop on num array works (2)
ok 48 - Mutating for loop on num array works (3)
ok 49 - Mutating for loop on num array works (4)
ok 50 - Can map over num array
ok 51 - Mutating map on num array works (1)
ok 52 - Mutating map on num array works (2)
ok 53 - Mutating map on num array works (3)
ok 54 - Mutating map on num array works (4)
ok 55 - grep a num array
ok 56 - num array.grep(Num)
ok 57 - num array.grep(Num, :k)
ok 58 - num array.grep(Num, :kv)
ok 59 - num array.grep(Num, :p)
ok 60 - num array.grep(Num, :v)
ok 61 - num array.grep(Num)
ok 62 - num array.grep(Num, :k)
ok 63 - num array.grep(Num, :kv)
ok 64 - num array.grep(Num, :p)
ok 65 - num array.grep(Num, :v)
ok 66 - Can use reduce meta-op on a num array
ok 67 - .values from a num array
ok 68 - .pairup from a num array
ok 69 - .keys from a num array
ok 70 - .pairs from a num array
ok 71 - .antipairs from a num array
ok 72 - .kv from a num array
ok 73 - .pick from a num array
ok 74 - .roll from a num array
ok 75 - num array.unique
ok 76 - num array.repeated
ok 77 - num array.squish
ok 78 - Trying to pop a shaped num array dies
ok 79 - Trying to shift a shaped num array dies
ok 80 - Trying to push a shaped num array dies
ok 81 - Trying to unshift a shaped num array dies
ok 82 - Cannot bind to a num array
ok 83 - Cannot delete from a num array
ok 84 - Cannot append to a num array
ok 85 - Cannot prepend to a num array
ok 86 - Cannot splice to a num array
ok 87 - .Str space-separates on num array
ok 88 - .gist space-separates on num array
ok 89 - .raku includes type and num values on num array
ok 90 - # SKIP STORE not working correctly yet)
ok 91 - does slice handle containerized range
ok 92 - does join a num array
ok 93 - Can clear num array by assigning empty list
ok 94 - does emptying a num array reset
ok 95 - does re-initializing a num array work
ok 96 - List-assigning num array to untyped works (1)
ok 97 - List-assigning num array to untyped works (2)
ok 98 - List-assigning num array to untyped works (3)
ok 99 - List-assign num array surrounded by literals (1)
ok 100 - List-assign num array surrounded by literals (2)
ok 101 - List-assign num array surrounded by literals (3)
ok 102 - List-assign num array surrounded by literals (4)
ok 103 - List-assign num array surrounded by literals (5)
ok 104 - List-assign untyped array of Num to num array (1)
ok 105 - List-assign untyped array of Num to num array (2)
ok 106 - List-assign untyped array of Num to num array (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 107 - List-assigning incompatible untyped array to num array dies
ok 108 - Smartmatching same num arrays works
ok 109 - Can we sort num array
ok 110 - Can we sort 2-element sorted num array
ok 111 - Can we sort 1-element sorted num array
ok 112 - num32 array is Positional
not ok 113 - num32 array is Positional[num32] # TODO apparently it is not a typed Positional
# Failed test 'num32 array is Positional[num32]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-num.rakudo line 17
ok 114 - num32 array .of is num32
ok 115 - num32 array is Positional
not ok 116 - num32 array is Positional[num32] # TODO apparently it is not a typed Positional
# Failed test 'num32 array is Positional[num32]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-num.rakudo line 23
ok 117 - num32 array .of is num32
ok 118 - .new from num32 array is Positional
not ok 119 - .new from num32 array Positional[num32] # TODO apparently it is not a typed Positional
# Failed test '.new from num32 array Positional[num32]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-num.rakudo line 27
ok 120 - .new from num32 array .of is num32
ok 121 - New num32 array has 5 elems
ok 122 - New num32 array has end of -1
ok 123 - New num32 array Int-ifies to 5
ok 124 - New num32 array numifies to 5
ok 125 - Empty num32 array is not lazy
ok 126 - Accessing non-existing on num32 array dies
ok 127 - Elems do not grow just from an access on num32 array
ok 128 - Can store num in an num32 array with Int index
ok 129 - Can get value from num32 array with Int index
ok 130 - can store num in an $t array with int index
ok 131 - Can get value from num32 array with int index
ok 132 - Can slice-assign to num32 array
ok 133 - Can get slice-assigned value from num32 array (1)
ok 134 - Can get slice-assigned value from num32 array (2)
ok 135 - :exists works on num32 array with int index
ok 136 - :exists works on num32 array with Int index
ok 137 - :exists works on num32 array when out of range
ok 138 - :!exists works on num32 array with int index
ok 139 - :!exists works on num32 array with Int index
ok 140 - :!exists works on num32 array when out of range
ok 141 - :delete dies on num32 array with int index
ok 142 - :delete dies on num32 array with Int index
ok 143 - :!delete works on num32 array with int index
ok 144 - :!delete works on num32 array with Int index
ok 145 - Can call num32 array constructor with a single value
ok 146 - Correct number of elems set in constructor of num32 array
ok 147 - Correct element value set by constructor of num32 array
ok 148 - Can call num32 array constructor with values
ok 149 - Correct number of elems set in constructor of num32 array
ok 150 - Correct elem value set by constructor of num32 array (1)
ok 151 - Correct elem value set by constructor of num32 array (2)
ok 152 - Correct elem value set by constructor of num32 array (3)
ok 153 - Correct elem value set by constructor of num32 array (4)
ok 154 - Can also get last 2 elements on num32 array
ok 155 - num32 array .flat returns a Seq
ok 156 - num32 array .eager returns identity
ok 157 - Mutating for loop on num32 array works (1)
ok 158 - Mutating for loop on num32 array works (2)
ok 159 - Mutating for loop on num32 array works (3)
ok 160 - Mutating for loop on num32 array works (4)
ok 161 - Can map over num32 array
ok 162 - Mutating map on num32 array works (1)
ok 163 - Mutating map on num32 array works (2)
ok 164 - Mutating map on num32 array works (3)
ok 165 - Mutating map on num32 array works (4)
ok 166 - grep a num32 array
ok 167 - num32 array.grep(Num)
ok 168 - num32 array.grep(Num, :k)
ok 169 - num32 array.grep(Num, :kv)
ok 170 - num32 array.grep(Num, :p)
ok 171 - num32 array.grep(Num, :v)
ok 172 - num32 array.grep(Num)
ok 173 - num32 array.grep(Num, :k)
ok 174 - num32 array.grep(Num, :kv)
ok 175 - num32 array.grep(Num, :p)
ok 176 - num32 array.grep(Num, :v)
ok 177 - Can use reduce meta-op on a num32 array
ok 178 - .values from a num32 array
ok 179 - .pairup from a num32 array
ok 180 - .keys from a num32 array
ok 181 - .pairs from a num32 array
ok 182 - .antipairs from a num32 array
ok 183 - .kv from a num32 array
ok 184 - .pick from a num32 array
ok 185 - .roll from a num32 array
ok 186 - num32 array.unique
ok 187 - num32 array.repeated
ok 188 - num32 array.squish
ok 189 - Trying to pop a shaped num32 array dies
ok 190 - Trying to shift a shaped num32 array dies
ok 191 - Trying to push a shaped num32 array dies
ok 192 - Trying to unshift a shaped num32 array dies
ok 193 - Cannot bind to a num32 array
ok 194 - Cannot delete from a num32 array
ok 195 - Cannot append to a num32 array
ok 196 - Cannot prepend to a num32 array
ok 197 - Cannot splice to a num32 array
ok 198 - .Str space-separates on num32 array
ok 199 - .gist space-separates on num32 array
ok 200 - .raku includes type and num values on num32 array
ok 201 - # SKIP STORE not working correctly yet)
ok 202 - does slice handle containerized range
ok 203 - does join a num32 array
ok 204 - Can clear num32 array by assigning empty list
ok 205 - does emptying a num32 array reset
ok 206 - does re-initializing a num32 array work
ok 207 - List-assigning num32 array to untyped works (1)
ok 208 - List-assigning num32 array to untyped works (2)
ok 209 - List-assigning num32 array to untyped works (3)
ok 210 - List-assign num32 array surrounded by literals (1)
ok 211 - List-assign num32 array surrounded by literals (2)
ok 212 - List-assign num32 array surrounded by literals (3)
ok 213 - List-assign num32 array surrounded by literals (4)
ok 214 - List-assign num32 array surrounded by literals (5)
ok 215 - List-assign untyped array of Num to num32 array (1)
ok 216 - List-assign untyped array of Num to num32 array (2)
ok 217 - List-assign untyped array of Num to num32 array (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 218 - List-assigning incompatible untyped array to num32 array dies
ok 219 - Smartmatching same num32 arrays works
ok 220 - Can we sort num32 array
ok 221 - Can we sort 2-element sorted num32 array
ok 222 - Can we sort 1-element sorted num32 array
ok 223 - num64 array is Positional
not ok 224 - num64 array is Positional[num64] # TODO apparently it is not a typed Positional
# Failed test 'num64 array is Positional[num64]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-num.rakudo line 17
ok 225 - num64 array .of is num64
ok 226 - num64 array is Positional
not ok 227 - num64 array is Positional[num64] # TODO apparently it is not a typed Positional
# Failed test 'num64 array is Positional[num64]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-num.rakudo line 23
ok 228 - num64 array .of is num64
ok 229 - .new from num64 array is Positional
not ok 230 - .new from num64 array Positional[num64] # TODO apparently it is not a typed Positional
# Failed test '.new from num64 array Positional[num64]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-num.rakudo line 27
ok 231 - .new from num64 array .of is num64
ok 232 - New num64 array has 5 elems
ok 233 - New num64 array has end of -1
ok 234 - New num64 array Int-ifies to 5
ok 235 - New num64 array numifies to 5
ok 236 - Empty num64 array is not lazy
ok 237 - Accessing non-existing on num64 array dies
ok 238 - Elems do not grow just from an access on num64 array
ok 239 - Can store num in an num64 array with Int index
ok 240 - Can get value from num64 array with Int index
ok 241 - can store num in an $t array with int index
ok 242 - Can get value from num64 array with int index
ok 243 - Can slice-assign to num64 array
ok 244 - Can get slice-assigned value from num64 array (1)
ok 245 - Can get slice-assigned value from num64 array (2)
ok 246 - :exists works on num64 array with int index
ok 247 - :exists works on num64 array with Int index
ok 248 - :exists works on num64 array when out of range
ok 249 - :!exists works on num64 array with int index
ok 250 - :!exists works on num64 array with Int index
ok 251 - :!exists works on num64 array when out of range
ok 252 - :delete dies on num64 array with int index
ok 253 - :delete dies on num64 array with Int index
ok 254 - :!delete works on num64 array with int index
ok 255 - :!delete works on num64 array with Int index
ok 256 - Can call num64 array constructor with a single value
ok 257 - Correct number of elems set in constructor of num64 array
ok 258 - Correct element value set by constructor of num64 array
ok 259 - Can call num64 array constructor with values
ok 260 - Correct number of elems set in constructor of num64 array
ok 261 - Correct elem value set by constructor of num64 array (1)
ok 262 - Correct elem value set by constructor of num64 array (2)
ok 263 - Correct elem value set by constructor of num64 array (3)
ok 264 - Correct elem value set by constructor of num64 array (4)
ok 265 - Can also get last 2 elements on num64 array
ok 266 - num64 array .flat returns a Seq
ok 267 - num64 array .eager returns identity
ok 268 - Mutating for loop on num64 array works (1)
ok 269 - Mutating for loop on num64 array works (2)
ok 270 - Mutating for loop on num64 array works (3)
ok 271 - Mutating for loop on num64 array works (4)
ok 272 - Can map over num64 array
ok 273 - Mutating map on num64 array works (1)
ok 274 - Mutating map on num64 array works (2)
ok 275 - Mutating map on num64 array works (3)
ok 276 - Mutating map on num64 array works (4)
ok 277 - grep a num64 array
ok 278 - num64 array.grep(Num)
ok 279 - num64 array.grep(Num, :k)
ok 280 - num64 array.grep(Num, :kv)
ok 281 - num64 array.grep(Num, :p)
ok 282 - num64 array.grep(Num, :v)
ok 283 - num64 array.grep(Num)
ok 284 - num64 array.grep(Num, :k)
ok 285 - num64 array.grep(Num, :kv)
ok 286 - num64 array.grep(Num, :p)
ok 287 - num64 array.grep(Num, :v)
ok 288 - Can use reduce meta-op on a num64 array
ok 289 - .values from a num64 array
ok 290 - .pairup from a num64 array
ok 291 - .keys from a num64 array
ok 292 - .pairs from a num64 array
ok 293 - .antipairs from a num64 array
ok 294 - .kv from a num64 array
ok 295 - .pick from a num64 array
ok 296 - .roll from a num64 array
ok 297 - num64 array.unique
ok 298 - num64 array.repeated
ok 299 - num64 array.squish
ok 300 - Trying to pop a shaped num64 array dies
ok 301 - Trying to shift a shaped num64 array dies
ok 302 - Trying to push a shaped num64 array dies
ok 303 - Trying to unshift a shaped num64 array dies
ok 304 - Cannot bind to a num64 array
ok 305 - Cannot delete from a num64 array
ok 306 - Cannot append to a num64 array
ok 307 - Cannot prepend to a num64 array
ok 308 - Cannot splice to a num64 array
ok 309 - .Str space-separates on num64 array
ok 310 - .gist space-separates on num64 array
ok 311 - .raku includes type and num values on num64 array
ok 312 - # SKIP STORE not working correctly yet)
ok 313 - does slice handle containerized range
ok 314 - does join a num64 array
ok 315 - Can clear num64 array by assigning empty list
ok 316 - does emptying a num64 array reset
ok 317 - does re-initializing a num64 array work
ok 318 - List-assigning num64 array to untyped works (1)
ok 319 - List-assigning num64 array to untyped works (2)
ok 320 - List-assigning num64 array to untyped works (3)
ok 321 - List-assign num64 array surrounded by literals (1)
ok 322 - List-assign num64 array surrounded by literals (2)
ok 323 - List-assign num64 array surrounded by literals (3)
ok 324 - List-assign num64 array surrounded by literals (4)
ok 325 - List-assign num64 array surrounded by literals (5)
ok 326 - List-assign untyped array of Num to num64 array (1)
ok 327 - List-assign untyped array of Num to num64 array (2)
ok 328 - List-assign untyped array of Num to num64 array (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 329 - List-assigning incompatible untyped array to num64 array dies
ok 330 - Smartmatching same num64 arrays works
ok 331 - Can we sort num64 array
ok 332 - Can we sort 2-element sorted num64 array
ok 333 - Can we sort 1-element sorted num64 array
# FUDGED!
1..111
ok 1 - str array is Positional
not ok 2 - str array is Positional[str] # TODO apparently it is not a typed Positional
# Failed test 'str array is Positional[str]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-str.rakudo line 12
ok 3 - str array .of is str
ok 4 - str array is Positional
not ok 5 - str array is Positional[str] # TODO apparently it is not a typed Positional
# Failed test 'str array is Positional[str]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-str.rakudo line 18
ok 6 - str array .of is str
ok 7 - .new from str array is Positional
not ok 8 - .new from str array Positional[str] # TODO apparently it is not a typed Positional
# Failed test '.new from str array Positional[str]'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-str.rakudo line 22
ok 9 - .new from str array .of is str
ok 10 - New str array has 5 elems
ok 11 - New str array has end of -1
ok 12 - New str array Int-ifies to 5
ok 13 - New str array numifies to 5
ok 14 - Empty str array is not lazy
ok 15 - Accessing non-existing on str array dies
ok 16 - Elems do not grow just from an access on str array
ok 17 - Can store string in an str array with Int index
ok 18 - Can get value from str array with Int index
ok 19 - can store string in an $t array with int index
ok 20 - Can get value from str array with int index
ok 21 - Can slice-assign to an str array
ok 22 - Can get slice-assigned value from str array (1)
ok 23 - Can get slice-assigned value from str array (2)
ok 24 - :exists works on str array with int index
ok 25 - :exists works on str array with Int index
ok 26 - :exists works on str array when out of range
ok 27 - :!exists works on str array with int index
ok 28 - :!exists works on str array with Int index
ok 29 - :!exists works on str array when out of range
ok 30 - :delete dies on str array with int index
ok 31 - :delete dies on str array with Int index
ok 32 - :!delete works on str array with int index
ok 33 - :!delete works on str array with Int index
ok 34 - Can call str array constructor with a single value
ok 35 - Correct number of elems set in constructor of str array
ok 36 - Correct element value set by constructor of str array
ok 37 - Can call str array constructor with values
ok 38 - Correct number of elems set in constructor of str array
ok 39 - Correct elem value set by constructor of str array (1)
ok 40 - Correct elem value set by constructor of str array (2)
ok 41 - Correct elem value set by constructor of str array (3)
ok 42 - Correct elem value set by constructor of str array (4)
ok 43 - Can also get last 2 elements on str array
ok 44 - str array .flat returns a Seq
ok 45 - str array .eager returns identity
ok 46 - Mutating for loop on str array works (1)
ok 47 - Mutating for loop on str array works (2)
ok 48 - Mutating for loop on str array works (3)
ok 49 - Mutating for loop on str array works (4)
ok 50 - Can map over str array
ok 51 - Mutating map on str array works (1)
ok 52 - Mutating map on str array works (2)
ok 53 - Mutating map on str array works (3)
ok 54 - Mutating map on str array works (4)
ok 55 - grep a str array
ok 56 - str array.grep(Str)
ok 57 - str array.grep(Str, :k)
ok 58 - str array.grep(Str, :kv)
ok 59 - str array.grep(Str, :p)
ok 60 - str array.grep(Str, :v)
ok 61 - str array.grep(Str)
ok 62 - str array.grep(Str, :k)
ok 63 - str array.grep(Str, :kv)
ok 64 - str array.grep(Str, :p)
ok 65 - str array.grep(Str, :v)
ok 66 - Can use reduce meta-op on a str array
ok 67 - .values from a str array
ok 68 - .pairup from a str array
ok 69 - .keys from a str array
ok 70 - .pairs from a str array
ok 71 - .antipairs from a str array
ok 72 - .kv from a str array
ok 73 - .pick from a str array
ok 74 - .roll from a str array
ok 75 - str array.unique
ok 76 - str array.repeated
ok 77 - str array.squish
ok 78 - Trying to pop a shaped str array dies
ok 79 - Trying to shift a shaped str array dies
ok 80 - Trying to push a shaped str array dies
ok 81 - Trying to unshift a shaped str array dies
ok 82 - Cannot bind to a str array
ok 83 - Cannot delete from a str array
ok 84 - Cannot append to a str array
ok 85 - Cannot prepend to a str array
ok 86 - Cannot splice to a str array
ok 87 - .Str space-separates on str array
ok 88 - .gist space-separates on str array
ok 89 - .raku includes type and str values on str array
ok 90 - # SKIP STORE not working correctly yet)
ok 91 - does slice handle containerized range
ok 92 - does join a str array
ok 93 - Can clear str array by assigning empty list
ok 94 - does emptying a str array reset
ok 95 - does re-initializing a str array work
ok 96 - List-assigning str array to untyped works (1)
ok 97 - List-assigning str array to untyped works (2)
ok 98 - List-assigning str array to untyped works (3)
ok 99 - List-assign str array surrounded by literals (1)
ok 100 - List-assign str array surrounded by literals (2)
ok 101 - List-assign str array surrounded by literals (3)
ok 102 - List-assign str array surrounded by literals (4)
ok 103 - List-assign str array surrounded by literals (5)
ok 104 - List-assign untyped array of Str to str array (1)
ok 105 - List-assign untyped array of Str to str array (2)
ok 106 - List-assign untyped array of Str to str array (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 107 - List-assigning incompatible untyped array to str array dies
ok 108 - Smartmatching same str arrays works
ok 109 - Can we sort str array
ok 110 - Can we sort 2-element sorted str array
ok 111 - Can we sort 1-element sorted str array
# FUDGED!
1..183
ok 1 - str array type is Positional
ok 2 - str array type is Positional[str]
ok 3 - str array type .of is str
ok 4 - str array is Positional
ok 5 - str array is Positional[str]
ok 6 - str array .of is str
ok 7 - str array is Positional
ok 8 - str array is Positional[str]
ok 9 - str array .of is str
ok 10 - .new from str array is Positional
ok 11 - .new from str array Positional[str]
ok 12 - .new from str array .of is str
ok 13 - New str array has no elems
ok 14 - New str array has end of -1
ok 15 - New str array Int-ifies to 0
ok 16 - New str array numifies to 0
ok 17 - New str array is falsey
ok 18 - Empty str array is not lazy
ok 19 - # SKIP non-existing str elements return null_s
ok 20 - Elems do not grow just from an access on str array
ok 21 - Can store string in an str array
ok 22 - Can get value from str array
ok 23 - The elems grew as expected on str array
ok 24 - str array becomes truthy when it has an element
ok 25 - Can slice-assign to an str array
ok 26 - Can get slice-assigned value from str array (1)
ok 27 - Can get slice-assigned value from str array (2)
ok 28 - The elems grew as expected on str array
ok 29 - The end value matches grown elems on str array
ok 30 - Int-ifies to grown number of elems on str array
ok 31 - Numifies to grown number of elems on str array
ok 32 - str array with values is not lazy
ok 33 - Can assign non-contiguously to str array
ok 34 - # SKIP non-existing str elements return null_s
ok 35 - Non-contiguous assignment works on str array
ok 36 - Can also get last element on str array
ok 37 - Can clear str array by assigning empty list
ok 38 - Cleared str array has no elems
ok 39 - Cleared str array has end of -1
ok 40 - Cleared str array Int-ifies to 0
ok 41 - Cleared str array numifies to 0
ok 42 - Cleared str array is falsey
ok 43 - Can assign Str range to str array
ok 44 - Got correct elems from range assign on str array
ok 45 - Got correct element from range assign on str array (1)
ok 46 - Got correct element from range assign on str array (2)
ok 47 - :exists works on str array (1)
ok 48 - :exists works on str array (2)
ok 49 - :exists works on str array (3)
ok 50 - Can call str array constructor with a single value
ok 51 - Correct number of elems set in constructor of str array
ok 52 - Correct element value set by constructor of str array
ok 53 - Can call str array constructor with values
ok 54 - Correct number of elems set in constructor of str array
ok 55 - Correct elem value set by constructor of str array (1)
ok 56 - Correct elem value set by constructor of str array (2)
ok 57 - Correct elem value set by constructor of str array (3)
ok 58 - Correct elem value set by constructor of str array (4)
ok 59 - Can also get last 2 elements on str array
ok 60 - str array .flat returns a Seq
ok 61 - str array .eager returns identity
ok 62 - Can iterate over str array
ok 63 - Mutating for loop on str array works (1)
ok 64 - Mutating for loop on str array works (2)
ok 65 - Mutating for loop on str array works (3)
ok 66 - Mutating for loop on str array works (4)
ok 67 - Can map over str array
ok 68 - Mutating map on str array works (1)
ok 69 - Mutating map on str array works (2)
ok 70 - Mutating map on str array works (3)
ok 71 - Mutating map on str array works (4)
ok 72 - Can grep a str array
ok 73 - str array.grep(Str)
ok 74 - str array.grep(Str, :k)
ok 75 - str array.grep(Str, :kv)
ok 76 - str array.grep(Str, :p)
ok 77 - str array.grep(Str, :v)
ok 78 - str array.grep(Str)
ok 79 - str array.grep(Str, :k)
ok 80 - str array.grep(Str, :kv)
ok 81 - str array.grep(Str, :p)
ok 82 - str array.grep(Str, :v)
ok 83 - Can use reduce meta-op on a str array
ok 84 - .values from a str array
ok 85 - .pairup from a str array
ok 86 - .keys from a str array
ok 87 - .pairs from a str array
ok 88 - .antipairs from a str array
ok 89 - .kv from a str array
ok 90 - .pick from a str array
ok 91 - .roll from a str array
ok 92 - str array.unique
ok 93 - str array.repeated
ok 94 - str array.squish
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Empty)
    ok 3 - .action matches pop
    ok 4 - .what matches array[str]
ok 95 - Trying to pop an empty str array dies
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::Cannot::Empty)
    ok 3 - .action matches shift
    ok 4 - .what matches array[str]
ok 96 - Trying to shift an empty str array dies
ok 97 - can push to str array
ok 98 - push to str array works (1)
ok 99 - push to str array works (2)
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck)
    ok 3 - .got matches (Int)
ok 100 - Cannot push non-str/Str to str array
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 101 - Cannot bind to str array
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 102 - Cannot delete from str array
ok 103 - can push multiple to str array
ok 104 - push multiple to str array works (1)
ok 105 - push multiple to str array works (2)
ok 106 - push multiple to str array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 107 - Cannot push non-str/Str to str array (multiple push)
ok 108 - can append to str array
ok 109 - append to str array works (1)
ok 110 - append to str array works (2)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 111 - Cannot append non-str/Str to str array
ok 112 - can append multiple to str array
ok 113 - append multiple to str array works (1)
ok 114 - append multiple to str array works (2)
ok 115 - append multiple to str array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 116 - Cannot append non-str/Str to str array (multiple append)
ok 117 - pop from str array works (1)
ok 118 - pop from str array works (2)
ok 119 - can unshift to str array
ok 120 - unshift to str array works (1)
ok 121 - unshift to str array works (2)
ok 122 - unshift to str array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 123 - Cannot unshift non-str/Str to str array
ok 124 - can unshift multiple to str array
ok 125 - unshift multiple to str array works (1)
ok 126 - unshift multiple to str array works (2)
ok 127 - unshift multiple to str array works (3)
ok 128 - unshift multiple to str array works (4)
ok 129 - unshift multiple to str array works (5)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 130 - Cannot unshift non-str/Str to str array (multiple unshift)
ok 131 - can prepend to str array
ok 132 - prepend to str array works (1)
ok 133 - prepend to str array works (2)
ok 134 - prepend to str array works (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 135 - Cannot prepend non-str/Str to str array
ok 136 - can prepend multiple to str array
ok 137 - unshift multiple to str array works (1)
ok 138 - prepend multiple to str array works (2)
ok 139 - prepend multiple to str array works (3)
ok 140 - prepend multiple to str array works (4)
ok 141 - prepend multiple to str array works (5)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 142 - Cannot prepend non-str/Str to str array (multiple unshift)
ok 143 - shift from str array works (1)
ok 144 - shift from str array works (2)
ok 145 - can initialize str from Range
ok 146 - Number of elems after splice str array
ok 147 - Splice on str array did the right thing (1)
ok 148 - Splice on str array did the right thing (2)
ok 149 - Splice on str array did the right thing (3)
ok 150 - Splice on str array did the right thing (4)
ok 151 - Splice on str array did the right thing (5)
ok 152 - Number of returned spliced values from str array
ok 153 - Correct value in splice returned from str array (1)
ok 154 - Correct value in splice returned from str array (2)
ok 155 - .Str space-separates on str array
ok 156 - .gist space-separates on str array
ok 157 - .raku includes type and int values on str array
ok 158 - does slice return same type
ok 159 - does slice handle containerized range
ok 160 - Flattening str array in call works
ok 161 - does join a str array
ok 162 - does emptying a str array really empty
ok 163 - does join handle holes in a str array
ok 164 - Smartmatching same str arrays works
ok 165 - Smartmatching different str arrays works
ok 166 - Can we sort str array
ok 167 - Can we sort 2-element sorted str array
ok 168 - Can we sort 2-element unsorted str array
ok 169 - Can we sort 1-element str array
ok 170 - Can we sort 0-element str array
ok 171 - List-assigning str array to untyped works (1)
ok 172 - List-assigning str array to untyped works (2)
ok 173 - List-assigning str array to untyped works (3)
ok 174 - List-assign str array surrounded by literals (1)
ok 175 - List-assign str array surrounded by literals (2)
ok 176 - List-assign str array surrounded by literals (3)
ok 177 - List-assign str array surrounded by literals (4)
ok 178 - List-assign str array surrounded by literals (5)
ok 179 - List-assign untyped array of Str to str array (1)
ok 180 - List-assign untyped array of Str to str array (2)
ok 181 - List-assign untyped array of Str to str array (3)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 182 - List-assigning incompatible untyped array to str array dies
ok 183 - did we survive the hole
# FUDGED!
1..17
ok 1 - A) merge multis without protos
ok 2 - A) doesn't import non-exported multis
ok 3 - A) doesn't dispatch to wrong signature
ok 4 - B) merge multis with proto in module
ok 5 - C) merge multis with proto before import
ok 6 - C) our multi is still there
    1..3
    not ok 1 - 'proto sub Dfoo( Mu ) { * }' died # TODO huh?
    # Failed test ''proto sub Dfoo( Mu ) { * }' died'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S11-modules/import-multi.rakudo line 51
    ok 2 - # SKIP Code did not die, can not check exception
    ok 3 - # SKIP Code did not die, can not check exception
not ok 7 - did we throws-like X::Redeclaration? # TODO huh?
# Failed test 'did we throws-like X::Redeclaration?'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S11-modules/import-multi.rakudo line 51
ok 8 - D) merge multis with proto after import
ok 9 - D) our multi is still there
ok 10 - E) merge multis with proto before import and in module
ok 11 - E) our multi is still there
    1..3
    not ok 1 - 'proto sub Ffoo( Mu ) { * }' died # TODO it just dies, can't check using throws-like
    # Failed test ''proto sub Ffoo( Mu ) { * }' died'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S11-modules/import-multi.rakudo line 81
    ok 2 - # SKIP Code did not die, can not check exception
    ok 3 - # SKIP Code did not die, can not check exception
not ok 12 - did we throws-like X::Redeclaration? # TODO it just dies, can't check using throws-like
# Failed test 'did we throws-like X::Redeclaration?'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S11-modules/import-multi.rakudo line 81
ok 13 - F) merge multis with proto after import and in module
ok 14 - F) our multi is still there
ok 15 - # SKIP A symbol "&Gfoo" has already been exported
ok 16 - H) trait "is awesome" applied
ok 17 - H) standard traits like "is export" still work
# FUDGED!
1..8
ok 1 - Try to initialize public attribute
ok 2 - Try to initialize private attribute
not ok 3 - non-compiling test # TODO Unimplemented yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-attributes/augment-and-initialization.rakudo line 39
ok 4 - Try to access the initialized private attribute.
not ok 5 - Testing value for initialized private attribue. # TODO Augmentation attributes support is not implemented
# Failed test 'Testing value for initialized private attribue.'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-attributes/augment-and-initialization.rakudo line 43
# expected: '2'
#      got: (Nil)
not ok 6 - non-compiling test # TODO Unimplemented yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-attributes/augment-and-initialization.rakudo line 52
ok 7 - Try to access the private attribute which is initialized by constructor.
not ok 8 - Testing value for private attribue which is initialized by constructor. # TODO Augmentation attributes support is not implemented
# Failed test 'Testing value for private attribue which is initialized by constructor.'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-attributes/augment-and-initialization.rakudo line 56
# expected: '4'
#      got: (Nil)
# FUDGED!
1..152
    1..2
    ok 1 - 'has $.x;' died
    ok 2 - right exception type (X::Attribute::NoPackage)
ok 1 - 'has' only works inside of class|role definitions
ok 2 - ... our Foo1 instance was created
ok 3 - .. checking autogenerated accessor existence
ok 4 - ... $foo.can("bar") should have returned true
ok 5 - .. autogenerated accessor works
ok 6 - .. autogenerated accessor works w/out parens
ok 7 - ... our Foo2 instance was created
ok 8 - .. checking autogenerated accessor existence
ok 9 - .. autogenerated accessor works
ok 10 - .. autogenerated accessor works w/out parens
ok 11 - attributes are ro by default
ok 12 - ... our Foo3 instance was created
ok 13 - .. checking autogenerated accessor existence
ok 14 - ... $foo.can("bar") should have returned true
ok 15 - .. autogenerated accessor works
ok 16 - .. autogenerated mutator as lvalue works
ok 17 - .. autogenerated mutator as lvalue set the value correctly
ok 18 - ... our Foo4 instance was created
ok 19 - .. checking autogenerated accessor existence
ok 20 - ... our Foo4a instance was created
ok 21 - .. checking autogenerated accessor existence
ok 22 - ... our Foo5 instance was created
ok 23 - setting a public rw attribute
ok 24 - getting a public rw attribute
ok 25 - setting a public ro attribute (1)
ok 26 - getting a public ro attribute (1)
not ok 27 - setting a public ro attribute (2) # TODO ro on list attributes
# Failed test 'setting a public ro attribute (2)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-attributes/instance.rakudo line 106
not ok 28 - getting a public ro attribute (2) # TODO ro on list attributes
# Failed test 'getting a public ro attribute (2)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-attributes/instance.rakudo line 109
# expected: '2'
#      got: '5'
ok 29 - modifiying a private attribute (1)
ok 30 - getting a private attribute (1)
ok 31 - modifiying a private attribute (2)
ok 32 - getting a private attribute (2)
ok 33 - ... our Foo6 instance was created
ok 34 - getting a public rw attribute (1)
ok 35 - getting a public ro attribute (2)
ok 36 - getting a private ro attribute (3)
ok 37 - ... our Foo6a instance was created
ok 38 - getting a public rw attribute (1)
ok 39 - getting a public rw attribute (2)
ok 40 - getting a private ro attribute (3)
ok 41 - ... our Foo6b instance was created
ok 42 - getting a public rw attribute (1)
ok 43 - getting a public rw attribute (2)
ok 44 - default attribute value (1)
ok 45 - default attribute value (4)
ok 46 - forty_two_supplier() was actually executed
ok 47 - forty_two_supplier() is executed per instantiation
ok 48 - optional attribute should take default value without passed-in value
ok 49 - ... optional non-attribute should too
ok 50 - optional attribute should take passed-in value over default
ok 51 - ... optional non-attribute should too
ok 52 - ... our Foo8 instance was created
ok 53 - BUILD received $foo
ok 54 - BUILD received $bar
ok 55 - cannot pass positional to .new
ok 56 - ... our Foo10 instance was created
ok 57 - BUILD received $foo
ok 58 - BUILD received $bar
ok 59 - BUILD received $self
ok 60 - .WHAT on attributes
ok 61 - .WHAT on attributes of same type as class
ok 62 - type check on recursive data structure
ok 63 - .WHAT on recursive data structure
ok 64 - use of self in closure on RHS of attr init works
ok 65 - attribute cloned
ok 66 - attribute cloned
ok 67 - changed attribute on clone...
ok 68 - ...and original not affected
ok 69 - clone with parameters...
ok 70 - ...leaves original intact...
ok 71 - ...and copies what we did not change.
ok 72 - original object not modified
ok 73 - cloned object has its own attributes
ok 74 - original object not modified
ok 75 - cloned object has new attributes
ok 76 - @.a[0] works
ok 77 - @.a[*-2] works
ok 78 - @.a[*-1] works
ok 79 - Can index array attributes with non-integers
not ok 80 - can not assign to @.array attribute # TODO ro array/hash with accessor
# Failed test 'can not assign to @.array attribute'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-attributes/instance.rakudo line 381
not ok 81 - can not assign to %.hash attribute # TODO ro array/hash with accessor
# Failed test 'can not assign to %.hash attribute'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-attributes/instance.rakudo line 382
ok 82 - can assign to @!array attribute
ok 83 - can assign to %!hash attribute
ok 84 - could use whitespace after "has ("
ok 85 - .. and a newline within the has() declarator
ok 86 - === works on typed attribute initialized with proto-object
ok 87 - C_Test.new().a worked
ok 88 - my $o = f(); $o.a worked
ok 89 - f().a worked (part 1)
ok 90 - g().a worked (part 2)
ok 91 - Initialized outside constructor
ok 92 - Get appears to have worked
ok 93 - Get Worked!
ok 94 - Initialized inside constructor
ok 95 - Get appears to have worked
ok 96 - Get Worked!
ok 97 - created object with typed attributes
ok 98 - typed public array attribute is empty
ok 99 - typed public hash attribute is empty
ok 100 - typed private array attribute is empty
ok 101 - typed private hash attribute is empty
ok 102 - array attribute is typed
ok 103 - Can assign to typed drw-array-attrib
ok 104 - Can insert into typed rw-array-attrib
ok 105 - Can push onto typed rw-array-attrib
ok 106 - ... all of the above actually worked (not only lived)
ok 107 - type enforced on array attrib (assignment)
ok 108 - type enforced on array attrib (item assignment)
ok 109 - type enforced on array attrib (push)
ok 110 - no autovivification (typed array)
not ok 111 - ... all of the above actually did nothing (not just died) # TODO over-eager auto-vivification bugs
# Failed test '... all of the above actually did nothing (not just died)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-attributes/instance.rakudo line 477
# expected: '2|3|4|5'
#      got: '2|3|4|5|1'
ok 112 - hash attribute is typed
ok 113 - assign to typed hash attrib
ok 114 - insertion into typed hash attrib
ok 115 - pushing onto typed hash attrib
ok 116 - ... all of them worked
ok 117 - Type enforced (hash, assignment)
ok 118 - Type enforced (hash, insertion)
ok 119 - Type enforced (hash, push)
ok 120 - No autovivification (typed hash)
ok 121 - hash still unchanged
ok 122 - Can initialize one attribute based on another (1)
ok 123 - Can initialize one attribute based on another (2)
ok 124 - Can initialize one attribute based on another (3)
ok 125 - &!m = sub { ... } works and an be called
ok 126 - &.a = { ... } works and also declares &!a
ok 127 - &.a has accessor returning closure
ok 128 - &!m = method { ... } and self.&!m() work
ok 129 - Test class include another class which inherited from same role
ok 130 - dies: trying to modify instance attribute when invocant is type object
ok 131 - binding to an attribute works
ok 132 - # SKIP dubious test - the initializer becomes a submethod here, implying a scope RT  \#124908
ok 133 - Can call a method all()
ok 134 - Can use outer lexicals in attribut initialization
ok 135 - Can use lexicals in attribut initialization
ok 136 - list assignment to attributes (1)
ok 137 - list assignment to attributes (type)
ok 138 - list assignment to attributes (2)
ok 139 - presence of BUILD does not prevent assignment of default values
    1..2
    ok 1 - 'my class AccessorClash { has @.a; has &.a }' died
    ok 2 - right exception type (Exception)
ok 140 - cannot have two attributes with same accessor name
    1..2
    ok 1 - 'class RT74274 { has $!a }; my $a = RT74274.new(a => 42);
    #     my $method = method { return $!a }; $a.$method()' died
    ok 2 - right exception type (Exception)
ok 141 - cannot sneak in access to private attribute through the backdoor
ok 142 - Scalar containers respected in attribute initialization
ok 143 - Can use .list to remove container
ok 144 - initializing with [...] follows one-arg rule
ok 145 - initializing with $[...] is still one item
ok 146 - Attribute declaration can be in sub-scope too
ok 147 - can shadow an attribute with a lexical
ok 148 - can 'is rw' multiple declared has attributes
    1..5
    ok 1 - 'class Zapis { has $.a is bar; }' died
    ok 2 - right exception type (X::Comp::Trait::Unknown)
    ok 3 - .type matches is
    ok 4 - .declaring matches n attribute
    ok 5 - .subtype matches bar
ok 149 - did we throws-like X::Comp::Trait::Unknown?
    1..5
    ok 1 - 'class Zapwill { has $.a will bar { ... } }' died
    ok 2 - right exception type (X::Comp::Trait::Unknown)
    ok 3 - .type matches will
    ok 4 - .declaring matches n attribute
    ok 5 - .subtype matches bar
ok 150 - did we throws-like X::Comp::Trait::Unknown?
ok 151 - is rw accessor method marked rw
ok 152 - readonly accessor method not marked rw
# FUDGED!
1..14
ok 1 - normal attribute
ok 2 - can't change a non-rw attribute
ok 3 - attribute didn't change value
ok 4 - mutators not called yet
ok 5 - mutator called during object construction
ok 6 - accessor by sub was called 
ok 7 - mutator by sub was called
ok 8 - attribute with overridden mutator by sub
ok 9 - accessor and mutator by sub were called
ok 10 - # SKIP RT  \#126198
ok 11 - # SKIP RT  \#126198
ok 12 - # SKIP RT  \#126198
ok 13 - # SKIP RT  \#126198
ok 14 - # SKIP RT  \#126198
# FUDGED!
1..49
ok 1 - Can read ro int attr default value
ok 2 - Can read ro num attr default value
ok 3 - Can read ro str attr default value
ok 4 - Cannot write to native int ro attr
ok 5 - Cannot write to native num ro attr
ok 6 - Cannot write to native str ro attr
ok 7 - Can read rw int attr default value
ok 8 - Can read rw num attr default value
ok 9 - Can read rw str attr default value
ok 10 - Can write to native int rw attr
ok 11 - Can write to native num rw attr
ok 12 - Can write to native str rw attr
ok 13 - Can read back rw int attr changed value
ok 14 - Can read back rw num attr changed value
ok 15 - Can read back rw str attr changed value
ok 16 - Attributes really updated
ok 17 - Cannot update int rw attr with non-int (1)
ok 18 - Cannot update int rw attr with non-int (2)
ok 19 - Cannot update num rw attr with non-num (1)
ok 20 - Cannot update num rw attr with non-num (2)
ok 21 - Cannot update str rw attr with non-str (1)
ok 22 - Cannot update str rw attr with non-str (2)
ok 23 - Can read ro int attr value from constructor
ok 24 - Can read ro num attr value from constructor
ok 25 - Can read ro str attr value from constructor
ok 26 - Can read rw int attr value from constructor
ok 27 - Can read rw num attr value from constructor
ok 28 - Can read rw str attr value from constructor
ok 29 - Can write to native int rw attr set by constructor
ok 30 - Can write to native num rw attr set by constructor
ok 31 - Can write to native str rw attr set by constructor
ok 32 - Can read back rw int attr changed value
ok 33 - Can read back rw num attr changed value
ok 34 - Can read back rw str attr changed value
ok 35 - Attributes really updated
ok 36 - Non-twigil native attr defaults work
ok 37 - Can set non-twigil native int attr
ok 38 - The update took effect
ok 39 - Can set non-twigil native num attr
ok 40 - The update took effect
ok 41 - Can set non-twigil native str attr
ok 42 - The update took effect
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Syntax::NoSelf)
ok 43 - did we throws-like X::Syntax::NoSelf?
ok 44 - uint64 native attribute accessor works
ok 45 - uint64 native attribute use in method works
not ok 46 - large unsigned ints
ok 47 - unsigned int sanity
not ok 48 - large unsigned ints # TODO RT #131122
# Failed test 'large unsigned ints'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-attributes/native.rakudo line 149
# expected: 200
#      got: -56
    1..5
    ok 1 - run 1
    ok 2 - run 2
    ok 3 - run 3
    ok 4 - run 4
    ok 5 - run 5
ok 49 - ops on native attributes
# FUDGED!
1..18
ok 1 - instantiated the class
ok 2 - isa check works
not ok 3 - .WHAT.gist stringifies to () # TODO Anonymous class stringification (?)
# Failed test '.WHAT.gist stringifies to ()'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-class/anonymous.rakudo line 14
# expected: '()'
#      got: '(<anon|1>)'
ok 4 - can call methods on anonymous classes
ok 5 - can call methods on anonymous classes
ok 6 - anonymous classes can have attributes
ok 7 - anonymous class creation
ok 8 - instantiation of anonymous class
ok 9 - calling a method on an instance of an anonymous class (1)
ok 10 - calling a method on an instance of an anonymous class (2)
ok 11 - anonymous class isa TestParent
ok 12 - inherited method from TestParent
ok 13 - can get anonymous class instance once
ok 14 - can get anonymous class instance twice
ok 15 - anonymous class stringified works
ok 16 - anonymous class numified works
    1..2
    ok 1 - 'anon class C { }; C.WHAT; ' died
    ok 2 - right exception type (X::Undeclared::Symbols)
ok 17 - anon class is actually anon
ok 18 - anonymous classes are distinct
# FUDGED!
1..14
ok 1 - basic method call works
ok 2 - added method call works
ok 3 - augment on non-existent class dies
ok 4 - can augment lexical class
ok 5 - can augment Hash
    1..2
    ok 1 - '
    #     class MethodClash { method foo() { 3 } };
    #     augment class MethodClash { method foo() { 3 } };
    # ' died
    ok 2 - right exception type (X::Syntax::Augment::WithoutMonkeyTyping)
ok 6 - cannot override a method by monkey-typing
ok 7 - augmenting a class which has a role composed works
ok 8 - # SKIP redeclaration of symbol Bar
ok 9 - # SKIP redeclaration of symbol Bar
ok 10 - cannot add multis with augment
ok 11 - integers produced from ranges have augmented methods
ok 12 - used to crash rakudo
ok 13 - used to crash rakudo
ok 14 - Augmenting a nested package lives
# FUDGED!
1..7
ok 1 - instantiated a class
ok 2 - initializing attributes in new
ok 3 - death to instantiating nonexistent class
ok 4 - error for "NoSuchClass.new()" mentions NoSuchClass
ok 5 - death to instantiating nonexistent::class
not ok 6 - error for "NoSuch::Subclass.new()" mentions NoSuch::Subclass # TODO error reporting
# Failed test 'error for "NoSuch::Subclass.new()" mentions NoSuch::Subclass'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-class/instantiate.rakudo line 33
ok 7 - instantiating from class name string creates a Str object
# FUDGED!
1..3
ok 1 - set attribute
ok 2 - # SKIP initialization of parent attributes
ok 3 - # SKIP initialization of parent attributes
# FUDGED!
1..9
ok 1 - Can stub a class, and later on declare it
ok 2 - Can stub a role, and later on declare it
ok 3 - Can stub a module, and later on declare it
not ok 4 - Can stub a package, and later on implement it as a class # TODO nom regression
# Failed test 'Can stub a package, and later on implement it as a class'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-class/stubs.rakudo line 16
# Error: The following packages were stubbed but not defined:
#     Test::StubD
    1..2
    ok 1 - 'my class StubbedButNotDeclared { ... }' died
    ok 2 - right exception type (X::Package::Stubbed)
ok 5 - stubbing a class but not providing a definition dies
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Package::Stubbed)
    ok 3 - .message matches The following packages were stubbed but not defined:
    #     A
ok 6 - did we throws-like X::Package::Stubbed?
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::Inheritance::NotComposed)
    ok 3 - .parent-name matches A
    ok 4 - .child-name matches B
ok 7 - did we throws-like X::Inheritance::NotComposed?
    1..2
        1..4
        ok 1 - …
        ok 2 - ...
        ok 3 - !!!
        ok 4 - ???
    ok 1 - lives when stubbed, then defined
        1..4
            1..2
            ok 1 - 'my class Foo { …   }' died
            ok 2 - right exception type (X::Package::Stubbed)
        ok 1 - …
            1..2
            ok 1 - 'my class Foo { ... }' died
            ok 2 - right exception type (X::Package::Stubbed)
        ok 2 - ...
            1..2
            ok 1 - 'my class Foo { !!! }' died
            ok 2 - right exception type (X::Package::Stubbed)
        ok 3 - !!!
            1..2
            ok 1 - 'my class Foo { ??? }' died
            ok 2 - right exception type (X::Package::Stubbed)
        ok 4 - ???
    ok 2 - throws when stubbed, and never defined
ok 8 - all forms of yadas work to stub classes
ok 9 - Can stub a class in a core namespace
# FUDGED!
1..28
ok 1 - coercion type on the inside
ok 2 - Coercion type coerces
ok 3 - Coercion type coerces to correct value
    1..2
    ok 1 - ' sub g(Str(Cool) $x) { $x }; g(Any) ' died
    ok 2 - right exception type (X::TypeCheck::Binding)
ok 4 - coercion type still type-checks
ok 5 - Coercion with user-defined types
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Coerce::Impossible)
ok 6 - coercion that does not produce the target type dies
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck::Binding::Parameter)
    ok 3 - .message matches /expected \s \S* Cool\:D/
ok 7 - did we throws-like X::TypeCheck::Binding::Parameter?
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck::Binding::Parameter)
    ok 3 - .message matches /expected \s \S* Cool\:D/
ok 8 - did we throws-like X::TypeCheck::Binding::Parameter?
ok 9 - Definedness check + coercion (1)
ok 10 - Definedness check + coercion (2)
ok 11 - Coercion dies if it doees not satisfy definedness constraint of target
ok 12 - basic enum sanity
ok 13 - coercion to enum
ok 14 - Coercion type on variable
ok 15 - Coercion type on variable after assignment (type)
ok 16 - Coercion type on variable after assignment (value)
ok 17 - an array with coercion type
ok 18 - a hash with coercion type
ok 19 - # SKIP NYI
ok 20 - # SKIP NYI
ok 21 - Can gist a coercion type
ok 22 - Sigilless variable does not confuse coercion type parsing
ok 23 - coercer with subset target did not crash
ok 24 - coercions from a Str subclass works
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Coerce::Impossible)
ok 25 - .^coerce throws on unacceptable value
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck::Assignment)
ok 26 - assigning unacceptable value to a coercive variable throws
ok 27 - nested coercions work
ok 28 - optional coercive parameter defaults to its target type
# FUDGED!
1..12
ok 1 - Called Parent's BUILD method once
ok 2 - Called Child's BUILD method once
ok 3 - submethods were called in right order (Parent first)
ok 4 - submethods were called with the correct arguments
ok 5 - can call child's methods in parent's BUILD
ok 6 - initilized called in the right order (MI)
ok 7 - BUILD called once
not ok 8 - method BUILD produces a compile-time warning # TODO method BUILD should warn
# Failed test 'method BUILD produces a compile-time warning'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-construction/BUILD.rakudo line 98
ok 9 - can call BUILD without providing a value for a !-twigiled named parameter
ok 10 - BUILD provided by role can use attributes in signature
    1..2
    ok 1 - code returned a Failure
        1..3
        ok 1 - code dies
        ok 2 - right exception type (X::AdHoc)
        ok 3 - .message matches noway
    ok 2 - Failure threw when sunk
ok 11 - fail in BUILD works
    1..15
    ok 1 - str
    ok 2 - byte
    ok 3 - int
    ok 4 - int8
    ok 5 - int16
    ok 6 - int32
    ok 7 - int64
    ok 8 - uint
    ok 9 - uint8
    ok 10 - uint16
    ok 11 - uint32
    ok 12 - uint64
    ok 13 - num
    ok 14 - num32
    ok 15 - num64
ok 12 - BUILD with a native typed attribute
# FUDGED!
1..28
ok 1 - can instantiate class with parent attributes
ok 2 - ... worked for the child
ok 3 - ... worked for the parent
ok 4 - # SKIP parent attributes in initialization
ok 5 - # SKIP parent attributes in initialization
ok 6 - # SKIP parent attributes in initialization
ok 7 - # SKIP parent attributes in initialization
ok 8 - # SKIP parent attributes in initialization
ok 9 - # SKIP parent attributes in initialization
ok 10 - # SKIP parent attributes in initialization
ok 11 - # SKIP parent attributes in initialization
ok 12 - # SKIP parent attributes in initialization
ok 13 - NewClass is not .defined
ok 14 - class asked to build itself refuses
ok 15 - NewClass is still not .defined
not ok 16 - die trying to instantiate missing class # TODO nested package handling does't quite get this one right
# Failed test 'die trying to instantiate missing class'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-construction/new.rakudo line 66
ok 17 - can delegate to self.Mu::new
ok 18 - ... got the right attribute (1)
ok 19 - ... got the right attribute (2)
ok 20 - Mu.new is a multi method
ok 21 - multi-constructor class alternate (positional) constructor
ok 22 - multi-constructor class alternate default named constructor
ok 23 - Can call nextwith in .new
ok 24 - RT  \#100780
ok 25 - multi method($) does not break attribute initialization
ok 26 - Can call .=new on a variable of a lexical type
ok 27 - Initialization of attributes in multiple inheritance works (1)
ok 28 - Initialization of attributes in multiple inheritance works (2)
# FUDGED!
1..54
ok 1 - First item of an enum is 0
ok 2 - Last item has the right value
ok 3 - Values exported into namespace too.
ok 4 - Values exported into namespace too.
ok 5 - Can construct ranges from Pair values
ok 6 - Can do arithmetics with Pair values
not ok 7 - Can test with .does() for enum type # TODO rakudo#1296 butting issue on Str and Enum
# Failed test 'Can test with .does() for enum type'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-enums/basic.rakudo line 30
not ok 8 - Can smartmatch for enum type # TODO rakudo#1296 butting issue on Str and Enum
# Failed test 'Can smartmatch for enum type'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-enums/basic.rakudo line 31
not ok 9 - Can Smartmatch for enum value # TODO rakudo#1296 butting issue on Str and Enum
# Failed test 'Can Smartmatch for enum value'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-enums/basic.rakudo line 32
not ok 10 - given/when with enum values # TODO rakudo#1296 butting issue on Str and Enum
# Failed test 'given/when with enum values'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-enums/basic.rakudo line 38
# expected: '1'
#      got: '0'
not ok 11 - given/when with enum values # TODO rakudo#1296 butting issue on Str and Enum
# Failed test 'given/when with enum values'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-enums/basic.rakudo line 44
# expected: '2'
#      got: '0'
ok 12 - .raku on long form of Pair key
ok 13 - .raku on short form of Pair value
ok 14 - .key on long form of Pair value
ok 15 - .key on short form of Pair value
ok 16 - .WHAT.gist on enum value stringifies to the enum name
ok 17 - enum with parens works and non-0 starting point works
ok 18 - .raku works on enum with parens
ok 19 - .key works on enum with parens
ok 20 - Pair of one element works.
ok 21 - empty enum can be constructed
ok 22 - empty enum with () can be constructed
ok 23 - can assign enum value to typed variable with long name
ok 24 - can assign enum value to typed variable with short name
ok 25 - enum as a type enforces checks
ok 26 - short name of the enum without parenthesis is an enum
ok 27 - short name with parenthesis is a sub
ok 28 - Color.pick assigns to Color var
ok 29 - Color.pick.isa
ok 30 - .pick on enums
ok 31 - .pick(2) on enums
ok 32 - enum element of enum with double colons is in namespace
ok 33 - enum keys (1)
ok 34 - enum keys (2)
ok 35 - RT  \#75370 enum name
    1..5
    ok 1 - code dies
    ok 2 - right exception type (X::PoisonedAlias)
    ok 3 - .package-type matches enum
    ok 4 - .alias matches b
    ok 5 - .package-name matches S2
ok 36 - did we throws-like X::PoisonedAlias?
ok 37 - still can access redeclared enum values via package
ok 38 - .enums returns a Map
    1..2
    ok 1 - enum element has correct value
    ok 2 - .enums are all correct
ok 39 - dynamically created lists can be used to define an enum
    1..3
    ok 1 - first element
    ok 2 - second element
    ok 3 - element with duped value
ok 40 - Enumeration:D.kv
    1..3
    ok 1 - first element
    ok 2 - second element
    ok 3 - element with duped value
ok 41 - Enumeration:D.pair
    1..3
    ok 1 - first element
    ok 2 - second element
    ok 3 - element with duped value
ok 42 - Enumeration:D.Int
    1..10
    ok 1 - .pred on first element, returns first element
    ok 2 - .pred on second element, returns first element
    ok 3 - .pred on 3rd element, returns 2nd element, even if values are same
    ok 4 - .pred on last element, returns previous, even if values are same
    ok 5 - .succ on first element, returns second element
    ok 6 - .succ second element, returns third one, even if values are same
    ok 7 - .succ 4th element, returns 5th element, even if values are same
    ok 8 - .succ last element, returns last element
    ok 9 - .pred on enum with 1 value works
    ok 10 - .succ on enum with 1 value works
ok 43 - .pred/.succ
    1..6
    ok 1 - different enums; different values => different
    ok 2 - different enums; same values => different
    ok 3 - type object vs. instance => different
    ok 4 - same enums => same (1)
    ok 5 - same enums => same (2)
    ok 6 - type object vs. type object => same
ok 44 - === on different enums with same values
ok 45 - Bool.enums returns a Map, not a Hash
ok 46 - build enum using Z=> operator properly
ok 47 - can build enum using Z=> operator
    1..3
    ok 1 - Block
    ok 2 - Code
    ok 3 - Code
ok 48 - can build enum with built-ins' names
ok 49 - enums can be created via Seq of Pairs
    1..5
    ok 1 - (1)
    ok 2 - (2)
    ok 3 - (3)
    ok 4 - (4)
    ok 5 - (5)
ok 50 - can provide enum values via Pairs
ok 51 - can create enum with a Hash
ok 52 - "NumericStringyEnumeration" uses key as .Str value
ok 53 - Pair elements in the list given to enum declaration work
ok 54 - Coercing an enum from a coercion of an enum from an int works
# FUDGED!
1..6
ok 1 - stringy enum first value
ok 2 - stringy enum first value
    1..2
    ok 1 - 'my enum B (a => 1, b => "bar")' died
    ok 2 - right exception type (Exception)
ok 3 - mixed type enums are forbidden
not ok 4 - ... unless that type covers both enum value types # TODO NYI
# Failed test '... unless that type covers both enum value types'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-enums/non-int.rakudo line 14
# Error: Incompatible MROs in P6opaque rebless for types Int and C
    1..2
    ok 1 - 'my Str enum D (a => 1)' died
    ok 2 - right exception type (Exception)
ok 5 - violating an explicit type constraint dies
ok 6 - Str enum correctly uses string-increment
# FUDGED!
1..60
ok 1 - enum itself stringififes
ok 2 - enum.WHAT returned a value
ok 3 - enum.raku returned a value
ok 4 - # SKIP NYI
ok 5 - # SKIP NYI
ok 6 - # SKIP NYI
ok 7 - # SKIP NYI
ok 8 - # SKIP NYI
ok 9 - # SKIP NYI
ok 10 - # SKIP NYI
ok 11 - # SKIP NYI
ok 12 - # SKIP NYI
ok 13 - # SKIP NYI
ok 14 - # SKIP NYI
ok 15 - # SKIP NYI
ok 16 - # SKIP NYI
ok 17 - # SKIP NYI
ok 18 - # SKIP does day::Tue
ok 19 - # SKIP does day::Tue
ok 20 - # SKIP does day::Tue
ok 21 - # SKIP does day::Tue
ok 22 - # SKIP does day::Tue
ok 23 - # SKIP does day::Tue
ok 24 - # SKIP does day::Tue
ok 25 - # SKIP does day::Tue
ok 26 - # SKIP does day::Tue
ok 27 - # SKIP does day::Tue
ok 28 - # SKIP does day::Tue
ok 29 - # SKIP does day::Tue
ok 30 - # SKIP does day::Tue
ok 31 - # SKIP does day::Tue
ok 32 - # SKIP does &day::("Tue")
ok 33 - # SKIP does &day::("Tue")
ok 34 - # SKIP does &day::("Tue")
ok 35 - # SKIP does &day::("Tue")
ok 36 - # SKIP does &day::("Tue")
ok 37 - # SKIP does &day::("Tue")
ok 38 - # SKIP does &day::("Tue")
ok 39 - # SKIP does &day::("Tue")
ok 40 - # SKIP does &day::("Tue")
ok 41 - # SKIP does &day::("Tue")
ok 42 - # SKIP does &day::("Tue")
ok 43 - # SKIP does &day::("Tue")
ok 44 - # SKIP does &day::("Tue")
ok 45 - # SKIP does &day::("Tue")
ok 46 - # SKIP does &day::("Tue")
ok 47 - method on short name pick up the one from the enum
ok 48 - method on long name pick up the one from the enum
ok 49 - True.raku
ok 50 - Bool::True.raku
ok 51 - simple assignment from enum
ok 52 - assignment from enum works
    1..2
    ok 1 - 'RT66886::c' died
    ok 2 - right exception type (Exception)
ok 53 - accessing non-value of enum dies proper-like
ok 54 - can index enum by number
ok 55 - enum and math and index
ok 56 - marking enum export does not die
    1..2
    not ok 1 - 'enum rt_101900 < a b >; class A { }; note A but rt_101900::a' died # TODO RT #101900
    # Failed test ''enum rt_101900 < a b >; class A { }; note A but rt_101900::a' died'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-enums/thorough.rakudo line 111
    ok 2 - # SKIP Code did not die, can not check exception
not ok 57 - Cannot mixin an enum into a class # TODO RT #101900
# Failed test 'Cannot mixin an enum into a class'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-enums/thorough.rakudo line 111
ok 58 - .can(...) on an enum
ok 59 - .^can(...) on an enum
ok 60 - Can mix a private method into an enum value
# FUDGED!
1..38
ok 1 - Still alive after new
ok 2 - The direct object notation call without arguments
ok 3 - The indirect object notation call without arguments without ()
ok 4 - The indirect object notation call without arguments with ()
ok 5 - Still alive after new
ok 6 - The direct object notation call with argument
ok 7 - The indirect object notation call with argument without ()
ok 8 - The indirect object notation call with argument with ()
    1..2
    ok 1 - '$name $o: $seed' died
    ok 2 - right exception type (X::Syntax::Confused)
ok 9 - Indirect object notation and indirect method calls cannot be combined
ok 10 - The indirect object notation call with multiple arguments without ()
ok 11 - The indirect object notation call with multiple arguments with ()
ok 12 - indirect object notation with colon at EOF works
ok 13 - calling method with $object."methodname"
ok 14 - calling method with $object."method$name"
ok 15 - calling method with $object."method$name"
ok 16 - calling method with $object.$methodref
ok 17 - # SKIP .@foo not yet working
ok 18 - # SKIP .@foo not yet working
ok 19 - # SKIP .@foo not yet working
ok 20 - # SKIP .@foo not yet working
ok 21 - # SKIP .@foo not yet working
ok 22 - # SKIP .@foo not yet working
ok 23 - Can't call nonexisting method
ok 24 - # SKIP .*, .+ and .? with @foo
ok 25 - # SKIP .*, .+ and .? with @foo
ok 26 - # SKIP .*, .+ and .? with @foo
ok 27 - # SKIP .*, .+ and .? with @foo
ok 28 - # SKIP .*, .+ and .? with @foo
ok 29 - # SKIP .*, .+ and .? with @foo
ok 30 - # SKIP .*, .+ and .? with @foo
ok 31 - # SKIP .*, .+ and .? with @foo
ok 32 - # SKIP .*, .+ and .? with @foo
ok 33 - # SKIP .*, .+ and .? with @foo
ok 34 - # SKIP .*, .+ and .? with @foo
ok 35 - # SKIP .*, .+ and .? with @foo
ok 36 - # SKIP .*, .+ and .? with @foo
ok 37 - # SKIP .*, .+ and .? with @foo
ok 38 - # SKIP .*, .+ and .? with @foo
# FUDGED!
1..29
ok 1 - Foo.new() worked (1)
ok 2 - Foo's BUILD was called
ok 3 - Bar's BUILD counter not available
ok 4 - Bar.new() worked
ok 5 - Foo's BUILD was called again
ok 6 - Bar's BUILD was called, too
ok 7 - Foo.new() worked (2)
ok 8 - Foo's BUILD was called again
ok 9 - Baz.new() worked
ok 10 - Grtz.new() worked
ok 11 - can call submethod on parent class
ok 12 - Baz's submethod blarb was called
ok 13 - Grtz's submethod blarb was not called
ok 14 - can call submethod on child class
ok 15 - Baz's submethod blarb was not called
ok 16 - Grtz's submethod blarb was called now
ok 17 - $obj.Class::submthod
ok 18 - Baz's submethod blarb was called now
ok 19 - Grtz's submethod blarb was not called again
ok 20 - # SKIP outer lexicals in roles
ok 21 - # SKIP outer lexicals in roles
ok 22 - # SKIP roles and submethods
ok 23 - # SKIP roles and submethods
ok 24 - # SKIP roles and submethods
ok 25 - # SKIP roles and submethods
ok 26 - BUILD() should allow default values of optional params in signature
ok 27 - ... or value passed in
ok 28 - Bool method in class is used in boolificiation
ok 29 - Bool submethod in class is used in boolificiation
# FUDGED!
1..91
ok 1 - we can compile subtype declarations
ok 2 - and we can use them, too
ok 3 - and they actually work
ok 4 - we can compile subtype declarations
ok 5 - and we can use them, too
ok 6 - and they actually work
ok 7 - subset types refine candidate matches
ok 8 - 3 is an odd num
ok 9 - objects of Int::Odd don't get even
ok 10 - subtypes are undefined
ok 11 - calling sub worked
ok 12 - calling sub did not work
ok 13 - Int accepted by Int::Odd
ok 14 - 
ok 15 - our var is a Int::Even
ok 16 - setting a Int::Even to an odd value dies
ok 17 - lexically declared subtype went out of scope
ok 18 - basic sanity (1)
ok 19 - basic sanity (2)
ok 20 - creating a new Num::Multiple
ok 21 - creating a new Num::Multiple actually worked
ok 22 - negative test also works
ok 23 - variable kept previous value
ok 24 - changed subtype definition worked
    1..3
    ok 1 - code dies
    ok 2 - right exception type (Exception)
    ok 3 - .message matches 1 is not even
ok 25 - custom subset errors can be created with fail()
ok 26 - where /regex/ works (positive)
    1..2
    ok 1 - 'my HasA $x = "foo"' died
    ok 2 - right exception type (X::TypeCheck::Assignment)
ok 27 - where /regex/ works (negative)
ok 28 - where works with smart-matching on string
ok 29 - where works with smart-matching on string
ok 30 - where works with smart-matching on regex
ok 31 - where works with smart-matching on regex
ok 32 - where works with smart-matching on regex
ok 33 - parameter in subtype is read-only...
ok 34 - ...even in anonymous ones.
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck::Assignment)
ok 35 - Even $x can not be ++ed
ok 36 - ..and the value was preserved
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck::Assignment)
ok 37 - Even $x can not be --ed
ok 38 - and the value was preserved
ok 39 - can satisfy both conditions on chained subset types
ok 40 - violating first condition barfs
ok 41 - violating second condition barfs
ok 42 - subtypes based on classes work
ok 43 - subtypes based on classes work
ok 44 - subtypes based on roles work
ok 45 - subtypes based on roles work
ok 46 - subset declaration without where clause does type it refines
ok 47 - subset declaration without where clause accepts right value
ok 48 - subset declaration without where clause accepts right value
ok 49 - subset declaration without where clause rejects wrong value
ok 50 - subset declaration without where clause rejects wrong value
ok 51 - subset type is enforced as attribute in new() (1)
ok 52 - subset type enforced as attribute in new() (2)
ok 53 - my subset type is enforced as attribute in new() (1)
ok 54 - my subset type enforced as attribute in new() (2)
ok 55 - code called when subtype built on subtype
ok 56 - level one subset check is false
ok 57 - level one subset checked (should fail)
ok 58 - level two subset not checked
ok 59 - overall subset check is false
ok 60 - level one subset checked (should fail)
ok 61 - level two subset not checked
ok 62 - level one subset check is true
ok 63 - level one subset checked (should succeed)
ok 64 - level two subset not checked
ok 65 - overall subset check is true
ok 66 - level one subset checked (should succeed)
ok 67 - level two subset checked (should succeed)
ok 68 - subsets of roles (1)
ok 69 - subsets of roles (2)
ok 70 - smart-matching a subset returns a Bool (1)
ok 71 - smart-matching a subset returns a Bool (2)
ok 72 - subset names with many parts work
ok 73 - Cannot violate Int::Positive constraint
not ok 74 - Array of subset type as parameter to function # TODO Parameterized subs do not take Array of subset types
# Failed test 'Array of subset type as parameter to function'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-subset/subtypes.rakudo line 271
# Constraint type check failed in binding to parameter '@a'; expected PInt but got Array[PInt] (Array[PInt].new(2, 3))
ok 75 - error message mentions subset name
ok 76 - my str subset MyStr creates basically a type alias (1)
ok 77 - my str subset MyStr creates basically a type alias (2)
ok 78 - Ints are not in there
ok 79 - subset in signature cannot use non-predeclared variable
    1..2
    ok 1 - '
    #         subset Tiny of Any where ^3;
    #         my Tiny $foo;
    #         $foo = 42; say $foo;
    #     ' died
    ok 2 - right exception type (X::TypeCheck)
ok 80 - code dies with right exception
ok 81 - code runs without error (and does not mention "Obsolete"!)
ok 82 - ASubType:D dies if passed type object
ok 83 - ASubType:D dies if passed non-matching concrete value
ok 84 - ASubType:D passes if passed matching concrete value
    1..2
    ok 1 - dispatch does not die
    ok 2 - dispatch happened in right order
ok 85 - multi with :D subset dispatches correctly
ok 86 - where constraint on |c parameter works
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck::Binding::Parameter)
ok 87 - where constraint on |c parameter is enforced
ok 88 - UInt:D parameter doesn't fail in a multi
    1..3
        1..22
            1..2
            ok 1 - 'b1 "x"' died
            ok 2 - right exception type (X::TypeCheck::Binding::Parameter)
        ok 1 - rejected by where, type
            1..2
            ok 1 - 'b1 2.2' died
            ok 2 - right exception type (X::TypeCheck::Binding::Parameter)
        ok 2 - rejected by where, type (2)
            1..2
            ok 1 - 'b2 2.2' died
            ok 2 - right exception type (X::TypeCheck::Binding::Parameter)
        ok 3 - rejected by where, type (3)
            1..2
            ok 1 - 'b4 i' died
            ok 2 - right exception type (X::TypeCheck::Binding::Parameter)
        ok 4 - rejected by where, type (4)
            1..2
            ok 1 - 'b2 Num' died
            ok 2 - right exception type (X::TypeCheck::Binding::Parameter)
        ok 5 - rejected by where, definiteness
            1..2
            ok 1 - 'b4 Num' died
            ok 2 - right exception type (X::TypeCheck::Binding::Parameter)
        ok 6 - rejected by where, definiteness (2)
            1..2
            ok 1 - 'b3 42' died
            ok 2 - right exception type (X::TypeCheck::Binding::Parameter)
        ok 7 - rejected by where, definiteness (3)
            1..2
            ok 1 - 'b2 $*VM' died
            ok 2 - right exception type (X::TypeCheck::Binding::Parameter)
        ok 8 - rejected by type, type
            1..2
            ok 1 - 'b3 Num' died
            ok 2 - right exception type (X::Parameter::InvalidConcreteness)
        ok 9 - rejected by type, definiteness
            1..2
            ok 1 - 'b4 Any' died
            ok 2 - right exception type (X::TypeCheck::Binding::Parameter)
        ok 10 - rejected by coercer, source type
            1..2
            ok 1 - 'b4 "x"' died
            ok 2 - right exception type (X::TypeCheck::Binding::Parameter)
        ok 11 - rejected by coercer, target type
        ok 12 - accepted (1)
        ok 13 - accepted (2)
        ok 14 - accepted (3)
        ok 15 - accepted (4)
        ok 16 - accepted (5)
        ok 17 - accepted (6)
        ok 18 - accepted (7)
        ok 19 - accepted (8)
        ok 20 - accepted (9)
        ok 21 - accepted (10)
        ok 22 - accepted (11)
    ok 1 - routine sig
        1..14
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 1 - rejected by where, type
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 2 - rejected by where, type (2)
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 3 - rejected by where, type (3)
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 4 - rejected by where, definiteness
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 5 - rejected by where, definiteness (3)
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 6 - rejected by type, type
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 7 - rejected by type, definiteness
        ok 8 - accepted (1)
        ok 9 - accepted (2)
        ok 10 - accepted (3)
        ok 11 - accepted (4)
        ok 12 - accepted (5)
        ok 13 - accepted (6)
        ok 14 - accepted (7)
    ok 2 - variables
        1..14
        ok 1 - rejected by where, type
        ok 2 - rejected by where, type (2)
        ok 3 - rejected by where, type (3)
        ok 4 - rejected by where, definiteness
        ok 5 - rejected by where, definiteness (3)
        ok 6 - rejected by type, type
        ok 7 - rejected by type, definiteness
        ok 8 - accepted (1)
        ok 9 - accepted (2)
        ok 10 - accepted (3)
        ok 11 - accepted (4)
        ok 12 - accepted (5)
        ok 13 - accepted (6)
        ok 14 - accepted (7)
    ok 3 - subset
ok 89 - "any" Junction of types in where
    1..6
    ok 1 - stored $a
    ok 2 - stored $b
    ok 3 - stored b
    ok 4 - stored $d
        1..5
            1..2
            ok 1 - 'my ($ where 2)  = 3' died
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 1 - anon where literal
            1..2
            ok 1 - 'my ($a where 2) = 3' died
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 2 - where literal
            1..2
            ok 1 - 'my ($b where Int) = .1' died
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 3 - where type
            1..2
            ok 1 - 'my (\b where "x") = "y"' died
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 4 - sigilless where literal
            1..2
            ok 1 - 'my ("foo") = "bar"' died
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 5 - literal
    ok 5 - single-arg
        1..5
            1..2
            ok 1 - 'my ($ where 2, $b where Int ) = 3, 4' died
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 1 - anon where literal
            1..2
            ok 1 - 'my ($a where 2, $b where Int) = 3, .1' died
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 2 - where literal
            1..2
            ok 1 - 'my ($a where 2, $b where Int) = 3, .1' died
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 3 - where type
            1..2
            ok 1 - 'my (\b where "x", "foo") = "y", "foo"' died
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 4 - sigilless where literal
            1..2
            ok 1 - 'my (\b where "x", "foo") = "x", "bar"' died
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 5 - literal
    ok 6 - multi-arg
ok 90 - postconstraints on variables in my (...)
    1..6
        1..12
        ok 1 - pos
        ok 2 - pos arg
        ok 3 - neg
        ok 4 - neg arg
        ok 5 - pos block
        ok 6 - pos arg block
        ok 7 - neg block
        ok 8 - neg arg block
        ok 9 - pos Whatever
        ok 10 - pos arg Whatever
        ok 11 - neg Whatever
        ok 12 - neg arg Whatever
    ok 1 - subset
        1..12
        ok 1 - pos
        ok 2 - pos arg
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 3 - neg
        ok 4 - neg arg
        ok 5 - pos block
        ok 6 - pos arg block
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 7 - neg block
        ok 8 - neg arg block
        ok 9 - pos Whatever
        ok 10 - pos arg Whatever
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 11 - neg Whatever
        ok 12 - neg arg Whatever
    ok 2 - my
        1..12
        ok 1 - sub called with right arg value [sub]
        ok 2 - pos arg
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::TypeCheck)
        ok 3 - neg
        ok 4 - neg arg
        ok 5 - sub called with right arg value [block]
        ok 6 - pos arg block
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::TypeCheck)
        ok 7 - neg block
        ok 8 - neg arg block
        ok 9 - sub called with right arg value [Whatever]
        ok 10 - pos arg wat
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::TypeCheck)
        ok 11 - neg wat
        ok 12 - neg arg wat
    ok 3 - sub signature, simple
        1..12
        ok 1 - sub called with right arg value [sub]
        ok 2 - pos arg
        ok 3 - neg
        ok 4 - neg arg
        ok 5 - sub called with right arg value [block]
        ok 6 - pos arg block
        ok 7 - neg block
        ok 8 - neg arg block
        ok 9 - sub called with right arg value [Whatever]
        ok 10 - pos arg Whatever
        ok 11 - neg Whatever
        ok 12 - neg arg Whatever
    ok 4 - sub signature, multi-dispatch
        1..21
        ok 1 - method called w/right arg val [sub]
        ok 2 - pos arg
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::TypeCheck)
        ok 3 - neg
        ok 4 - neg arg
        ok 5 - method called w/right val in $x [sub]
        ok 6 - method called w/right val in $y [sub]
        ok 7 - pos arg in wild method
        ok 8 - method called w/right arg val [block]
        ok 9 - pos arg block
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::TypeCheck)
        ok 10 - neg block
        ok 11 - neg arg block
        ok 12 - method called w/right val in $x [block]
        ok 13 - method called w/right val in $y [block]
        ok 14 - pos arg in wild method block
        ok 15 - method called w/right arg val [Whatever]
        ok 16 - pos arg Whatever
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::TypeCheck)
        ok 17 - neg Whatever
        ok 18 - neg arg Whatever
        ok 19 - method called w/right val in $x [Whatever]
        ok 20 - method called w/right val in $y [Whatever]
        ok 21 - pos arg in wild method Whatever
    ok 5 - method signature, fancy
        1..6
        ok 1 - sig matches capture [sub]
        ok 2 - pos arg [sub]
        ok 3 - sig matches capture [block]
        ok 4 - pos arg [block]
        ok 5 - sig matches capture [Whatever]
        ok 6 - pos arg [Whatever]
    ok 6 - detached signature object
ok 91 - `&`- sigiled variable be used in where
# FUDGED!
1..5
not ok 1 - &method is implemented, consider unfudging this test # TODO Canary test for &method
# Failed test '&method is implemented, consider unfudging this test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S13-syntax/aliasing.rakudo line 10
# Error: Undeclared routine:
#     bar used at line 1. Did you mean 'bag', 'VAR'?
# 
not ok 2 - ::= is implemented, consider unfudging this test # TODO Canary test for ::=
# Failed test '::= is implemented, consider unfudging this test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S13-syntax/aliasing.rakudo line 13
# Error: "::=" not yet implemented. Sorry.
not ok 3 - non-compiling test # TODO Requires &method and ::= to be implemented
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S13-syntax/aliasing.rakudo line 41
not ok 4 - non-compiling test # TODO Requires &method and ::= to be implemented
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S13-syntax/aliasing.rakudo line 41
not ok 5 - non-compiling test # TODO Requires &method and ::= to be implemented
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S13-syntax/aliasing.rakudo line 41
# FUDGED!
1..28
ok 1 - imperative does to apply a parametrized role (1)
ok 2 - attribute was initialized correctly (1)
ok 3 - .HOW.does gives correct information (1-1)
ok 4 - .^does gives correct information (1-1)
ok 5 - .HOW.does gives correct information (1-2)
ok 6 - .^does gives correct information (1-2)
ok 7 - imperative does to apply a parametrized role (2)
ok 8 - attribute was initialized correctly (2)
ok 9 - .HOW.does gives correct information (2-1)
ok 10 - .^does gives correct information (2-1)
ok 11 - .HOW.does gives correct information (2-2)
ok 12 - .^does gives correct information (2-2)
ok 13 - imperative does to apply a parametrized role (3)
ok 14 - .HOW.does gives correct information (3-1)
ok 15 - .^does gives correct information (3-1)
ok 16 - .HOW.does gives correct information (3-2)
ok 17 - .^does gives correct information (3-2)
ok 18 - type information was processed correctly (1)
ok 19 - type information was processed correctly (2)
ok 20 - imperative does to apply a parametrized role (4)
ok 21 - .HOW.does gives correct information (4-1)
ok 22 - .^does gives correct information (4-1)
not ok 23 - .HOW.does gives correct information (4-3) # TODO .does with parametric roles
# Failed test '.HOW.does gives correct information (4-3)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S14-roles/parameterized-mixin.rakudo line 96
not ok 24 - .^does gives correct information (4-3) # TODO .does with parametric roles
# Failed test '.^does gives correct information (4-3)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S14-roles/parameterized-mixin.rakudo line 98
ok 25 - .type works correctly
ok 26 - .name works correctly
ok 27 - Parametric role used first time uses correct default value
ok 28 - Parametric role used a second time uses correct default value
# FUDGED!
1..16
ok 1 - can call sub that has had a trait applied to it by role name with arg
ok 2 - description role applied and set with argument
ok 3 - can call sub that has had a trait applied to it by role name without arg
ok 4 - description role applied without argument
ok 5 - can call sub that has had a trait applied to it by named param with arg
ok 6 - named trait handler applied other role set with argument
ok 7 - can call sub that has had a trait applied to it by named param without arg
ok 8 - named trait handler applied other role without argument
ok 9 - Can call subroutine that was wrapped by a trait
not ok 10 - and the wrapper has been called once # TODO trait mod / .wrap interaction
# Failed test 'and the wrapper has been called once'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S14-traits/routines.rakudo line 51
# expected: 'wrap'
#      got: ''
ok 11 - [BUG] multi without proto gets wrong lexical lookup chain (RT  \#112664)
ok 12 - declaration of a sub with an unknown trait mentions trait_mod:<is> in dispatch error
ok 13 - wrapping a routine at compile time makes it soft
ok 14 - Applying traits to submethods works
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Method::NotFound)
ok 15 - Applying traits to submethods retains submethod semantics
ok 16 - interaction of mixin to routine with array attribute and wrap is correct
# FUDGED!
1..4
ok 1 - Reading UTF-8 file as NFG (one grapheme)
ok 2 - Reading UTF-8 file as NFG (a few graphemes)
ok 3 - # SKIP writing utf16 NYI
ok 4 - # SKIP writing utf16 NYI
# FUDGED!
1..10
ok 1 - # SKIP NFC quoting adverb NYI RT  \#124995
ok 2 - # SKIP NFC quoting adverb NYI RT  \#124995
ok 3 - # SKIP NFC quoting adverb NYI RT  \#124995
ok 4 - # SKIP NFC quoting adverb NYI RT  \#124995
ok 5 - # SKIP NFC quoting adverb NYI RT  \#124995
ok 6 - # SKIP NFD quoting adverb NYI RT  \#124996
ok 7 - # SKIP NFD quoting adverb NYI RT  \#124996
ok 8 - # SKIP NFD quoting adverb NYI RT  \#124996
ok 9 - # SKIP NFD quoting adverb NYI RT  \#124996
ok 10 - # SKIP NFD quoting adverb NYI RT  \#124996
# FUDGED!
1..10
ok 1 - # SKIP NFKC type NYI RT  \#124989
ok 2 - # SKIP NFKC type NYI RT  \#124989
ok 3 - # SKIP NFKC type NYI RT  \#124989
ok 4 - # SKIP NFKC type NYI RT  \#124989
ok 5 - # SKIP NFKC type NYI RT  \#124989
ok 6 - # SKIP NFKD type NYI
ok 7 - # SKIP NFKD type NYI
ok 8 - # SKIP NFKD type NYI
ok 9 - # SKIP NFKD type NYI
ok 10 - # SKIP NFKD type NYI
# FUDGED!
1..4
ok 1 - Strings are of type Str by default.
ok 2 - # SKIP :nfg adverb NYI
ok 3 - Str.chars returns number of graphemes.
ok 4 - Str.ord returns first NFC codepoint for NFG grapheme
# FUDGED!
1..48
ok 1 - uniname an empty string yields Nil
ok 2 - uninames an empty string yields an empty list
ok 3 - ''.uniname yields Nil
ok 4 - ''.uninames yields an empty list
    1..2
    ok 1 - 'uniname Str' died
    ok 2 - right exception type (X::Multi::NoMatch)
ok 5 - cannot call uniname with a Str
    1..2
    ok 1 - 'Str.uniname' died
    ok 2 - right exception type (X::Multi::NoMatch)
ok 6 - cannot call uniname with a Str
    1..2
    ok 1 - 'uniname Int' died
    ok 2 - right exception type (X::Multi::NoMatch)
ok 7 - cannot call uniname with a Int
    1..2
    ok 1 - 'Int.uniname' died
    ok 2 - right exception type (X::Multi::NoMatch)
ok 8 - cannot call uniname with a Int
ok 9 - method uniname returns a name
ok 10 - method uniname works in string form
ok 11 - uniname returns a name
ok 12 - uniname works in string form
ok 13 - string version of uniname converts to NFG strings to NFC
ok 14 - uniname() returns current Unicode name for graphic character.
ok 15 - uniname() returns codepoint label for control character without a current name.
ok 16 - uniname() on character with current & Unicode 1 name returns current name.
ok 17 - uniname() returns current Unicode name for formatting character.
ok 18 - uniname() returns codepoint label for control character without any name.
ok 19 - # SKIP :one NYI
ok 20 - # SKIP :one NYI
ok 21 - # SKIP :one NYI
ok 22 - # SKIP :one NYI
ok 23 - # SKIP :one NYI
ok 24 - # SKIP :either NYI
ok 25 - # SKIP :either NYI
ok 26 - # SKIP :either NYI
ok 27 - # SKIP :either NYI
ok 28 - # SKIP :either NYI
ok 29 - # SKIP :either and :one NYI
ok 30 - # SKIP :either and :one NYI
ok 31 - # SKIP :either and :one NYI
ok 32 - # SKIP :either and :one NYI
ok 33 - # SKIP :either and :one NYI
ok 34 - uniname with negative returns <illegal> (1)
ok 35 - uniname with negative returns <illegal> (2)
ok 36 - uniname too high returns <unassigned> (1)
ok 37 - uniname too high returns <unassigned> (2)
ok 38 - uninames correctly works on every character
ok 39 - uninames correctly works on every character
ok 40 - Can resolve Unicode 9 character name
ok 41 - Supports composed Hangul Syllable names
ok 42 - U+4FFE is 'CJK UNIFIED IDEOGRAPH-4FFE>
    1..98
    ok 1 - nonchar
    ok 2 - nonchar
    ok 3 - nonchar
    ok 4 - nonchar
    ok 5 - nonchar
    ok 6 - nonchar
    ok 7 - nonchar
    ok 8 - nonchar
    ok 9 - nonchar
    ok 10 - nonchar
    ok 11 - nonchar
    ok 12 - nonchar
    ok 13 - nonchar
    ok 14 - nonchar
    ok 15 - nonchar
    ok 16 - nonchar
    ok 17 - nonchar
    ok 18 - nonchar
    ok 19 - nonchar
    ok 20 - nonchar
    ok 21 - nonchar
    ok 22 - nonchar
    ok 23 - nonchar
    ok 24 - nonchar
    ok 25 - nonchar
    ok 26 - nonchar
    ok 27 - nonchar
    ok 28 - nonchar
    ok 29 - nonchar
    ok 30 - nonchar
    ok 31 - nonchar
    ok 32 - nonchar
    ok 33 - codepoint below U+FDD0 is not a noncharacter
    ok 34 - codepoint after U+FDEF is not a noncharacter
    ok 35 - U+1FFFD is a not a noncharacter
    ok 36 - U+1FFFE is a noncharacter
    ok 37 - U+1FFFF is a noncharacter
    ok 38 - U+20000 is a not a noncharacter
    ok 39 - U+2FFFD is a not a noncharacter
    ok 40 - U+2FFFE is a noncharacter
    ok 41 - U+2FFFF is a noncharacter
    ok 42 - U+30000 is a not a noncharacter
    ok 43 - U+3FFFD is a not a noncharacter
    ok 44 - U+3FFFE is a noncharacter
    ok 45 - U+3FFFF is a noncharacter
    ok 46 - U+40000 is a not a noncharacter
    ok 47 - U+4FFFD is a not a noncharacter
    ok 48 - U+4FFFE is a noncharacter
    ok 49 - U+4FFFF is a noncharacter
    ok 50 - U+50000 is a not a noncharacter
    ok 51 - U+5FFFD is a not a noncharacter
    ok 52 - U+5FFFE is a noncharacter
    ok 53 - U+5FFFF is a noncharacter
    ok 54 - U+60000 is a not a noncharacter
    ok 55 - U+6FFFD is a not a noncharacter
    ok 56 - U+6FFFE is a noncharacter
    ok 57 - U+6FFFF is a noncharacter
    ok 58 - U+70000 is a not a noncharacter
    ok 59 - U+7FFFD is a not a noncharacter
    ok 60 - U+7FFFE is a noncharacter
    ok 61 - U+7FFFF is a noncharacter
    ok 62 - U+80000 is a not a noncharacter
    ok 63 - U+8FFFD is a not a noncharacter
    ok 64 - U+8FFFE is a noncharacter
    ok 65 - U+8FFFF is a noncharacter
    ok 66 - U+90000 is a not a noncharacter
    ok 67 - U+9FFFD is a not a noncharacter
    ok 68 - U+9FFFE is a noncharacter
    ok 69 - U+9FFFF is a noncharacter
    ok 70 - U+A0000 is a not a noncharacter
    ok 71 - U+AFFFD is a not a noncharacter
    ok 72 - U+AFFFE is a noncharacter
    ok 73 - U+AFFFF is a noncharacter
    ok 74 - U+B0000 is a not a noncharacter
    ok 75 - U+BFFFD is a not a noncharacter
    ok 76 - U+BFFFE is a noncharacter
    ok 77 - U+BFFFF is a noncharacter
    ok 78 - U+C0000 is a not a noncharacter
    ok 79 - U+CFFFD is a not a noncharacter
    ok 80 - U+CFFFE is a noncharacter
    ok 81 - U+CFFFF is a noncharacter
    ok 82 - U+D0000 is a not a noncharacter
    ok 83 - U+DFFFD is a not a noncharacter
    ok 84 - U+DFFFE is a noncharacter
    ok 85 - U+DFFFF is a noncharacter
    ok 86 - U+E0000 is a not a noncharacter
    ok 87 - U+EFFFD is a not a noncharacter
    ok 88 - U+EFFFE is a noncharacter
    ok 89 - U+EFFFF is a noncharacter
    ok 90 - U+F0000 is a not a noncharacter
    ok 91 - U+FFFFD is a not a noncharacter
    ok 92 - U+FFFFE is a noncharacter
    ok 93 - U+FFFFF is a noncharacter
    ok 94 - U+100000 is a not a noncharacter
    ok 95 - U+10FFFD is a not a noncharacter
    ok 96 - U+10FFFE is a noncharacter
    ok 97 - U+10FFFF is a noncharacter
    ok 98 - U+110000 is a not a noncharacter
ok 43 - Noncharacters
ok 44 - 0x10FFFF is <noncharacter-10FFFF>
ok 45 - Codepoints higher than 0x10FFFF return <unassigned>
ok 46 - Codepoints higher than 0x10FFFF return <unassigned>
ok 47 - Unassigned codepoints below 0x10FFFF return <reserved-XXXX>
ok 48 - Codepoints lower than 0x0 return <illegal>
# FUDGED!
1..11
ok 1 - IO.modified should be greater than pre-creation timestamp
ok 2 - IO.changed should be greater than pre-creation timestamp
ok 3 - IO.accessed should be greater than pre-creation timestamp
ok 4 - IO.modified should be updated when file content changes
ok 5 - IO.changed should be updated when file content changes
ok 6 - # SKIP TODO figure out a better way for noatime systems
ok 7 - IO.modified should NOT be updated when file mode is altered
ok 8 - IO.changed should be updated when file mode is altered
ok 9 - IO.changed and IO.modified should differ after file mode change
ok 10 - Test file temp-16-filehandles-filestat-56244-1.temp was successfully removed
ok 11 - Test file temp-16-filehandles-filestat-56244-2.temp was successfully removed
# FUDGED!
1..128
ok 1 - file test from before spec revision 27503 is error
ok 2 - ~~:d returns true on directories
ok 3 - can :d-test against non-existing dir and live
ok 4 - can :d-test against non-existing dir and return false
ok 5 - ~~:f returns true on files
ok 6 - ~~:e returns true on files
ok 7 - ~~:e returns true on directories
ok 8 - ~~:r returns true on readable files
ok 9 - ~~:w returns true on writable files
ok 10 - # SKIP 'rakudo-m' is not present (interactive mode?)
ok 11 - ~~:x returns true on cwd()able directories
ok 12 - ~~:f returns false on directories
ok 13 - ~~:r returns true on a readable directory
ok 14 - ~~:d returns false on non-existent directories
ok 15 - ~~:r returns false on non-existent directories
ok 16 - ~~:w returns false on non-existent directories
ok 17 - ~~:x returns false on non-existent directories
ok 18 - ~~:f returns false on non-existent directories
ok 19 - ~~:f returns false on non-existent files
ok 20 - ~~:r returns false on non-existent files
ok 21 - ~~:w returns false on non-existent files
ok 22 - ~~:x returns false on non-existent files
ok 23 - ~~:f returns false on non-existent files
ok 24 - ~~:s returns size on existent files
ok 25 - ~~:s returns false on non-existent files
ok 26 - ~~:z returns false on existent files
ok 27 - ~~:z returns false on non-existent files
ok 28 - ~~:z returns inverse boolified size on directories
ok 29 - ~~:z returns true for an empty file
ok 30 - # SKIP :M, :C, :A
ok 31 - # SKIP :M, :C, :A
ok 32 - # SKIP :M, :C, :A
ok 33 - # SKIP no file README
ok 34 - # SKIP no file README
ok 35 - # SKIP no file README
ok 36 - # SKIP :M, :C, :A
ok 37 - # SKIP :M, :C, :A
ok 38 - # SKIP :M, :C, :A
ok 39 - f(...) works
ok 40 - - f(...) does not call the ~~:f filetest
ok 41 - - f(...) does not call the ~~:f filetest
ok 42 - can :l-test against non-existing file and live
ok 43 - ~~:l returns false on non-existent files
ok 44 - .l on broken symlinks gives True
    1..2
    ok 1 - code returned a Failure
        1..2
        ok 1 - code dies
        ok 2 - right exception type (X::IO::DoesNotExist)
    ok 2 - Failure threw when sunk
ok 45 - .z fails for non-existent files
ok 46 - .z returns True for empty files
ok 47 - .z return False for non-empty files
ok 48 - .z can be called on directories
ok 49 - .r is True with 0777 mode
ok 50 - ~~ :r is True with 0777 mode
ok 51 - .r is True with 0666 mode
ok 52 - ~~ :r is True with 0666 mode
ok 53 - .r is True with 0555 mode
ok 54 - ~~ :r is True with 0555 mode
ok 55 - .r is True with 0444 mode
ok 56 - ~~ :r is True with 0444 mode
ok 57 - .r is False with 0333 mode
ok 58 - ~~ :r is False with 0333 mode
ok 59 - .r is False with 0222 mode
ok 60 - ~~ :r is False with 0222 mode
ok 61 - .r is False with 0111 mode
ok 62 - ~~ :r is False with 0111 mode
ok 63 - .r is False with 00 mode
ok 64 - ~~ :r is False with 00 mode
ok 65 - .w is True with 0777 mode
ok 66 - ~~ :w is True with 0777 mode
ok 67 - .w is True with 0666 mode
ok 68 - ~~ :w is True with 0666 mode
ok 69 - .w is False with 0555 mode
ok 70 - ~~ :w is False with 0555 mode
ok 71 - .w is False with 0444 mode
ok 72 - ~~ :w is False with 0444 mode
ok 73 - .w is True with 0333 mode
ok 74 - ~~ :w is True with 0333 mode
ok 75 - .w is True with 0222 mode
ok 76 - ~~ :w is True with 0222 mode
ok 77 - .w is False with 0111 mode
ok 78 - ~~ :w is False with 0111 mode
ok 79 - .w is False with 00 mode
ok 80 - ~~ :w is False with 00 mode
ok 81 - .x is True with 0777 mode
ok 82 - ~~ :x is True with 0777 mode
ok 83 - .x is False with 0666 mode
ok 84 - ~~ :x is False with 0666 mode
ok 85 - .x is True with 0555 mode
ok 86 - ~~ :x is True with 0555 mode
ok 87 - .x is False with 0444 mode
ok 88 - ~~ :x is False with 0444 mode
ok 89 - .x is True with 0333 mode
ok 90 - ~~ :x is True with 0333 mode
ok 91 - .x is False with 0222 mode
ok 92 - ~~ :x is False with 0222 mode
ok 93 - .x is True with 0111 mode
ok 94 - ~~ :x is True with 0111 mode
ok 95 - .x is False with 00 mode
ok 96 - ~~ :x is False with 00 mode
ok 97 - .rw is True with 0777 mode
ok 98 - ~~ :rw is True with 0777 mode
ok 99 - .rw is True with 0666 mode
ok 100 - ~~ :rw is True with 0666 mode
ok 101 - .rw is False with 0555 mode
ok 102 - ~~ :rw is False with 0555 mode
ok 103 - .rw is False with 0444 mode
ok 104 - ~~ :rw is False with 0444 mode
ok 105 - .rw is False with 0333 mode
ok 106 - ~~ :rw is False with 0333 mode
ok 107 - .rw is False with 0222 mode
ok 108 - ~~ :rw is False with 0222 mode
ok 109 - .rw is False with 0111 mode
ok 110 - ~~ :rw is False with 0111 mode
ok 111 - .rw is False with 00 mode
ok 112 - ~~ :rw is False with 00 mode
ok 113 - .rwx is True with 0777 mode
ok 114 - ~~ :rwx is True with 0777 mode
ok 115 - .rwx is False with 0666 mode
ok 116 - ~~ :rwx is False with 0666 mode
ok 117 - .rwx is False with 0555 mode
ok 118 - ~~ :rwx is False with 0555 mode
ok 119 - .rwx is False with 0444 mode
ok 120 - ~~ :rwx is False with 0444 mode
ok 121 - .rwx is False with 0333 mode
ok 122 - ~~ :rwx is False with 0333 mode
ok 123 - .rwx is False with 0222 mode
ok 124 - ~~ :rwx is False with 0222 mode
ok 125 - .rwx is False with 0111 mode
ok 126 - ~~ :rwx is False with 0111 mode
ok 127 - .rwx is False with 00 mode
ok 128 - ~~ :rwx is False with 00 mode
# FUDGED!
1..1
not ok 1 - IO::Socket::INet.getpeername works # TODO getpeername is not implemented yet
# Failed test 'IO::Socket::INet.getpeername works'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S16-unfiled/getpeername.rakudo line 17
# FUDGED!
1..2
ok 1 - # SKIP contextual rebinding regression
ok 2 - # SKIP contextual rebinding regression
# FUDGED!
1..47
ok 1 - The object is-a 'Proc::Async'
ok 2 - 
ok 3 - 
ok 4 - program not yet started
ok 5 - Not opened for writing
ok 6 - The object is-a 'Promise'
ok 7 - program has been started
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Proc::Async::AlreadyStarted)
ok 8 - did we throws-like X::Proc::Async::AlreadyStarted?
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Proc::Async::OpenForWriting)
    ok 3 - .method matches print
ok 9 - did we throws-like X::Proc::Async::OpenForWriting?
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Proc::Async::OpenForWriting)
    ok 3 - .method matches say
ok 10 - did we throws-like X::Proc::Async::OpenForWriting?
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Proc::Async::OpenForWriting)
    ok 3 - .method matches write
ok 11 - did we throws-like X::Proc::Async::OpenForWriting?
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Proc::Async::TapBeforeSpawn)
    ok 3 - .handle matches stdout
ok 12 - did we throws-like X::Proc::Async::TapBeforeSpawn?
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Proc::Async::TapBeforeSpawn)
    ok 3 - .handle matches stderr
ok 13 - did we throws-like X::Proc::Async::TapBeforeSpawn?
ok 14 - pid method returns a Promise
ok 15 - Can get the process ID
ok 16 - was ready kept after succesful execution
ok 17 - The object is-a 'Proc'
ok 18 - was execution successful
ok 19 - is the status ok
ok 20 - did we get STDOUT
ok 21 - did we get STDERR
ok 22 - opened for writing
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Proc::Async::MustBeStarted)
    ok 3 - .method matches close-stdin
ok 23 - did we throws-like X::Proc::Async::MustBeStarted?
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Proc::Async::MustBeStarted)
    ok 3 - .method matches kill
ok 24 - did we throws-like X::Proc::Async::MustBeStarted?
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Proc::Async::MustBeStarted)
    ok 3 - .method matches say
ok 25 - did we throws-like X::Proc::Async::MustBeStarted?
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Proc::Async::MustBeStarted)
    ok 3 - .method matches print
ok 26 - did we throws-like X::Proc::Async::MustBeStarted?
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Proc::Async::MustBeStarted)
    ok 3 - .method matches write
ok 27 - did we throws-like X::Proc::Async::MustBeStarted?
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Proc::Async::CharsOrBytes)
    ok 3 - .handle matches stdout
ok 28 - did we throws-like X::Proc::Async::CharsOrBytes?
ok 29 - .write returned a promise
ok 30 - .print returned a promise
ok 31 - external program still running (stdin still open)
ok 32 - # SKIP returns Nil (flapping tests)
ok 33 - # SKIP returns Nil (flapping tests)
ok 34 - # SKIP returns Nil (flapping tests)
ok 35 - Proc returned from .start has correct .command
ok 36 - Proc::Async.command has correct args
ok 37 - Tapping stdout supply after start of process does not lose data
ok 38 - Process that doesn't output anything does not emit
ok 39 - \r\n is translated in character mode to \n
ok 40 - .new slurps all args, including command
ok 41 - .Supply gives merged stdout/stderr
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Proc::Async::SupplyOrStd)
ok 42 - Cannot do .stdout after .Supply
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Proc::Async::SupplyOrStd)
ok 43 - Cannot do .stderr after .Supply
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Proc::Async::SupplyOrStd)
ok 44 - Cannot do .Supply after stdout
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Proc::Async::SupplyOrStd)
ok 45 - Cannot do .Supply after stderr
    1..3
    ok 1 - stdout is good
    ok 2 - stderr is empty
    ok 3 - exit code successful
ok 46 - .new accepts command + args via a single Iterable arg
    1..4
    ok 1 - # SKIP No way to portably determine arg0 on *nix.
    ok 2 - # SKIP No way to portably determine arg0 on *nix.
    ok 3 - # SKIP No way to portably determine arg0 on *nix.
    ok 4 - # SKIP No way to portably determine arg0 on *nix.
ok 47 - Specifying ARG0 via separate arg works.
# FUDGED!
1..16
ok 1 - could we write the tester
ok 2 - did the tester arrive ok
ok 3 - The object is-a 'Proc::Async'
ok 4 - 
ok 5 - 
ok 6 - STDOUT should be empty
ok 7 - STDERR should be empty
ok 8 - The object is-a 'Promise'
ok 9 - The object is-a 'Promise'
ok 10 - The object is-a 'Promise'
ok 11 - did the close of STDIN work
ok 12 - # SKIP Flapping tests
ok 13 - # SKIP Flapping tests
ok 14 - # SKIP Flapping tests
ok 15 - # SKIP Flapping tests
ok 16 - # SKIP Flapping tests
# FUDGED!
1..34
ok 1 - ThreadPoolScheduler does Scheduler role
ok 2 - ThreadPoolScheduler returns a value before cuing
ok 3 - # SKIP waiting for new '.loads' semantics
ok 4 - # SKIP waiting for new '.loads' semantics
ok 5 - # SKIP waiting for new '.loads' semantics
ok 6 - # SKIP waiting for new '.loads' semantics
ok 7 - # SKIP waiting for new '.loads' semantics
ok 8 - # SKIP waiting for new '.loads' semantics
ok 9 - # SKIP waiting for new '.loads' semantics
ok 10 - # SKIP waiting for new '.loads' semantics
ok 11 - # SKIP waiting for new '.loads' semantics
ok 12 - # SKIP waiting for new '.loads' semantics
ok 13 - ThreadPoolScheduler cannot combine :in and :at
ok 14 - ThreadPoolScheduler cannot combine :every with :in and :at
ok 15 - ThreadPoolScheduler cannot combine :catch with :in and :at
ok 16 - ThreadPoolScheduler cannot combine :every/:catch with :in and :at
ok 17 - ThreadPoolScheduler cannot combine :every, :times and :stop
ok 18 - CurrentThreadScheduler does Scheduler role
ok 19 - Cued code on CurrentThreadScheduler ran
ok 20 - can we cancel (1)
ok 21 - Code was cued to CurrentThreadScheduler by default
ok 22 - can we cancel (2)
ok 23 - CurrentThreadScheduler setting uncaught_handler works
ok 24 - CurrentThreadScheduler passed correct exception to handler
ok 25 - can we cancel (3)
ok 26 - Code run on CurrentThreadScheduler, then handler
ok 27 - can we cancel (4)
ok 28 - Catch handler on CurrentThreadScheduler not run if no error
ok 29 - CurrentThreadScheduler cannot specify :every in CurrentThreadScheduler
ok 30 - CurrentThreadScheduler cannot combine :in and :at
ok 31 - CurrentThreadScheduler cannot combine :every with :in and :at
ok 32 - CurrentThreadScheduler cannot combine :catch with :in and :at
ok 33 - CurrentThreadScheduler cannot combine :every/:catch with :in and :at
ok 34 - CurrentThreadScheduler cannot combine :every, :times and :stop
# FUDGED!
1..13
ok 1 - can not be called as a class method
ok 2 - # SKIP doesn't work or can't test
ok 3 - # SKIP doesn't work or can't test
ok 4 - # SKIP doesn't work or can't test
ok 5 - # SKIP doesn't work or can't test
ok 6 - delaying by 0 is a noop
    1..5
    ok 1 - Supply appears to be doing Supply
    ok 2 - Supply appears to NOT be live
    ok 3 - noop delay got a tap
    ok 4 - noop delay was really done
    ok 5 - noop delay
ok 7 - noop delay
ok 8 - # SKIP doesn't work or can't test
ok 9 - # SKIP doesn't work or can't test
ok 10 - # SKIP doesn't work or can't test
ok 11 - # SKIP doesn't work or can't test
ok 12 - delaying by 0 is a noop
    1..5
    ok 1 - Supply appears to be doing Supply
    ok 2 - Supply appears to NOT be live
    ok 3 - noop delay got a tap
    ok 4 - noop delay was really done
    ok 5 - noop delay
ok 13 - noop delay
# FUDGED!
1..32
ok 1 - can not be called as a class method
not ok 2 - no param version illegal # TODO only deprecated so far
# Failed test 'no param version illegal'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S17-supply/rotor.rakudo line 8
    1..5
    ok 1 - Supply appears to be doing Supply
    ok 2 - Supply appears to NOT be live
    ok 3 - we can rotor with negative gap got a tap
    ok 4 - we can rotor with negative gap was really done
    ok 5 - we can rotor with negative gap
ok 3 - we can rotor with negative gap
    1..5
    ok 1 - Supply appears to be doing Supply
    ok 2 - Supply appears to NOT be live
    ok 3 - we can rotor with negative gap without partial got a tap
    ok 4 - we can rotor with negative gap without partial was really done
    ok 5 - we can rotor with negative gap without partial
ok 4 - we can rotor with negative gap without partial
    1..5
    ok 1 - Supply appears to be doing Supply
    ok 2 - Supply appears to NOT be live
    ok 3 - we can rotor with negative gap with partial got a tap
    ok 4 - we can rotor with negative gap with partial was really done
    ok 5 - we can rotor with negative gap with partial
ok 5 - we can rotor with negative gap with partial
    1..5
    ok 1 - Supply appears to be doing Supply
    ok 2 - Supply appears to NOT be live
    ok 3 - we can rotor without gap with 3 got a tap
    ok 4 - we can rotor without gap with 3 was really done
    ok 5 - we can rotor without gap with 3
ok 6 - we can rotor without gap with 3
    1..5
    ok 1 - Supply appears to be doing Supply
    ok 2 - Supply appears to NOT be live
    ok 3 - we can rotor without gap without partial with 3 got a tap
    ok 4 - we can rotor without gap without partial with 3 was really done
    ok 5 - we can rotor without gap without partial with 3
ok 7 - we can rotor without gap without partial with 3
    1..5
    ok 1 - Supply appears to be doing Supply
    ok 2 - Supply appears to NOT be live
    ok 3 - we can rotor without gap with partial with 3 got a tap
    ok 4 - we can rotor without gap with partial with 3 was really done
    ok 5 - we can rotor without gap with partial with 3
ok 8 - we can rotor without gap with partial with 3
    1..5
    ok 1 - Supply appears to be doing Supply
    ok 2 - Supply appears to NOT be live
    ok 3 - we can rotor without gap with 3 => 0 got a tap
    ok 4 - we can rotor without gap with 3 => 0 was really done
    ok 5 - we can rotor without gap with 3 => 0
ok 9 - we can rotor without gap with 3 => 0
    1..5
    ok 1 - Supply appears to be doing Supply
    ok 2 - Supply appears to NOT be live
    ok 3 - we can rotor without gap without partial with 3 => 0 got a tap
    ok 4 - we can rotor without gap without partial with 3 => 0 was really done
    ok 5 - we can rotor without gap without partial with 3 => 0
ok 10 - we can rotor without gap without partial with 3 => 0
    1..5
    ok 1 - Supply appears to be doing Supply
    ok 2 - Supply appears to NOT be live
    ok 3 - we can rotor without gap with partial with 3 => 0 got a tap
    ok 4 - we can rotor without gap with partial with 3 => 0 was really done
    ok 5 - we can rotor without gap with partial with 3 => 0
ok 11 - we can rotor without gap with partial with 3 => 0
    1..5
    ok 1 - Supply appears to be doing Supply
    ok 2 - Supply appears to NOT be live
    ok 3 - we can rotor with positive gap got a tap
    ok 4 - we can rotor with positive gap was really done
    ok 5 - we can rotor with positive gap
ok 12 - we can rotor with positive gap
    1..5
    ok 1 - Supply appears to be doing Supply
    ok 2 - Supply appears to NOT be live
    ok 3 - we can rotor with positive gap without partial got a tap
    ok 4 - we can rotor with positive gap without partial was really done
    ok 5 - we can rotor with positive gap without partial
ok 13 - we can rotor with positive gap without partial
    1..5
    ok 1 - Supply appears to be doing Supply
    ok 2 - Supply appears to NOT be live
    ok 3 - we can rotor with positive gap with partial got a tap
    ok 4 - we can rotor with positive gap with partial was really done
    ok 5 - we can rotor with positive gap with partial
ok 14 - we can rotor with positive gap with partial
    1..5
    ok 1 - Supply appears to be doing Supply
    ok 2 - Supply appears to NOT be live
    ok 3 - we can rotor with multiple different gaps got a tap
    ok 4 - we can rotor with multiple different gaps was really done
    ok 5 - we can rotor with multiple different gaps
ok 15 - we can rotor with multiple different gaps
    1..5
    ok 1 - Supply appears to be doing Supply
    ok 2 - Supply appears to NOT be live
    ok 3 - we can rotor with multiple different gaps without partial got a tap
    ok 4 - we can rotor with multiple different gaps without partial was really done
    ok 5 - we can rotor with multiple different gaps without partial
ok 16 - we can rotor with multiple different gaps without partial
    1..5
    ok 1 - Supply appears to be doing Supply
    ok 2 - Supply appears to NOT be live
    ok 3 - we can rotor with multiple different gaps with partial got a tap
    ok 4 - we can rotor with multiple different gaps with partial was really done
    ok 5 - we can rotor with multiple different gaps with partial
ok 17 - we can rotor with multiple different gaps with partial
    1..5
    ok 1 - Supply appears to be doing Supply
    ok 2 - Supply appears to NOT be live
    ok 3 - we can rotor with negative gap got a tap
    ok 4 - we can rotor with negative gap was really done
    ok 5 - we can rotor with negative gap
ok 18 - we can rotor with negative gap
    1..5
    ok 1 - Supply appears to be doing Supply
    ok 2 - Supply appears to NOT be live
    ok 3 - we can rotor with negative gap without partial got a tap
    ok 4 - we can rotor with negative gap without partial was really done
    ok 5 - we can rotor with negative gap without partial
ok 19 - we can rotor with negative gap without partial
    1..5
    ok 1 - Supply appears to be doing Supply
    ok 2 - Supply appears to NOT be live
    ok 3 - we can rotor with negative gap with partial got a tap
    ok 4 - we can rotor with negative gap with partial was really done
    ok 5 - we can rotor with negative gap with partial
ok 20 - we can rotor with negative gap with partial
    1..5
    ok 1 - Supply appears to be doing Supply
    ok 2 - Supply appears to NOT be live
    ok 3 - we can rotor without gap with 3 got a tap
    ok 4 - we can rotor without gap with 3 was really done
    ok 5 - we can rotor without gap with 3
ok 21 - we can rotor without gap with 3
    1..5
    ok 1 - Supply appears to be doing Supply
    ok 2 - Supply appears to NOT be live
    ok 3 - we can rotor without gap without partial with 3 got a tap
    ok 4 - we can rotor without gap without partial with 3 was really done
    ok 5 - we can rotor without gap without partial with 3
ok 22 - we can rotor without gap without partial with 3
    1..5
    ok 1 - Supply appears to be doing Supply
    ok 2 - Supply appears to NOT be live
    ok 3 - we can rotor without gap with partial with 3 got a tap
    ok 4 - we can rotor without gap with partial with 3 was really done
    ok 5 - we can rotor without gap with partial with 3
ok 23 - we can rotor without gap with partial with 3
    1..5
    ok 1 - Supply appears to be doing Supply
    ok 2 - Supply appears to NOT be live
    ok 3 - we can rotor without gap with 3 => 0 got a tap
    ok 4 - we can rotor without gap with 3 => 0 was really done
    ok 5 - we can rotor without gap with 3 => 0
ok 24 - we can rotor without gap with 3 => 0
    1..5
    ok 1 - Supply appears to be doing Supply
    ok 2 - Supply appears to NOT be live
    ok 3 - we can rotor without gap without partial with 3 => 0 got a tap
    ok 4 - we can rotor without gap without partial with 3 => 0 was really done
    ok 5 - we can rotor without gap without partial with 3 => 0
ok 25 - we can rotor without gap without partial with 3 => 0
    1..5
    ok 1 - Supply appears to be doing Supply
    ok 2 - Supply appears to NOT be live
    ok 3 - we can rotor without gap with partial with 3 => 0 got a tap
    ok 4 - we can rotor without gap with partial with 3 => 0 was really done
    ok 5 - we can rotor without gap with partial with 3 => 0
ok 26 - we can rotor without gap with partial with 3 => 0
    1..5
    ok 1 - Supply appears to be doing Supply
    ok 2 - Supply appears to NOT be live
    ok 3 - we can rotor with positive gap got a tap
    ok 4 - we can rotor with positive gap was really done
    ok 5 - we can rotor with positive gap
ok 27 - we can rotor with positive gap
    1..5
    ok 1 - Supply appears to be doing Supply
    ok 2 - Supply appears to NOT be live
    ok 3 - we can rotor with positive gap without partial got a tap
    ok 4 - we can rotor with positive gap without partial was really done
    ok 5 - we can rotor with positive gap without partial
ok 28 - we can rotor with positive gap without partial
    1..5
    ok 1 - Supply appears to be doing Supply
    ok 2 - Supply appears to NOT be live
    ok 3 - we can rotor with positive gap with partial got a tap
    ok 4 - we can rotor with positive gap with partial was really done
    ok 5 - we can rotor with positive gap with partial
ok 29 - we can rotor with positive gap with partial
    1..5
    ok 1 - Supply appears to be doing Supply
    ok 2 - Supply appears to NOT be live
    ok 3 - we can rotor with multiple different gaps got a tap
    ok 4 - we can rotor with multiple different gaps was really done
    ok 5 - we can rotor with multiple different gaps
ok 30 - we can rotor with multiple different gaps
    1..5
    ok 1 - Supply appears to be doing Supply
    ok 2 - Supply appears to NOT be live
    ok 3 - we can rotor with multiple different gaps without partial got a tap
    ok 4 - we can rotor with multiple different gaps without partial was really done
    ok 5 - we can rotor with multiple different gaps without partial
ok 31 - we can rotor with multiple different gaps without partial
    1..5
    ok 1 - Supply appears to be doing Supply
    ok 2 - Supply appears to NOT be live
    ok 3 - we can rotor with multiple different gaps with partial got a tap
    ok 4 - we can rotor with multiple different gaps with partial was really done
    ok 5 - we can rotor with multiple different gaps with partial
ok 32 - we can rotor with multiple different gaps with partial
# FUDGED!
1..7
ok 1 - can not be called as a class method
ok 2 - # SKIP doesn't work or can't test
ok 3 - stable by 0 is a noop
    1..5
    ok 1 - Supply appears to be doing Supply
    ok 2 - Supply appears to NOT be live
    ok 3 - noop stable got a tap
    ok 4 - noop stable was really done
    ok 5 - noop stable
ok 4 - noop stable
ok 5 - # SKIP doesn't work or can't test
ok 6 - stable by 0 is a noop
    1..5
    ok 1 - Supply appears to be doing Supply
    ok 2 - Supply appears to NOT be live
    ok 3 - noop stable got a tap
    ok 4 - noop stable was really done
    ok 5 - noop stable
ok 7 - noop stable
# FUDGED!
1..6
ok 1 - -n -e .say works like cat
ok 2 - -ne .say works like cat
    1..3
    ok 1 - 
    ok 2 - 
    ok 3 - 
ok 3 - -n -e "" works like awk ""
not ok 4 - -n -e "FIRST .say" prints the first line of the input # TODO LAST working with -n NYI
# Failed test '-n -e "FIRST .say" prints the first line of the input'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S19-command-line-options/02-dash-n.rakudo line 59
not ok 5 - -n -e "LAST .say" prints the last line of the input # TODO LAST working with -n NYI
# Failed test '-n -e "LAST .say" prints the last line of the input'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S19-command-line-options/02-dash-n.rakudo line 70
not ok 6 - -n -e "NEXT .say" prints each line of the input # TODO LAST working with -n NYI
# Failed test '-n -e "NEXT .say" prints each line of the input'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S19-command-line-options/02-dash-n.rakudo line 81
# FUDGED!
1..3
not ok 1 - negating stagestats doesn't print them # TODO 
# Failed test 'negating stagestats doesn't print them'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S19-command-line-options/04-negation.rakudo line 14
not ok 2 - negation of multiple short options fails # TODO 
# Failed test 'negation of multiple short options fails'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S19-command-line-options/04-negation.rakudo line 22
not ok 3 - negation of short option that needs a value fails # TODO 
# Failed test 'negation of short option that needs a value fails'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S19-command-line-options/04-negation.rakudo line 29
# FUDGED!
1..1
not ok 1 - delimited options end up in the right place # TODO delimited options NYI
# Failed test 'delimited options end up in the right place'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S19-command-line-options/05-delimited-options.rakudo line 13
# FUDGED!
1..12
not ok 1 - non-compiling test # TODO Module Test doesn't implement force_todo yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S24-testing/2-force_todo.rakudo line 21
not ok 2 - non-compiling test # TODO Module Test doesn't implement force_todo yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S24-testing/2-force_todo.rakudo line 21
not ok 3 - non-compiling test # TODO Module Test doesn't implement force_todo yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S24-testing/2-force_todo.rakudo line 21
not ok 4 - non-compiling test # TODO Module Test doesn't implement force_todo yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S24-testing/2-force_todo.rakudo line 21
not ok 5 - non-compiling test # TODO Module Test doesn't implement force_todo yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S24-testing/2-force_todo.rakudo line 21
not ok 6 - non-compiling test # TODO Module Test doesn't implement force_todo yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S24-testing/2-force_todo.rakudo line 21
not ok 7 - non-compiling test # TODO Module Test doesn't implement force_todo yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S24-testing/2-force_todo.rakudo line 21
not ok 8 - non-compiling test # TODO Module Test doesn't implement force_todo yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S24-testing/2-force_todo.rakudo line 21
not ok 9 - non-compiling test # TODO Module Test doesn't implement force_todo yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S24-testing/2-force_todo.rakudo line 21
not ok 10 - non-compiling test # TODO Module Test doesn't implement force_todo yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S24-testing/2-force_todo.rakudo line 21
not ok 11 - non-compiling test # TODO Module Test doesn't implement force_todo yet
# Failed test 'non-compiling test'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S24-testing/2-force_todo.rakudo line 21
not ok 12 - force_todo is implemented # TODO Canary test for &Test::force_todo
# Failed test 'force_todo is implemented'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S24-testing/2-force_todo.rakudo line 25
# Error: Undeclared routine:
#     force_todo used at line 1
# 
# FUDGED!
1..1
    1..19
    ok 1 - is config<numbered>:exists
    ok 2 - ok config<numbered>
    ok 3 - is config<numbered>:exists
    ok 4 - ok config<numbered>
    ok 5 - is term "foo"
    ok 6 - is config<numbered>:exists
    ok 7 - ok config<numbered>
    ok 8 - is config<numbered>:exists
    ok 9 - ok config<numbered>
    ok 10 - is config<numbered>:exists
    ok 11 - ok config<numbered>
    ok 12 - is config<numbered>:exists
    ok 13 - ok config<numbered>
    ok 14 - is config<numbered>:exists
    ok 15 - ok config<numbered>
    ok 16 - is config<numbered>:exists
    ok 17 - ok config<numbered>
    ok 18 - is config<numbered>:exists
    ok 19 - ok config<numbered>
ok 1 - :numbered alias abbreviated blocks
# FUDGED!
1..30
ok 1 - EVAL runs code in the proper lexical scope
ok 2 - simple EVAL works and returns the value
ok 3 - simple EVAL using variable defined outside
ok 4 - EVAL does not trap die
ok 5 - EVAL throws on syntax error
ok 6 - EVAL dies on fatal use
ok 7 - block EVAL is gone
ok 8 - EVAL works inside class methods
ok 9 - EVAL works inside instance methods
ok 10 - EVAL works inside class methods, with outer lexicals
ok 11 - EVAL works inside instance methods, with outer lexicals
ok 12 - EVAL(Buf)
ok 13 - # SKIP Buf.EVAL NYI (if ever)
ok 14 - EVAL of non-string works
ok 15 - .EVAL of non-string works
ok 16 - EVAL of non-string variable works
ok 17 - .EVAL of non-string variable works
ok 18 - can execute the same EVAL multiple times, without surrounding block
ok 19 - EVAL in bogus language mentions the language
ok 20 - method form of EVAL sees outer lexicals
ok 21 - presence of low level types doesn't cause EVAL error
ok 22 - Can EVAL with a sigilless var
ok 23 - EVAL with sigilless var gives correct result
ok 24 - EVAL's package does not leak to the surrounding compilation unit
ok 25 - EVAL(Buf)
ok 26 - Did the EVAL run BEGIN
ok 27 - Did the EVAL run CHECK
ok 28 - Did the EVAL NOT run the code
ok 29 - EVAL preserves version 6.c
ok 30 - EVAL preserves version 6.d
# FUDGED!
1..259
ok 1 - ord() works for \32 == ' '
ok 2 - chr() works for \32 == ' '
ok 3 - ord() works for \33 == '!'
ok 4 - chr() works for \33 == '!'
ok 5 - ord() works for \34 == '"'
ok 6 - chr() works for \34 == '"'
ok 7 - ord() works for \35 == ' \#'
ok 8 - chr() works for \35 == ' \#'
ok 9 - ord() works for \36 == '$'
ok 10 - chr() works for \36 == '$'
ok 11 - ord() works for \37 == '%'
ok 12 - chr() works for \37 == '%'
ok 13 - ord() works for \38 == '&'
ok 14 - chr() works for \38 == '&'
ok 15 - ord() works for \39 == '''
ok 16 - chr() works for \39 == '''
ok 17 - ord() works for \40 == '('
ok 18 - chr() works for \40 == '('
ok 19 - ord() works for \41 == ')'
ok 20 - chr() works for \41 == ')'
ok 21 - ord() works for \42 == '*'
ok 22 - chr() works for \42 == '*'
ok 23 - ord() works for \43 == '+'
ok 24 - chr() works for \43 == '+'
ok 25 - ord() works for \44 == ','
ok 26 - chr() works for \44 == ','
ok 27 - ord() works for \45 == '-'
ok 28 - chr() works for \45 == '-'
ok 29 - ord() works for \46 == '.'
ok 30 - chr() works for \46 == '.'
ok 31 - ord() works for \47 == '/'
ok 32 - chr() works for \47 == '/'
ok 33 - ord() works for \48 == '0'
ok 34 - chr() works for \48 == '0'
ok 35 - ord() works for \49 == '1'
ok 36 - chr() works for \49 == '1'
ok 37 - ord() works for \50 == '2'
ok 38 - chr() works for \50 == '2'
ok 39 - ord() works for \51 == '3'
ok 40 - chr() works for \51 == '3'
ok 41 - ord() works for \52 == '4'
ok 42 - chr() works for \52 == '4'
ok 43 - ord() works for \53 == '5'
ok 44 - chr() works for \53 == '5'
ok 45 - ord() works for \54 == '6'
ok 46 - chr() works for \54 == '6'
ok 47 - ord() works for \55 == '7'
ok 48 - chr() works for \55 == '7'
ok 49 - ord() works for \56 == '8'
ok 50 - chr() works for \56 == '8'
ok 51 - ord() works for \57 == '9'
ok 52 - chr() works for \57 == '9'
ok 53 - ord() works for \58 == ':'
ok 54 - chr() works for \58 == ':'
ok 55 - ord() works for \59 == ';'
ok 56 - chr() works for \59 == ';'
ok 57 - ord() works for \60 == '<'
ok 58 - chr() works for \60 == '<'
ok 59 - ord() works for \61 == '='
ok 60 - chr() works for \61 == '='
ok 61 - ord() works for \62 == '>'
ok 62 - chr() works for \62 == '>'
ok 63 - ord() works for \63 == '?'
ok 64 - chr() works for \63 == '?'
ok 65 - ord() works for \64 == '@'
ok 66 - chr() works for \64 == '@'
ok 67 - ord() works for \65 == 'A'
ok 68 - chr() works for \65 == 'A'
ok 69 - ord() works for \66 == 'B'
ok 70 - chr() works for \66 == 'B'
ok 71 - ord() works for \67 == 'C'
ok 72 - chr() works for \67 == 'C'
ok 73 - ord() works for \68 == 'D'
ok 74 - chr() works for \68 == 'D'
ok 75 - ord() works for \69 == 'E'
ok 76 - chr() works for \69 == 'E'
ok 77 - ord() works for \70 == 'F'
ok 78 - chr() works for \70 == 'F'
ok 79 - ord() works for \71 == 'G'
ok 80 - chr() works for \71 == 'G'
ok 81 - ord() works for \72 == 'H'
ok 82 - chr() works for \72 == 'H'
ok 83 - ord() works for \73 == 'I'
ok 84 - chr() works for \73 == 'I'
ok 85 - ord() works for \74 == 'J'
ok 86 - chr() works for \74 == 'J'
ok 87 - ord() works for \75 == 'K'
ok 88 - chr() works for \75 == 'K'
ok 89 - ord() works for \76 == 'L'
ok 90 - chr() works for \76 == 'L'
ok 91 - ord() works for \77 == 'M'
ok 92 - chr() works for \77 == 'M'
ok 93 - ord() works for \78 == 'N'
ok 94 - chr() works for \78 == 'N'
ok 95 - ord() works for \79 == 'O'
ok 96 - chr() works for \79 == 'O'
ok 97 - ord() works for \80 == 'P'
ok 98 - chr() works for \80 == 'P'
ok 99 - ord() works for \81 == 'Q'
ok 100 - chr() works for \81 == 'Q'
ok 101 - ord() works for \82 == 'R'
ok 102 - chr() works for \82 == 'R'
ok 103 - ord() works for \83 == 'S'
ok 104 - chr() works for \83 == 'S'
ok 105 - ord() works for \84 == 'T'
ok 106 - chr() works for \84 == 'T'
ok 107 - ord() works for \85 == 'U'
ok 108 - chr() works for \85 == 'U'
ok 109 - ord() works for \86 == 'V'
ok 110 - chr() works for \86 == 'V'
ok 111 - ord() works for \87 == 'W'
ok 112 - chr() works for \87 == 'W'
ok 113 - ord() works for \88 == 'X'
ok 114 - chr() works for \88 == 'X'
ok 115 - ord() works for \89 == 'Y'
ok 116 - chr() works for \89 == 'Y'
ok 117 - ord() works for \90 == 'Z'
ok 118 - chr() works for \90 == 'Z'
ok 119 - ord() works for \91 == '['
ok 120 - chr() works for \91 == '['
ok 121 - ord() works for \92 == '\'
ok 122 - chr() works for \92 == '\'
ok 123 - ord() works for \93 == ']'
ok 124 - chr() works for \93 == ']'
ok 125 - ord() works for \94 == '^'
ok 126 - chr() works for \94 == '^'
ok 127 - ord() works for \95 == '_'
ok 128 - chr() works for \95 == '_'
ok 129 - ord() works for \96 == '`'
ok 130 - chr() works for \96 == '`'
ok 131 - ord() works for \97 == 'a'
ok 132 - chr() works for \97 == 'a'
ok 133 - ord() works for \98 == 'b'
ok 134 - chr() works for \98 == 'b'
ok 135 - ord() works for \99 == 'c'
ok 136 - chr() works for \99 == 'c'
ok 137 - ord() works for \100 == 'd'
ok 138 - chr() works for \100 == 'd'
ok 139 - ord() works for \101 == 'e'
ok 140 - chr() works for \101 == 'e'
ok 141 - ord() works for \102 == 'f'
ok 142 - chr() works for \102 == 'f'
ok 143 - ord() works for \103 == 'g'
ok 144 - chr() works for \103 == 'g'
ok 145 - ord() works for \104 == 'h'
ok 146 - chr() works for \104 == 'h'
ok 147 - ord() works for \105 == 'i'
ok 148 - chr() works for \105 == 'i'
ok 149 - ord() works for \106 == 'j'
ok 150 - chr() works for \106 == 'j'
ok 151 - ord() works for \107 == 'k'
ok 152 - chr() works for \107 == 'k'
ok 153 - ord() works for \108 == 'l'
ok 154 - chr() works for \108 == 'l'
ok 155 - ord() works for \109 == 'm'
ok 156 - chr() works for \109 == 'm'
ok 157 - ord() works for \110 == 'n'
ok 158 - chr() works for \110 == 'n'
ok 159 - ord() works for \111 == 'o'
ok 160 - chr() works for \111 == 'o'
ok 161 - ord() works for \112 == 'p'
ok 162 - chr() works for \112 == 'p'
ok 163 - ord() works for \113 == 'q'
ok 164 - chr() works for \113 == 'q'
ok 165 - ord() works for \114 == 'r'
ok 166 - chr() works for \114 == 'r'
ok 167 - ord() works for \115 == 's'
ok 168 - chr() works for \115 == 's'
ok 169 - ord() works for \116 == 't'
ok 170 - chr() works for \116 == 't'
ok 171 - ord() works for \117 == 'u'
ok 172 - chr() works for \117 == 'u'
ok 173 - ord() works for \118 == 'v'
ok 174 - chr() works for \118 == 'v'
ok 175 - ord() works for \119 == 'w'
ok 176 - chr() works for \119 == 'w'
ok 177 - ord() works for \120 == 'x'
ok 178 - chr() works for \120 == 'x'
ok 179 - ord() works for \121 == 'y'
ok 180 - chr() works for \121 == 'y'
ok 181 - ord() works for \122 == 'z'
ok 182 - chr() works for \122 == 'z'
ok 183 - ord() works for \123 == '{'
ok 184 - chr() works for \123 == '{'
ok 185 - ord() works for \124 == '|'
ok 186 - chr() works for \124 == '|'
ok 187 - ord() works for \125 == '}'
ok 188 - chr() works for \125 == '}'
ok 189 - ord() works for \126 == '~'
ok 190 - chr() works for \126 == '~'
ok 191 - ord() works for \228 == 'ä'
ok 192 - chr() works for \228 == 'ä'
ok 193 - ord() works for \8364 == '€'
ok 194 - chr() works for \8364 == '€'
ok 195 - ord() works for \187 == '»'
ok 196 - chr() works for \187 == '»'
ok 197 - ord() works for \171 == '«'
ok 198 - chr() works for \171 == '«'
ok 199 - ord() works for \0
ok 200 - chr() works for \0
ok 201 - ord() works for \1
ok 202 - chr() works for \1
ok 203 - ord() works for \3
ok 204 - chr() works for \3
ok 205 - ord(chr(0)) is 0
ok 206 - ord(chr(1)) is 1
ok 207 - ord(chr(2)) is 2
ok 208 - ord(chr(3)) is 3
ok 209 - ord(chr(4)) is 4
ok 210 - ord(chr(5)) is 5
ok 211 - ord(chr(6)) is 6
ok 212 - ord(chr(7)) is 7
ok 213 - ord(chr(8)) is 8
ok 214 - ord(chr(9)) is 9
ok 215 - ord(chr(10)) is 10
ok 216 - ord(chr(11)) is 11
ok 217 - ord(chr(12)) is 12
ok 218 - ord(chr(13)) is 13
ok 219 - ord(chr(14)) is 14
ok 220 - ord(chr(15)) is 15
ok 221 - ord(chr(16)) is 16
ok 222 - ord(chr(17)) is 17
ok 223 - ord(chr(18)) is 18
ok 224 - ord(chr(19)) is 19
ok 225 - ord(chr(20)) is 20
ok 226 - ord(chr(21)) is 21
ok 227 - ord(chr(22)) is 22
ok 228 - ord(chr(23)) is 23
ok 229 - ord(chr(24)) is 24
ok 230 - ord(chr(25)) is 25
ok 231 - ord(chr(26)) is 26
ok 232 - ord(chr(27)) is 27
ok 233 - ord(chr(28)) is 28
ok 234 - ord(chr(29)) is 29
ok 235 - ord(chr(30)) is 30
ok 236 - ord(chr(31)) is 31
ok 237 - ords() works as expected
ok 238 - chrs() method works as expected
ok 239 - chrs(ords()) round-trips correctly
ok 240 - ords(chrs()) round-trips correctly
ok 241 - there's a .ord method
ok 242 - there's a .chr method
ok 243 - there's a .ords method
ok 244 - there's a .chrs method
ok 245 - ords > chrs round-trips correctly
ok 246 - chrs > ords round-trips correctly
ok 247 - chrs works with a list of ints
not ok 248 - chr of surrogate # TODO chr surrogate
# Failed test 'chr of surrogate'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S29-conversions/ord_and_chr.rakudo line 154
ok 249 - chr of noncharacter
ok 250 - chr of noncharacter
ok 251 - chr out of range (max)
ok 252 - chr out of range (negative)
ok 253 - ord("") returns an undefined value
ok 254 - ord of named high character
ok 255 - chr > ord round trip of high character
ok 256 - .ord gives first NFC codepoint (1)
ok 257 - .ord gives first NFC codepoint (2)
ok 258 - chrs works with a list of numifiable strings
    1..6
        1..2
        ok 1 - 'chr 2⁶³-1' died
        ok 2 - right exception type (Exception)
    ok 1 - "chr 2⁶³-1"
        1..2
        ok 1 - '(2⁶³-1).chr' died
        ok 2 - right exception type (Exception)
    ok 2 - "(2⁶³-1).chr"
        1..2
        ok 1 - 'chr 2⁶³' died
        ok 2 - right exception type (Exception)
    ok 3 - "chr 2⁶³"
        1..2
        ok 1 - '2⁶³.chr' died
        ok 2 - right exception type (Exception)
    ok 4 - "2⁶³.chr"
        1..2
        ok 1 - 'chr 2¹⁰⁰' died
        ok 2 - right exception type (Exception)
    ok 5 - "chr 2¹⁰⁰"
        1..2
        ok 1 - '(2¹⁰⁰).chr' died
        ok 2 - right exception type (Exception)
    ok 6 - "(2¹⁰⁰).chr"
ok 259 - chr with large codepoints throws useful error
# FUDGED!
1..38
ok 1 - we have 4 elements in the array
ok 2 - pop(@pop) works
ok 3 - we have 3 elements in the array
ok 4 - pop @pop works
ok 5 - we have 2 elements in the array
ok 6 - @pop.pop() works
ok 7 - we have 1 element in the array
ok 8 - @pop.pop works
ok 9 - we have 1 element in the array
ok 10 - @pop.pop works
ok 11 - we have no more element in the array
ok 12 - after the array is exhausted pop() returns undefined
ok 13 - after the array is exhausted pop() returns Failure
ok 14 - we have 4 elements in the array
ok 15 - inline pop(@pop) works
ok 16 - we have 3 elements in the array
ok 17 - inline pop @pop works
ok 18 - we have 2 elements in the array
ok 19 - inline @pop.pop() works
ok 20 - we have 1 element in the array
ok 21 - inline @pop.pop works
ok 22 - we have no more element in the array
ok 23 - after the array is exhausted pop() returns undefined
ok 24 - after the array is exhausted pop() returns Failure
ok 25 - this will return 3
ok 26 - this will return undefined
ok 27 - [].pop is a Failure
ok 28 - pop on an un-initialized array returns undefined
ok 29 - pop off uninitialized array is a Failure
    1..2
    ok 1 - 'pop' died
    ok 2 - right exception type (X::TypeCheck::Argument)
ok 30 - pop() requires arguments
    1..2
    ok 1 - '42.pop' died
    ok 2 - right exception type (X::Method::NotFound)
ok 31 - .pop should not work on scalars
    1..2
    ok 1 - 'pop(@pop,10)' died
    ok 2 - right exception type (Exception)
ok 32 - pop() should not allow extra arguments
    1..2
    ok 1 - '@pop.pop(10)' died
    ok 2 - right exception type (Exception)
ok 33 - .pop() should not allow extra arguments
    1..2
    ok 1 - '@pop.pop = 3' died
    ok 2 - right exception type (Exception)
ok 34 - Cannot assign to a readonly variable or a value
    1..2
    ok 1 - 'pop(@pop) = 3' died
    ok 2 - right exception type (Exception)
ok 35 - Cannot assign to a readonly variable or a value
    1..2
    ok 1 - 'pop @push' died
    ok 2 - right exception type (X::Cannot::Lazy)
ok 36 - cannot pop from a lazy list
not ok 37 - reading first key in sink context does not influence later code # TODO RT #111720
# Failed test 'reading first key in sink context does not influence later code'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-array/pop.rakudo line 101
# expected: '1-2'
#      got: '1-2-3'
    1..5
    ok 1 - .pop
    ok 2 - &pop
    ok 3 - .shift
    ok 4 - &shift
    ok 5 - :delete
ok 38 - no ghost elements after pop/shift
# FUDGED!
1..392
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array sub: whole
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array method: whole
ok 1 - Array whole
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array sub: simple 1 elem
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array method: simple 1 elem
ok 2 - Array simple 1 elem
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array sub: simple 2 elems
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array method: simple 2 elems
ok 3 - Array simple 2 elems
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array sub: simple 2 elems, as Str
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array method: simple 2 elems, as Str
ok 4 - Array simple 2 elems, as Str
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array sub: simple rest
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array method: simple rest
ok 5 - Array simple rest
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array sub: simple rest *
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array method: simple rest *
ok 6 - Array simple rest *
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array sub: none rest
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array method: none rest
ok 7 - Array none rest
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array sub: none * rest
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array method: none * rest
ok 8 - Array none * rest
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array sub: end rest
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array method: end rest
ok 9 - Array end rest
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array sub: end some
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array method: end some
ok 10 - Array end some
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array sub: end some callable
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array method: end some callable
ok 11 - Array end some callable
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array sub: push none
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array method: push none
ok 12 - Array push none
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array sub: push none *
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array method: push none *
ok 13 - Array push none *
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array sub: push none callable
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array method: push none callable
ok 14 - Array push none callable
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array sub: push two
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array method: push two
ok 15 - Array push two
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array sub: push two *
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array method: push two *
ok 16 - Array push two *
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array sub: push self
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array method: push self
ok 17 - Array push self
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array sub: push self *
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array method: push self *
ok 18 - Array push self *
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array sub: unshift
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array method: unshift
ok 19 - Array unshift
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array sub: unshift none
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array method: unshift none
ok 20 - Array unshift none
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array sub: unshift self
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array method: unshift self
ok 21 - Array unshift self
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array sub: replace self
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array method: replace self
ok 22 - Array replace self
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array sub: replace 1 with 1
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array method: replace 1 with 1
ok 23 - Array replace 1 with 1
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array sub: replace 1 with range
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array method: replace 1 with range
ok 24 - Array replace 1 with range
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array sub: replace 1 with none
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array method: replace 1 with none
ok 25 - Array replace 1 with none
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array sub: replace 1 with self
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array method: replace 1 with self
ok 26 - Array replace 1 with self
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array sub: replace none with 1
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array method: replace none with 1
ok 27 - Array replace none with 1
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array sub: replace none with range
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array method: replace none with range
ok 28 - Array replace none with range
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array sub: replace none with none
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array method: replace none with none
ok 29 - Array replace none with none
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array sub: replace none with self
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array method: replace none with self
ok 30 - Array replace none with self
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array sub: remove 1 past end
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array method: remove 1 past end
ok 31 - Array remove 1 past end
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array sub: remove 1 past end + push
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array method: remove 1 past end + push
ok 32 - Array remove 1 past end + push
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array sub: remove whatever past end + push
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array method: remove whatever past end + push
ok 33 - Array remove whatever past end + push
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array sub: two *, no list
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array method: two *, no list
ok 34 - Array two *, no list
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array sub: two * with a given list
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array method: two * with a given list
ok 35 - Array two * with a given list
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array sub: .splice(Callable, Whatever)
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array method: .splice(Callable, Whatever)
ok 36 - Array .splice(Callable, Whatever)
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array sub: .splice(Callable, Whatever, List)
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array method: .splice(Callable, Whatever, List)
ok 37 - Array .splice(Callable, Whatever, List)
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array sub: .splice(Int, Callable, List)
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array method: .splice(Int, Callable, List)
ok 38 - Array .splice(Int, Callable, List)
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array sub: .splice(Callable, Int, List)
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array method: .splice(Callable, Int, List)
ok 39 - Array .splice(Callable, Int, List)
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array sub: .splice(Callable, Callable, List)
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array method: .splice(Callable, Callable, List)
ok 40 - Array .splice(Callable, Callable, List)
    1..3
    ok 1 - 'splice @a,0,0,1..Inf' died
    ok 2 - right exception type (X::Cannot::Lazy)
    ok 3 - .action matches splice in
ok 41 - did we throws-like X::Cannot::Lazy?
    1..3
    ok 1 - '@a.splice: 0,0,1..Inf' died
    ok 2 - right exception type (X::Cannot::Lazy)
    ok 3 - .action matches splice in
ok 42 - did we throws-like X::Cannot::Lazy?
    1..5
    ok 1 - 'splice @a,11,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .what matches Offset argument to splice
    ok 4 - .got matches 11
    ok 5 - .range matches 0..10
ok 43 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - '@a.splice: 11,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .got matches 11
    ok 4 - .what matches Offset argument to splice
    ok 5 - .range matches 0..10
ok 44 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - 'splice @a,-1,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .got matches -1
    ok 4 - .what matches Offset argument to splice
    ok 5 - .range matches 0..10
ok 45 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - '@a.splice: -1,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .range matches 0..10
    ok 4 - .got matches -1
    ok 5 - .what matches Offset argument to splice
ok 46 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - 'splice @a,*-11,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .range matches 0..10
    ok 4 - .got matches -1
    ok 5 - .what matches Offset argument to splice
ok 47 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - '@a.splice: *-11,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .got matches -1
    ok 4 - .range matches 0..10
    ok 5 - .what matches Offset argument to splice
ok 48 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - 'splice @a,3,-1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .range matches 0..^7
    ok 4 - .got matches -1
    ok 5 - .what matches Size argument to splice
ok 49 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - '@a.splice: 3,-1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .what matches Size argument to splice
    ok 4 - .got matches -1
    ok 5 - .range matches 0..^7
ok 50 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - 'splice @a,3,*-8' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .got matches -1
    ok 4 - .what matches Size argument to splice
    ok 5 - .range matches 0..^7
ok 51 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - '@a.splice: 3,*-8' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .got matches -1
    ok 4 - .what matches Size argument to splice
    ok 5 - .range matches 0..^7
ok 52 - did we throws-like X::OutOfRange?
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int] sub: whole
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int] method: whole
ok 53 - array[int] whole
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int] sub: simple 1 elem
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int] method: simple 1 elem
ok 54 - array[int] simple 1 elem
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int] sub: simple 2 elems
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int] method: simple 2 elems
ok 55 - array[int] simple 2 elems
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int] sub: simple 2 elems, as Str
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int] method: simple 2 elems, as Str
ok 56 - array[int] simple 2 elems, as Str
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int] sub: simple rest
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int] method: simple rest
ok 57 - array[int] simple rest
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int] sub: simple rest *
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int] method: simple rest *
ok 58 - array[int] simple rest *
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int] sub: none rest
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int] method: none rest
ok 59 - array[int] none rest
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int] sub: none * rest
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int] method: none * rest
ok 60 - array[int] none * rest
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int] sub: end rest
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int] method: end rest
ok 61 - array[int] end rest
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int] sub: end some
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int] method: end some
ok 62 - array[int] end some
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int] sub: end some callable
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int] method: end some callable
ok 63 - array[int] end some callable
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int] sub: push none
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int] method: push none
ok 64 - array[int] push none
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int] sub: push none *
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int] method: push none *
ok 65 - array[int] push none *
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int] sub: push none callable
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int] method: push none callable
ok 66 - array[int] push none callable
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int] sub: push two
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int] method: push two
ok 67 - array[int] push two
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int] sub: push two *
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int] method: push two *
ok 68 - array[int] push two *
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int] sub: push self
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int] method: push self
ok 69 - array[int] push self
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int] sub: push self *
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int] method: push self *
ok 70 - array[int] push self *
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int] sub: unshift
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int] method: unshift
ok 71 - array[int] unshift
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int] sub: unshift none
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int] method: unshift none
ok 72 - array[int] unshift none
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int] sub: unshift self
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int] method: unshift self
ok 73 - array[int] unshift self
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int] sub: replace self
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int] method: replace self
ok 74 - array[int] replace self
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int] sub: replace 1 with 1
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int] method: replace 1 with 1
ok 75 - array[int] replace 1 with 1
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int] sub: replace 1 with range
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int] method: replace 1 with range
ok 76 - array[int] replace 1 with range
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int] sub: replace 1 with none
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int] method: replace 1 with none
ok 77 - array[int] replace 1 with none
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int] sub: replace 1 with self
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int] method: replace 1 with self
ok 78 - array[int] replace 1 with self
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int] sub: replace none with 1
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int] method: replace none with 1
ok 79 - array[int] replace none with 1
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int] sub: replace none with range
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int] method: replace none with range
ok 80 - array[int] replace none with range
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int] sub: replace none with none
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int] method: replace none with none
ok 81 - array[int] replace none with none
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int] sub: replace none with self
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int] method: replace none with self
ok 82 - array[int] replace none with self
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int] sub: remove 1 past end
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int] method: remove 1 past end
ok 83 - array[int] remove 1 past end
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int] sub: remove 1 past end + push
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int] method: remove 1 past end + push
ok 84 - array[int] remove 1 past end + push
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int] sub: remove whatever past end + push
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int] method: remove whatever past end + push
ok 85 - array[int] remove whatever past end + push
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int] sub: two *, no list
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int] method: two *, no list
ok 86 - array[int] two *, no list
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int] sub: two * with a given list
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int] method: two * with a given list
ok 87 - array[int] two * with a given list
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int] sub: .splice(Callable, Whatever)
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int] method: .splice(Callable, Whatever)
ok 88 - array[int] .splice(Callable, Whatever)
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int] sub: .splice(Callable, Whatever, List)
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int] method: .splice(Callable, Whatever, List)
ok 89 - array[int] .splice(Callable, Whatever, List)
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int] sub: .splice(Int, Callable, List)
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int] method: .splice(Int, Callable, List)
ok 90 - array[int] .splice(Int, Callable, List)
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int] sub: .splice(Callable, Int, List)
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int] method: .splice(Callable, Int, List)
ok 91 - array[int] .splice(Callable, Int, List)
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int] sub: .splice(Callable, Callable, List)
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int] method: .splice(Callable, Callable, List)
ok 92 - array[int] .splice(Callable, Callable, List)
    1..3
    ok 1 - 'splice @a,0,0,1..Inf' died
    ok 2 - right exception type (X::Cannot::Lazy)
    ok 3 - .action matches splice in
ok 93 - did we throws-like X::Cannot::Lazy?
    1..3
    ok 1 - '@a.splice: 0,0,1..Inf' died
    ok 2 - right exception type (X::Cannot::Lazy)
    ok 3 - .action matches splice in
ok 94 - did we throws-like X::Cannot::Lazy?
    1..5
    ok 1 - 'splice @a,11,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .got matches 11
    ok 4 - .range matches 0..10
    ok 5 - .what matches Offset argument to splice
ok 95 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - '@a.splice: 11,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .range matches 0..10
    ok 4 - .what matches Offset argument to splice
    ok 5 - .got matches 11
ok 96 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - 'splice @a,-1,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .what matches Offset argument to splice
    ok 4 - .got matches -1
    ok 5 - .range matches 0..10
ok 97 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - '@a.splice: -1,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .got matches -1
    ok 4 - .what matches Offset argument to splice
    ok 5 - .range matches 0..10
ok 98 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - 'splice @a,*-11,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .range matches 0..10
    ok 4 - .got matches -1
    ok 5 - .what matches Offset argument to splice
ok 99 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - '@a.splice: *-11,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .what matches Offset argument to splice
    ok 4 - .got matches -1
    ok 5 - .range matches 0..10
ok 100 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - 'splice @a,3,-1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .what matches Size argument to splice
    ok 4 - .got matches -1
    ok 5 - .range matches 0..^7
ok 101 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - '@a.splice: 3,-1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .got matches -1
    ok 4 - .range matches 0..^7
    ok 5 - .what matches Size argument to splice
ok 102 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - 'splice @a,3,*-8' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .what matches Size argument to splice
    ok 4 - .got matches -1
    ok 5 - .range matches 0..^7
ok 103 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - '@a.splice: 3,*-8' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .what matches Size argument to splice
    ok 4 - .range matches 0..^7
    ok 5 - .got matches -1
ok 104 - did we throws-like X::OutOfRange?
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int8] sub: whole
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int8] method: whole
ok 105 - array[int8] whole
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int8] sub: simple 1 elem
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int8] method: simple 1 elem
ok 106 - array[int8] simple 1 elem
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int8] sub: simple 2 elems
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int8] method: simple 2 elems
ok 107 - array[int8] simple 2 elems
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int8] sub: simple 2 elems, as Str
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int8] method: simple 2 elems, as Str
ok 108 - array[int8] simple 2 elems, as Str
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int8] sub: simple rest
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int8] method: simple rest
ok 109 - array[int8] simple rest
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int8] sub: simple rest *
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int8] method: simple rest *
ok 110 - array[int8] simple rest *
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int8] sub: none rest
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int8] method: none rest
ok 111 - array[int8] none rest
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int8] sub: none * rest
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int8] method: none * rest
ok 112 - array[int8] none * rest
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int8] sub: end rest
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int8] method: end rest
ok 113 - array[int8] end rest
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int8] sub: end some
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int8] method: end some
ok 114 - array[int8] end some
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int8] sub: end some callable
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int8] method: end some callable
ok 115 - array[int8] end some callable
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int8] sub: push none
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int8] method: push none
ok 116 - array[int8] push none
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int8] sub: push none *
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int8] method: push none *
ok 117 - array[int8] push none *
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int8] sub: push none callable
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int8] method: push none callable
ok 118 - array[int8] push none callable
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int8] sub: push two
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int8] method: push two
ok 119 - array[int8] push two
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int8] sub: push two *
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int8] method: push two *
ok 120 - array[int8] push two *
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int8] sub: push self
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int8] method: push self
ok 121 - array[int8] push self
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int8] sub: push self *
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int8] method: push self *
ok 122 - array[int8] push self *
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int8] sub: unshift
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int8] method: unshift
ok 123 - array[int8] unshift
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int8] sub: unshift none
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int8] method: unshift none
ok 124 - array[int8] unshift none
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int8] sub: unshift self
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int8] method: unshift self
ok 125 - array[int8] unshift self
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int8] sub: replace self
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int8] method: replace self
ok 126 - array[int8] replace self
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int8] sub: replace 1 with 1
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int8] method: replace 1 with 1
ok 127 - array[int8] replace 1 with 1
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int8] sub: replace 1 with range
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int8] method: replace 1 with range
ok 128 - array[int8] replace 1 with range
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int8] sub: replace 1 with none
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int8] method: replace 1 with none
ok 129 - array[int8] replace 1 with none
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int8] sub: replace 1 with self
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int8] method: replace 1 with self
ok 130 - array[int8] replace 1 with self
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int8] sub: replace none with 1
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int8] method: replace none with 1
ok 131 - array[int8] replace none with 1
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int8] sub: replace none with range
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int8] method: replace none with range
ok 132 - array[int8] replace none with range
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int8] sub: replace none with none
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int8] method: replace none with none
ok 133 - array[int8] replace none with none
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int8] sub: replace none with self
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int8] method: replace none with self
ok 134 - array[int8] replace none with self
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int8] sub: remove 1 past end
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int8] method: remove 1 past end
ok 135 - array[int8] remove 1 past end
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int8] sub: remove 1 past end + push
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int8] method: remove 1 past end + push
ok 136 - array[int8] remove 1 past end + push
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int8] sub: remove whatever past end + push
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int8] method: remove whatever past end + push
ok 137 - array[int8] remove whatever past end + push
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int8] sub: two *, no list
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int8] method: two *, no list
ok 138 - array[int8] two *, no list
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int8] sub: two * with a given list
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int8] method: two * with a given list
ok 139 - array[int8] two * with a given list
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int8] sub: .splice(Callable, Whatever)
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int8] method: .splice(Callable, Whatever)
ok 140 - array[int8] .splice(Callable, Whatever)
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int8] sub: .splice(Callable, Whatever, List)
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int8] method: .splice(Callable, Whatever, List)
ok 141 - array[int8] .splice(Callable, Whatever, List)
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int8] sub: .splice(Int, Callable, List)
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int8] method: .splice(Int, Callable, List)
ok 142 - array[int8] .splice(Int, Callable, List)
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int8] sub: .splice(Callable, Int, List)
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int8] method: .splice(Callable, Int, List)
ok 143 - array[int8] .splice(Callable, Int, List)
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int8] sub: .splice(Callable, Callable, List)
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int8] method: .splice(Callable, Callable, List)
ok 144 - array[int8] .splice(Callable, Callable, List)
    1..3
    ok 1 - 'splice @a,0,0,1..Inf' died
    ok 2 - right exception type (X::Cannot::Lazy)
    ok 3 - .action matches splice in
ok 145 - did we throws-like X::Cannot::Lazy?
    1..3
    ok 1 - '@a.splice: 0,0,1..Inf' died
    ok 2 - right exception type (X::Cannot::Lazy)
    ok 3 - .action matches splice in
ok 146 - did we throws-like X::Cannot::Lazy?
    1..5
    ok 1 - 'splice @a,11,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .got matches 11
    ok 4 - .range matches 0..10
    ok 5 - .what matches Offset argument to splice
ok 147 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - '@a.splice: 11,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .what matches Offset argument to splice
    ok 4 - .got matches 11
    ok 5 - .range matches 0..10
ok 148 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - 'splice @a,-1,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .what matches Offset argument to splice
    ok 4 - .range matches 0..10
    ok 5 - .got matches -1
ok 149 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - '@a.splice: -1,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .what matches Offset argument to splice
    ok 4 - .got matches -1
    ok 5 - .range matches 0..10
ok 150 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - 'splice @a,*-11,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .what matches Offset argument to splice
    ok 4 - .got matches -1
    ok 5 - .range matches 0..10
ok 151 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - '@a.splice: *-11,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .what matches Offset argument to splice
    ok 4 - .range matches 0..10
    ok 5 - .got matches -1
ok 152 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - 'splice @a,3,-1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .what matches Size argument to splice
    ok 4 - .got matches -1
    ok 5 - .range matches 0..^7
ok 153 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - '@a.splice: 3,-1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .range matches 0..^7
    ok 4 - .got matches -1
    ok 5 - .what matches Size argument to splice
ok 154 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - 'splice @a,3,*-8' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .got matches -1
    ok 4 - .what matches Size argument to splice
    ok 5 - .range matches 0..^7
ok 155 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - '@a.splice: 3,*-8' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .got matches -1
    ok 4 - .range matches 0..^7
    ok 5 - .what matches Size argument to splice
ok 156 - did we throws-like X::OutOfRange?
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int16] sub: whole
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int16] method: whole
ok 157 - array[int16] whole
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int16] sub: simple 1 elem
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int16] method: simple 1 elem
ok 158 - array[int16] simple 1 elem
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int16] sub: simple 2 elems
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int16] method: simple 2 elems
ok 159 - array[int16] simple 2 elems
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int16] sub: simple 2 elems, as Str
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int16] method: simple 2 elems, as Str
ok 160 - array[int16] simple 2 elems, as Str
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int16] sub: simple rest
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int16] method: simple rest
ok 161 - array[int16] simple rest
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int16] sub: simple rest *
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int16] method: simple rest *
ok 162 - array[int16] simple rest *
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int16] sub: none rest
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int16] method: none rest
ok 163 - array[int16] none rest
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int16] sub: none * rest
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int16] method: none * rest
ok 164 - array[int16] none * rest
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int16] sub: end rest
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int16] method: end rest
ok 165 - array[int16] end rest
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int16] sub: end some
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int16] method: end some
ok 166 - array[int16] end some
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int16] sub: end some callable
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int16] method: end some callable
ok 167 - array[int16] end some callable
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int16] sub: push none
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int16] method: push none
ok 168 - array[int16] push none
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int16] sub: push none *
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int16] method: push none *
ok 169 - array[int16] push none *
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int16] sub: push none callable
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int16] method: push none callable
ok 170 - array[int16] push none callable
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int16] sub: push two
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int16] method: push two
ok 171 - array[int16] push two
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int16] sub: push two *
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int16] method: push two *
ok 172 - array[int16] push two *
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int16] sub: push self
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int16] method: push self
ok 173 - array[int16] push self
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int16] sub: push self *
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int16] method: push self *
ok 174 - array[int16] push self *
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int16] sub: unshift
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int16] method: unshift
ok 175 - array[int16] unshift
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int16] sub: unshift none
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int16] method: unshift none
ok 176 - array[int16] unshift none
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int16] sub: unshift self
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int16] method: unshift self
ok 177 - array[int16] unshift self
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int16] sub: replace self
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int16] method: replace self
ok 178 - array[int16] replace self
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int16] sub: replace 1 with 1
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int16] method: replace 1 with 1
ok 179 - array[int16] replace 1 with 1
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int16] sub: replace 1 with range
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int16] method: replace 1 with range
ok 180 - array[int16] replace 1 with range
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int16] sub: replace 1 with none
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int16] method: replace 1 with none
ok 181 - array[int16] replace 1 with none
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int16] sub: replace 1 with self
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int16] method: replace 1 with self
ok 182 - array[int16] replace 1 with self
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int16] sub: replace none with 1
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int16] method: replace none with 1
ok 183 - array[int16] replace none with 1
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int16] sub: replace none with range
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int16] method: replace none with range
ok 184 - array[int16] replace none with range
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int16] sub: replace none with none
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int16] method: replace none with none
ok 185 - array[int16] replace none with none
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int16] sub: replace none with self
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int16] method: replace none with self
ok 186 - array[int16] replace none with self
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int16] sub: remove 1 past end
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int16] method: remove 1 past end
ok 187 - array[int16] remove 1 past end
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int16] sub: remove 1 past end + push
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int16] method: remove 1 past end + push
ok 188 - array[int16] remove 1 past end + push
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int16] sub: remove whatever past end + push
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int16] method: remove whatever past end + push
ok 189 - array[int16] remove whatever past end + push
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int16] sub: two *, no list
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int16] method: two *, no list
ok 190 - array[int16] two *, no list
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int16] sub: two * with a given list
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int16] method: two * with a given list
ok 191 - array[int16] two * with a given list
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int16] sub: .splice(Callable, Whatever)
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int16] method: .splice(Callable, Whatever)
ok 192 - array[int16] .splice(Callable, Whatever)
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int16] sub: .splice(Callable, Whatever, List)
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int16] method: .splice(Callable, Whatever, List)
ok 193 - array[int16] .splice(Callable, Whatever, List)
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int16] sub: .splice(Int, Callable, List)
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int16] method: .splice(Int, Callable, List)
ok 194 - array[int16] .splice(Int, Callable, List)
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int16] sub: .splice(Callable, Int, List)
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int16] method: .splice(Callable, Int, List)
ok 195 - array[int16] .splice(Callable, Int, List)
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int16] sub: .splice(Callable, Callable, List)
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int16] method: .splice(Callable, Callable, List)
ok 196 - array[int16] .splice(Callable, Callable, List)
    1..3
    ok 1 - 'splice @a,0,0,1..Inf' died
    ok 2 - right exception type (X::Cannot::Lazy)
    ok 3 - .action matches splice in
ok 197 - did we throws-like X::Cannot::Lazy?
    1..3
    ok 1 - '@a.splice: 0,0,1..Inf' died
    ok 2 - right exception type (X::Cannot::Lazy)
    ok 3 - .action matches splice in
ok 198 - did we throws-like X::Cannot::Lazy?
    1..5
    ok 1 - 'splice @a,11,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .what matches Offset argument to splice
    ok 4 - .got matches 11
    ok 5 - .range matches 0..10
ok 199 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - '@a.splice: 11,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .what matches Offset argument to splice
    ok 4 - .got matches 11
    ok 5 - .range matches 0..10
ok 200 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - 'splice @a,-1,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .range matches 0..10
    ok 4 - .got matches -1
    ok 5 - .what matches Offset argument to splice
ok 201 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - '@a.splice: -1,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .range matches 0..10
    ok 4 - .what matches Offset argument to splice
    ok 5 - .got matches -1
ok 202 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - 'splice @a,*-11,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .range matches 0..10
    ok 4 - .what matches Offset argument to splice
    ok 5 - .got matches -1
ok 203 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - '@a.splice: *-11,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .got matches -1
    ok 4 - .range matches 0..10
    ok 5 - .what matches Offset argument to splice
ok 204 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - 'splice @a,3,-1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .range matches 0..^7
    ok 4 - .got matches -1
    ok 5 - .what matches Size argument to splice
ok 205 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - '@a.splice: 3,-1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .what matches Size argument to splice
    ok 4 - .got matches -1
    ok 5 - .range matches 0..^7
ok 206 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - 'splice @a,3,*-8' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .what matches Size argument to splice
    ok 4 - .range matches 0..^7
    ok 5 - .got matches -1
ok 207 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - '@a.splice: 3,*-8' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .what matches Size argument to splice
    ok 4 - .got matches -1
    ok 5 - .range matches 0..^7
ok 208 - did we throws-like X::OutOfRange?
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int32] sub: whole
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int32] method: whole
ok 209 - array[int32] whole
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int32] sub: simple 1 elem
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int32] method: simple 1 elem
ok 210 - array[int32] simple 1 elem
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int32] sub: simple 2 elems
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int32] method: simple 2 elems
ok 211 - array[int32] simple 2 elems
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int32] sub: simple 2 elems, as Str
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int32] method: simple 2 elems, as Str
ok 212 - array[int32] simple 2 elems, as Str
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int32] sub: simple rest
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int32] method: simple rest
ok 213 - array[int32] simple rest
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int32] sub: simple rest *
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int32] method: simple rest *
ok 214 - array[int32] simple rest *
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int32] sub: none rest
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int32] method: none rest
ok 215 - array[int32] none rest
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int32] sub: none * rest
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int32] method: none * rest
ok 216 - array[int32] none * rest
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int32] sub: end rest
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int32] method: end rest
ok 217 - array[int32] end rest
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int32] sub: end some
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int32] method: end some
ok 218 - array[int32] end some
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int32] sub: end some callable
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int32] method: end some callable
ok 219 - array[int32] end some callable
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int32] sub: push none
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int32] method: push none
ok 220 - array[int32] push none
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int32] sub: push none *
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int32] method: push none *
ok 221 - array[int32] push none *
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int32] sub: push none callable
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int32] method: push none callable
ok 222 - array[int32] push none callable
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int32] sub: push two
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int32] method: push two
ok 223 - array[int32] push two
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int32] sub: push two *
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int32] method: push two *
ok 224 - array[int32] push two *
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int32] sub: push self
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int32] method: push self
ok 225 - array[int32] push self
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int32] sub: push self *
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int32] method: push self *
ok 226 - array[int32] push self *
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int32] sub: unshift
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int32] method: unshift
ok 227 - array[int32] unshift
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int32] sub: unshift none
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int32] method: unshift none
ok 228 - array[int32] unshift none
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int32] sub: unshift self
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int32] method: unshift self
ok 229 - array[int32] unshift self
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int32] sub: replace self
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int32] method: replace self
ok 230 - array[int32] replace self
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int32] sub: replace 1 with 1
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int32] method: replace 1 with 1
ok 231 - array[int32] replace 1 with 1
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int32] sub: replace 1 with range
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int32] method: replace 1 with range
ok 232 - array[int32] replace 1 with range
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int32] sub: replace 1 with none
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int32] method: replace 1 with none
ok 233 - array[int32] replace 1 with none
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int32] sub: replace 1 with self
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int32] method: replace 1 with self
ok 234 - array[int32] replace 1 with self
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int32] sub: replace none with 1
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int32] method: replace none with 1
ok 235 - array[int32] replace none with 1
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int32] sub: replace none with range
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int32] method: replace none with range
ok 236 - array[int32] replace none with range
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int32] sub: replace none with none
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int32] method: replace none with none
ok 237 - array[int32] replace none with none
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int32] sub: replace none with self
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int32] method: replace none with self
ok 238 - array[int32] replace none with self
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int32] sub: remove 1 past end
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int32] method: remove 1 past end
ok 239 - array[int32] remove 1 past end
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int32] sub: remove 1 past end + push
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int32] method: remove 1 past end + push
ok 240 - array[int32] remove 1 past end + push
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int32] sub: remove whatever past end + push
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int32] method: remove whatever past end + push
ok 241 - array[int32] remove whatever past end + push
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int32] sub: two *, no list
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int32] method: two *, no list
ok 242 - array[int32] two *, no list
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int32] sub: two * with a given list
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int32] method: two * with a given list
ok 243 - array[int32] two * with a given list
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int32] sub: .splice(Callable, Whatever)
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int32] method: .splice(Callable, Whatever)
ok 244 - array[int32] .splice(Callable, Whatever)
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int32] sub: .splice(Callable, Whatever, List)
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int32] method: .splice(Callable, Whatever, List)
ok 245 - array[int32] .splice(Callable, Whatever, List)
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int32] sub: .splice(Int, Callable, List)
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int32] method: .splice(Int, Callable, List)
ok 246 - array[int32] .splice(Int, Callable, List)
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int32] sub: .splice(Callable, Int, List)
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int32] method: .splice(Callable, Int, List)
ok 247 - array[int32] .splice(Callable, Int, List)
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int32] sub: .splice(Callable, Callable, List)
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int32] method: .splice(Callable, Callable, List)
ok 248 - array[int32] .splice(Callable, Callable, List)
    1..3
    ok 1 - 'splice @a,0,0,1..Inf' died
    ok 2 - right exception type (X::Cannot::Lazy)
    ok 3 - .action matches splice in
ok 249 - did we throws-like X::Cannot::Lazy?
    1..3
    ok 1 - '@a.splice: 0,0,1..Inf' died
    ok 2 - right exception type (X::Cannot::Lazy)
    ok 3 - .action matches splice in
ok 250 - did we throws-like X::Cannot::Lazy?
    1..5
    ok 1 - 'splice @a,11,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .what matches Offset argument to splice
    ok 4 - .range matches 0..10
    ok 5 - .got matches 11
ok 251 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - '@a.splice: 11,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .what matches Offset argument to splice
    ok 4 - .got matches 11
    ok 5 - .range matches 0..10
ok 252 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - 'splice @a,-1,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .got matches -1
    ok 4 - .what matches Offset argument to splice
    ok 5 - .range matches 0..10
ok 253 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - '@a.splice: -1,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .range matches 0..10
    ok 4 - .got matches -1
    ok 5 - .what matches Offset argument to splice
ok 254 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - 'splice @a,*-11,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .what matches Offset argument to splice
    ok 4 - .got matches -1
    ok 5 - .range matches 0..10
ok 255 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - '@a.splice: *-11,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .what matches Offset argument to splice
    ok 4 - .got matches -1
    ok 5 - .range matches 0..10
ok 256 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - 'splice @a,3,-1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .range matches 0..^7
    ok 4 - .got matches -1
    ok 5 - .what matches Size argument to splice
ok 257 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - '@a.splice: 3,-1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .what matches Size argument to splice
    ok 4 - .range matches 0..^7
    ok 5 - .got matches -1
ok 258 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - 'splice @a,3,*-8' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .range matches 0..^7
    ok 4 - .got matches -1
    ok 5 - .what matches Size argument to splice
ok 259 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - '@a.splice: 3,*-8' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .what matches Size argument to splice
    ok 4 - .got matches -1
    ok 5 - .range matches 0..^7
ok 260 - did we throws-like X::OutOfRange?
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int64] sub: whole
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int64] method: whole
ok 261 - array[int64] whole
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int64] sub: simple 1 elem
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int64] method: simple 1 elem
ok 262 - array[int64] simple 1 elem
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int64] sub: simple 2 elems
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int64] method: simple 2 elems
ok 263 - array[int64] simple 2 elems
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int64] sub: simple 2 elems, as Str
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int64] method: simple 2 elems, as Str
ok 264 - array[int64] simple 2 elems, as Str
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int64] sub: simple rest
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int64] method: simple rest
ok 265 - array[int64] simple rest
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int64] sub: simple rest *
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int64] method: simple rest *
ok 266 - array[int64] simple rest *
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int64] sub: none rest
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int64] method: none rest
ok 267 - array[int64] none rest
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int64] sub: none * rest
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int64] method: none * rest
ok 268 - array[int64] none * rest
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int64] sub: end rest
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int64] method: end rest
ok 269 - array[int64] end rest
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int64] sub: end some
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int64] method: end some
ok 270 - array[int64] end some
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int64] sub: end some callable
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int64] method: end some callable
ok 271 - array[int64] end some callable
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int64] sub: push none
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int64] method: push none
ok 272 - array[int64] push none
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int64] sub: push none *
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int64] method: push none *
ok 273 - array[int64] push none *
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int64] sub: push none callable
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int64] method: push none callable
ok 274 - array[int64] push none callable
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int64] sub: push two
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int64] method: push two
ok 275 - array[int64] push two
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int64] sub: push two *
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int64] method: push two *
ok 276 - array[int64] push two *
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int64] sub: push self
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int64] method: push self
ok 277 - array[int64] push self
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int64] sub: push self *
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int64] method: push self *
ok 278 - array[int64] push self *
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int64] sub: unshift
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int64] method: unshift
ok 279 - array[int64] unshift
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int64] sub: unshift none
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int64] method: unshift none
ok 280 - array[int64] unshift none
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int64] sub: unshift self
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int64] method: unshift self
ok 281 - array[int64] unshift self
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int64] sub: replace self
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int64] method: replace self
ok 282 - array[int64] replace self
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int64] sub: replace 1 with 1
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int64] method: replace 1 with 1
ok 283 - array[int64] replace 1 with 1
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int64] sub: replace 1 with range
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int64] method: replace 1 with range
ok 284 - array[int64] replace 1 with range
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int64] sub: replace 1 with none
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int64] method: replace 1 with none
ok 285 - array[int64] replace 1 with none
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int64] sub: replace 1 with self
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int64] method: replace 1 with self
ok 286 - array[int64] replace 1 with self
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int64] sub: replace none with 1
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int64] method: replace none with 1
ok 287 - array[int64] replace none with 1
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int64] sub: replace none with range
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int64] method: replace none with range
ok 288 - array[int64] replace none with range
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int64] sub: replace none with none
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int64] method: replace none with none
ok 289 - array[int64] replace none with none
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int64] sub: replace none with self
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int64] method: replace none with self
ok 290 - array[int64] replace none with self
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int64] sub: remove 1 past end
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int64] method: remove 1 past end
ok 291 - array[int64] remove 1 past end
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int64] sub: remove 1 past end + push
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int64] method: remove 1 past end + push
ok 292 - array[int64] remove 1 past end + push
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int64] sub: remove whatever past end + push
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int64] method: remove whatever past end + push
ok 293 - array[int64] remove whatever past end + push
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int64] sub: two *, no list
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int64] method: two *, no list
ok 294 - array[int64] two *, no list
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int64] sub: two * with a given list
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int64] method: two * with a given list
ok 295 - array[int64] two * with a given list
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int64] sub: .splice(Callable, Whatever)
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int64] method: .splice(Callable, Whatever)
ok 296 - array[int64] .splice(Callable, Whatever)
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int64] sub: .splice(Callable, Whatever, List)
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int64] method: .splice(Callable, Whatever, List)
ok 297 - array[int64] .splice(Callable, Whatever, List)
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int64] sub: .splice(Int, Callable, List)
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int64] method: .splice(Int, Callable, List)
ok 298 - array[int64] .splice(Int, Callable, List)
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int64] sub: .splice(Callable, Int, List)
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int64] method: .splice(Callable, Int, List)
ok 299 - array[int64] .splice(Callable, Int, List)
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - array[int64] sub: .splice(Callable, Callable, List)
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - array[int64] method: .splice(Callable, Callable, List)
ok 300 - array[int64] .splice(Callable, Callable, List)
    1..3
    ok 1 - 'splice @a,0,0,1..Inf' died
    ok 2 - right exception type (X::Cannot::Lazy)
    ok 3 - .action matches splice in
ok 301 - did we throws-like X::Cannot::Lazy?
    1..3
    ok 1 - '@a.splice: 0,0,1..Inf' died
    ok 2 - right exception type (X::Cannot::Lazy)
    ok 3 - .action matches splice in
ok 302 - did we throws-like X::Cannot::Lazy?
    1..5
    ok 1 - 'splice @a,11,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .what matches Offset argument to splice
    ok 4 - .got matches 11
    ok 5 - .range matches 0..10
ok 303 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - '@a.splice: 11,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .what matches Offset argument to splice
    ok 4 - .got matches 11
    ok 5 - .range matches 0..10
ok 304 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - 'splice @a,-1,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .got matches -1
    ok 4 - .range matches 0..10
    ok 5 - .what matches Offset argument to splice
ok 305 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - '@a.splice: -1,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .got matches -1
    ok 4 - .what matches Offset argument to splice
    ok 5 - .range matches 0..10
ok 306 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - 'splice @a,*-11,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .what matches Offset argument to splice
    ok 4 - .got matches -1
    ok 5 - .range matches 0..10
ok 307 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - '@a.splice: *-11,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .range matches 0..10
    ok 4 - .got matches -1
    ok 5 - .what matches Offset argument to splice
ok 308 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - 'splice @a,3,-1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .got matches -1
    ok 4 - .range matches 0..^7
    ok 5 - .what matches Size argument to splice
ok 309 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - '@a.splice: 3,-1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .range matches 0..^7
    ok 4 - .what matches Size argument to splice
    ok 5 - .got matches -1
ok 310 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - 'splice @a,3,*-8' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .what matches Size argument to splice
    ok 4 - .range matches 0..^7
    ok 5 - .got matches -1
ok 311 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - '@a.splice: 3,*-8' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .got matches -1
    ok 4 - .what matches Size argument to splice
    ok 5 - .range matches 0..^7
ok 312 - did we throws-like X::OutOfRange?
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array[Int] sub: whole
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array[Int] method: whole
ok 313 - Array[Int] whole
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array[Int] sub: simple 1 elem
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array[Int] method: simple 1 elem
ok 314 - Array[Int] simple 1 elem
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array[Int] sub: simple 2 elems
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array[Int] method: simple 2 elems
ok 315 - Array[Int] simple 2 elems
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array[Int] sub: simple 2 elems, as Str
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array[Int] method: simple 2 elems, as Str
ok 316 - Array[Int] simple 2 elems, as Str
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array[Int] sub: simple rest
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array[Int] method: simple rest
ok 317 - Array[Int] simple rest
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array[Int] sub: simple rest *
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array[Int] method: simple rest *
ok 318 - Array[Int] simple rest *
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array[Int] sub: none rest
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array[Int] method: none rest
ok 319 - Array[Int] none rest
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array[Int] sub: none * rest
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array[Int] method: none * rest
ok 320 - Array[Int] none * rest
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array[Int] sub: end rest
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array[Int] method: end rest
ok 321 - Array[Int] end rest
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array[Int] sub: end some
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array[Int] method: end some
ok 322 - Array[Int] end some
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array[Int] sub: end some callable
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array[Int] method: end some callable
ok 323 - Array[Int] end some callable
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array[Int] sub: push none
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array[Int] method: push none
ok 324 - Array[Int] push none
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array[Int] sub: push none *
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array[Int] method: push none *
ok 325 - Array[Int] push none *
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array[Int] sub: push none callable
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array[Int] method: push none callable
ok 326 - Array[Int] push none callable
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array[Int] sub: push two
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array[Int] method: push two
ok 327 - Array[Int] push two
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array[Int] sub: push two *
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array[Int] method: push two *
ok 328 - Array[Int] push two *
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array[Int] sub: push self
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array[Int] method: push self
ok 329 - Array[Int] push self
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array[Int] sub: push self *
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array[Int] method: push self *
ok 330 - Array[Int] push self *
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array[Int] sub: unshift
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array[Int] method: unshift
ok 331 - Array[Int] unshift
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array[Int] sub: unshift none
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array[Int] method: unshift none
ok 332 - Array[Int] unshift none
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array[Int] sub: unshift self
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array[Int] method: unshift self
ok 333 - Array[Int] unshift self
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array[Int] sub: replace self
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array[Int] method: replace self
ok 334 - Array[Int] replace self
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array[Int] sub: replace 1 with 1
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array[Int] method: replace 1 with 1
ok 335 - Array[Int] replace 1 with 1
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array[Int] sub: replace 1 with range
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array[Int] method: replace 1 with range
ok 336 - Array[Int] replace 1 with range
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array[Int] sub: replace 1 with none
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array[Int] method: replace 1 with none
ok 337 - Array[Int] replace 1 with none
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array[Int] sub: replace 1 with self
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array[Int] method: replace 1 with self
ok 338 - Array[Int] replace 1 with self
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array[Int] sub: replace none with 1
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array[Int] method: replace none with 1
ok 339 - Array[Int] replace none with 1
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array[Int] sub: replace none with range
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array[Int] method: replace none with range
ok 340 - Array[Int] replace none with range
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array[Int] sub: replace none with none
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array[Int] method: replace none with none
ok 341 - Array[Int] replace none with none
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array[Int] sub: replace none with self
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array[Int] method: replace none with self
ok 342 - Array[Int] replace none with self
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array[Int] sub: remove 1 past end
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array[Int] method: remove 1 past end
ok 343 - Array[Int] remove 1 past end
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array[Int] sub: remove 1 past end + push
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array[Int] method: remove 1 past end + push
ok 344 - Array[Int] remove 1 past end + push
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array[Int] sub: remove whatever past end + push
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array[Int] method: remove whatever past end + push
ok 345 - Array[Int] remove whatever past end + push
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array[Int] sub: two *, no list
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array[Int] method: two *, no list
ok 346 - Array[Int] two *, no list
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array[Int] sub: two * with a given list
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array[Int] method: two * with a given list
ok 347 - Array[Int] two * with a given list
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array[Int] sub: .splice(Callable, Whatever)
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array[Int] method: .splice(Callable, Whatever)
ok 348 - Array[Int] .splice(Callable, Whatever)
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array[Int] sub: .splice(Callable, Whatever, List)
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array[Int] method: .splice(Callable, Whatever, List)
ok 349 - Array[Int] .splice(Callable, Whatever, List)
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array[Int] sub: .splice(Int, Callable, List)
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array[Int] method: .splice(Int, Callable, List)
ok 350 - Array[Int] .splice(Int, Callable, List)
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array[Int] sub: .splice(Callable, Int, List)
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array[Int] method: .splice(Callable, Int, List)
ok 351 - Array[Int] .splice(Callable, Int, List)
    1..2
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 1 - Array[Int] sub: .splice(Callable, Callable, List)
        1..4
        ok 1 - return types match
        ok 2 - return results match
        ok 3 - remainder types match
        ok 4 - remainder results match
    ok 2 - Array[Int] method: .splice(Callable, Callable, List)
ok 352 - Array[Int] .splice(Callable, Callable, List)
    1..3
    ok 1 - 'splice @a,0,0,1..Inf' died
    ok 2 - right exception type (X::Cannot::Lazy)
    ok 3 - .action matches splice in
ok 353 - did we throws-like X::Cannot::Lazy?
    1..3
    ok 1 - '@a.splice: 0,0,1..Inf' died
    ok 2 - right exception type (X::Cannot::Lazy)
    ok 3 - .action matches splice in
ok 354 - did we throws-like X::Cannot::Lazy?
    1..5
    ok 1 - 'splice @a,11,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .got matches 11
    ok 4 - .range matches 0..10
    ok 5 - .what matches Offset argument to splice
ok 355 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - '@a.splice: 11,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .range matches 0..10
    ok 4 - .got matches 11
    ok 5 - .what matches Offset argument to splice
ok 356 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - 'splice @a,-1,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .range matches 0..10
    ok 4 - .got matches -1
    ok 5 - .what matches Offset argument to splice
ok 357 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - '@a.splice: -1,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .got matches -1
    ok 4 - .range matches 0..10
    ok 5 - .what matches Offset argument to splice
ok 358 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - 'splice @a,*-11,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .what matches Offset argument to splice
    ok 4 - .range matches 0..10
    ok 5 - .got matches -1
ok 359 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - '@a.splice: *-11,1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .got matches -1
    ok 4 - .what matches Offset argument to splice
    ok 5 - .range matches 0..10
ok 360 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - 'splice @a,3,-1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .got matches -1
    ok 4 - .what matches Size argument to splice
    ok 5 - .range matches 0..^7
ok 361 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - '@a.splice: 3,-1' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .range matches 0..^7
    ok 4 - .got matches -1
    ok 5 - .what matches Size argument to splice
ok 362 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - 'splice @a,3,*-8' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .range matches 0..^7
    ok 4 - .got matches -1
    ok 5 - .what matches Size argument to splice
ok 363 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - '@a.splice: 3,*-8' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .range matches 0..^7
    ok 4 - .what matches Size argument to splice
    ok 5 - .got matches -1
ok 364 - did we throws-like X::OutOfRange?
ok 365 - 
ok 366 - 
    1..5
    ok 1 - 'splice @a,0,0,"foo"' died
    not ok 2 - right exception type (X::TypeCheck::Splice) # TODO somehow the test causes different typecheck error
    # Failed test 'right exception type (X::TypeCheck::Splice)'
    # at SETTING::src/core.c/native_array.pm6 line 1070
    # Expected: X::TypeCheck::Splice
    # Got:      X::AdHoc
    # Exception message: This type cannot unbox to a native integer: P6opaque, Str
    ok 3 - # SKIP wrong exception type
    ok 4 - # SKIP wrong exception type
    ok 5 - # SKIP wrong exception type
not ok 367 - did we throws-like X::TypeCheck::Splice? # TODO somehow the test causes different typecheck error
# Failed test 'did we throws-like X::TypeCheck::Splice?'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-array/splice.rakudo line 189
    1..5
    ok 1 - '@a.splice: 0,0,"foo"' died
    not ok 2 - right exception type (X::TypeCheck::Splice) # TODO somehow the test causes different typecheck error
    # Failed test 'right exception type (X::TypeCheck::Splice)'
    # at SETTING::src/core.c/native_array.pm6 line 1074
    # Expected: X::TypeCheck::Splice
    # Got:      X::AdHoc
    # Exception message: This type cannot unbox to a native integer: P6opaque, Str
    ok 3 - # SKIP wrong exception type
    ok 4 - # SKIP wrong exception type
    ok 5 - # SKIP wrong exception type
not ok 368 - did we throws-like X::TypeCheck::Splice? # TODO somehow the test causes different typecheck error
# Failed test 'did we throws-like X::TypeCheck::Splice?'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-array/splice.rakudo line 189
    1..5
    ok 1 - 'splice @a,0,0,"foo"' died
    not ok 2 - right exception type (X::TypeCheck::Splice) # TODO somehow the test causes different typecheck error
    # Failed test 'right exception type (X::TypeCheck::Splice)'
    # at SETTING::src/core.c/native_array.pm6 line 1070
    # Expected: X::TypeCheck::Splice
    # Got:      X::AdHoc
    # Exception message: This type cannot unbox to a native integer: P6opaque, Str
    ok 3 - # SKIP wrong exception type
    ok 4 - # SKIP wrong exception type
    ok 5 - # SKIP wrong exception type
not ok 369 - did we throws-like X::TypeCheck::Splice? # TODO somehow the test causes different typecheck error
# Failed test 'did we throws-like X::TypeCheck::Splice?'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-array/splice.rakudo line 189
    1..5
    ok 1 - '@a.splice: 0,0,"foo"' died
    not ok 2 - right exception type (X::TypeCheck::Splice) # TODO somehow the test causes different typecheck error
    # Failed test 'right exception type (X::TypeCheck::Splice)'
    # at SETTING::src/core.c/native_array.pm6 line 1074
    # Expected: X::TypeCheck::Splice
    # Got:      X::AdHoc
    # Exception message: This type cannot unbox to a native integer: P6opaque, Str
    ok 3 - # SKIP wrong exception type
    ok 4 - # SKIP wrong exception type
    ok 5 - # SKIP wrong exception type
not ok 370 - did we throws-like X::TypeCheck::Splice? # TODO somehow the test causes different typecheck error
# Failed test 'did we throws-like X::TypeCheck::Splice?'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-array/splice.rakudo line 189
    1..5
    ok 1 - 'splice @a,0,0,"foo"' died
    not ok 2 - right exception type (X::TypeCheck::Splice) # TODO somehow the test causes different typecheck error
    # Failed test 'right exception type (X::TypeCheck::Splice)'
    # at SETTING::src/core.c/native_array.pm6 line 1070
    # Expected: X::TypeCheck::Splice
    # Got:      X::AdHoc
    # Exception message: This type cannot unbox to a native integer: P6opaque, Str
    ok 3 - # SKIP wrong exception type
    ok 4 - # SKIP wrong exception type
    ok 5 - # SKIP wrong exception type
not ok 371 - did we throws-like X::TypeCheck::Splice? # TODO somehow the test causes different typecheck error
# Failed test 'did we throws-like X::TypeCheck::Splice?'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-array/splice.rakudo line 189
    1..5
    ok 1 - '@a.splice: 0,0,"foo"' died
    not ok 2 - right exception type (X::TypeCheck::Splice) # TODO somehow the test causes different typecheck error
    # Failed test 'right exception type (X::TypeCheck::Splice)'
    # at SETTING::src/core.c/native_array.pm6 line 1074
    # Expected: X::TypeCheck::Splice
    # Got:      X::AdHoc
    # Exception message: This type cannot unbox to a native integer: P6opaque, Str
    ok 3 - # SKIP wrong exception type
    ok 4 - # SKIP wrong exception type
    ok 5 - # SKIP wrong exception type
not ok 372 - did we throws-like X::TypeCheck::Splice? # TODO somehow the test causes different typecheck error
# Failed test 'did we throws-like X::TypeCheck::Splice?'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-array/splice.rakudo line 189
    1..5
    ok 1 - 'splice @a,0,0,"foo"' died
    not ok 2 - right exception type (X::TypeCheck::Splice) # TODO somehow the test causes different typecheck error
    # Failed test 'right exception type (X::TypeCheck::Splice)'
    # at SETTING::src/core.c/native_array.pm6 line 1070
    # Expected: X::TypeCheck::Splice
    # Got:      X::AdHoc
    # Exception message: This type cannot unbox to a native integer: P6opaque, Str
    ok 3 - # SKIP wrong exception type
    ok 4 - # SKIP wrong exception type
    ok 5 - # SKIP wrong exception type
not ok 373 - did we throws-like X::TypeCheck::Splice? # TODO somehow the test causes different typecheck error
# Failed test 'did we throws-like X::TypeCheck::Splice?'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-array/splice.rakudo line 189
    1..5
    ok 1 - '@a.splice: 0,0,"foo"' died
    not ok 2 - right exception type (X::TypeCheck::Splice) # TODO somehow the test causes different typecheck error
    # Failed test 'right exception type (X::TypeCheck::Splice)'
    # at SETTING::src/core.c/native_array.pm6 line 1074
    # Expected: X::TypeCheck::Splice
    # Got:      X::AdHoc
    # Exception message: This type cannot unbox to a native integer: P6opaque, Str
    ok 3 - # SKIP wrong exception type
    ok 4 - # SKIP wrong exception type
    ok 5 - # SKIP wrong exception type
not ok 374 - did we throws-like X::TypeCheck::Splice? # TODO somehow the test causes different typecheck error
# Failed test 'did we throws-like X::TypeCheck::Splice?'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-array/splice.rakudo line 189
    1..5
    ok 1 - 'splice @a,0,0,"foo"' died
    not ok 2 - right exception type (X::TypeCheck::Splice) # TODO somehow the test causes different typecheck error
    # Failed test 'right exception type (X::TypeCheck::Splice)'
    # at SETTING::src/core.c/native_array.pm6 line 1070
    # Expected: X::TypeCheck::Splice
    # Got:      X::AdHoc
    # Exception message: This type cannot unbox to a native integer: P6opaque, Str
    ok 3 - # SKIP wrong exception type
    ok 4 - # SKIP wrong exception type
    ok 5 - # SKIP wrong exception type
not ok 375 - did we throws-like X::TypeCheck::Splice? # TODO somehow the test causes different typecheck error
# Failed test 'did we throws-like X::TypeCheck::Splice?'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-array/splice.rakudo line 189
    1..5
    ok 1 - '@a.splice: 0,0,"foo"' died
    not ok 2 - right exception type (X::TypeCheck::Splice) # TODO somehow the test causes different typecheck error
    # Failed test 'right exception type (X::TypeCheck::Splice)'
    # at SETTING::src/core.c/native_array.pm6 line 1074
    # Expected: X::TypeCheck::Splice
    # Got:      X::AdHoc
    # Exception message: This type cannot unbox to a native integer: P6opaque, Str
    ok 3 - # SKIP wrong exception type
    ok 4 - # SKIP wrong exception type
    ok 5 - # SKIP wrong exception type
not ok 376 - did we throws-like X::TypeCheck::Splice? # TODO somehow the test causes different typecheck error
# Failed test 'did we throws-like X::TypeCheck::Splice?'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-array/splice.rakudo line 189
    1..5
    ok 1 - 'splice @a,0,0,"foo"' died
    ok 2 - right exception type (X::TypeCheck::Splice)
    not ok 3 - .expected matches Array[Int] # TODO somehow the test causes different typecheck error
    # Failed test '.expected matches Array[Int]'
    # at SETTING::src/core.c/Any-iterable-methods.pm6 line 626
    # Expected: Array[Int]
    # Got:      
    ok 4 - .action matches splice
    ok 5 - .got matches (Str)
not ok 377 - did we throws-like X::TypeCheck::Splice? # TODO somehow the test causes different typecheck error
# Failed test 'did we throws-like X::TypeCheck::Splice?'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-array/splice.rakudo line 189
    1..5
    ok 1 - '@a.splice: 0,0,"foo"' died
    ok 2 - right exception type (X::TypeCheck::Splice)
    not ok 3 - .expected matches Array[Int] # TODO somehow the test causes different typecheck error
    # Failed test '.expected matches Array[Int]'
    # at SETTING::src/core.c/Any-iterable-methods.pm6 line 626
    # Expected: Array[Int]
    # Got:      
    ok 4 - .action matches splice
    ok 5 - .got matches (Str)
not ok 378 - did we throws-like X::TypeCheck::Splice? # TODO somehow the test causes different typecheck error
# Failed test 'did we throws-like X::TypeCheck::Splice?'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-array/splice.rakudo line 189
ok 379 - Calling splice with immediate and indirect context returns consistent results
ok 380 - Explicit call/assignment gives the expected results
ok 381 - Implicit context gives the expected results
ok 382 - Explicit scalar context returns an array reference
ok 383 - 'while (…splice…)' should neither hang nor even run
ok 384 - &splice is type-safe
ok 385 - .splice is type-safe
ok 386 - Whatever splice
    1..4
    ok 1 - method on empty array
    ok 2 - method on array with elements
    ok 3 - sub with empty array
    ok 4 - sub with array with elements
ok 387 - splice can extend an array
ok 388 - splice(Whatever, Callable) lives
ok 389 - splice(Whatever, Callable, @a) lives
    1..62
    ok 1 - return correct for \()
    ok 2 - result correct for \()
    ok 3 - return correct for \(*)
    ok 4 - result correct for \(*)
    ok 5 - return correct for \(*, *)
    ok 6 - result correct for \(*, *)
    ok 7 - return correct for \(*, *, [4, 5, 6])
    ok 8 - result correct for \(*, *, [4, 5, 6])
    ok 9 - return correct for \(*, 2)
    ok 10 - result correct for \(*, 2)
    ok 11 - return correct for \(*, 2, [4, 5, 6])
    ok 12 - result correct for \(*, 2, [4, 5, 6])
    ok 13 - return correct for \(*, -> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140435280341408) ... })
    ok 14 - result correct for \(*, -> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140435280341408) ... })
    ok 15 - return correct for \(*, -> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140435280341264) ... }, [4, 5, 6])
    ok 16 - result correct for \(*, -> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140435280341264) ... }, [4, 5, 6])
    ok 17 - return correct for \(*, *, 4, 5, 6)
    ok 18 - result correct for \(*, *, 4, 5, 6)
    ok 19 - return correct for \(*, 2, 4, 5, 6)
    ok 20 - result correct for \(*, 2, 4, 5, 6)
    ok 21 - return correct for \(*, -> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140435280341120) ... }, 4, 5, 6)
    ok 22 - result correct for \(*, -> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140435280341120) ... }, 4, 5, 6)
    ok 23 - return correct for \(-> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140435280340976) ... })
    ok 24 - result correct for \(-> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140435280340976) ... })
    ok 25 - return correct for \(-> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140435280340832) ... }, *)
    ok 26 - result correct for \(-> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140435280340832) ... }, *)
    ok 27 - return correct for \(-> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140435280340688) ... }, *, [4, 5, 6])
    ok 28 - result correct for \(-> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140435280340688) ... }, *, [4, 5, 6])
    ok 29 - return correct for \(-> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140435280340544) ... }, 1)
    ok 30 - result correct for \(-> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140435280340544) ... }, 1)
    ok 31 - return correct for \(-> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140435280340400) ... }, 1, [4, 5, 6])
    ok 32 - result correct for \(-> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140435280340400) ... }, 1, [4, 5, 6])
    ok 33 - return correct for \(-> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140435280340256) ... }, -> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140435280340112) ... })
    ok 34 - result correct for \(-> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140435280340256) ... }, -> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140435280340112) ... })
    ok 35 - return correct for \(-> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140435280339968) ... }, -> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140435280339824) ... }, [4, 5, 6])
    ok 36 - result correct for \(-> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140435280339968) ... }, -> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140435280339824) ... }, [4, 5, 6])
    ok 37 - return correct for \(-> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140435280339680) ... }, *, 4, 5, 6)
    ok 38 - result correct for \(-> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140435280339680) ... }, *, 4, 5, 6)
    ok 39 - return correct for \(-> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140435280339536) ... }, 1, 4, 5, 6)
    ok 40 - result correct for \(-> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140435280339536) ... }, 1, 4, 5, 6)
    ok 41 - return correct for \(-> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140435280339392) ... }, -> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140435280339248) ... }, 4, 5, 6)
    ok 42 - result correct for \(-> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140435280339392) ... }, -> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140435280339248) ... }, 4, 5, 6)
    ok 43 - return correct for \(2)
    ok 44 - result correct for \(2)
    ok 45 - return correct for \(2, *)
    ok 46 - result correct for \(2, *)
    ok 47 - return correct for \(2, *, [4, 5, 6])
    ok 48 - result correct for \(2, *, [4, 5, 6])
    ok 49 - return correct for \(2, 1)
    ok 50 - result correct for \(2, 1)
    ok 51 - return correct for \(2, 1, [4, 5, 6])
    ok 52 - result correct for \(2, 1, [4, 5, 6])
    ok 53 - return correct for \(2, -> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140435280339104) ... })
    ok 54 - result correct for \(2, -> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140435280339104) ... })
    ok 55 - return correct for \(2, -> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140435280338960) ... }, [4, 5, 6])
    ok 56 - result correct for \(2, -> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140435280338960) ... }, [4, 5, 6])
    ok 57 - return correct for \(2, *, 4, 5, 6)
    ok 58 - result correct for \(2, *, 4, 5, 6)
    ok 59 - return correct for \(2, 1, 4, 5, 6)
    ok 60 - result correct for \(2, 1, 4, 5, 6)
    ok 61 - return correct for \(2, -> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140435280338816) ... }, 4, 5, 6)
    ok 62 - result correct for \(2, -> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140435280338816) ... }, 4, 5, 6)
ok 390 - Array.splice
    1..12
    ok 1 - arg is correct for start
    ok 2 - arg is correct for offset
    ok 3 - arg is correct for start
    ok 4 - arg is correct for offset
    ok 5 - arg is correct for start
    ok 6 - arg is correct for offset
    ok 7 - arg is correct for start
    ok 8 - arg is correct for offset
    ok 9 - arg is correct for start
    ok 10 - arg is correct for offset
    ok 11 - arg is correct for start
    ok 12 - arg is correct for offset
ok 391 - Array.splice callable args
    1..8
    ok 1 - return value (non-lazy)
    ok 2 - result (non-lazy)
    ok 3 - return value (lazy)
    ok 4 - result (lazy)
    ok 5 - return value (uninitialized)
    ok 6 - result (uninitialized)
    ok 7 - return value (empty)
    ok 8 - result (empty)
ok 392 - Array.splice can splice beyond end of Array
# FUDGED!
1..129
ok 1 - Hash.AT-KEY
ok 2 - Hash.AT-KEY =
ok 3 - Hash.AT-KEY (changed)
ok 4 - Hash.EXISTS-KEY (existing)
ok 5 - !Hash.EXISTS-KEY (non-existing)
ok 6 - Hash.ASSIGN-KEY (existing)
ok 7 - Hash.AT-KEY (existing ASSIGN-KEY)
ok 8 - Hash.ASSIGN-KEY (non-existing)
ok 9 - Hash.AT-KEY (non-existing ASSIGN-KEY)
ok 10 - Hash.BIND-KEY (existing)
ok 11 - Hash.AT-KEY (existing BIND-KEY)
ok 12 - Hash.AT-KEY (changed existing BIND-KEY)
ok 13 - Hash.BIND-KEY (non-existing)
ok 14 - Hash.AT-KEY (non-existing BIND-KEY)
ok 15 - Hash.AT-KEY (changed non-existing BIND-KEY)
ok 16 - Hash.DELETE-KEY (existing)
ok 17 - !Hash.EXISTS-KEY (existing DELETE-KEY)
ok 18 - Hash.DELETE-KEY (non-existing)
ok 19 - !Hash.EXISTS-KEY (non-existing DELETE-KEY)
ok 20 - Hash[Int].AT-KEY
ok 21 - Hash[Int].AT-KEY =
ok 22 - Hash[Int].AT-KEY (changed)
ok 23 - Hash[Int].EXISTS-KEY (existing)
ok 24 - !Hash[Int].EXISTS-KEY (non-existing)
ok 25 - Hash[Int].ASSIGN-KEY (existing)
ok 26 - Hash[Int].AT-KEY (existing ASSIGN-KEY)
ok 27 - Hash[Int].ASSIGN-KEY (non-existing)
ok 28 - Hash[Int].AT-KEY (non-existing ASSIGN-KEY)
ok 29 - Hash[Int].BIND-KEY (existing)
ok 30 - Hash[Int].AT-KEY (existing BIND-KEY)
ok 31 - Hash[Int].AT-KEY (changed existing BIND-KEY)
ok 32 - Hash[Int].BIND-KEY (non-existing)
ok 33 - Hash[Int].AT-KEY (non-existing BIND-KEY)
ok 34 - Hash[Int].AT-KEY (changed non-existing BIND-KEY)
ok 35 - Hash[Int].DELETE-KEY (existing)
ok 36 - !Hash[Int].EXISTS-KEY (existing DELETE-KEY)
ok 37 - Hash[Int].DELETE-KEY (non-existing)
ok 38 - !Hash[Int].EXISTS-KEY (non-existing DELETE-KEY)
ok 39 - Hash[Int,Any].AT-KEY
ok 40 - Hash[Int,Any].AT-KEY =
ok 41 - Hash[Int,Any].AT-KEY (changed)
ok 42 - Hash[Int,Any].EXISTS-KEY (existing)
ok 43 - !Hash[Int,Any].EXISTS-KEY (non-existing)
ok 44 - Hash[Int,Any].ASSIGN-KEY (existing)
ok 45 - Hash[Int,Any].AT-KEY (existing ASSIGN-KEY)
ok 46 - Hash[Int,Any].ASSIGN-KEY (non-existing)
ok 47 - Hash[Int,Any].AT-KEY (non-existing ASSIGN-KEY)
ok 48 - Hash[Int,Any].BIND-KEY (existing)
ok 49 - Hash[Int,Any].AT-KEY (existing BIND-KEY)
ok 50 - Hash[Int,Any].AT-KEY (changed existing BIND-KEY)
ok 51 - Hash[Int,Any].BIND-KEY (non-existing)
ok 52 - Hash[Int,Any].AT-KEY (non-existing BIND-KEY)
ok 53 - Hash[Int,Any].AT-KEY (changed non-existing BIND-KEY)
ok 54 - Hash[Int,Any].DELETE-KEY (existing)
ok 55 - !Hash[Int,Any].EXISTS-KEY (existing DELETE-KEY)
ok 56 - Hash[Int,Any].DELETE-KEY (non-existing)
ok 57 - !Hash[Int,Any].EXISTS-KEY (non-existing DELETE-KEY)
ok 58 - $a.EXISTS-KEY (undefined)
ok 59 - $a.AT-KEY (undefined)
ok 60 - $a.AT-KEY = (undefined)
ok 61 - $a.AT-KEY (defined)
ok 62 - $a.EXISTS-KEY (defined)
ok 63 - $a.DELETE-KEY (defined)
ok 64 - $a.EXISTS-KEY (after delete)
ok 65 - $a.ASSIGN-KEY (undefined)
ok 66 - $a.AT-KEY (defined)
ok 67 - $a.DELETE-KEY (defined)
ok 68 - $a.EXISTS-KEY (after delete)
ok 69 - $a.BIND-KEY (undefined)
ok 70 - $a.AT-KEY (defined)
not ok 71 - $a.AT-KEY (defined) # TODO binding to a key in an undefine doesn't work?
# Failed test '$a.AT-KEY (defined)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-basics/xxKEY.rakudo line 69
# expected: '65'
#      got: '42'
not ok 72 - $a.DELETE-KEY (defined) # TODO binding to a key in an undefine doesn't work?
# Failed test '$a.DELETE-KEY (defined)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-basics/xxKEY.rakudo line 70
# expected: '65'
#      got: '42'
ok 73 - $a.EXISTS-KEY (after delete)
ok 74 - $a.DELETE-KEY (undefined)
ok 75 - $a.EXISTS-KEY (after delete)
ok 76 - $s.EXISTS-KEY
ok 77 - !$s.EXISTS-KEY
ok 78 - $s.AT-KEY
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Bind)
    ok 3 - .target matches Set
ok 79 - $s.BIND-KEY
ok 80 - $s.AT-KEY (after bind)
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::Immutable)
    ok 3 - .method matches DELETE-KEY
    ok 4 - .typename matches Set
ok 81 - $s.DELETE-KEY
ok 82 - $s.AT-KEY (after delete)
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Assignment::RO)
    ok 3 - .typename matches Set
ok 83 - $s.ASSIGN-KEY
ok 84 - $s.AT-KEY (after assignment)
ok 85 - $sh.EXISTS-KEY
ok 86 - !$sh.EXISTS-KEY
ok 87 - $sh.AT-KEY
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Bind)
    ok 3 - .target matches SetHash
ok 88 - $sh.BIND-KEY
ok 89 - $sh.AT-KEY (after bind)
ok 90 - $sh.DELETE-KEY
ok 91 - $sh.EXISTS-KEY (after delete)
ok 92 - $sh.ASSIGN-KEY
ok 93 - $sh.AT-KEY (after assignment)
ok 94 - $b.EXISTS-KEY
ok 95 - !$b.EXISTS-KEY
ok 96 - $b.AT-KEY
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Bind)
    ok 3 - .target matches Bag
ok 97 - $b.BIND-KEY
ok 98 - $b.AT-KEY (after bind)
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::Immutable)
    ok 3 - .method matches DELETE-KEY
    ok 4 - .typename matches Bag
ok 99 - $b.DELETE-KEY
ok 100 - $b.AT-KEY (after delete)
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Assignment::RO)
    ok 3 - .typename matches Int
ok 101 - $b.ASSIGN-KEY
ok 102 - $b.AT-KEY (after assignment)
ok 103 - $bh.EXISTS-KEY
ok 104 - !$bh.EXISTS-KEY
ok 105 - $bh.AT-KEY
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Bind)
    ok 3 - .target matches BagHash
ok 106 - $bh.BIND-KEY
ok 107 - $bh.AT-KEY (after bind)
ok 108 - $bh.DELETE-KEY
ok 109 - $bh.EXISTS-KEY (after delete)
ok 110 - $bh.ASSIGN-KEY
ok 111 - $bh.EXISTS-KEY (after assignment)
ok 112 - $m.EXISTS-KEY
ok 113 - !$m.EXISTS-KEY
ok 114 - $m.AT-KEY
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Bind)
    ok 3 - .target matches Mix
ok 115 - $m.BIND-KEY
ok 116 - $m.AT-KEY (after bind)
    1..4
    ok 1 - code dies
    ok 2 - right exception type (X::Immutable)
    ok 3 - .typename matches Mix
    ok 4 - .method matches DELETE-KEY
ok 117 - $m.DELETE-KEY
ok 118 - $m.AT-KEY (after delete)
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Assignment::RO)
    ok 3 - .typename matches Int
ok 119 - $m.ASSIGN-KEY
ok 120 - $m.AT-KEY (after assignment)
ok 121 - $mh.EXISTS-KEY
ok 122 - !$mh.EXISTS-KEY
ok 123 - $mh.AT-KEY
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Bind)
    ok 3 - .target matches MixHash
ok 124 - $mh.BIND-KEY
ok 125 - $mh.AT-KEY (after bind)
ok 126 - $mh.DELETE-KEY
ok 127 - $mh.EXISTS-KEY (after delete)
ok 128 - $mh.ASSIGN-KEY
ok 129 - $mh.EXISTS-KEY (after assignment)
# FUDGED!
1..64
ok 1 - Array.elems (original)
ok 2 - Array.AT-POS
ok 3 - Array.AT-POS =
ok 4 - Array.AT-POS (changed)
ok 5 - Array.EXISTS-POS (existing)
ok 6 - !Array.EXISTS-POS (non-existing)
ok 7 - Array.ASSIGN-POS (existing)
ok 8 - Array.AT-POS (existing ASSIGN-POS)
ok 9 - Array.ASSIGN-POS (non-existing)
ok 10 - Array.AT-POS (non-existing ASSIGN-POS)
ok 11 - Array.elens (one added)
ok 12 - Array.BIND-POS (existing)
ok 13 - Array.AT-POS (existing BIND-POS)
ok 14 - Array.AT-POS (changed existing BIND-POS)
ok 15 - Array.BIND-POS (non-existing)
ok 16 - Array.AT-POS (non-existing BIND-POS)
ok 17 - Array.AT-POS (changed non-existing BIND-POS)
ok 18 - Array.DELETE-POS (existing)
ok 19 - !Array.EXISTS-POS (existing DELETE-POS)
ok 20 - Array.DELETE-POS (non-existing)
ok 21 - !Array.EXISTS-POS (non-existing DELETE-POS)
ok 22 - Array[Int].elems (original)
ok 23 - Array[Int].AT-POS
ok 24 - Array[Int].AT-POS =
ok 25 - Array[Int].AT-POS (changed)
ok 26 - Array[Int].EXISTS-POS (existing)
ok 27 - !Array[Int].EXISTS-POS (non-existing)
ok 28 - Array[Int].ASSIGN-POS (existing)
ok 29 - Array[Int].AT-POS (existing ASSIGN-POS)
ok 30 - Array[Int].ASSIGN-POS (non-existing)
ok 31 - Array[Int].AT-POS (non-existing ASSIGN-POS)
ok 32 - Array[Int].elens (one added)
ok 33 - Array[Int].BIND-POS (existing)
ok 34 - Array[Int].AT-POS (existing BIND-POS)
ok 35 - Array[Int].AT-POS (changed existing BIND-POS)
ok 36 - Array[Int].BIND-POS (non-existing)
ok 37 - Array[Int].AT-POS (non-existing BIND-POS)
ok 38 - Array[Int].AT-POS (changed non-existing BIND-POS)
ok 39 - Array[Int].DELETE-POS (existing)
ok 40 - !Array[Int].EXISTS-POS (existing DELETE-POS)
ok 41 - Array[Int].DELETE-POS (non-existing)
ok 42 - !Array[Int].EXISTS-POS (non-existing DELETE-POS)
ok 43 - $a.EXISTS-POS (undefined)
ok 44 - $a.AT-POS (undefined)
ok 45 - $a.AT-POS = (undefined)
ok 46 - $a.AT-POS (defined)
ok 47 - $a.EXISTS-POS (defined)
ok 48 - $a.DELETE-POS (defined)
ok 49 - $a.EXISTS-POS (after delete)
ok 50 - $a.ASSIGN-POS (undefined)
ok 51 - $a.AT-POS (defined)
ok 52 - $a.DELETE-POS (defined)
ok 53 - $a.EXISTS-POS (after delete)
ok 54 - # SKIP No such method 'BIND-POS' for invocant of type 'Any'
ok 55 - # SKIP No such method 'BIND-POS' for invocant of type 'Any'
ok 56 - # SKIP No such method 'BIND-POS' for invocant of type 'Any'
ok 57 - # SKIP No such method 'BIND-POS' for invocant of type 'Any'
ok 58 - # SKIP No such method 'BIND-POS' for invocant of type 'Any'
ok 59 - $a.DELETE-POS (undefined)
ok 60 - $a.EXISTS-POS (after delete)
ok 61 - 2 dimensional EXISTS-POS with Failure
ok 62 - 3 dimensional EXISTS-POS with Failure
ok 63 - 4 dimensional EXISTS-POS with Failure
ok 64 - Could we change the "element" without creating ASSIGN-POS?
# FUDGED!
1..6
ok 1 - # SKIP cat NYI
ok 2 - # SKIP cat NYI
ok 3 - # SKIP cat NYI
ok 4 - # SKIP cat NYI
ok 5 - # SKIP cat NYI
ok 6 - # SKIP cat NYI
# FUDGED!
1..14
ok 1 - simple zip
ok 2 - also with Z char
ok 3 - zip of 3 arrays
ok 4 - also with Z char
ok 5 - zip uses length of shortest
ok 6 - # SKIP lvalue zip
ok 7 - # SKIP lvalue zip
ok 8 - infix:<Z> imposes list context
ok 9 - can mix arrays and ranges for infix:<Z>
ok 10 - can mix arrays and ranges for infix:<Z>
ok 11 - zip:with works on list associative
ok 12 - zip:with works on left associative
ok 13 - zip:with works on right associative
ok 14 - zip:with works on chain associative
# FUDGED!
1..267
    1..3
    ok 1 - '42 +' died
    ok 2 - right exception type (Exception)
    ok 3 - .message matches rx/term/
ok 1 - missing rhs of infix
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Buf::AsStr)
    ok 3 - .method matches Str
ok 2 - did we throws-like X::Buf::AsStr?
    1..3
    ok 1 - 'use experimental :pack; pack("B",  1)' died
    ok 2 - right exception type (X::Buf::Pack)
    ok 3 - .directive matches B
ok 3 - did we throws-like X::Buf::Pack?
    1..3
    ok 1 - 'use experimental :pack; Buf.new.unpack("B")' died
    ok 2 - right exception type (X::Buf::Pack)
    ok 3 - .directive matches B
ok 4 - did we throws-like X::Buf::Pack?
    1..3
    ok 1 - 'use experimental :pack; pack "A2", "mÄ"' died
    ok 2 - right exception type (X::Buf::Pack::NonASCII)
    ok 3 - .char matches Ä
ok 5 - did we throws-like X::Buf::Pack::NonASCII?
    1..6
    ok 1 - 'my class Foo { method a() { $!bar } }' died
    ok 2 - right exception type (X::Attribute::Undeclared)
    ok 3 - .what matches attribute
    ok 4 - .package-kind matches class
    ok 5 - .package-name matches Foo
    ok 6 - .symbol matches $!bar
ok 6 - did we throws-like X::Attribute::Undeclared?
    1..4
    ok 1 - 'sub f() { $^x }' died
    ok 2 - right exception type (X::Signature::Placeholder)
    ok 3 - .placeholder matches $^x
    ok 4 - .line matches 1
ok 7 - did we throws-like X::Signature::Placeholder?
    1..4
    ok 1 - 'qr/a/' died
    ok 2 - right exception type (X::Obsolete)
    ok 3 - .replacement matches rx/<<rx>>/
    ok 4 - .old matches rx/<<qr>>/
ok 8 - did we throws-like X::Obsolete?
    1..3
    ok 1 - '"a" . "b"' died
    ok 2 - right exception type (X::Obsolete)
    ok 3 - .replacement matches ~
ok 9 - did we throws-like X::Obsolete?
    1..2
    ok 1 - 's/a/b/i' died
    ok 2 - right exception type (X::Obsolete)
ok 10 - did we throws-like X::Obsolete?
    1..2
    ok 1 - 'my $a; ${a} = 5' died
    ok 2 - right exception type (X::Obsolete)
ok 11 - did we throws-like X::Obsolete?
    1..2
    ok 1 - '${۳}' died
    ok 2 - right exception type (X::Obsolete)
ok 12 - did we throws-like X::Obsolete?
    1..3
    ok 1 - 'do    { $^x }' died
    ok 2 - right exception type (X::Placeholder::Block)
    ok 3 - .placeholder matches $^x
ok 13 - did we throws-like X::Placeholder::Block?
    1..3
    ok 1 - 'do    { @_  }' died
    ok 2 - right exception type (X::Placeholder::Block)
    ok 3 - .placeholder matches @_
ok 14 - did we throws-like X::Placeholder::Block?
    1..3
    ok 1 - 'class { $^x }' died
    ok 2 - right exception type (X::Placeholder::Block)
    ok 3 - .placeholder matches $^x
ok 15 - did we throws-like X::Placeholder::Block?
    1..3
    ok 1 - '$^x' died
    ok 2 - right exception type (X::Placeholder::Mainline)
    ok 3 - .placeholder matches $^x
ok 16 - did we throws-like X::Placeholder::Mainline?
    1..3
    ok 1 - '@_' died
    ok 2 - right exception type (X::Placeholder::Mainline)
    ok 3 - .placeholder matches @_
ok 17 - did we throws-like X::Placeholder::Mainline?
    1..2
    ok 1 - '"foo".{ say $^a }' died
    ok 2 - right exception type (X::Placeholder::Mainline)
ok 18 - did we throws-like X::Placeholder::Mainline?
    1..3
    ok 1 - 'class RT78112 { has $.a = $^b + 1; }' died
    ok 2 - right exception type (X::Placeholder::Attribute)
    ok 3 - .placeholder matches $^b
ok 19 - did we throws-like X::Placeholder::Attribute?
    1..4
    ok 1 - 'sub f(*@ = 2) { }' died
    ok 2 - right exception type (X::Parameter::Default)
    ok 3 - .parameter matches WhateverCode.new
    ok 4 - .how matches slurpy
ok 20 - did we throws-like X::Parameter::Default?
    1..4
    ok 1 - 'sub f($x! = 3) { }' died
    ok 2 - right exception type (X::Parameter::Default)
    ok 3 - .how matches required
    ok 4 - .parameter matches $x
ok 21 - did we throws-like X::Parameter::Default?
    1..3
    ok 1 - 'sub f(:$x! = 3) { }' died
    ok 2 - right exception type (X::Parameter::Default)
    ok 3 - .how matches required
ok 22 - did we throws-like X::Parameter::Default?
    1..4
    ok 1 - 'sub f($:x) { }' died
    ok 2 - right exception type (X::Parameter::Placeholder)
    ok 3 - .parameter matches $:x
    ok 4 - .right matches :$x
ok 23 - did we throws-like X::Parameter::Placeholder?
    1..4
    ok 1 - 'sub f($?x) { }' died
    ok 2 - right exception type (X::Parameter::Twigil)
    ok 3 - .parameter matches $?x
    ok 4 - .twigil matches ?
ok 24 - did we throws-like X::Parameter::Twigil?
    1..2
    ok 1 - 'sub (Int Str $x) { }' died
    ok 2 - right exception type (X::Parameter::MultipleTypeConstraints)
ok 25 - did we throws-like X::Parameter::MultipleTypeConstraints?
    1..3
    ok 1 - 'sub f($x = 60 is rw) { }' died
    ok 2 - right exception type (X::Parameter::AfterDefault)
    ok 3 - .type matches trait
ok 26 - did we throws-like X::Parameter::AfterDefault?
    1..3
    ok 1 - 'sub f($x = 60 where Int) { }' died
    ok 2 - right exception type (X::Parameter::AfterDefault)
    ok 3 - .type matches post constraint
ok 27 - did we throws-like X::Parameter::AfterDefault?
    1..4
    ok 1 - 'sub a { }; sub a { }' died
    ok 2 - right exception type (X::Redeclaration)
    ok 3 - .what matches routine
    ok 4 - .symbol matches a
ok 28 - did we throws-like X::Redeclaration?
    1..4
    ok 1 - 'my &a; multi a { }' died
    ok 2 - right exception type (X::Redeclaration)
    ok 3 - .symbol matches a
    ok 4 - .what matches routine
ok 29 - did we throws-like X::Redeclaration?
    1..4
    ok 1 - 'sub a { }; multi sub a { }' died
    ok 2 - right exception type (X::Redeclaration)
    ok 3 - .symbol matches a
    ok 4 - .what matches routine
ok 30 - did we throws-like X::Redeclaration?
    1..3
    ok 1 - 'my class A { }; my class A { }' died
    ok 2 - right exception type (X::Redeclaration)
    ok 3 - .symbol matches A
ok 31 - did we throws-like X::Redeclaration?
    1..3
    ok 1 - 'my class B { }; my subset B of Any;' died
    ok 2 - right exception type (X::Redeclaration)
    ok 3 - .symbol matches B
ok 32 - did we throws-like X::Redeclaration?
    1..3
    ok 1 - 'CATCH { }; CATCH { }' died
    ok 2 - right exception type (X::Phaser::Multiple)
    ok 3 - .block matches CATCH
ok 33 - did we throws-like X::Phaser::Multiple?
    1..2
    ok 1 - 'sub f(--> List) returns Str { }' died
    ok 2 - right exception type (X::Redeclaration)
ok 34 - did we throws-like X::Redeclaration?
    1..2
    ok 1 - 'my Int sub f(--> Str) { }' died
    ok 2 - right exception type (X::Redeclaration)
ok 35 - did we throws-like X::Redeclaration?
    1..3
    ok 1 - 'my class F { }; role F { }' died
    ok 2 - right exception type (X::Redeclaration)
    ok 3 - .symbol matches F
ok 36 - did we throws-like X::Redeclaration?
    1..3
    ok 1 - 'class AAAA { class B {} }; use MONKEY; augment class AAAA { class B { } }' died
    ok 2 - right exception type (X::Redeclaration)
    ok 3 - .symbol matches B
ok 37 - did we throws-like X::Redeclaration?
    1..3
    ok 1 - 'class AAAAA { class B::C {} }; use MONKEY; augment class AAAAA { class B::C { } }' died
    ok 2 - right exception type (X::Redeclaration)
    ok 3 - .symbol matches B::C
ok 38 - did we throws-like X::Redeclaration?
    1..5
    ok 1 - 'my class A { my @a; @a!List::foo() }' died
    ok 2 - right exception type (X::Method::Private::Permission)
    ok 3 - .source-package matches List
    ok 4 - .method matches foo
    ok 5 - .calling-package matches A
ok 39 - did we throws-like X::Method::Private::Permission?
    1..3
    ok 1 - '1!foo()' died
    ok 2 - right exception type (X::Method::Private::Unqualified)
    ok 3 - .method matches foo
ok 40 - did we throws-like X::Method::Private::Unqualified?
    1..2
    ok 1 - 'sub f() { }; f() := 2' died
    ok 2 - right exception type (X::Bind)
ok 41 - did we throws-like X::Bind?
    1..3
    ok 1 - 'OUTER := 5' died
    ok 2 - right exception type (X::Bind)
    ok 3 - .target matches /OUTER/
ok 42 - did we throws-like X::Bind?
    1..3
    ok 1 - 'my int $x := 2' died
    ok 2 - right exception type (X::Bind::NativeType)
    ok 3 - .name matches $x
ok 43 - did we throws-like X::Bind::NativeType?
    1..3
    ok 1 - 'my @a; @a[] := <foo bar baz>' died
    ok 2 - right exception type (X::Bind::ZenSlice)
    ok 3 - .type matches (Array)
ok 44 - did we throws-like X::Bind::ZenSlice?
    1..3
    ok 1 - 'my %a; %a{} := foo=>1, bar=>2, baz=>3' died
    ok 2 - right exception type (X::Bind::ZenSlice)
    ok 3 - .type matches (Hash)
ok 45 - did we throws-like X::Bind::ZenSlice?
    1..4
    ok 1 - 'for (1; 1; 1) { }' died
    ok 2 - right exception type (X::Obsolete)
    ok 3 - .old matches rx/<<for>>/
    ok 4 - .replacement matches rx/<<loop>>/
ok 46 - did we throws-like X::Obsolete?
    1..4
    ok 1 - 'foreach (1..10) { }' died
    ok 2 - right exception type (X::Obsolete)
    ok 3 - .replacement matches 'for'
    ok 4 - .old matches 'foreach'
ok 47 - did we throws-like X::Obsolete?
    1..3
    ok 1 - 'undef' died
    ok 2 - right exception type (X::Obsolete)
    ok 3 - .old matches rx/<<undef>>/
ok 48 - did we throws-like X::Obsolete?
    1..3
    ok 1 - '<>' died
    ok 2 - right exception type (X::Obsolete)
    ok 3 - .old matches <>
ok 49 - did we throws-like X::Obsolete?
    1..2
    ok 1 - 'my ($a, $b); $a . $b' died
    ok 2 - right exception type (X::Obsolete)
ok 50 - did we throws-like X::Obsolete?
    1..2
    ok 1 - 'my $a::::b' died
    ok 2 - right exception type (X::Syntax::Name::Null)
ok 51 - did we throws-like X::Syntax::Name::Null?
    1..2
    ok 1 - 'unless 1 { } else { }' died
    ok 2 - right exception type (X::Syntax::UnlessElse)
ok 52 - did we throws-like X::Syntax::UnlessElse?
    1..2
    ok 1 - 'unless 1 { } elsif 42 { }' died
    ok 2 - right exception type (X::Syntax::UnlessElse)
ok 53 - did we throws-like X::Syntax::UnlessElse?
    1..2
    ok 1 - 'for my $x (1, 2, 3) { }' died
    ok 2 - right exception type (X::Syntax::P5)
ok 54 - did we throws-like X::Syntax::P5?
    1..3
    ok 1 - ':!foo(3)' died
    ok 2 - right exception type (X::Syntax::NegatedPair)
    ok 3 - .key matches foo
ok 55 - did we throws-like X::Syntax::NegatedPair?
    1..2
    ok 1 - 'my $0' died
    ok 2 - right exception type (X::Syntax::Variable::Numeric)
ok 56 - did we throws-like X::Syntax::Variable::Numeric?
    1..3
    ok 1 - 'my sub f($0) { }' died
    ok 2 - right exception type (X::Syntax::Variable::Numeric)
    ok 3 - .what matches parameter
ok 57 - did we throws-like X::Syntax::Variable::Numeric?
    1..2
    ok 1 - 'my $<a>' died
    ok 2 - right exception type (X::Syntax::Variable::Match)
ok 58 - did we throws-like X::Syntax::Variable::Match?
    1..4
    ok 1 - 'my class A { my $!foo }' died
    ok 2 - right exception type (X::Syntax::Variable::Twigil)
    ok 3 - .twigil matches !
    ok 4 - .scope matches my
ok 59 - did we throws-like X::Syntax::Variable::Twigil?
    1..4
    ok 1 - 'role Breakable { my $!broken = Bool::False; }; class Frobnitz does Breakable {};' died
    ok 2 - right exception type (X::Syntax::Variable::Twigil)
    ok 3 - .scope matches my
    ok 4 - .twigil matches !
ok 60 - did we throws-like X::Syntax::Variable::Twigil?
    1..4
    ok 1 - 'my $?FILE' died
    ok 2 - right exception type (X::Syntax::Variable::Twigil)
    ok 3 - .scope matches my
    ok 4 - .twigil matches ?
ok 61 - did we throws-like X::Syntax::Variable::Twigil?
    1..2
    ok 1 - 'constant $?FILE = "foo"' died
    ok 2 - right exception type (X::Comp::NYI)
ok 62 - did we throws-like X::Comp::NYI?
    1..2
    ok 1 - 'my $::("foo")' died
    ok 2 - right exception type (X::Syntax::Variable::IndirectDeclaration)
ok 63 - did we throws-like X::Syntax::Variable::IndirectDeclaration?
    1..3
    ok 1 - '@a' died
    ok 2 - right exception type (X::Undeclared)
    ok 3 - .symbol matches @a
ok 64 - did we throws-like X::Undeclared?
    1..3
    ok 1 - '"@a[]"' died
    ok 2 - right exception type (X::Undeclared)
    ok 3 - .symbol matches @a
ok 65 - did we throws-like X::Undeclared?
    1..2
    ok 1 - 'augment class Any { }' died
    ok 2 - right exception type (X::Syntax::Augment::WithoutMonkeyTyping)
ok 66 - did we throws-like X::Syntax::Augment::WithoutMonkeyTyping?
    1..2
    ok 1 - '{ use MONKEY-TYPING; }; augment class Any { }' died
    ok 2 - right exception type (X::Syntax::Augment::WithoutMonkeyTyping)
ok 67 - MONKEY-TYPING applies lexically
    1..2
    ok 1 - 'use MONKEY-TYPING; augment role Positional { }' died
    ok 2 - right exception type (X::Syntax::Augment::Illegal)
ok 68 - did we throws-like X::Syntax::Augment::Illegal?
    1..3
    ok 1 - 'sub twigil:<@>() { }' died
    ok 2 - right exception type (X::Syntax::Extension::Category)
    ok 3 - .category matches twigil
ok 69 - did we throws-like X::Syntax::Extension::Category?
    1..2
    ok 1 - 'sub infix:sym< >() { }' died
    ok 2 - right exception type (X::Syntax::Extension::Null)
ok 70 - did we throws-like X::Syntax::Extension::Null?
    1..3
    ok 1 - 'my @a = 1, => 2' died
    ok 2 - right exception type (X::Syntax::InfixInTermPosition)
    ok 3 - .infix matches =>
ok 71 - did we throws-like X::Syntax::InfixInTermPosition?
    1..3
    ok 1 - 'sub f(:in(:$in)) { }' died
    ok 2 - right exception type (X::Signature::NameClash)
    ok 3 - .name matches in
ok 72 - did we throws-like X::Signature::NameClash?
    1..2
    ok 1 - '(my $foo) does Int' died
    ok 2 - right exception type (X::Does::TypeObject)
ok 73 - did we throws-like X::Does::TypeObject?
    1..2
    ok 1 - '(my $foo) does Int, Bool' died
    ok 2 - right exception type (X::Does::TypeObject)
ok 74 - did we throws-like X::Does::TypeObject?
    1..2
    ok 1 - 'Bool does role { method Str() { $.raku } };' died
    ok 2 - right exception type (X::Does::TypeObject)
ok 75 - did we throws-like X::Does::TypeObject?
    1..2
    ok 1 - 'my role R { }; 99 but R("wrong");' died
    ok 2 - right exception type (X::Role::Initialization)
ok 76 - did we throws-like X::Role::Initialization?
    1..2
    ok 1 - 'my role R { has $.x; has $.y }; 99 but R("wrong");' died
    ok 2 - right exception type (X::Role::Initialization)
ok 77 - did we throws-like X::Role::Initialization?
    1..2
    ok 1 - 'my role R { }; 99 does R("wrong");' died
    ok 2 - right exception type (X::Role::Initialization)
ok 78 - did we throws-like X::Role::Initialization?
    1..2
    ok 1 - 'my role R { has $.x; has $.y }; 99 does R("wrong");' died
    ok 2 - right exception type (X::Role::Initialization)
ok 79 - did we throws-like X::Role::Initialization?
    1..3
    ok 1 - 'if() {}' died
    ok 2 - right exception type (X::Comp::Group)
    ok 3 - .sorrows matches sub { }
ok 80 - did we throws-like X::Comp::Group?
    1..3
    ok 1 - 'with() {}' died
    ok 2 - right exception type (X::Comp::Group)
    ok 3 - .sorrows matches sub { }
ok 81 - did we throws-like X::Comp::Group?
    1..3
    ok 1 - 'without() {}' died
    ok 2 - right exception type (X::Comp::Group)
    ok 3 - .sorrows matches sub { }
ok 82 - did we throws-like X::Comp::Group?
    1..2
    ok 1 - 'my grammar G { regex foo { } }' died
    ok 2 - right exception type (X::Syntax::Regex::NullRegex)
ok 83 - did we throws-like X::Syntax::Regex::NullRegex?
    1..2
    ok 1 - '/ /' died
    ok 2 - right exception type (X::Syntax::Regex::NullRegex)
ok 84 - did we throws-like X::Syntax::Regex::NullRegex?
    1..2
    ok 1 - '/ a | /' died
    ok 2 - right exception type (X::Syntax::Regex::NullRegex)
ok 85 - did we throws-like X::Syntax::Regex::NullRegex?
    1..2
    ok 1 - '/ a || /' died
    ok 2 - right exception type (X::Syntax::Regex::NullRegex)
ok 86 - did we throws-like X::Syntax::Regex::NullRegex?
    1..2
    ok 1 - '/ a & /' died
    ok 2 - right exception type (X::Syntax::Regex::NullRegex)
ok 87 - did we throws-like X::Syntax::Regex::NullRegex?
    1..2
    ok 1 - '/ [] /' died
    ok 2 - right exception type (X::Syntax::Regex::NullRegex)
ok 88 - did we throws-like X::Syntax::Regex::NullRegex?
    1..2
    ok 1 - '/ | /' died
    ok 2 - right exception type (X::Syntax::Regex::NullRegex)
ok 89 - did we throws-like X::Syntax::Regex::NullRegex?
    1..2
    ok 1 - '/ () /' died
    ok 2 - right exception type (X::Syntax::Regex::NullRegex)
ok 90 - did we throws-like X::Syntax::Regex::NullRegex?
    1..2
    ok 1 - 's//b/' died
    ok 2 - right exception type (X::Syntax::Regex::NullRegex)
ok 91 - did we throws-like X::Syntax::Regex::NullRegex?
    1..4
    ok 1 - 'sub f($a?, $b) { }' died
    ok 2 - right exception type (X::Parameter::WrongOrder)
    ok 3 - .misplaced matches required
    ok 4 - .after matches optional
ok 92 - did we throws-like X::Parameter::WrongOrder?
    1..4
    ok 1 - 'sub f(*@a, $b) { }' died
    ok 2 - right exception type (X::Parameter::WrongOrder)
    ok 3 - .misplaced matches required
    ok 4 - .after matches variadic
ok 93 - did we throws-like X::Parameter::WrongOrder?
    1..4
    ok 1 - 'sub f(*@a, $b?) { }' died
    ok 2 - right exception type (X::Parameter::WrongOrder)
    ok 3 - .after matches variadic
    ok 4 - .misplaced matches optional positional
ok 94 - did we throws-like X::Parameter::WrongOrder?
    1..4
    ok 1 - 'sub f(:$a, $b) { }' died
    ok 2 - right exception type (X::Parameter::WrongOrder)
    ok 3 - .misplaced matches required
    ok 4 - .after matches named
ok 95 - did we throws-like X::Parameter::WrongOrder?
    1..2
    not ok 1 - ' \#`' died # TODO parsing regression
    # Failed test '' \#`' died'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-exceptions/misc2.rakudo line 188
    ok 2 - # SKIP Code did not die, can not check exception
not ok 96 - did we throws-like X::Syntax::Comment::Embedded? # TODO parsing regression
# Failed test 'did we throws-like X::Syntax::Comment::Embedded?'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-exceptions/misc2.rakudo line 188
    1..4
    ok 1 - '=begin
    # ' died
    ok 2 - right exception type (X::Syntax::Pod::BeginWithoutIdentifier)
    ok 3 - .line matches 1
    ok 4 - .filename matches rx/EVAL/
ok 97 - did we throws-like X::Syntax::Pod::BeginWithoutIdentifier?
    1..2
    ok 1 - '$^A = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 98 - Did $^A throw Perl5Var?
    1..2
    ok 1 - '$^B = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 99 - Did $^B throw Perl5Var?
    1..2
    ok 1 - '$^C = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 100 - Did $^C throw Perl5Var?
    1..2
    ok 1 - '$^D = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 101 - Did $^D throw Perl5Var?
    1..2
    ok 1 - '$^E = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 102 - Did $^E throw Perl5Var?
    1..2
    ok 1 - '$^F = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 103 - Did $^F throw Perl5Var?
    1..2
    ok 1 - '$^G = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 104 - Did $^G throw Perl5Var?
    1..2
    ok 1 - '$^H = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 105 - Did $^H throw Perl5Var?
    1..2
    ok 1 - '$^I = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 106 - Did $^I throw Perl5Var?
    1..2
    ok 1 - '$^J = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 107 - Did $^J throw Perl5Var?
    1..2
    ok 1 - '$^K = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 108 - Did $^K throw Perl5Var?
    1..2
    ok 1 - '$^L = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 109 - Did $^L throw Perl5Var?
    1..2
    ok 1 - '$^M = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 110 - Did $^M throw Perl5Var?
    1..2
    ok 1 - '$^N = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 111 - Did $^N throw Perl5Var?
    1..2
    ok 1 - '$^O = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 112 - Did $^O throw Perl5Var?
    1..2
    ok 1 - '$^P = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 113 - Did $^P throw Perl5Var?
    1..2
    ok 1 - '$^Q = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 114 - Did $^Q throw Perl5Var?
    1..2
    ok 1 - '$^R = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 115 - Did $^R throw Perl5Var?
    1..2
    ok 1 - '$^S = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 116 - Did $^S throw Perl5Var?
    1..2
    ok 1 - '$^T = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 117 - Did $^T throw Perl5Var?
    1..2
    ok 1 - '$^U = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 118 - Did $^U throw Perl5Var?
    1..2
    ok 1 - '$^V = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 119 - Did $^V throw Perl5Var?
    1..2
    ok 1 - '$^W = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 120 - Did $^W throw Perl5Var?
    1..2
    ok 1 - '$^X = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 121 - Did $^X throw Perl5Var?
    1..2
    ok 1 - '$^Y = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 122 - Did $^Y throw Perl5Var?
    1..2
    ok 1 - '$^Z = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 123 - Did $^Z throw Perl5Var?
    1..2
    ok 1 - '$" = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 124 - Did $" throw Perl5Var?
    1..2
    ok 1 - '$$ = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 125 - Did $$ throw Perl5Var?
    1..2
    ok 1 - '$; = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 126 - Did $; throw Perl5Var?
    1..2
    ok 1 - '$& = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 127 - Did $& throw Perl5Var?
    1..2
    ok 1 - '$` = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 128 - Did $` throw Perl5Var?
    1..2
    ok 1 - '$' = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 129 - Did $' throw Perl5Var?
    1..2
    ok 1 - '$, = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 130 - Did $, throw Perl5Var?
    1..2
    ok 1 - '$. = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 131 - Did $. throw Perl5Var?
    1..2
    ok 1 - '$\ = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 132 - Did $\ throw Perl5Var?
    1..2
    ok 1 - '$| = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 133 - Did $| throw Perl5Var?
    1..2
    ok 1 - '$? = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 134 - Did $? throw Perl5Var?
    1..2
    ok 1 - '$@ = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 135 - Did $@ throw Perl5Var?
    1..2
    ok 1 - '$] = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 136 - Did $] throw Perl5Var?
    1..2
    ok 1 - '@- = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 137 - Did @- throw Perl5Var?
    1..2
    ok 1 - '@+ = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 138 - Did @+ throw Perl5Var?
    1..2
    ok 1 - '%- = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 139 - Did %- throw Perl5Var?
    1..2
    ok 1 - '%+ = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 140 - Did %+ throw Perl5Var?
    1..2
    ok 1 - '%! = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 141 - Did %! throw Perl5Var?
    1..2
    ok 1 - '$ \#foo' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
ok 142 - did we throws-like X::Syntax::Perl5Var?
ok 143 - $@ is no longer a problem
    1..3
    ok 1 - '$\ = 1;' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
    ok 3 - .message matches /'.nl-out'/
ok 144 - Error message for $\ mentions .nl-out
    1..3
    ok 1 - '$/ = "\n\n";' died
    ok 2 - right exception type (X::Syntax::Perl5Var)
    ok 3 - .message matches /'.nl-in'/
ok 145 - Error message for $/ mentions .nl-in
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Backslash::NonVariableDollar)
ok 146 - non-variable $ in double quotes requires backslash
ok 147 - uses of $@!bar not wrongfully accused of using old $@ variable
    1..2
    ok 1 - '1∞' died
    ok 2 - right exception type (X::Syntax::Confused)
ok 148 - did we throws-like X::Syntax::Confused?
    1..3
    ok 1 - 'for 1, 2' died
    ok 2 - right exception type (X::Syntax::Missing)
    ok 3 - .what matches block
ok 149 - did we throws-like X::Syntax::Missing?
    1..3
    ok 1 - 'my @a()' died
    ok 2 - right exception type (X::Syntax::Reserved)
    ok 3 - .reserved matches all(/shape/, /array/)
ok 150 - did we throws-like X::Syntax::Reserved?
    1..3
    ok 1 - 'my &a()' died
    ok 2 - right exception type (X::Syntax::Reserved)
    ok 3 - .instead matches /':()'/
ok 151 - did we throws-like X::Syntax::Reserved?
    1..3
    ok 1 - '"\u"' died
    ok 2 - right exception type (X::Backslash::UnrecognizedSequence)
    ok 3 - .sequence matches u
ok 152 - did we throws-like X::Backslash::UnrecognizedSequence?
    1..2
    ok 1 - 'm:i(@*ARGS[0])/foo/' died
    ok 2 - right exception type (X::Value::Dynamic)
ok 153 - did we throws-like X::Value::Dynamic?
    1..2
    ok 1 - 'self' died
    ok 2 - right exception type (X::Syntax::Self::WithoutObject)
ok 154 - did we throws-like X::Syntax::Self::WithoutObject?
    1..3
    ok 1 - 'class { has $.x = $.y }' died
    ok 2 - right exception type (X::Syntax::VirtualCall)
    ok 3 - .call matches $.y
ok 155 - did we throws-like X::Syntax::VirtualCall?
    1..3
    ok 1 - '$.a' died
    ok 2 - right exception type (X::Syntax::NoSelf)
    ok 3 - .variable matches $.a
ok 156 - did we throws-like X::Syntax::NoSelf?
    1..3
    ok 1 - 'my class B0Rk { $.a }' died
    ok 2 - right exception type (X::Syntax::NoSelf)
    ok 3 - .variable matches $.a
ok 157 - did we throws-like X::Syntax::NoSelf?
    1..2
    ok 1 - 'has $.x' died
    ok 2 - right exception type (X::Attribute::NoPackage)
ok 158 - did we throws-like X::Attribute::NoPackage?
    1..3
    ok 1 - 'my module A { has $.x }' died
    ok 2 - right exception type (X::Attribute::Package)
    ok 3 - .package-kind matches module
ok 159 - did we throws-like X::Attribute::Package?
    1..3
    ok 1 - 'package Y { has $.foo }' died
    ok 2 - right exception type (X::Attribute::Package)
    ok 3 - .package-kind matches package
ok 160 - did we throws-like X::Attribute::Package?
    1..4
    ok 1 - 'has sub a() { }' died
    ok 2 - right exception type (X::Declaration::Scope)
    ok 3 - .scope matches has
    ok 4 - .declaration matches sub
ok 161 - did we throws-like X::Declaration::Scope?
    1..4
    ok 1 - 'has package a { }' died
    ok 2 - right exception type (X::Declaration::Scope)
    ok 3 - .scope matches has
    ok 4 - .declaration matches package
ok 162 - did we throws-like X::Declaration::Scope?
    1..3
    ok 1 - 'our multi a() { }' died
    ok 2 - right exception type (X::Declaration::Scope::Multi)
    ok 3 - .scope matches our
ok 163 - did we throws-like X::Declaration::Scope::Multi?
    1..3
    ok 1 - 'multi sub () { }' died
    ok 2 - right exception type (X::Anon::Multi)
    ok 3 - .multiness matches multi
ok 164 - did we throws-like X::Anon::Multi?
    1..3
    ok 1 - 'proto sub () { }' died
    ok 2 - right exception type (X::Anon::Multi)
    ok 3 - .multiness matches proto
ok 165 - did we throws-like X::Anon::Multi?
    1..3
    ok 1 - 'class { multi method () { }}' died
    ok 2 - right exception type (X::Anon::Multi)
    ok 3 - .routine-type matches method
ok 166 - did we throws-like X::Anon::Multi?
    1..3
    ok 1 - 'use MONKEY-TYPING; augment class { }' died
    ok 2 - right exception type (X::Anon::Augment)
    ok 3 - .package-kind matches class
ok 167 - did we throws-like X::Anon::Augment?
    1..4
    ok 1 - 'use MONKEY-TYPING; augment class NoSuchClass { }' died
    ok 2 - right exception type (X::Augment::NoSuchType)
    ok 3 - .package-kind matches class
    ok 4 - .package matches NoSuchClass
ok 168 - did we throws-like X::Augment::NoSuchType?
    1..3
    ok 1 - 'use MONKEY-TYPING; augment class No::Such::Class { }' died
    ok 2 - right exception type (X::Augment::NoSuchType)
    ok 3 - .package matches No::Such::Class
ok 169 - did we throws-like X::Augment::NoSuchType?
    1..3
    ok 1 - ':45<abcd>' died
    ok 2 - right exception type (X::Syntax::Number::RadixOutOfRange)
    ok 3 - .radix matches 45
ok 170 - did we throws-like X::Syntax::Number::RadixOutOfRange?
    1..3
    ok 1 - ':0<0>' died
    ok 2 - right exception type (X::Syntax::Number::RadixOutOfRange)
    ok 3 - .message matches rx/0/
ok 171 - did we throws-like X::Syntax::Number::RadixOutOfRange?
    1..4
    ok 1 - 'rx:g/a/' died
    ok 2 - right exception type (X::Syntax::Regex::Adverb)
    ok 3 - .construct matches rx
    ok 4 - .adverb matches g
ok 172 - did we throws-like X::Syntax::Regex::Adverb?
    1..2
    ok 1 - 'my sub f($x, $y:) { }' died
    ok 2 - right exception type (X::Syntax::Signature::InvocantMarker)
ok 173 - did we throws-like X::Syntax::Signature::InvocantMarker?
    1..3
    ok 1 - 'Date.new("2012-02-30")' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .message matches -> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140332317144728) ... }
ok 174 - did we throws-like X::OutOfRange?
    1..3
    ok 1 - 'DateTime.new(year => 2012, month => 5, day => 22, hour => 18, minute => 3, second => 60)' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .comment matches /'leap second'/
ok 175 - did we throws-like X::OutOfRange?
    1..5
    ok 1 - 'use fatal; "foo"[2]' died
    ok 2 - right exception type (X::OutOfRange)
    ok 3 - .range matches 0..0
    ok 4 - .what matches rx:i/index/
    ok 5 - .got matches 2
ok 176 - did we throws-like X::OutOfRange?
    1..2
    ok 1 - 'sub f() { }; &f.unwrap("foo")' died
    ok 2 - right exception type (X::Routine::Unwrap)
ok 177 - did we throws-like X::Routine::Unwrap?
    1..3
    ok 1 - 'Mu.new(1)' died
    ok 2 - right exception type (X::Constructor::Positional)
    ok 3 - .type matches (Mu)
ok 178 - did we throws-like X::Constructor::Positional?
    1..3
    ok 1 - 'Foo.new(1, 2, 3);' died
    ok 2 - right exception type (X::Constructor::Positional)
    ok 3 - .type matches (Foo)
ok 179 - did we throws-like X::Constructor::Positional?
    1..2
    ok 1 - 'my %h = 1' died
    ok 2 - right exception type (X::Hash::Store::OddNumber)
ok 180 - did we throws-like X::Hash::Store::OddNumber?
    1..3
    ok 1 - 'sub foo;' died
    ok 2 - right exception type (X::UnitScope::Invalid)
    ok 3 - .what matches sub
ok 181 - did we throws-like X::UnitScope::Invalid?
    1..3
    ok 1 - 'my $d; my class A {method x { $d }}; for () { sub }' died
    ok 2 - right exception type (X::Syntax::Missing)
    ok 3 - .what matches block
ok 182 - did we throws-like X::Syntax::Missing?
    1..3
    ok 1 - 'constant foo;' died
    ok 2 - right exception type (X::Syntax::Missing)
    ok 3 - .what matches /initializer/
ok 183 - did we throws-like X::Syntax::Missing?
    1..3
    ok 1 - 'constant * = 3;' died
    ok 2 - right exception type (X::Syntax::Missing)
    ok 3 - .what matches /constant/
ok 184 - did we throws-like X::Syntax::Missing?
    1..4
    ok 1 - '1 <=> 2 <=> 3' died
    ok 2 - right exception type (X::Syntax::NonAssociative)
    ok 3 - .left matches <=>
    ok 4 - .right matches <=>
ok 185 - did we throws-like X::Syntax::NonAssociative?
    1..3
    ok 1 - 'my class A {...}; my grammar B { ... }' died
    ok 2 - right exception type (X::Package::Stubbed)
    ok 3 - .packages matches (A B)
ok 186 - did we throws-like X::Package::Stubbed?
    1..4
    ok 1 - 'my sub a { PRE 0  }; a()' died
    ok 2 - right exception type (X::Phaser::PrePost)
    ok 3 - .phaser matches PRE
    ok 4 - .condition matches /0/
ok 187 - did we throws-like X::Phaser::PrePost?
    1..4
    ok 1 - 'my sub a { POST 0 }; a()' died
    ok 2 - right exception type (X::Phaser::PrePost)
    ok 3 - .phaser matches POST
    ok 4 - .condition matches /0/
ok 188 - did we throws-like X::Phaser::PrePost?
    1..5
    ok 1 - 'use fatal; my $x = "5 foo" + 8;' died
    ok 2 - right exception type (X::Str::Numeric)
    ok 3 - .source matches 5 foo
    ok 4 - .reason matches /:i trailing/
    ok 5 - .pos matches 1
ok 189 - did we throws-like X::Str::Numeric?
    1..3
    ok 1 - '"a".match(:x([1, 2, 3]), /a/).Str' died
    ok 2 - right exception type (X::Str::Match::x)
    ok 3 - .got matches (Array)
ok 190 - did we throws-like X::Str::Match::x?
    1..3
    ok 1 - '"a".trans([Any.new] => [Any.new])' died
    ok 2 - right exception type (X::Str::Trans::IllegalKey)
    ok 3 - .key matches (Any)
ok 191 - did we throws-like X::Str::Trans::IllegalKey?
    1..3
    ok 1 - '"a".trans(rx/a/)' died
    ok 2 - right exception type (X::Str::Trans::InvalidArg)
    ok 3 - .got matches (Regex)
ok 192 - did we throws-like X::Str::Trans::InvalidArg?
    1..4
    ok 1 - '1.foo' died
    ok 2 - right exception type (X::Method::NotFound)
    ok 3 - .typename matches Int
    ok 4 - .method matches foo
ok 193 - did we throws-like X::Method::NotFound?
    1..4
    ok 1 - '1.+foo' died
    ok 2 - right exception type (X::Method::NotFound)
    ok 3 - .typename matches Int
    ok 4 - .method matches foo
ok 194 - did we throws-like X::Method::NotFound?
    1..5
    ok 1 - 'my class Priv { method x { self!foo } }; Priv.x' died
    ok 2 - right exception type (X::Method::NotFound)
    ok 3 - .typename matches Priv
    ok 4 - .private matches -> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140332251461896) ... }
    ok 5 - .method matches foo
ok 195 - did we throws-like X::Method::NotFound?
    1..3
    ok 1 - 'my %h; %h.nosuchmethods' died
    ok 2 - right exception type (X::Method::NotFound)
    ok 3 - .typename matches Hash
ok 196 - did we throws-like X::Method::NotFound?
    1..2
    ok 1 - 'sub (int $i) { $i() }(42)' died
    ok 2 - right exception type (X::Method::NotFound)
ok 197 - did we throws-like X::Method::NotFound?
    1..5
    ok 1 - '1.List::join' died
    ok 2 - right exception type (X::Method::InvalidQualifier)
    ok 3 - .invocant matches 1
    ok 4 - .method matches join
    ok 5 - .qualifier-type matches (List)
ok 198 - did we throws-like X::Method::InvalidQualifier?
    1..3
    ok 1 - '!!! 42' died
    ok 2 - right exception type (X::StubCode)
    ok 3 - .message matches 42
ok 199 - did we throws-like X::StubCode?
    1..3
    ok 1 - 'use fatal; ... 42' died
    ok 2 - right exception type (X::StubCode)
    ok 3 - .message matches 42
ok 200 - did we throws-like X::StubCode?
ok 201 - ??? with argument warns
    1..3
    ok 1 - 'die "foo"' died
    ok 2 - right exception type (Exception)
    ok 3 - .backtrace matches (Backtrace)
ok 202 - did we throws-like Exception?
    1..2
    ok 1 - 'use fatal; ~(1, 2, 6 ... 10)' died
    ok 2 - right exception type (X::Sequence::Deduction)
ok 203 - did we throws-like X::Sequence::Deduction?
    1..4
    ok 1 - 'my class B does Int { }' died
    ok 2 - right exception type (X::Composition::NotComposable)
    ok 3 - .composer matches (Int)
    ok 4 - .target-name matches B
ok 204 - did we throws-like X::Composition::NotComposable?
    1..4
    ok 1 - 'my Str $x := 3' died
    ok 2 - right exception type (X::TypeCheck::Binding)
    ok 3 - .got matches (Int)
    ok 4 - .expected matches (Str)
ok 205 - did we throws-like X::TypeCheck::Binding?
    1..4
    ok 1 - 'sub f() returns Str { 5 }; f' died
    ok 2 - right exception type (X::TypeCheck::Return)
    ok 3 - .got matches (Int)
    ok 4 - .expected matches (Str)
ok 206 - did we throws-like X::TypeCheck::Return?
    1..3
    ok 1 - 'sub f(--> Nil) { return 5 }; f' died
    ok 2 - right exception type (X::Comp)
    ok 3 - .payload matches /Nil/
ok 207 - did we throws-like X::Comp?
    1..3
    ok 1 - 'sub f(--> 42) { return 43 }; f' died
    ok 2 - right exception type (X::Comp)
    ok 3 - .payload matches /42/
ok 208 - did we throws-like X::Comp?
    1..3
    ok 1 - 'sub f(--> 42) { return 42 }; f' died
    ok 2 - right exception type (X::Comp)
    ok 3 - .payload matches /42/
ok 209 - we don't allow args even if the same
    1..3
    ok 1 - 'sub f(--> "foo") { return () }; f' died
    ok 2 - right exception type (X::Comp)
    ok 3 - .payload matches /'"foo"'/
ok 210 - did we throws-like X::Comp?
    1..4
    ok 1 - 'sub f(--> Junction) { 5 }; f' died
    ok 2 - right exception type (X::TypeCheck::Return)
    ok 3 - .expected matches (Junction)
    ok 4 - .got matches (Int)
ok 211 - did we throws-like X::TypeCheck::Return?
    1..5
    ok 1 - 'my Int $x = "foo"' died
    ok 2 - right exception type (X::TypeCheck::Assignment)
    ok 3 - .symbol matches $x
    ok 4 - .got matches foo
    ok 5 - .expected matches (Int)
ok 212 - did we throws-like X::TypeCheck::Assignment?
    1..2
    ok 1 - 'subset Fu of Mu where * eq "foo"; my Fu $x = "bar";' died
    ok 2 - right exception type (X::TypeCheck::Assignment)
ok 213 - did we throws-like X::TypeCheck::Assignment?
    1..2
    ok 1 - 'sub f() { 42 }; f() = 3' died
    ok 2 - right exception type (X::Assignment::RO)
ok 214 - did we throws-like X::Assignment::RO?
    1..2
    ok 1 - '1.0 = 3' died
    ok 2 - right exception type (X::Assignment::RO)
ok 215 - did we throws-like X::Assignment::RO?
    1..2
    ok 1 - '120 = 3' died
    ok 2 - right exception type (X::Assignment::RO)
ok 216 - did we throws-like X::Assignment::RO?
    1..2
    ok 1 - '1e0 = 3' died
    ok 2 - right exception type (X::Assignment::RO)
ok 217 - did we throws-like X::Assignment::RO?
    1..2
    ok 1 - '"a" = 3' died
    ok 2 - right exception type (X::Assignment::RO)
ok 218 - did we throws-like X::Assignment::RO?
    1..4
    ok 1 - '1.foo' died
    ok 2 - right exception type (X::Method::NotFound)
    ok 3 - .typename matches Int
    ok 4 - .method matches foo
ok 219 - did we throws-like X::Method::NotFound?
    1..4
    ok 1 - 'my class NC { }; NC.new does NC' died
    ok 2 - right exception type (X::Mixin::NotComposable)
    ok 3 - .rolish matches WhateverCode.new
    ok 4 - .target matches WhateverCode.new
ok 220 - did we throws-like X::Mixin::NotComposable?
    1..4
    ok 1 - 'my class NC { }; NC.new but  NC' died
    ok 2 - right exception type (X::Mixin::NotComposable)
    ok 3 - .rolish matches WhateverCode.new
    ok 4 - .target matches WhateverCode.new
ok 221 - did we throws-like X::Mixin::NotComposable?
    1..4
    ok 1 - 'last' died
    ok 2 - right exception type (X::ControlFlow)
    ok 3 - .illegal matches last
    ok 4 - .enclosing matches loop construct
ok 222 - did we throws-like X::ControlFlow?
    1..4
    ok 1 - 'next' died
    ok 2 - right exception type (X::ControlFlow)
    ok 3 - .enclosing matches loop construct
    ok 4 - .illegal matches next
ok 223 - did we throws-like X::ControlFlow?
    1..4
    ok 1 - 'redo' died
    ok 2 - right exception type (X::ControlFlow)
    ok 3 - .enclosing matches loop construct
    ok 4 - .illegal matches redo
ok 224 - did we throws-like X::ControlFlow?
    1..2
    ok 1 - 'my package A { }; my class B is A { }' died
    ok 2 - right exception type (X::Inheritance::Unsupported)
ok 225 - did we throws-like X::Inheritance::Unsupported?
    1..3
    ok 1 - 'my module Expo { sub f is export { }; { sub f is export { } } }' died
    ok 2 - right exception type (X::Export::NameClash)
    ok 3 - .symbol matches &f
ok 226 - did we throws-like X::Export::NameClash?
    1..5
    ok 1 - '<a b> »+« <c>' died
    ok 2 - right exception type (X::HyperOp::NonDWIM)
    ok 3 - .left-elems matches 2
    ok 4 - .right-elems matches 1
    ok 5 - .operator matches -> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140332361299024) ... }
ok 227 - did we throws-like X::HyperOp::NonDWIM?
    1..2
    ok 1 - 'my sub f() { gather { return } }; ~f()' died
    ok 2 - right exception type (X::ControlFlow::Return)
ok 228 - did we throws-like X::ControlFlow::Return?
    1..4
    ok 1 - 'DateTime.new("2012/04")' died
    ok 2 - right exception type (X::Temporal::InvalidFormat)
    ok 3 - .target matches DateTime
    ok 4 - .invalid-str matches 2012/04
ok 229 - did we throws-like X::Temporal::InvalidFormat?
    1..4
    ok 1 - 'Date.new("2012/04")' died
    ok 2 - right exception type (X::Temporal::InvalidFormat)
    ok 3 - .invalid-str matches 2012/04
    ok 4 - .target matches Date
ok 230 - did we throws-like X::Temporal::InvalidFormat?
    1..3
    ok 1 - 'EVAL("foo", :lang<no-such-language>)' died
    ok 2 - right exception type (X::Eval::NoSuchLang)
    ok 3 - .lang matches no-such-language
ok 231 - did we throws-like X::Eval::NoSuchLang?
    1..2
    ok 1 - 'DateTime.new("1998-12-31T23:59:60+0200", :timezone<Z>)' died
    ok 2 - right exception type (X::DateTime::TimezoneClash)
ok 232 - did we throws-like X::DateTime::TimezoneClash?
    1..3
    ok 1 - 'use fatal; (1+2i).Num' died
    ok 2 - right exception type (X::Numeric::Real)
    ok 3 - .target matches (Num)
ok 233 - did we throws-like X::Numeric::Real?
    1..3
    ok 1 - 'use fatal; (1+2i).Real' died
    ok 2 - right exception type (X::Numeric::Real)
    ok 3 - .target matches (Real)
ok 234 - did we throws-like X::Numeric::Real?
    1..2
    ok 1 - 'my class A {}; (-> &c, $m { A.new()(); CATCH { default { $m } } } )(A, "")' died
    ok 2 - right exception type (X::TypeCheck::Binding)
ok 235 - did we throws-like X::TypeCheck::Binding?
ok 236 - Should fail type check with unbound variable
ok 237 - nextsame in proto
    1..3
    ok 1 - '["a" "b"]' died
    ok 2 - right exception type (X::Syntax::Confused)
    ok 3 - .reason matches Two terms in a row
ok 238 - did we throws-like X::Syntax::Confused?
    1..2
    ok 1 - 'my class A { has $.a syntax error; }' died
    ok 2 - right exception type (X::Syntax::Confused)
ok 239 - did we throws-like X::Syntax::Confused?
    1..2
    ok 1 - 'my $bar = "test"; my $foo = { given $bar { when Real { 1 } when Str { 2 } } };' died
    ok 2 - right exception type (X::Syntax::Confused)
ok 240 - did we throws-like X::Syntax::Confused?
    1..3
    ok 1 - 'my $foo = 10; say $Foo;' died
    ok 2 - right exception type (X::Undeclared)
    ok 3 - .suggestions matches $foo
ok 241 - did we throws-like X::Undeclared?
    1..3
    ok 1 - 'my @barf = 1, 2, 3; say $barf[2]' died
    ok 2 - right exception type (X::Undeclared)
    ok 3 - .suggestions matches @barf
ok 242 - did we throws-like X::Undeclared?
    1..3
    ok 1 - 'my $intergalactic-planetary = "planetary intergalactic"; say $IntergalacticPlanetary' died
    ok 2 - right exception type (X::Undeclared)
    ok 3 - .suggestions matches $intergalactic-planetary
ok 243 - did we throws-like X::Undeclared?
    1..3
    ok 1 - 'my class Foo is Junktion {}' died
    ok 2 - right exception type (X::Inheritance::UnknownParent)
    ok 3 - .suggestions matches Junction
ok 244 - did we throws-like X::Inheritance::UnknownParent?
    1..3
    ok 1 - 'my class Bar is junction {}' died
    ok 2 - right exception type (X::Inheritance::UnknownParent)
    ok 3 - .suggestions matches Junction
ok 245 - did we throws-like X::Inheritance::UnknownParent?
    1..3
    ok 1 - 'my class Baz is Juntcion {}' died
    ok 2 - right exception type (X::Inheritance::UnknownParent)
    ok 3 - .suggestions matches Junction
ok 246 - did we throws-like X::Inheritance::UnknownParent?
ok 247 - &huc throws X::Undeclared::Symbols
ok 248 - &uc is a suggestion
ok 249 - huc throws X::Undeclared::Symbols
ok 250 - uc is a suggestion
ok 251 - no suggestions for a strange name
ok 252 - doesn't show suggestions if there are none.
ok 253 - no suggestions for a strange class
ok 254 - doesn't show suggestions if there are none.
ok 255 - no suggestions for a strange variable
ok 256 - doesn't suggest if there's no suggestions.
    1..3
    ok 1 - 'sub yoink(Junctoin $barf) { }' died
    ok 2 - right exception type (X::Parameter::InvalidType)
    ok 3 - .suggestions matches Junction
ok 257 - did we throws-like X::Parameter::InvalidType?
ok 258 - my cool $a throws an X::Comp::Group.
ok 259 - the first sorrow is X::Undeclared.
ok 260 - the suggestions are Cool and Bool
ok 261 - Ecxeption.new throws X::Undeclared::Symbols
ok 262 - Exception is a suggestion
    1..3
    ok 1 - 'sub greet($name) { say "hello, $nam" }' died
    ok 2 - right exception type (X::Undeclared)
    ok 3 - .suggestions matches $name
ok 263 - did we throws-like X::Undeclared?
    1..3
    ok 1 - 'class Greeter { has $.name; method greet { say "hi, $name" } }' died
    ok 2 - right exception type (X::Undeclared)
    ok 3 - .suggestions matches $!name
ok 264 - did we throws-like X::Undeclared?
ok 265 - is "use experimental :pack" visible?
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck::Assignment)
ok 266 - ContainerDescriptor::BindHashPos has a 'name' method
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::TypeCheck::Assignment)
ok 267 - ContainerDescriptor::BindArrayPos has a 'name' method
# FUDGED!
1..15
ok 1 - # SKIP unspecced
ok 2 - Test existence for single key. (adverb)
ok 3 - Test existence for single key. (adverb 2)
ok 4 - Defined 0 value for key: none
ok 5 - Defined 1 value for key: one
ok 6 - NOT Defined value for key: nothing
ok 7 - empty hash stays same when read from (1)
ok 8 - empty hash stays same when read from (2)
ok 9 - empty hash stays same when read from (3)
ok 10 - taking a reference to a hash element does not auto-vivify the element
ok 11 - empty hash stays same when read from (4)
ok 12 - populated hash stays same when read from (1)
ok 13 - populated hash stays same when read from (2)
ok 14 - populated hash stays same when read from (3)
ok 15 - populated hash stays same when read from (4)
# FUDGED!
1..10
    1..2
    not ok 1 - code returned a Failure # TODO IO::Path doesn't implement :secure yet
    # Failed test 'code returned a Failure'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-io/child-secure.rakudo line 56
    # Actual type: IO::Path
        1..2
        not ok 1 - code dies # TODO IO::Path doesn't implement :secure yet
        # Failed test 'code dies'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-io/child-secure.rakudo line 57
        ok 2 - # SKIP Code did not die, can not check exception
    not ok 2 - Failure threw when sunk # TODO IO::Path doesn't implement :secure yet
    # Failed test 'Failure threw when sunk'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-io/child-secure.rakudo line 57
not ok 1 - non-resolving parent fails (given path is non-child) # TODO IO::Path doesn't implement :secure yet
# Failed test 'non-resolving parent fails (given path is non-child)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-io/child-secure.rakudo line 46
    1..2
    not ok 1 - code returned a Failure # TODO IO::Path doesn't implement :secure yet
    # Failed test 'code returned a Failure'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-io/child-secure.rakudo line 56
    # Actual type: IO::Path
        1..2
        not ok 1 - code dies # TODO IO::Path doesn't implement :secure yet
        # Failed test 'code dies'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-io/child-secure.rakudo line 57
        ok 2 - # SKIP Code did not die, can not check exception
    not ok 2 - Failure threw when sunk # TODO IO::Path doesn't implement :secure yet
    # Failed test 'Failure threw when sunk'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-io/child-secure.rakudo line 57
not ok 2 - non-resolving parent fails (given path is child) # TODO IO::Path doesn't implement :secure yet
# Failed test 'non-resolving parent fails (given path is child)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-io/child-secure.rakudo line 46
    1..2
    not ok 1 - code returned a Failure # TODO IO::Path doesn't implement :secure yet
    # Failed test 'code returned a Failure'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-io/child-secure.rakudo line 56
    # Actual type: IO::Path
        1..2
        not ok 1 - code dies # TODO IO::Path doesn't implement :secure yet
        # Failed test 'code dies'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-io/child-secure.rakudo line 57
        ok 2 - # SKIP Code did not die, can not check exception
    not ok 2 - Failure threw when sunk # TODO IO::Path doesn't implement :secure yet
    # Failed test 'Failure threw when sunk'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-io/child-secure.rakudo line 57
not ok 3 - resolving parent fails (given path is a child, but not resolving) # TODO IO::Path doesn't implement :secure yet
# Failed test 'resolving parent fails (given path is a child, but not resolving)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-io/child-secure.rakudo line 46
    1..2
    not ok 1 - code returned a Failure # TODO IO::Path doesn't implement :secure yet
    # Failed test 'code returned a Failure'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-io/child-secure.rakudo line 56
    # Actual type: IO::Path
        1..2
        not ok 1 - code dies # TODO IO::Path doesn't implement :secure yet
        # Failed test 'code dies'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-io/child-secure.rakudo line 57
        ok 2 - # SKIP Code did not die, can not check exception
    not ok 2 - Failure threw when sunk # TODO IO::Path doesn't implement :secure yet
    # Failed test 'Failure threw when sunk'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-io/child-secure.rakudo line 57
not ok 4 - resolved parent fails (given path is not a child) # TODO IO::Path doesn't implement :secure yet
# Failed test 'resolved parent fails (given path is not a child)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-io/child-secure.rakudo line 46
ok 5 - resolved parent with resolving, non-existent child
ok 6 - resolved parent with resolving, existent child
ok 7 - resolved parent with resolving, existent child in a subdir
ok 8 - resolved parent with resolving, non-existent child, with ../
    1..2
    not ok 1 - code returned a Failure # TODO IO::Path doesn't implement :secure yet
    # Failed test 'code returned a Failure'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-io/child-secure.rakudo line 56
    # Actual type: IO::Path
        1..2
        not ok 1 - code dies # TODO IO::Path doesn't implement :secure yet
        # Failed test 'code dies'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-io/child-secure.rakudo line 57
        ok 2 - # SKIP Code did not die, can not check exception
    not ok 2 - Failure threw when sunk # TODO IO::Path doesn't implement :secure yet
    # Failed test 'Failure threw when sunk'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-io/child-secure.rakudo line 57
not ok 9 - resolved parent fails (given path is not a child, via child + ../) # TODO IO::Path doesn't implement :secure yet
# Failed test 'resolved parent fails (given path is not a child, via child + ../)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-io/child-secure.rakudo line 46
    1..2
    not ok 1 - code returned a Failure # TODO IO::Path doesn't implement :secure yet
    # Failed test 'code returned a Failure'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-io/child-secure.rakudo line 56
    # Actual type: IO::Path
        1..2
        not ok 1 - code dies # TODO IO::Path doesn't implement :secure yet
        # Failed test 'code dies'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-io/child-secure.rakudo line 57
        ok 2 - # SKIP Code did not die, can not check exception
    not ok 2 - Failure threw when sunk # TODO IO::Path doesn't implement :secure yet
    # Failed test 'Failure threw when sunk'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-io/child-secure.rakudo line 57
not ok 10 - resolved parent fails (given path is not a child, via combiners) # TODO IO::Path doesn't implement :secure yet
# Failed test 'resolved parent fails (given path is not a child, via combiners)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-io/child-secure.rakudo line 46
# FUDGED!
1..17
ok 1 - dir() runs in cwd()
not ok 2 - current directory contains a t/ dir # TODO directories are not marked with trailing / yet
# Failed test 'current directory contains a t/ dir'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-io/dir.rakudo line 13
ok 3 - current directory contains a t/ dir
ok 4 - dir() returns IO::Path objects
ok 5 - dir() returns IO::Path objects properly resolving to the found paths
ok 6 - "." and ".." are not returned
ok 7 - ... unless you override :test
ok 8 - can exclude t/ dir
ok 9 - "." and ".." are not returned
ok 10 - ... unless you override :test
ok 11 - can exclude t/ dir
ok 12 - dir("t") returns paths with .dirname of "t"
ok 13 - results for 'dir "/"' do not begin with 2 slashes
ok 14 - $*CWD is set right inside dir(:test)
    1..2
    ok 1 - relative invocant
    ok 2 - absolute invocant
ok 15 - dir-created IO::Paths' absoluteness controlled by invocant
    1..3
    ok 1 - right .dir with original path
    ok 2 - right .dir with .add-ed path
    ok 3 - right .dir with relative path
ok 16 - .dir with relative paths sets right CWD
ok 17 - make sure dir / produces absolute paths
# FUDGED!
1..30
    1..4
    ok 1 - default
    ok 2 - changed
    ok 3 - attributes get set on next handles
    ok 4 - can set .nl-in to a string
ok 1 - chomp method and nl-in method
    1..4
    ok 1 - we have some IO::Handles that are open before calling .close
    ok 2 - .close returns True
    ok 3 - all of original IO::Handles got closed
    ok 4 - all the handles get removed and active handle is niled
ok 2 - close method
    1..12
    ok 1 - \()
    ok 2 - \("")
    ok 3 - \("♥")
    ok 4 - \("♥", 2)
    ok 5 - \(0)
    ok 6 - \(1)
    ok 7 - \(5)
    ok 8 - \(1000)
    ok 9 - \(2, 3)
    ok 10 - \(/../)
    ok 11 - \(/../, 2)
    ok 12 - \(/<:alpha>/, 3)
ok 3 - comb method
    1..3
    ok 1 - we have some IO::Handles that are open before calling .DESTROY
    ok 2 - all of original IO::Handles got closed
    ok 3 - all the handles get removed and active handle is niled
ok 4 - DESTROY method
    1..4
    ok 1 - default
    ok 2 - can change via .new
        1..3
        ok 1 - ascii
        ok 2 - utf8
        ok 3 - utf8-c8
    ok 3 - can change via .encoding while iterating through handles
    ok 4 - can change via .encoding when no @handles are left
ok 5 - encoding method
    1..8
    ok 1 - no handles from start
    ok 2 - no handles from start (bin)
        1..2
        ok 1 - before exhausting handle
        ok 2 - after exhausting handle
    ok 3 - with 1 handle
        1..2
        ok 1 - before exhausting handle
        ok 2 - after exhausting handle
    ok 4 - with 1 handle (bin)
        1..5
        ok 1 - before exhausting handles
        ok 2 - after exhausting first handle
        ok 3 - read a bit of second handle
        ok 4 - after exhausting all handles
        ok 5 - after read after exhaustion
    ok 5 - with 2 handles
        1..5
        ok 1 - before exhausting handles
        ok 2 - after exhausting first handle
        ok 3 - read a bit of second handle
        ok 4 - after exhausting all handles
        ok 5 - after read after exhaustion
    ok 6 - with 2 handles (bin)
        1..2
        ok 1 - before reads
        ok 2 - after reads
    ok 7 - with 3 handles to empty files
        1..2
        ok 1 - before reads
        ok 2 - after reads
    ok 8 - with 3 handles to empty files (bin)
ok 6 - eof method
    1..3
    ok 1 - .get with defaults
    ok 2 - .get on exhausted handle
    ok 3 - .get with handles set to different chomp/nl-in attributes
ok 7 - get method
    1..4
    ok 1 - .getc on handle-path mix
    ok 2 - .getc on exhausted cat handle
    ok 3 - .getc on exhausted cat handle continues giving Nil
    ok 4 - .getc on text with combiners # TODO end of file
ok 8 - getc method
    1..5
    ok 1 - type object
    ok 2 - instantiated with no handles
    ok 3 - opened, first handle
    ok 4 - opened, second handle
    ok 5 - after exhausting handles
ok 9 - gist method
    1..4
        1..1
        ok 1 - received right data
    ok 1 - called on fresh cat
        1..1
        ok 1 - received right data
    ok 2 - called on partially-consumed cat
        1..1
        ok 1 - received right data
    ok 3 - called on fully-consumed cat
        1..5
        ok 1 - first use
        ok 2 - second use
        ok 3 - handles gives right handle even if it was switched by other means
        ok 4 - no more handles (1)
        ok 5 - no more handles (2)
    ok 4 - using handles while also consuming using other methods
ok 10 - handles method
    1..4
    ok 1 - 1
    ok 2 - 2
    ok 3 - 3
    ok 4 - 4
ok 11 - IO method
    1..13
    ok 1 - no arg
    ok 2 - $limit 500
    ok 3 - $limit 5
    ok 4 - $limit 0 (return value)
    ok 5 - $limit 0 (all opened handles remained open)
    ok 6 - :close arg (return value)
    ok 7 - :close arg (all opened handles got closed)
    ok 8 - $limit 500, :close arg (return value)
    ok 9 - $limit 500, :close arg (all opened handles got closed)
    ok 10 - $limit 5, :close arg (return value)
    ok 11 - $limit 5, :close arg (all opened handles got closed)
    ok 12 - $limit 0, :close arg (return value)
    ok 13 - $limit 0, :close arg (all opened handles got closed)
ok 12 - lines method
    1..5
    ok 1 - 1
    ok 2 - 2
    ok 3 - 3
    ok 4 - The object is-a 'Int'
    ok 5 - after exhausting handles
ok 13 - native-descriptor method
    1..3
    ok 1 - .new
    ok 2 - .new of subclass returns subclass
    ok 3 - instantiated subclass is a CatHandle
ok 14 - new method
    1..11
    ok 1 - 1
    ok 2 - 2
    ok 3 - 3
    ok 4 - 4
    ok 5 - 5
    ok 6 - 6
    ok 7 - 7
    ok 8 - 8
    ok 9 - 9
    ok 10 - 10
    ok 11 - .next-handle causes .on-switch callable to be called
ok 15 - next-handle method
    1..11
    ok 1 - can count files' line numbers (.count 0)
    ok 2 - .count 1
    ok 3 - .count 2 (first arg)
    ok 4 - .count 2 (second arg)
    ok 5 - .count Inf (first arg)
    ok 6 - .count Inf (second arg)
        1..5
        ok 1 - first change
        ok 2 - second change
        ok 3 - third change
        ok 4 - fourth change
        ok 5 - can change attribute after setting it via .new
    ok 7 - can change .on-switch by assigning to attribute
    ok 8 - on-switch gets called $handles + 1 number of times
    ok 9 - second arg on first iteration is Nil
    ok 10 - first arg on last iteration is Nil
    ok 11 - .on-switch an iteration after handle exhaustion has Nil args
ok 16 - on-switch method
    1..4
    ok 1 - after instantiation (no handles)
    ok 2 - after instantiation
    ok 3 - second handle
    ok 4 - after exhausting all handles
ok 17 - open method
    1..4
    ok 1 - after instantiation (no handles)
    ok 2 - after instantiation
    ok 3 - second handle
    ok 4 - after exhausting all handles
ok 18 - opened method
    1..4
    ok 1 - 1
    ok 2 - 2
    ok 3 - 3
    ok 4 - 4
ok 19 - path method
    1..8
    ok 1 - type object
    ok 2 - no args
    ok 3 - just handles
    ok 4 - :bin
    ok 5 - :encoding
    ok 6 - :encoding + :nl-in
    ok 7 - :encoding + :nl-in + :!chomp
    ok 8 - :encoding, :nl-in, :!chomp and no handles
ok 20 - perl method
    1..3
        1..4
        ok 1 - 1
        ok 2 - 2
        ok 3 - 3
        ok 4 - 4
    ok 1 - binary cat
        1..4
        ok 1 - 1
        ok 2 - 2
        ok 3 - 3
        ok 4 - 4
    ok 2 - non-binary cat
    ok 3 - IO::CatHandle.read has some reasonable size default value
ok 21 - read method
    1..8
        1..2
        ok 1 - code dies
        ok 2 - right exception type (X::IO::BinaryMode)
    ok 1 - binary cat
    ok 2 - 1
    ok 3 - 2
    ok 4 - 3
    ok 5 - 4
    ok 6 - 5
    ok 7 - 6
    ok 8 - 7
ok 22 - readchars method
    1..5
    ok 1 - .seek on zero-handle cat
    ok 2 - .tell on zero-handle cat
        1..3
        ok 1 - first handle
        ok 2 - seeking past handle's end does not switch handles
            1..2
            ok 1 - code dies
            ok 2 - right exception type (Exception)
        ok 3 - seeking earlier than beginning of active handle throws
    ok 3 - SeekFromBeginning
        1..4
        ok 1 - first handle
        ok 2 - first handle
        ok 3 - seeking past handle's end does not switch handles
            1..2
            ok 1 - code dies
            ok 2 - right exception type (Exception)
        ok 4 - seeking earlier than beginning of active handle throws
    ok 4 - SeekFromCurrent
        1..3
        ok 1 - first handle
        ok 2 - seeking past handle's end does not switch handles
            1..2
            ok 1 - code dies
            ok 2 - right exception type (Exception)
        ok 3 - seeking earlier than beginning of active handle throws
    ok 5 - SeekFromEnd
ok 23 - seek method and tell method
    1..4
    ok 1 - non-binary
    ok 2 - binary
    ok 3 - :enc parameter works
        1..2
        not ok 1 - code dies
        ok 2 - # SKIP Code did not die, can not check exception
    not ok 4 - file containing single non-valid-UTF8 byte throws in utf8 slurp
not ok 24 - slurp method
    1..22
    ok 1 - \("")
    ok 2 - \("♥")
    ok 3 - \("♥", 2)
    ok 4 - \(0)
    ok 5 - \(1)
    ok 6 - \(5)
    ok 7 - \(1000)
    ok 8 - \(2, 3)
    ok 9 - \(/../)
    ok 10 - \(/../, 2)
    ok 11 - \(/<:alpha>/, 3)
    ok 12 - \("", :skip-empty)
    ok 13 - \("♥", :k)
    ok 14 - \("♥", :v)
    ok 15 - \(0, :kv)
    ok 16 - \(1, :p)
    ok 17 - \(5, :k, :skip-empty)
    ok 18 - \(1000, :skip-empty, :v)
    ok 19 - \(2, 3, :kv, :skip-empty)
    ok 20 - \(/../, :p, :skip-empty)
    ok 21 - \(/../, 2, :p, :skip-empty)
    ok 22 - \(/<:alpha>/, 3, :kv, :skip-empty)
ok 25 - split method
    1..4
    ok 1 - 1
    ok 2 - 2
    ok 3 - 3
    ok 4 - 4
ok 26 - Str method
    1..5
        1..4
        ok 1 - no args
        ok 2 - size 2
        ok 3 - size 5
        ok 4 - size 1000
    ok 1 - binary cat
        1..4
        ok 1 - no args
        ok 2 - size 2
        ok 3 - size 5
        ok 4 - size 1000
    ok 2 - non-binary cat, utf8
        1..4
        ok 1 - no args
        ok 2 - size 2
        ok 3 - size 5
        ok 4 - size 1000
    ok 3 - non-binary cat, utf8-c8
    ok 4 - supply on exhausted cat is empty
    ok 5 - supply on exhausted cat is empty (second call)
ok 27 - Supply method
    1..4
    ok 1 - 1
    ok 2 - 2
    ok 3 - 3
    ok 4 - after exhausting handles
ok 28 - t method
    1..13
    ok 1 - no arg
    ok 2 - $limit 500
    ok 3 - $limit 5
    ok 4 - $limit 0 (return value)
    ok 5 - $limit 0 (all opened handles remained open)
    ok 6 - :close arg (return value)
    ok 7 - :close arg (all opened handles got closed)
    ok 8 - $limit 500, :close arg (return value)
    ok 9 - $limit 500, :close arg (all opened handles got closed)
    ok 10 - $limit 5, :close arg (return value)
    ok 11 - $limit 5, :close arg (all opened handles got closed)
    ok 12 - $limit 0, :close arg (return value)
    ok 13 - $limit 0, :close arg (all opened handles got closed)
ok 29 - words method
    1..2
    ok 1 - got all elements
    ok 2 - STDERR is empty
ok 30 - IO::CatHandle.read does not switch to another handle too early
# FUDGED!
1..52
ok 1 - Can create IO::Path::Cygwin
ok 2 - volume "/foo/bar" -> ""
ok 3 - dirname "/foo/bar" -> "/foo"
ok 4 - basename "/foo/bar" -> "bar"
ok 5 - volume "C:foo\\bar\" -> "C:"
ok 6 - dirname "C:foo\\bar\" -> "foo"
ok 7 - basename "C:foo\\bar\" -> "bar"
ok 8 - .path returns Str of path
ok 9 - .raku loopback
ok 10 - volume "//server/share/" -> ""/server/share"
ok 11 - dirname "\\server\share\" -> "\"
ok 12 - basename "\\server\share\" -> "\"
ok 13 - "\\server\share" restringifies to itself
ok 14 - volume "//server/share/a" -> ""//server/share"
ok 15 - dirname "//server/share/a" -> "/"
ok 16 - basename "//server/share/a" -> "a"
ok 17 - "//server/share/a" restringifies to itself
ok 18 - current directory
ok 19 - parent directory
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 20 - no path not allowed
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 21 - empty not allowed
ok 22 - cleanup '/usr/////local/./bin/.\./perl/' -> '/usr/local/bin/perl'
ok 23 - relative path is-relative
ok 24 - relative path ! is-absolute
ok 25 - absolute path ! is-relative
ok 26 - absolute path is-absolute
ok 27 - UNC path is-absolute
ok 28 - UNC path with forward slash is-absolute
ok 29 - path beginning with backslash is absolute
ok 30 - "A:\" is absolute
ok 31 - "A:b" is relative
ok 32 - absolute path from $*CWD
ok 33 - absolute path specified
ok 34 - relative path specified
ok 35 - relative inverts absolute
ok 36 - absolute inverts relative
not ok 37 - absolute inverts relative with resolve # TODO resolve NYI, needs nqp::readlink
# Failed test 'absolute inverts relative with resolve'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-io/io-path-cygwin.rakudo line 65
# expected: '\foo\bar'
#      got: '/zip/loc/../../foo/bar'
ok 38 - parent of 'foo/bar' is 'foo'
ok 39 - parent of 'foo' is '.'
ok 40 - parent of '.' is '..'
ok 41 - parent of '..' is '../..'
ok 42 - parent at top level is '/'
ok 43 - parent of root is '/'
ok 44 - parent of root ('\') is '/'
ok 45 - append to root
ok 46 - append to cwd
ok 47 - succ basic
ok 48 - succ x 2
ok 49 - pred basic
ok 50 - succ only effects basename
ok 51 - pred only effects basename
ok 52 - .absolute on paths starting with `-` does not produce empty string
# FUDGED!
1..37
ok 1 - Can create IO::Path::Unix
ok 2 - volume is empty on POSIX
ok 3 - dirname "/foo/bar" -> "/foo"
ok 4 - basename "/foo/bar" -> "bar"
ok 5 - dirname "foo//bar//" -> "foo"
ok 6 - basename "foo//bar//" -> "bar"
ok 7 - .path returns Str
IO::Path::Unix.new("foo//bar//", :CWD("/zip/loc"))
ok 8 - .raku loopback
ok 9 - current directory
ok 10 - parent directory
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 11 - no path not allowed
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 12 - empty not allowed
ok 13 - cleanup '/usr/////local/./bin/././perl/' -> '/usr/local/bin/perl'
ok 14 - relative path is-relative
ok 15 - relative path ! is-absolute
ok 16 - absolute path ! is-relative
ok 17 - absolute path is-absolute
ok 18 - absolute path from $*CWD
ok 19 - absolute path specified
ok 20 - relative path specified
ok 21 - relative inverts absolute
ok 22 - absolute inverts relative
not ok 23 - absolute inverts relative with resolve # TODO resolve NYI, needs nqp::readlink
# Failed test 'absolute inverts relative with resolve'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-io/io-path-unix.rakudo line 50
# expected: '/foo/bar'
#      got: '/zip/loc/../../foo/bar'
ok 24 - parent of 'foo/bar' is 'foo'
ok 25 - parent of 'foo' is '.'
ok 26 - parent of '.' is '..'
ok 27 - parent of '..' is '../..'
ok 28 - parent at top level is '/'
ok 29 - parent of root is '/'
ok 30 - append to root
ok 31 - append to cwd
ok 32 - succ basic
ok 33 - succ x 2
ok 34 - pred basic
ok 35 - succ only effects basename
ok 36 - pred only effects basename
ok 37 - .absolute on paths starting with `-` does not produce empty string
# FUDGED!
1..51
ok 1 - Can create IO::Path::Win32
ok 2 - volume "\foo\bar" -> ""
ok 3 - dirname "\foo\bar" -> "\foo"
ok 4 - basename "\foo\bar" -> "bar"
ok 5 - volume "C:foo//bar//" -> "C:"
ok 6 - dirname "C:foo//bar//" -> "foo"
ok 7 - basename "C:foo//bar//" -> "bar"
ok 8 - .path returns Str
ok 9 - .raku loopback
ok 10 - volume "\\server\share\" -> ""\\server\share"
ok 11 - dirname "\\server\share\" -> "\"
ok 12 - basename "\\server\share\" -> "\"
ok 13 - "\\server\share\" restringifies to itself
ok 14 - volume "//server/share/a" -> ""//server/share"
ok 15 - directory "//server/share/a" -> "/"
ok 16 - basename "//server/share/a" -> "a"
ok 17 - "//server/share/a" restringifies to itself
ok 18 - current directory
ok 19 - parent directory
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 20 - no path not allowed
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 21 - empty not allowed
ok 22 - cleanup '/usr/////local/./bin/././perl/' -> '\usr\local\bin\perl'
ok 23 - relative path is-relative
ok 24 - relative path ! is-absolute
ok 25 - absolute path ! is-relative
ok 26 - absolute path is-absolute
ok 27 - UNC path is-absolute
ok 28 - UNC path with forward slash is-absolute
ok 29 - path beginning with forward slash is absolute
ok 30 - "A:\" is absolute
ok 31 - "A:b" is relative
ok 32 - absolute path from $*CWD
ok 33 - absolute path specified
ok 34 - relative path specified
ok 35 - relative inverts absolute
ok 36 - absolute inverts relative
not ok 37 - absolute inverts relative with resolve # TODO resolve NYI, needs nqp::readlink
# Failed test 'absolute inverts relative with resolve'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-io/io-path-win.rakudo line 65
# expected: '\foo\bar'
#      got: 'C:\zip\loc\..\..\foo\bar'
ok 38 - parent of 'foo/bar' is 'foo'
ok 39 - parent of 'foo' is '.'
ok 40 - parent of '.' is '..'
ok 41 - parent of '..' is '../..'
ok 42 - parent at top level is '/'
ok 43 - parent of root is '/'
ok 44 - append to root
ok 45 - append to cwd
ok 46 - succ basic
ok 47 - succ x 2
ok 48 - pred basic
ok 49 - succ only effects basename
ok 50 - pred only effects basename
ok 51 - .absolute on paths starting with `-` does not produce empty string
# FUDGED!
1..7
ok 1 - /private/var/folders/b5/yttfnvk10cj5500y1q5mmnrr0000gn/T/perl6_roast_mkdir_rmdir_rakudo_line11_0_063226893950596441613282829 exists
ok 2 - /private/var/folders/b5/yttfnvk10cj5500y1q5mmnrr0000gn/T/perl6_roast_mkdir_rmdir_rakudo_line11_0_063226893950596441613282829 is a directory
    1..2
    ok 1 - code returned a Failure
        1..2
        ok 1 - code dies
        ok 2 - right exception type (X::IO::Rmdir)
    ok 2 - Failure threw when sunk
ok 3 - did we fails-like X::IO::Rmdir?
    1..2
    ok 1 - code returned a Failure
        1..2
        ok 1 - code dies
        ok 2 - right exception type (X::IO::Rmdir)
    ok 2 - Failure threw when sunk
ok 4 - did we fails-like X::IO::Rmdir?
ok 5 - # SKIP mkdir NYI
ok 6 - # SKIP mkdir NYI
ok 7 - "/".IO.mkdir does not segfault
# FUDGED!
1..40
ok 1 - basic classify from list with Sub
ok 2 - basic classify as subroutine with Sub
ok 3 - basic classify as sub with Sub and new into
ok 4 - basic classify as sub with Sub and existing into
ok 5 - basic classify from list with Sub and new into
ok 6 - basic classify from list with Sub and existing into
ok 7 - basic classify from list with Block
ok 8 - basic classify as subroutine with Block
ok 9 - basic classify as sub with Block and new into
ok 10 - basic classify as sub with Block and existing into
ok 11 - basic classify from list with Block and new into
ok 12 - basic classify from list with Block and existing into
ok 13 - basic classify from list with Hash
ok 14 - basic classify as subroutine with Hash
ok 15 - basic classify as sub with Hash and new into
ok 16 - basic classify as sub with Hash and existing into
ok 17 - basic classify from list with Hash and new into
ok 18 - basic classify from list with Hash and existing into
ok 19 - basic classify from list with List
ok 20 - basic classify as subroutine with List
ok 21 - basic classify as sub with List and new into
ok 22 - basic classify as sub with List and existing into
ok 23 - basic classify from list with List and new into
ok 24 - basic classify from list with List and existing into
ok 25 - basic classify as sub with Sub and new into Bag 1) two evens
ok 26 -     2) two odds
ok 27 -     3) no other keys
ok 28 - # SKIP Cannot use bind operator with this LHS
ok 29 - # SKIP Cannot use bind operator with this LHS
ok 30 - # SKIP Cannot use bind operator with this LHS
ok 31 - can classify by numbers
ok 32 - can classify by numbers into an existing empty hash
ok 33 - can classify by numbers into an existing filled hash
ok 34 - can classify by numbers into an existing filled hash with an :as
ok 35 - classify single num
ok 36 - classify single string
ok 37 - multi-level classify
ok 38 - classify an empty list
ok 39 - &test only run once for each item
    1..4
    ok 1 - method form (True  key)
    ok 2 - method form (False key)
    ok 3 - sub form (True  key)
    ok 4 - sub form (False key)
ok 40 - classify works with Junctions
# FUDGED!
1..26
ok 1 - first(, :end, :k) returns an Int
ok 2 - returned value by first() is correct
ok 3 - first(, :end, :k) returns an Int
ok 4 - returned value by first(, :end, :k) is correct
ok 5 - method form of first, :end, :k returns an Int
ok 6 - method form of first, :end, :k returns the expected item
ok 7 - # SKIP adverbial block
ok 8 - # SKIP adverbial block
ok 9 - first, :end, :k returns Nil on unsuccessful match
ok 10 - first(, :end, :k) search for odd elements successful
ok 11 - Matching closure in first(, :end, :k) is only executed twice
ok 12 - method form of first, :end, :k with range returns the expected item
ok 13 - method form of first, :end, :k with range returns the expected item
ok 14 - first by type Str works
ok 15 - first by type Int works
ok 16 - first by type Rat works
ok 17 - first by regex /o/
ok 18 - first by regex /ob/
ok 19 - first by regex /l.*o/
ok 20 - .first, :end, :k also takes a junction as matcher
ok 21 - .first, :end, :k also takes a junction as matcher (sub form)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Match::Bool)
ok 22 - did we throws-like X::Match::Bool?
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Match::Bool)
ok 23 - did we throws-like X::Match::Bool?
ok 24 - can we match on Bool as type
ok 25 - can we match on Bool as type
ok 26 - is :!k the same as no attribute
# FUDGED!
1..25
ok 1 - first() returns an Int
ok 2 - returned value by first() is correct
ok 3 - first() returns an Int
ok 4 - returned value by first() is correct
ok 5 - method form of first returns an Int
ok 6 - method form of first returns the expected item
ok 7 - # SKIP adverbial block
ok 8 - # SKIP adverbial block
ok 9 - first returns Nil on unsuccessful match
ok 10 - first() search for odd elements successful
ok 11 - Matching closure in first() is only executed once
ok 12 - method form of first with range returns the expected item
ok 13 - method form of first with range returns the expected item
ok 14 - first by type Str works
ok 15 - first by type Int works
ok 16 - first by type Rat works
ok 17 - first by regex /o/
ok 18 - first by regex /ob/
ok 19 - first by regex /l.*o/
ok 20 - .first also takes a junction as matcher
ok 21 - .first also takes a junction as matcher (sub form)
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Match::Bool)
ok 22 - did we throws-like X::Match::Bool?
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Match::Bool)
ok 23 - did we throws-like X::Match::Bool?
ok 24 - can we match on Bool as type
ok 25 - can we match on Bool as type
# FUDGED!
1..31
ok 1 - first() returns an Int
ok 2 - returned value by first() is correct
ok 3 - first() returns an Int
ok 4 - returned value by first() is correct
ok 5 - method form of first returns an Int
ok 6 - method form of first returns the expected item
ok 7 - # SKIP adverbial block
ok 8 - # SKIP adverbial block
ok 9 - first returns undefined unsuccessful match
ok 10 - first() search for odd elements successful
ok 11 - Matching closure in first() is only executed once
ok 12 - method form of first with range returns the expected item
ok 13 - method form of first with range returns the expected item
ok 14 - Looking up first by type Str works
ok 15 - Looking up first by type Int works
ok 16 - Looking up first by type Rat works
ok 17 - Looking up first by regex /o/
ok 18 - Looking up first by regex /ob/
ok 19 - Looking up first by regex /l.*o/
ok 20 - .first also takes a junction as matcher
ok 21 - .first also takes a junction as matcher (sub form)
ok 22 - first() returns Nil when no values match
ok 23 - .first returns Nil when no values match
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Match::Bool)
ok 24 - did we throws-like X::Match::Bool?
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Match::Bool)
ok 25 - did we throws-like X::Match::Bool?
ok 26 - can we match on Bool as type
ok 27 - can we match on Bool as type
ok 28 - first is rw-like, can chain it to modify one element of grepped list/array
    1..2
        1..6
        ok 1 - matcher only (1)
        ok 2 - matcher only (2)
        ok 3 - with :k (1)
        ok 4 - with :k (2)
        ok 5 - with :kv (1)
        ok 6 - with :kv (2)
    ok 1 - method form
        1..6
        ok 1 - matcher only (1)
        ok 2 - matcher only (2)
        ok 3 - with :k (1)
        ok 4 - with :k (2)
        ok 5 - with :kv (1)
        ok 6 - with :kv (2)
    ok 2 - sub form
ok 29 - Junctions work correctly as a matcher in .first
    1..12
    ok 1 - no args
    ok 2 - Regex matcher
    ok 3 - Junction matcher
    ok 4 - :k
    ok 5 - :p
    ok 6 - :kv
    ok 7 - :end, no args
    ok 8 - :end, Regex matcher
    ok 9 - :end, Junction matcher
    ok 10 - :end, :k
    ok 11 - :end, :p
    ok 12 - :end, :kv
ok 30 - .first works on correctly when called on Numerics
    1..14
    ok 1 - no args
    ok 2 - :k
    ok 3 - :kv
    ok 4 - :p
        1..2
        ok 1 - code dies
        ok 2 - right exception type (X::Adverb)
    ok 5 - :k + :kv throws
        1..2
        ok 1 - code dies
        ok 2 - right exception type (X::Adverb)
    ok 6 - :k + :p throws
        1..2
        ok 1 - code dies
        ok 2 - right exception type (X::Adverb)
    ok 7 - :P + :kv throws
    ok 8 - :end, no args
    ok 9 - :end, :k
    ok 10 - :end, :kv
    ok 11 - :end, :p
        1..2
        ok 1 - code dies
        ok 2 - right exception type (X::Adverb)
    ok 12 - :end, :k + :kv throws
        1..2
        ok 1 - code dies
        ok 2 - right exception type (X::Adverb)
    ok 13 - :end, :k + :p throws
        1..2
        ok 1 - code dies
        ok 2 - right exception type (X::Adverb)
    ok 14 - :end, :P + :kv throws
ok 31 - adverbs work on .first without matcher
# FUDGED!
1..40
ok 1 - do we get Ints
ok 2 - simple direct test of sub
ok 3 - simple direct test of method
ok 4 - we got a list back
ok 5 - got the value we expected
ok 6 - got the value we expected
ok 7 - got the value we expected
ok 8 - got the value we expected
ok 9 - got the value we expected
ok 10 - # SKIP adverbial block
ok 11 - # SKIP adverbial block
ok 12 - # SKIP adverbial block
ok 13 - # SKIP adverbial block
ok 14 - # SKIP adverbial block
ok 15 - # SKIP adverbial block
ok 16 - # SKIP adverbial block
ok 17 - # SKIP adverbial block
ok 18 - # SKIP adverbial block
ok 19 - # SKIP adverbial block
ok 20 - # SKIP adverbial block
ok 21 - # SKIP adverbial block
not ok 22 - we got a list back # TODO closure as non-final argument
# Failed test 'we got a list back'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-list/grep-k.rakudo line 51
# expected: '5'
#      got: '0'
not ok 23 - got the value we expected # TODO closure as non-final argument
# Failed test 'got the value we expected'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-list/grep-k.rakudo line 52
# expected: '0'
#      got: (Any)
not ok 24 - got the value we expected # TODO closure as non-final argument
# Failed test 'got the value we expected'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-list/grep-k.rakudo line 53
# expected: '2'
#      got: (Any)
not ok 25 - got the value we expected # TODO closure as non-final argument
# Failed test 'got the value we expected'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-list/grep-k.rakudo line 54
# expected: '4'
#      got: (Any)
not ok 26 - got the value we expected # TODO closure as non-final argument
# Failed test 'got the value we expected'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-list/grep-k.rakudo line 55
# expected: '6'
#      got: (Any)
not ok 27 - got the value we expected # TODO closure as non-final argument
# Failed test 'got the value we expected'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-list/grep-k.rakudo line 56
# expected: '8'
#      got: (Any)
ok 28 - method form of grep works on numbers
ok 29 - method form of grep works on strings
ok 30 - mutating $_ in grep works (1)
ok 31 - mutating $_ in grep works (2)
ok 32 - last works in grep
ok 33 - next works in grep
ok 34 - .grep with non-Code matcher
ok 35 - grep with non-Code matcher
ok 36 - Junction matcher
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Match::Bool)
ok 37 - did we throws-like X::Match::Bool?
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Match::Bool)
ok 38 - did we throws-like X::Match::Bool?
ok 39 - can we match on Bool as type
ok 40 - can we match on Bool as type
# FUDGED!
1..49
ok 1 - we got a list back
ok 2 - got the value we expected
ok 3 - got the value we expected
ok 4 - got the value we expected
ok 5 - got the value we expected
ok 6 - got the value we expected
ok 7 - # SKIP adverbial block
ok 8 - # SKIP adverbial block
ok 9 - # SKIP adverbial block
ok 10 - # SKIP adverbial block
ok 11 - # SKIP adverbial block
ok 12 - # SKIP adverbial block
ok 13 - # SKIP adverbial block
ok 14 - # SKIP adverbial block
ok 15 - # SKIP adverbial block
ok 16 - # SKIP adverbial block
ok 17 - # SKIP adverbial block
ok 18 - # SKIP adverbial block
ok 19 - method form of grep works on numbers
ok 20 - method form of grep works on strings
ok 21 - mutating $_ in grep works (1)
ok 22 - mutating $_ in grep works (2)
ok 23 - last works in grep
ok 24 - next works in grep
ok 25 - last in grep on infinite list
ok 26 - redo works in grep (1)
ok 27 - redo works in grep (2)
ok 28 - .grep with non-Code matcher
ok 29 - grep() with non-Code matcher
ok 30 - grep takes two at a time
ok 31 - Junction matcher
ok 32 - Non-empty return value from grep is true (1)
ok 33 - Non-empty return value from grep is true (2)
ok 34 - Empty return value from grep is false
ok 35 - chained greps work
    1..2
    ok 1 - 'temp $_ = 42; grep $_ == 1, 1,2,3' died
    ok 2 - right exception type (X::Match::Bool)
ok 36 - did we throws-like X::Match::Bool?
    1..2
    ok 1 - 'temp $_ = 42; (1,2,3).grep: $_== 1' died
    ok 2 - right exception type (X::Match::Bool)
ok 37 - did we throws-like X::Match::Bool?
ok 38 - can we match on Bool as type
ok 39 - can we match on Bool as type
ok 40 - grep is rw-like, can chain it to modify elements of grepped list/array
ok 41 - .grep propagates .is-lazy
ok 42 - grep() propagates .is-lazy
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Adverb)
    ok 3 - .unexpected matches -> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140721176152448) ... }
ok 43 - grep on an instance with an unexpected adverb
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::Adverb)
    ok 3 - .unexpected matches -> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140721176153672) ... }
ok 44 - grep on a type object with an unexpected adverb
    1..4
    ok 1 - race basic
    ok 2 - hyper basic
    ok 3 - race, with shared var
    ok 4 - hyper, w/  shared var
ok 45 - .grep(Regex) on hyper/race Seq do not crash
ok 46 - Block returning a regex to grep will Do The Right Thing, dubious as it is
ok 47 - is any junction handled correctly in grep
ok 48 - is one junction handled correctly in grep
ok 49 - is none junction handled correctly in grep
# FUDGED!
1..61
ok 1 - sub form: we got a list back
ok 2 - got the values we expected
ok 3 - # SKIP adverbial block
ok 4 - # SKIP adverbial block
ok 5 - invcant colon method form: we got a list back
ok 6 - got the values we expected
ok 7 - # SKIP closure as non-final argument
ok 8 - # SKIP closure as non-final argument
ok 9 - Slip returned from closure interpolates elements
ok 10 - got the values we expected
ok 11 - multiple statements in block: we got a list back
ok 12 - got the values we expect
ok 13 - heuristic for block - looks like a closure
ok 14 - The object is-a 'Hash'
ok 15 -  got the hash we expect
ok 16 - map() works with 2-ary functions
ok 17 - map() works with 3-ary functions
ok 18 - map() works with 4-ary functions
ok 19 - map() works with 5-ary functions
ok 20 - argument number mismatch on odd-numbered list
ok 21 - method form of map works on numbers
ok 22 - method form of map works on strings
ok 23 - map of constant list works
ok 24 - should be 3 elements
ok 25 - should be 6 elements (bare block)
ok 26 - flattens with .Slip
ok 27 - mutating $_ in map works (1)
ok 28 - mutating $_ in map works (2)
ok 29 - intern method in map
ok 30 - extern method in map
ok 31 - map works with the map body returning an empty list
ok 32 - map works with the map body returning an empty array
ok 33 - map works with the map body returning an empty arrayitem
ok 34 - map works with the map body returning an empty arrayitem variable
ok 35 - map works with the map body returning undefined
ok 36 - map works with the map body returning an undefined variable
ok 37 - map works with the map body returning () for each iteration
ok 38 - map took 2 elements at a time
ok 39 - first element ok
ok 40 - second element ok
ok 41 - third element ok
ok 42 - map should't flatten our arrayitem (1)
ok 43 - map should't flatten our arrayitem (2)
ok 44 - map should't flatten our arrayitem (3)
ok 45 - dependency for following test (1)
ok 46 - dependency for following test (2)
ok 47 - int() should default to $_ inside map, too
ok 48 - lone $_ in map should work (1)
ok 49 - lone $_ in map should work (2)
ok 50 - lone .() in map should work (2)
ok 51 - next in map works
ok 52 - last in map works
ok 53 - map on pair works (comma)
ok 54 - map on pair works (=>)
ok 55 - map over a callable with a slurpy
ok 56 - map on list in array does not lose content
ok 57 - map on list in hash does not lose content
ok 58 - map can modify what it iterates
ok 59 - only defined Slips are treated specially
ok 60 - non-slippy-non-phaser map push-all works
ok 61 - non-slippy-non-phaser map sink-all works
# FUDGED!
1..50
ok 1 - array of numbers was sorted
ok 2 - array of numbers was sorted (w/out parens)
ok 3 - array of mixed numbers including Inf
ok 4 - array of numbers was sorted (using invocant form)
ok 5 - ... with explicit spaceship
ok 6 - ... with explicit spaceship (using invocant form)
ok 7 - ... reverse sort with explicit spaceship
ok 8 - ... reverse sort with explicit spaceship (using invocant form)
ok 9 - array of strings was sorted
ok 10 - array of strings was sorted (w/out parens)
ok 11 - array of strings was sorted (using invocant form)
ok 12 - ... with explicit cmp
ok 13 - ... with explicit cmp (using invocant form)
ok 14 - ... sort keys by string value
ok 15 - ... sort keys by string value (using invocant form)
ok 16 - ... sort keys by numeric value
ok 17 - ... sort keys by numeric value (using invocant form)
ok 18 - can sort with automated Schwartzian Transform
ok 19 - %hash.sort returns a List of Pairs
ok 20 - sort with unary sub
ok 21 - sort with arity 0 closure is stable
ok 22 - sort with arity 1 closure is stable
ok 23 - sort with arity 2 closure is stable
ok 24 - method form of sort should work on numbers
ok 25 - method form of sort should work on strings
ok 26 - method form of sort should work on lists
ok 27 - sort by class name
    1..2
    ok 1 - code dies
    ok 2 - right exception type (Exception)
ok 28 - sort does not accept 0-arity sub
    1..2
    ok 1 - '(1..10).sort(&rand)' died
    ok 2 - right exception type (Exception)
ok 29 - sort does not accept &rand
ok 30 - sorting by stringified class instance (name and memory address)
ok 31 - .sort stored in a sub returns a List
ok 32 - &sort stored in a sub returns a List
ok 33 - detached .sort returns a List
ok 34 - auto-primed *.sort returns a Seq
ok 35 - .sort on reified empty array does not crash
    1..13
    ok 1 - empty, no args
    ok 2 - empty, 1-arity
    ok 3 - empty, 2-arity
    ok 4 - 1 item, no args
    ok 5 - 1 item, 1-arity
    ok 6 - 1 item, 2-arity
    ok 7 - 2-item, no args (1)
    ok 8 - 2-item, no args (2)
    ok 9 - 2-item, 1-arity (1)
    ok 10 - 2-item, 1-arity (2)
    ok 11 - 2-item, 2-arity (2)
    ok 12 - 2-item, 2-arity (1)
    ok 13 - 2-item, 2-arity (3)
ok 36 - degenerate cases
ok 37 - no crashes when using &lc in .sort
ok 38 - is sorting a 2 elem list with a mapper stable?
    1..4
    ok 1 - code dies
    not ok 2 - right exception type (X::Cannot::Junction) # TODO awaiting https://github.com/rakudo/rakudo/pull/3849
    # Failed test 'right exception type (X::Cannot::Junction)'
    # at SETTING::src/core.c/Rakudo/Sorting.pm6 line 14
    # Expected: X::Cannot::Junction
    # Got:      X::AdHoc
    # Exception message: This type cannot unbox to a native integer: P6opaque, Junction
    ok 3 - # SKIP wrong exception type
    ok 4 - # SKIP wrong exception type
not ok 39 - does 2-element list with Junction throw when sorting # TODO awaiting https://github.com/rakudo/rakudo/pull/3849
# Failed test 'does 2-element list with Junction throw when sorting'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-list/sort.rakudo line 264
    1..4
    ok 1 - code dies
    not ok 2 - right exception type (X::Cannot::Junction) # TODO awaiting https://github.com/rakudo/rakudo/pull/3849
    # Failed test 'right exception type (X::Cannot::Junction)'
    # at SETTING::src/core.c/Rakudo/Sorting.pm6 line 14
    # Expected: X::Cannot::Junction
    # Got:      X::AdHoc
    # Exception message: This type cannot unbox to a native integer: P6opaque, Junction
    ok 3 - # SKIP wrong exception type
    ok 4 - # SKIP wrong exception type
not ok 40 - does 3-element list with Junction throw when sorting # TODO awaiting https://github.com/rakudo/rakudo/pull/3849
# Failed test 'does 3-element list with Junction throw when sorting'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-list/sort.rakudo line 268
    1..4
    ok 1 - code dies
    not ok 2 - right exception type (X::Cannot::Junction) # TODO awaiting https://github.com/rakudo/rakudo/pull/3849
    # Failed test 'right exception type (X::Cannot::Junction)'
    # at SETTING::src/core.c/List.pm6 line 1622
    # Expected: X::Cannot::Junction
    # Got:      X::AdHoc
    # Exception message: This type cannot unbox to a native integer: P6opaque, Junction
    ok 3 - # SKIP wrong exception type
    ok 4 - # SKIP wrong exception type
not ok 41 - does 2-element list with list with Junction throw when sorting # TODO awaiting https://github.com/rakudo/rakudo/pull/3849
# Failed test 'does 2-element list with list with Junction throw when sorting'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-list/sort.rakudo line 272
    1..4
    ok 1 - code dies
    not ok 2 - right exception type (X::Cannot::Junction) # TODO awaiting https://github.com/rakudo/rakudo/pull/3849
    # Failed test 'right exception type (X::Cannot::Junction)'
    # at SETTING::src/core.c/List.pm6 line 1622
    # Expected: X::Cannot::Junction
    # Got:      X::AdHoc
    # Exception message: This type cannot unbox to a native integer: P6opaque, Junction
    ok 3 - # SKIP wrong exception type
    ok 4 - # SKIP wrong exception type
not ok 42 - does 3-element list with list with Junction throw when sorting # TODO awaiting https://github.com/rakudo/rakudo/pull/3849
# Failed test 'does 3-element list with list with Junction throw when sorting'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-list/sort.rakudo line 276
    1..4
    ok 1 - code dies
    not ok 2 - right exception type (X::Cannot::Junction) # TODO awaiting https://github.com/rakudo/rakudo/pull/3849
    # Failed test 'right exception type (X::Cannot::Junction)'
    # at SETTING::src/core.c/Rakudo/Sorting.pm6 line 14
    # Expected: X::Cannot::Junction
    # Got:      X::AdHoc
    # Exception message: This type cannot unbox to a native integer: P6opaque, Junction
    ok 3 - # SKIP wrong exception type
    ok 4 - # SKIP wrong exception type
not ok 43 - does 2-element list with Pairs with Junction throw when sorting # TODO awaiting https://github.com/rakudo/rakudo/pull/3849
# Failed test 'does 2-element list with Pairs with Junction throw when sorting'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-list/sort.rakudo line 280
    1..4
    ok 1 - code dies
    not ok 2 - right exception type (X::Cannot::Junction) # TODO awaiting https://github.com/rakudo/rakudo/pull/3849
    # Failed test 'right exception type (X::Cannot::Junction)'
    # at SETTING::src/core.c/Rakudo/Sorting.pm6 line 14
    # Expected: X::Cannot::Junction
    # Got:      X::AdHoc
    # Exception message: This type cannot unbox to a native integer: P6opaque, Junction
    ok 3 - # SKIP wrong exception type
    ok 4 - # SKIP wrong exception type
not ok 44 - does 3-element list with Pairs with Junction throw when sorting # TODO awaiting https://github.com/rakudo/rakudo/pull/3849
# Failed test 'does 3-element list with Pairs with Junction throw when sorting'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-list/sort.rakudo line 284
ok 45 - do IntStrs sort correctly
ok 46 - do NumStrs sort correctly
ok 47 - do RatStrs sort correctly
ok 48 - do ComplexStrs sort correctly
ok 49 - do mixed allomorphs sort correctly
ok 50 - does NaN sort correctly
# FUDGED!
1..46
ok 1 - "-17".abs == 17
ok 2 - NotComplex.new.abs == $magic.abs
ok 3 - "3".conj == 3
ok 4 - NotComplex.new.conj == $magic.conj
ok 5 - "3".exp == 3.exp
ok 6 - NotComplex.new.exp == $magic.exp
ok 7 - "3".exp("2") == 3.exp(2)
ok 8 - NotComplex.new.exp("2") == $magic.exp("2")
ok 9 - "3".exp(NotComplex.new) == 3.exp($magic)
ok 10 - NotComplex.new.exp(NotComplex.new) == $magic.exp($magic)
ok 11 - "17".log == 17.log
ok 12 - NotComplex.new.log == $magic.log
ok 13 - "17".log("17") == 17.log(17)
ok 14 - NotComplex.new.log("17") == $magic.log(17)
ok 15 - "17".log("17") == 17.log(17)
ok 16 - NotComplex.new.log(NotComplex.new) == $magic.log($magic)
ok 17 - "17".log10 == 17.log10
ok 18 - NotComplex.new.log10 == $magic.log10
ok 19 - "17".sqrt == 17.sqrt
ok 20 - NotComplex.new.sqrt == $magic.sqrt
ok 21 - root 2.0305431848689306+0i found once
ok 22 - root 1.243349105940104e-16+2.0305431848689306i found once
ok 23 - root -2.0305431848689306+2.486698211880208e-16i found once
ok 24 - root -3.730047317820312e-16-2.0305431848689306i found once
ok 25 - root 1.2466105363113318+0.4731614097078769i found once
ok 26 - root -1.033075069053144+0.8430156882170183i found once
ok 27 - root -0.21353546725818734-1.3161770979248952i found once
ok 28 - "17"i == 17i
ok 29 - (NotComplex.new)i == $magic\i
ok 30 - # SKIP angle conversion
ok 31 - # SKIP angle conversion
ok 32 - # SKIP angle conversion
ok 33 - # SKIP angle conversion
ok 34 - "17.25".floor == 17.25.floor
ok 35 - "17.25".ceiling == 17.25.ceiling
ok 36 - "17.25".round == 17.25.round
ok 37 - "17.25".round("0.1") == 17.25.round(0.1)
ok 38 - "17.25".truncate == 17.25.truncate
ok 39 - "17".sign == 1
ok 40 - "-17".sign == -1
ok 41 - "0".sign == 0
ok 42 - "17".cis == 17.cis
ok 43 - <4+2i>.cis
ok 44 - i.cis
ok 45 - "17".unpolar("42") == 17.unpolar(42)
    1..15
    ok 1 - truncate(Array)
    ok 2 - truncate(Bool::True)
    ok 3 - truncate(Bool::False)
    ok 4 - truncate(Cool)
    ok 5 - truncate(Duration)
    ok 6 - truncate(Map)
    ok 7 - truncate(FatRat)
    ok 8 - truncate(Hash)
    ok 9 - truncate(Instant)
    ok 10 - truncate(List)
    ok 11 - truncate(Match)
    ok 12 - truncate(Num)
    ok 13 - truncate(Range)
    ok 14 - truncate(Seq)
    ok 15 - truncate(Stash)
ok 46 - truncate() with Cools
# FUDGED!
1..29
ok 1 - got the log of 5
ok 2 - got the log of 0.1
ok 3 - log(8, 2) is 3
ok 4 - log(42, 23)
ok 5 - log(42, 23) with strings
ok 6 - got the log10 of 5
ok 7 - got the log10 of 0.1
ok 8 - log(0) = -Inf
ok 9 - log(Inf) = Inf
ok 10 - log(-Inf) = NaN
ok 11 - log(NaN) = NaN
ok 12 - log10(0) = -Inf
ok 13 - log10(Inf) = Inf
ok 14 - log10(-Inf) = NaN
ok 15 - log10(NaN) = NaN
ok 16 - got the log of -1
ok 17 - got the log10 of -1
ok 18 - got the log of -e
ok 19 - got the log10 of -10
ok 20 - log10(10)=1
ok 21 - got log of exp(i pi/4)
ok 22 - got the log of i (complex unit)
ok 23 - got the log10 of i
ok 24 - got log10 of exp(i pi/4)
ok 25 - got the log of -i (complex unit)
ok 26 - got the log10 of -i (complex unit)
ok 27 -  (i).log10 = - i  * pi/(2 log(10))
ok 28 - log10 of a complex returns a complex, not a list
not ok 29 - Can take the log of very large Ints # TODO HugeInt.log
# Failed test 'Can take the log of very large Ints'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-num/log.rakudo line 74
#     expected approximately: 1000
#                        got: Inf
# maximum relative tolerance: 1e-06
# actual relative difference: NaN
# FUDGED!
1..89
ok 1 - 0 ** 0 ==  1
ok 2 - 0 ** 1 ==  0
ok 3 - 1 **  2 ==  1
ok 4 - 4 **  0 ==  1
ok 5 - 4 **  1 ==  4
ok 6 - 4 **  2 == 16
ok 7 -   0 ** 4553535345364535345634543534 == 0
ok 8 -   1 ** 4553535345364535345634543534 == 1
ok 9 - 1e0 ** 4553535345364535345634543534 == 1
ok 10 -  -1 ** 4553535345364535345634543534 == 1
ok 11 -  -1 ** 4553535345364535345634543533  == -1
ok 12 - 4 ** .5 ==  2
ok 13 - 4 ** (1/2) == 2 
ok 14 - 4 ** (-1/2) == 1/2 
ok 15 - -2 ** 2 = 4
ok 16 - 1**Inf=1
ok 17 - 0**Inf=0
ok 18 - Inf**2 = Inf
ok 19 - (-Inf)**3 = -Inf
ok 20 - Inf**Inf = Inf
ok 21 - NaN propagates with integer powers
ok 22 - NaN propagates with numeric powers
ok 23 - 0**NaN=NaN
not ok 24 - NaN**1i=NaN # TODO wrong results for "NaN" used with "**"
# Failed test 'NaN**1i=NaN'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-num/power.rakudo line 39
# expected: NaN
#      got: <NaN+NaN\i>
not ok 25 - 1i**NaN=NaN # TODO wrong results for "NaN" used with "**"
# Failed test '1i**NaN=NaN'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-num/power.rakudo line 40
# expected: NaN
#      got: <NaN+NaN\i>
ok 26 - NaN**0=1
ok 27 - 1**NaN=1
ok 28 - NaN**NaN=NaN
ok 29 - Inf**NaN=NaN
ok 30 - NaN**Inf=NaN
ok 31 - e **  .5 ==   exp(.5)
ok 32 - e ** 2.5 ==  exp(2.5)
ok 33 - (4+0i) ** 2 == 16
ok 34 - i ** 4 == 1
ok 35 - (4+0i) ** .5 == 2
ok 36 - i ** 2 == -1
ok 37 - i ** 3 == -i
ok 38 - 5i ** 3 = -125i
ok 39 - 3i ** 3 = -27i
ok 40 - -3i ** 3 = 27i
not ok 41 - (-1) ** -i is approx 23.1406926327793 # TODO i
# Failed test '(-1) ** -i is approx 23.1406926327793'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-num/power.rakudo line 66
#     expected approximately: 23.1406926327793
#                        got: NaN+NaN\i
# maximum relative tolerance: 1e-06
# actual relative difference: NaN
ok 42 - quartic root of 8i ** 4 = 8i
ok 43 - quartic root of 8i ** 4 = 8i
ok 44 - quartic root of 8i ** 4 = 8i
ok 45 - quartic root of 8i ** 4 = 8i
ok 46 - e ** pi i = -1
ok 47 - (4+0i) ** (2+0i) == 16
ok 48 - 1.015 ** 200 is not NaN
ok 49 - 1.015 ** 200 == 19.6430286394751
ok 50 - 0⁰ ==  1
ok 51 - 0¹ ==  0
ok 52 - 1² ==  1
ok 53 - 4⁰ ==  1
ok 54 - 4¹ ==  4
ok 55 - 4² == 16
ok 56 - 2³² == 2 ** 32
ok 57 - 2⁶⁴ == 2 ** 64
ok 58 - 10¹⁰⁰ == 10 ** 100
ok 59 - *⁰(0) ==  1
ok 60 - *¹(0) ==  0
ok 61 - *²(1) ==  1
ok 62 - *⁰() ==  1
ok 63 - *¹() ==  4
ok 64 - *²() == 16
ok 65 - *³²(2) == 2 ** 32
ok 66 - *⁶⁴(2) == 2 ** 64
ok 67 - *¹⁰⁰(10) == 10 ** 100
ok 68 - 3³
ok 69 - 3⁴
ok 70 - 3⁵
ok 71 - 3⁶
ok 72 - 3⁷
ok 73 - 3⁸
ok 74 - 3⁹
ok 75 - 3¹⁰
ok 76 - 3¹³
ok 77 - (-1)¹²³
ok 78 -    0⁴⁵⁵³⁵³⁵³⁴⁵³⁶⁴⁵³⁵³⁴⁵ ==  0
ok 79 -    1⁴⁵⁵³⁵³⁵³⁴⁵³⁶⁴⁵³⁵³⁴⁵ ==  1
ok 80 -  1e0⁴⁵⁵³⁵³⁵³⁴⁵³⁶⁴⁵³⁵³⁴⁵ ==  1
ok 81 - (-1)⁴⁵⁵³⁵³⁵³⁴⁵³⁶⁴⁵³⁵³⁵⁴ ==  1
ok 82 - (-1)⁴⁵⁵³⁵³⁵³⁴⁵³⁶⁴⁵³⁵³⁴⁵ == -1
ok 83 - 4 ** ½ ==  2
ok 84 - 4 ** -½ == ½
ok 85 - 27 ** ⅓ ==  3
ok 86 - 27 ** ⅔ ==  9
ok 87 - 27 ** -⅓ == ⅓
ok 88 - 27 ** -⅔ == ⅑
    1..75
    ok 1 - ⁰¹²
    ok 2 - ⁰⁺¹²
    ok 3 - ⁰⁻¹²
    ok 4 - ⁰¯¹² (macron)
    ok 5 - 2**⁰²
    ok 6 - ¹¹²
    ok 7 - ¹⁺¹²
    ok 8 - ¹⁻¹²
    ok 9 - ¹¯¹² (macron)
    ok 10 - 2**¹²
    ok 11 - ²¹²
    ok 12 - ²⁺¹²
    ok 13 - ²⁻¹²
    ok 14 - ²¯¹² (macron)
    ok 15 - 2**²²
    ok 16 - ³¹²
    ok 17 - ³⁺¹²
    ok 18 - ³⁻¹²
    ok 19 - ³¯¹² (macron)
    ok 20 - 2**³²
    ok 21 - ⁴¹²
    ok 22 - ⁴⁺¹²
    ok 23 - ⁴⁻¹²
    ok 24 - ⁴¯¹² (macron)
    ok 25 - 2**⁴²
    ok 26 - ⁵¹²
    ok 27 - ⁵⁺¹²
    ok 28 - ⁵⁻¹²
    ok 29 - ⁵¯¹² (macron)
    ok 30 - 2**⁵²
    ok 31 - ⁶¹²
    ok 32 - ⁶⁺¹²
    ok 33 - ⁶⁻¹²
    ok 34 - ⁶¯¹² (macron)
    ok 35 - 2**⁶²
    ok 36 - ⁷¹²
    ok 37 - ⁷⁺¹²
    ok 38 - ⁷⁻¹²
    ok 39 - ⁷¯¹² (macron)
    ok 40 - 2**⁷²
    ok 41 - ⁸¹²
    ok 42 - ⁸⁺¹²
    ok 43 - ⁸⁻¹²
    ok 44 - ⁸¯¹² (macron)
    ok 45 - 2**⁸²
    ok 46 - ⁹¹²
    ok 47 - ⁹⁺¹²
    ok 48 - ⁹⁻¹²
    ok 49 - ⁹¯¹² (macron)
    ok 50 - 2**⁹²
    ok 51 - ⅟¹²
    ok 52 - ⅟⁺¹²
    ok 53 - ⅟⁻¹²
    ok 54 - ⅟¯¹² (macron)
    ok 55 - 2**⅟²
    ok 56 - 𑁓¹²
    ok 57 - 𑁓⁺¹²
    ok 58 - 𑁓⁻¹²
    ok 59 - 𑁓¯¹² (macron)
    ok 60 - 2**𑁓²
    ok 61 - ౸¹²
    ok 62 - ౸⁺¹²
    ok 63 - ౸⁻¹²
    ok 64 - ౸¯¹² (macron)
    ok 65 - 2**౸²
    ok 66 - ㆒¹²
    ok 67 - ㆒⁺¹²
    ok 68 - ㆒⁻¹²
    ok 69 - ㆒¯¹² (macron)
    ok 70 - 2**㆒²
    ok 71 - 𐌣¹²
    ok 72 - 𐌣⁺¹²
    ok 73 - 𐌣⁻¹²
    ok 74 - 𐌣¯¹² (macron)
    ok 75 - 2**𐌣²
ok 89 - power ops with uncommon No chars as terms work
# FUDGED!
1..113
ok 1 - rand returns numbers greater than or equal to 0
ok 2 - rand returns numbers less than 1
ok 3 - rand returns numbers in [0, 2)
ok 4 - rand returns numbers in [0, 2)
ok 5 - rand returns numbers in [0, 2)
ok 6 - rand returns numbers in [0, 2)
ok 7 - rand returns numbers in [0, 2)
ok 8 - rand returns numbers in [0, 2)
ok 9 - rand returns numbers in [0, 2)
ok 10 - rand returns numbers in [0, 2)
ok 11 - rand returns numbers in [0, 2)
ok 12 - rand returns numbers in [0, 2)
ok 13 - rand returns numbers in [0, 2)
ok 14 - rand returns numbers in [0, 2)
ok 15 - rand returns numbers in [0, 2)
ok 16 - rand returns numbers in [0, 2)
ok 17 - rand returns numbers in [0, 2)
ok 18 - rand returns numbers in [0, 2)
ok 19 - rand returns numbers in [0, 2)
ok 20 - rand returns numbers in [0, 2)
ok 21 - rand returns numbers in [0, 2)
ok 22 - rand returns numbers in [0, 2)
ok 23 - rand returns numbers in [0, 3)
ok 24 - rand returns numbers in [0, 3)
ok 25 - rand returns numbers in [0, 3)
ok 26 - rand returns numbers in [0, 3)
ok 27 - rand returns numbers in [0, 3)
ok 28 - rand returns numbers in [0, 3)
ok 29 - rand returns numbers in [0, 3)
ok 30 - rand returns numbers in [0, 3)
ok 31 - rand returns numbers in [0, 3)
ok 32 - rand returns numbers in [0, 3)
ok 33 - rand returns numbers in [0, 3)
ok 34 - rand returns numbers in [0, 3)
ok 35 - rand returns numbers in [0, 3)
ok 36 - rand returns numbers in [0, 3)
ok 37 - rand returns numbers in [0, 3)
ok 38 - rand returns numbers in [0, 3)
ok 39 - rand returns numbers in [0, 3)
ok 40 - rand returns numbers in [0, 3)
ok 41 - rand returns numbers in [0, 3)
ok 42 - rand returns numbers in [0, 3)
ok 43 - rand returns numbers in [0, 5)
ok 44 - rand returns numbers in [0, 5)
ok 45 - rand returns numbers in [0, 5)
ok 46 - rand returns numbers in [0, 5)
ok 47 - rand returns numbers in [0, 5)
ok 48 - rand returns numbers in [0, 5)
ok 49 - rand returns numbers in [0, 5)
ok 50 - rand returns numbers in [0, 5)
ok 51 - rand returns numbers in [0, 5)
ok 52 - rand returns numbers in [0, 5)
ok 53 - rand returns numbers in [0, 5)
ok 54 - rand returns numbers in [0, 5)
ok 55 - rand returns numbers in [0, 5)
ok 56 - rand returns numbers in [0, 5)
ok 57 - rand returns numbers in [0, 5)
ok 58 - rand returns numbers in [0, 5)
ok 59 - rand returns numbers in [0, 5)
ok 60 - rand returns numbers in [0, 5)
ok 61 - rand returns numbers in [0, 5)
ok 62 - rand returns numbers in [0, 5)
ok 63 - rand returns numbers in [0, 7)
ok 64 - rand returns numbers in [0, 7)
ok 65 - rand returns numbers in [0, 7)
ok 66 - rand returns numbers in [0, 7)
ok 67 - rand returns numbers in [0, 7)
ok 68 - rand returns numbers in [0, 7)
ok 69 - rand returns numbers in [0, 7)
ok 70 - rand returns numbers in [0, 7)
ok 71 - rand returns numbers in [0, 7)
ok 72 - rand returns numbers in [0, 7)
ok 73 - rand returns numbers in [0, 7)
ok 74 - rand returns numbers in [0, 7)
ok 75 - rand returns numbers in [0, 7)
ok 76 - rand returns numbers in [0, 7)
ok 77 - rand returns numbers in [0, 7)
ok 78 - rand returns numbers in [0, 7)
ok 79 - rand returns numbers in [0, 7)
ok 80 - rand returns numbers in [0, 7)
ok 81 - rand returns numbers in [0, 7)
ok 82 - rand returns numbers in [0, 7)
ok 83 - rand returns numbers in [0, 11)
ok 84 - rand returns numbers in [0, 11)
ok 85 - rand returns numbers in [0, 11)
ok 86 - rand returns numbers in [0, 11)
ok 87 - rand returns numbers in [0, 11)
ok 88 - rand returns numbers in [0, 11)
ok 89 - rand returns numbers in [0, 11)
ok 90 - rand returns numbers in [0, 11)
ok 91 - rand returns numbers in [0, 11)
ok 92 - rand returns numbers in [0, 11)
ok 93 - rand returns numbers in [0, 11)
ok 94 - rand returns numbers in [0, 11)
ok 95 - rand returns numbers in [0, 11)
ok 96 - rand returns numbers in [0, 11)
ok 97 - rand returns numbers in [0, 11)
ok 98 - rand returns numbers in [0, 11)
ok 99 - rand returns numbers in [0, 11)
ok 100 - rand returns numbers in [0, 11)
ok 101 - rand returns numbers in [0, 11)
ok 102 - rand returns numbers in [0, 11)
ok 103 - srand(1) lives and parses
ok 104 - srand() provides repeatability for rand
ok 105 - edge case: srand(0) provides repeatability
ok 106 - edge case: srand(0) not the same as srand(1)
ok 107 - srand(...) provides repeatability for rand
ok 108 - edge case: srand(0) provides repeatability
ok 109 - edge case: srand(0) not the same as srand(:seed(1))
ok 110 - # SKIP Test is too slow; srand call incorrect
ok 111 - Distribution is not very uneven
    1..2
    ok 1 - 'rand()' died
    ok 2 - right exception type (X::Obsolete)
ok 112 - did we throws-like X::Obsolete?
    1..2
    ok 1 - 'rand(3)' died
    ok 2 - right exception type (X::Obsolete)
ok 113 - did we throws-like X::Obsolete?
# FUDGED!
1..62
ok 1 - ~<3+4i>
ok 2 - <3+4i>.Str
ok 3 - <3+4i>.gist
ok 4 - <3+4i>.raku
ok 5 - ~<3-4i>
ok 6 - <3-4i>.Str
ok 7 - <3-4i>.gist
ok 8 - <3-4i>.raku
ok 9 - ~<-3+4i>
ok 10 - <-3+4i>.Str
ok 11 - <-3+4i>.gist
ok 12 - <-3+4i>.raku
ok 13 - ~<3.5+4i>
ok 14 - <3.5+4i>.Str
ok 15 - <3.5+4i>.gist
ok 16 - <3.5+4i>.raku
ok 17 - ~<3+4.5i>
ok 18 - <3+4.5i>.Str
ok 19 - <3+4.5i>.gist
ok 20 - <3+4.5i>.raku
ok 21 - ~<Inf+3i>
ok 22 - <Inf+3i>.Str
ok 23 - <Inf+3i>.gist
ok 24 - <Inf+3i>.raku
ok 25 - ~<0+Inf\i>
ok 26 - <0+Inf\i>.Str
ok 27 - <0+Inf\i>.gist
ok 28 - <0+Inf\i>.raku
ok 29 - ~<-Inf+3i>
ok 30 - <-Inf+3i>.Str
ok 31 - <-Inf+3i>.gist
ok 32 - <-Inf+3i>.raku
ok 33 - ~<0-Inf\i>
ok 34 - <0-Inf\i>.Str
ok 35 - <0-Inf\i>.gist
ok 36 - <0-Inf\i>.raku
ok 37 - ~<NaN+3i>
ok 38 - <NaN+3i>.Str
ok 39 - <NaN+3i>.gist
ok 40 - <NaN+3i>.raku
ok 41 - ~<0+NaN\i>
ok 42 - <0+NaN\i>.Str
ok 43 - <0+NaN\i>.gist
ok 44 - <0+NaN\i>.raku
ok 45 - Complex.gist
ok 46 - Complex.raku
ok 47 - ~Complex does not die
ok 48 - Complex.Str does not die
    1..7
    ok 1 - ~<1/2>
    ok 2 - <1/2>.Str
    ok 3 - <1/2>.gist
    ok 4 - <1/2>.raku
    ok 5 - ~<1/2>.FatRat
    ok 6 - <1/2>.FatRat.Str
    ok 7 - <1/2>.FatRat.gist
ok 49 - Rat Stringification (0.5)
    1..7
    ok 1 - ~<-1/2>
    ok 2 - <-1/2>.Str
    ok 3 - <-1/2>.gist
    ok 4 - <-1/2>.raku
    ok 5 - ~<-1/2>.FatRat
    ok 6 - <-1/2>.FatRat.Str
    ok 7 - <-1/2>.FatRat.gist
ok 50 - Rat Stringification (-0.5)
    1..7
    ok 1 - ~<0/1>
    ok 2 - <0/1>.Str
    ok 3 - <0/1>.gist
    ok 4 - <0/1>.raku
    ok 5 - ~<0/1>.FatRat
    ok 6 - <0/1>.FatRat.Str
    ok 7 - <0/1>.FatRat.gist
ok 51 - Rat Stringification (0)
    1..7
    ok 1 - ~<1/1>
    ok 2 - <1/1>.Str
    ok 3 - <1/1>.gist
    ok 4 - <1/1>.raku
    ok 5 - ~<1/1>.FatRat
    ok 6 - <1/1>.FatRat.Str
    ok 7 - <1/1>.FatRat.gist
ok 52 - Rat Stringification (1)
    1..7
    ok 1 - ~<1/3>
    ok 2 - <1/3>.Str
    ok 3 - <1/3>.gist
    ok 4 - <1/3>.raku
    ok 5 - ~<1/3>.FatRat
    ok 6 - <1/3>.FatRat.Str
    ok 7 - <1/3>.FatRat.gist
ok 53 - Rat Stringification (0.333333)
    1..7
    ok 1 - ~<1000001/10000>
    ok 2 - <1000001/10000>.Str
    ok 3 - <1000001/10000>.gist
    ok 4 - <1000001/10000>.raku
    ok 5 - ~<1000001/10000>.FatRat
    ok 6 - <1000001/10000>.FatRat.Str
    ok 7 - <1000001/10000>.FatRat.gist
ok 54 - Rat Stringification (100.0001)
    1..7
    ok 1 - ~<-1000001/10000>
    ok 2 - <-1000001/10000>.Str
    ok 3 - <-1000001/10000>.gist
    ok 4 - <-1000001/10000>.raku
    ok 5 - ~<-1000001/10000>.FatRat
    ok 6 - <-1000001/10000>.FatRat.Str
    ok 7 - <-1000001/10000>.FatRat.gist
ok 55 - Rat Stringification (-100.0001)
    1..7
    ok 1 - ~<555555555555555555555555555555555555555555555/5>
    ok 2 - <555555555555555555555555555555555555555555555/5>.Str
    ok 3 - <555555555555555555555555555555555555555555555/5>.gist
    ok 4 - <555555555555555555555555555555555555555555555/5>.raku
    ok 5 - ~<555555555555555555555555555555555555555555555/5>.FatRat
    ok 6 - <555555555555555555555555555555555555555555555/5>.FatRat.Str
    ok 7 - <555555555555555555555555555555555555555555555/5>.FatRat.gist
ok 56 - Rat Stringification (111111111111111111111111111111111111111111111)
    1..7
    not ok 1 - ~<1797010299914431210413179829509605039731475627537851106401/1152921504606846976> # TODO big stuff
    # Failed test '~<1797010299914431210413179829509605039731475627537851106401/1152921504606846976>'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-num/stringify.rakudo line 71
    # expected: '1558657976916843360832062017400788597510.058834953945635510598466400011830046423710882663726806640625'
    #      got: '1558657976916843360832062017400788597510.0588349539456355106'
    not ok 2 - <1797010299914431210413179829509605039731475627537851106401/1152921504606846976>.Str # TODO big stuff
    # Failed test '<1797010299914431210413179829509605039731475627537851106401/1152921504606846976>.Str'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-num/stringify.rakudo line 71
    # expected: '1558657976916843360832062017400788597510.058834953945635510598466400011830046423710882663726806640625'
    #      got: '1558657976916843360832062017400788597510.0588349539456355106'
    not ok 3 - <1797010299914431210413179829509605039731475627537851106401/1152921504606846976>.gist # TODO big stuff
    # Failed test '<1797010299914431210413179829509605039731475627537851106401/1152921504606846976>.gist'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-num/stringify.rakudo line 71
    # expected: '1558657976916843360832062017400788597510.058834953945635510598466400011830046423710882663726806640625'
    #      got: '1558657976916843360832062017400788597510.0588349539456355106'
    ok 4 - <1797010299914431210413179829509605039731475627537851106401/1152921504606846976>.raku
    ok 5 - ~<1797010299914431210413179829509605039731475627537851106401/1152921504606846976>.FatRat
    ok 6 - <1797010299914431210413179829509605039731475627537851106401/1152921504606846976>.FatRat.Str
    ok 7 - <1797010299914431210413179829509605039731475627537851106401/1152921504606846976>.FatRat.gist
not ok 57 - Rat Stringification (1558657976916843360832062017400788597510.0588349539456355106) # TODO big stuff
# Failed test 'Rat Stringification (1558657976916843360832062017400788597510.0588349539456355106)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-num/stringify.rakudo line 71
ok 58 - Rat.gist
ok 59 - Rat.raku
ok 60 - ~Rat does not die
ok 61 - Rat.Str does not die
    1..6
    ok 1 - pi
    ok 2 - pi (.raku.EVAL roundtripped)
    ok 3 - 0.1e0 does not get long string of zeros
    ok 4 - 0.3e0 does not get long string of zeros
    ok 5 - 0.1e0+0.2e0 gets 0.3000…
    ok 6 - 2e25 and 20e24 stringify the same
ok 62 - no precision loss in stringification of Nums
# FUDGED!
1..7
ok 1 - can we serialize a simple scalar
ok 2 - can we roundtrip simple scalar
ok 3 - make sure any value can be stored
not ok 4 - can we serialize a scalar with constrained values # TODO cannot roundtrip constrained scalars yet
# Failed test 'can we serialize a scalar with constrained values'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-scalar/perl.rakudo line 20
# expected: 'Int(1)'
#      got: '1'
ok 5 - can we roundtrip scalar constrained values
not ok 6 - make sure roundtripped values are Int # TODO cannot roundtrip constrained scalars yet
# Failed test 'make sure roundtripped values are Int'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-scalar/perl.rakudo line 25
    1..3
    ok 1 - Result is same as original
    ok 2 - Same .raku output
    ok 3 - ...and no failures.
ok 7 - Rat.raku is idempotent
# FUDGED!
1..91
ok 1 - Mu is not defined
ok 2 - uninitialized lexicals are undefined
ok 3 - uninitialized package vars are undefined
ok 4 - initialized var is defined
ok 5 - increment of undefined variable does not warn
ok 6 - undefine($a) does
ok 7 - string
ok 8 - assigning another undefined lexical
ok 9 - assigning another undefined global
ok 10 - pop from array
ok 11 - pop from empty array
ok 12 - shift from array
ok 13 - shift from empty array
ok 14 - hash subscript
ok 15 - non-existent hash subscript
ok 16 - undefine hash subscript
ok 17 - delete hash subscript
ok 18 - aggregate array defined
ok 19 - aggregate hash defined
not ok 20 - undefine array # TODO definedness of array
# Failed test 'undefine array'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-scalar/undef.rakudo line 87
not ok 21 - undefine hash # TODO definedness of hash
# Failed test 'undefine hash'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-scalar/undef.rakudo line 91
ok 22 - define array again
ok 23 - define hash again
ok 24 - # SKIP access to &your_sub
ok 25 - # SKIP access to &your_sub
ok 26 - # SKIP access to &your_sub
ok 27 - # SKIP access to &your_sub
ok 28 - # SKIP access to &your_sub
ok 29 - # SKIP access to &your_sub
ok 30 - Undef on LHS of list assignment
ok 31 - Undef on LHS of list assignment
ok 32 - Undef on LHS of list assignment
ok 33 - Undef on LHS of function assignment
ok 34 - Undef on LHS of function assignment
ok 35 - The object is-a 'Array'
ok 36 - array reference
ok 37 - undefine array referent
ok 38 - dangling array reference
ok 39 - The object is-a '"Hash"'
ok 40 - hash reference
ok 41 - undefine hash referent:
ok 42 - dangling hash reference
ok 43 - my Array
ok 44 - my Array subscript - Mu
ok 45 - push
ok 46 - comes to shove
ok 47 - my Hash
ok 48 - my Hash subscript - Mu
ok 49 - my Hash subscript - Mu, no autovivification happened
ok 50 - delete
ok 51 -  - once only
ok 52 - Unelaborated mutt
ok 53 -  - now real
ok 54 - # SKIP Cannot use bind operator with this left-hand side
ok 55 - # SKIP Cannot use bind operator with this left-hand side
ok 56 - # SKIP Cannot use bind operator with this left-hand side
ok 57 - # SKIP Cannot use bind operator with this left-hand side
ok 58 - # SKIP Cannot use bind operator with this left-hand side
ok 59 - # SKIP Cannot use bind operator with this left-hand side
ok 60 - # SKIP Cannot use bind operator with this left-hand side
ok 61 - # SKIP Cannot use bind operator with this left-hand side
ok 62 - # SKIP Cannot use bind operator with this left-hand side
ok 63 - # SKIP Cannot use bind operator with this left-hand side
ok 64 - all submatches undefined after failed match
ok 65 - defined param
ok 66 - unspecified optional param
ok 67 - unspecified optional param
ok 68 - Any + 1
ok 69 - 1 + Any
ok 70 - Any * 2
ok 71 - 2 * Any
ok 72 - Any xx 2
ok 73 - Any * Any
ok 74 - can use EVAL("") in further expressions
ok 75 - sub returns a bool
ok 76 - attempt to undefine returned Bool type dies
ok 77 - sub still returns a bool
ok 78 - sub returns array
ok 79 - attempt to undefine returned array lives
ok 80 - sub still returns array
ok 81 - attempt to undefine sub dies
ok 82 - attempt to undefine sub fails
ok 83 - can still call sub after attempt to undefine it
ok 84 - can undefine $a twice without any troubles
ok 85 - undefine is rw
ok 86 - Can undefine temp $var
ok 87 - Can temp undefine $var
ok 88 - Can temp undefine $var + assignment
ok 89 - temp restores value before undefine
ok 90 - temp restores value after undefine
ok 91 - temp restore default value after undefine
# FUDGED!
1..41
ok 1 - $str.encode returns a blob8
ok 2 - encoding to ASCII
ok 3 - right length of Buf
ok 4 - encoding to UTF-8
ok 5 - right length of Buf
ok 6 - right length of Buf with \n
ok 7 - Non-translation of \n outside Windows
ok 8 - indexing a utf8 gives correct value (1)
ok 9 - indexing a utf8 gives correct value (1)
ok 10 - cp1252 encodes most C1 substitutes
ok 11 - cp1252 encode tolerates unassigned C1 characters
    1..3
    ok 1 - '"aouÄÖÜ".encode("latin1").decode("utf8")' died
    ok 2 - right exception type (Exception)
    ok 3 - .message matches rx:s:i/line 1 col\w* 4/
ok 12 - did we throws-like Exception?
    1..3
    ok 1 - '"ssß".encode("latin1").decode("utf8")' died
    ok 2 - right exception type (Exception)
    ok 3 - .message matches rx:s:i/term/
ok 13 - did we throws-like Exception?
    1..3
    ok 1 - '"aoaou".encode("latin1").decode("utf16")' died
    ok 2 - right exception type (Exception)
    not ok 3 - .message matches rx:s:i/line 1 col\w* 2|term/ # TODO RT#107204 should say line and column or mention term(ination)
    # Failed test '.message matches rx:s:i/line 1 col\w* 2|term/'
    # at SETTING::src/core.c/Any-iterable-methods.pm6 line 627
    # Expected: rx:s:i/line 1 col\w* 2|term/
    # Got:      Malformed UTF-16; odd number of bytes (5)
not ok 14 - did we throws-like Exception? # TODO RT#107204 should say line and column or mention term(ination)
# Failed test 'did we throws-like Exception?'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-str/encode.rakudo line 38
    1..3
    ok 1 - '"aouÄÖÜ".encode("latin1").decode("utf16")' died
    ok 2 - right exception type (Exception)
    not ok 3 - .message matches rx:s:i/line 1 col\w* 2/ # TODO RT#107204 should say line and column
    # Failed test '.message matches rx:s:i/line 1 col\w* 2/'
    # at SETTING::src/core.c/Any-iterable-methods.pm6 line 627
    # Expected: rx:s:i/line 1 col\w* 2/
    # Got:      Malformed UTF-16; unexpected low surrogate
not ok 15 - did we throws-like Exception? # TODO RT#107204 should say line and column
# Failed test 'did we throws-like Exception?'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-str/encode.rakudo line 41
ok 16 - can index one element in a Buf
ok 17 - can slice-index a Buf
ok 18 - # SKIP We do not handle NDF yet RT  \#124687
ok 19 - encoding ä utf8 gives correct numbers
ok 20 - .decode returns a Str
ok 21 - decoding a Buf with UTF-8
ok 22 - decoding a Buf with Latin-1
ok 23 - cp1252 decodes most C1 substitutes
ok 24 - cp1252 decode tolerates unassigned C1 characters
ok 25 - Buf does Stringy
ok 26 - Buf does Positional
ok 27 - Buf.list gives a list of codepoints
ok 28 - encode a string to UTF-16 surrogate pair
ok 29 - creating utf16 Buf from a surrogate pair
ok 30 - indexing a utf16 gives correct value
ok 31 - indexing a utf16 gives correct value
ok 32 - decoding utf16 Buf to original value
ok 33 - Can encode noncharacters to UTF-8
ok 34 - Noncharacters round-trip with UTF-8
    1..4
        1..3
        ok 1 - code dies
        ok 2 - right exception type (Exception)
        ok 3 - .message matches rx:s:i/Error encoding $encoding string/
    ok 1 - No replacement dies
    ok 2 - Default replacement
    ok 3 - Zero-character replacement
    ok 4 - Multi-character replacement
ok 35 - Non-ascii character
    1..4
        1..3
        ok 1 - code dies
        ok 2 - right exception type (Exception)
        ok 3 - .message matches rx:s:i/Error encoding $encoding string/
    ok 1 - No replacement dies
    ok 2 - Default replacement
    ok 3 - Zero-character replacement
    ok 4 - Multi-character replacement
ok 36 - Non-latin-1 character
    1..4
        1..3
        ok 1 - code dies
        ok 2 - right exception type (Exception)
        ok 3 - .message matches rx:s:i/Error encoding $encoding string/
    ok 1 - No replacement dies
    ok 2 - Default replacement
    ok 3 - Zero-character replacement
    ok 4 - Multi-character replacement
ok 37 - Non-windows-1252 character
ok 38 - utf-16 BOM handled ok
ok 39 - Can decode utf-8 buffer as if it were utf8-c8
ok 40 - Can decode utf-8 buffer as if it were utf16le
ok 41 - Can decode utf-8 buffer as if it were utf16be
# FUDGED!
1..63
ok 1 - Simple .indent(1)
ok 2 - Simple .indent(2)
ok 3 - Simple .indent(3)
ok 4 - Simple .indent(4)
ok 5 - New indent goes after existing - .indent(1)
ok 6 - New indent goes after existing - .indent(2)
ok 7 - New indent goes after existing - .indent(3)
ok 8 - New indent goes after existing - .indent(4)
ok 9 - Same space - .indent(1) prefix="\x[20]"
ok 10 - Same space - .indent(1) prefix="\x[2002]"
ok 11 - Same space - .indent(2) prefix="\x[20]"
ok 12 - Same space - .indent(2) prefix="\x[2002]"
ok 13 - Same space - .indent(3) prefix="\x[20]"
ok 14 - Same space - .indent(3) prefix="\x[2002]"
ok 15 - Same space - .indent(4) prefix="\x[20]"
ok 16 - Same space - .indent(4) prefix="\x[2002]"
ok 17 - Samespace indent should work for a full $?TABSTOP with \t
ok 18 - Mixed space - .indent(1) prefix="\x[20]"
ok 19 - Mixed space - .indent(1) prefix="\x[9]"
ok 20 - Mixed space - .indent(1) prefix="\x[2002]"
ok 21 - Mixed space - .indent(2) prefix="\x[20]"
ok 22 - Mixed space - .indent(2) prefix="\x[9]"
ok 23 - Mixed space - .indent(2) prefix="\x[2002]"
ok 24 - Mixed space - .indent(3) prefix="\x[20]"
ok 25 - Mixed space - .indent(3) prefix="\x[9]"
ok 26 - Mixed space - .indent(3) prefix="\x[2002]"
ok 27 - Mixed space - .indent(4) prefix="\x[20]"
ok 28 - Mixed space - .indent(4) prefix="\x[9]"
ok 29 - Mixed space - .indent(4) prefix="\x[2002]"
ok 30 - Mixed space - .indent(5) prefix="\x[20]"
ok 31 - Mixed space - .indent(5) prefix="\x[9]"
ok 32 - Mixed space - .indent(5) prefix="\x[2002]"
ok 33 - Mixed space - .indent(6) prefix="\x[20]"
ok 34 - Mixed space - .indent(6) prefix="\x[9]"
ok 35 - Mixed space - .indent(6) prefix="\x[2002]"
ok 36 - Mixed space - .indent(7) prefix="\x[20]"
ok 37 - Mixed space - .indent(7) prefix="\x[9]"
ok 38 - Mixed space - .indent(7) prefix="\x[2002]"
ok 39 - Mixed space - .indent(8) prefix="\x[20]"
ok 40 - Mixed space - .indent(8) prefix="\x[9]"
ok 41 - Mixed space - .indent(8) prefix="\x[2002]"
ok 42 - Simple outdent
ok 43 - Simple outdent with tab (explodes because we delete from left)
ok 44 - Excess outdent test for correct output
ok 45 - Excess outdent test for warning
ok 46 - indent(*) on empty string
ok 47 - Whatever* outdent with at least 1 common indent
ok 48 - Whatever* outdent with one line flush left already
ok 49 - .indent(*) ignores empty lines
ok 50 - Tab explosion on outdent
ok 51 - Test that tabs explode from the right
ok 52 - Check that varying amounts of space before a tabstop explode in a visually consistent way
ok 53 - Spaces before a hard tab should be coalesced into the tabstop when exploding
ok 54 - Test that space-tab-tab outdent works as intended
ok 55 - Check that mixed spaces and tabs outdent correctly
ok 56 - Multiline indent test with tab-space indent
ok 57 - Multiline indent test with mixed line beginnings
ok 58 - Multiline $?TABSTOP-width indent with an unindented line and a tab-indented line
ok 59 - .indent(0) should be a no-op
ok 60 - .indent ignores empty lines
ok 61 - .indent accepts weird scalar input and coerces it to Int when necessary
ok 62 - Indentation should not be appended after a trailing \n
    1..6
    not ok 1 - no warnings when blank lines have trailing whitespace # TODO https://github.com/rakudo/rakudo/issues/2409
    # Failed test 'no warnings when blank lines have trailing whitespace'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-str/indent.rakudo line 144
    ok 2 - -4
    ok 3 - -8
    ok 4 - 0
    ok 5 - 4
    ok 6 - 8
ok 63 - indent/dedent
# FUDGED!
1..190
ok 1 -  (type)
ok 2 -  (value)
ok 3 -   (type)
ok 4 -   (value)
ok 5 -     (type)
ok 6 -     (value)
ok 7 - 123 (type)
ok 8 - 123 (value)
ok 9 -  123 (type)
ok 10 -  123 (value)
ok 11 - 0000123 (type)
ok 12 - 0000123 (value)
ok 13 - 1_2_3 (type)
ok 14 - 1_2_3 (value)
ok 15 - +123 (type)
ok 16 - +123 (value)
ok 17 - -123 (type)
ok 18 - -123 (value)
ok 19 - 3433683820292512484657849089281 (type)
ok 20 - 3433683820292512484657849089281 (value)
ok 21 - +"a+123" fails
ok 22 - +"123foo" fails
ok 23 - +"123+" fails
ok 24 - +"1__2" fails
ok 25 - +"123_" fails
ok 26 - +"123 and stuff" fails
ok 27 - 0b111 (type)
ok 28 - 0b111 (value)
ok 29 - 0b1_1_1 (type)
ok 30 - 0b1_1_1 (value)
ok 31 - +0b111 (type)
ok 32 - +0b111 (value)
ok 33 - -0b111 (type)
ok 34 - -0b111 (value)
ok 35 - 0b_1 (type)
ok 36 - 0b_1 (value)
ok 37 - +"0b112" fails
ok 38 - +"0b" fails
ok 39 - 0o77 (type)
ok 40 - 0o77 (value)
ok 41 - +0o77 (type)
ok 42 - +0o77 (value)
ok 43 - -0o77 (type)
ok 44 - -0o77 (value)
ok 45 - +"0o8" fails
ok 46 - 0d123 (type)
ok 47 - 0d123 (value)
ok 48 - -0d123 (type)
ok 49 - -0d123 (value)
ok 50 - +"0da" fails
ok 51 - 0x123 (type)
ok 52 - 0x123 (value)
ok 53 - -0x123 (type)
ok 54 - -0x123 (value)
ok 55 - 0xa0 (type)
ok 56 - 0xa0 (value)
ok 57 - -0xA0 (type)
ok 58 - -0xA0 (value)
ok 59 - +"0xag" fails
ok 60 - +"0xaf-" fails
ok 61 - :10<42> (type)
ok 62 - :10<42> (value)
ok 63 - -:10<42> (type)
ok 64 - -:10<42> (value)
ok 65 - -:1_0<4_2> (type)
ok 66 - -:1_0<4_2> (value)
ok 67 - :36<aZ> (type)
ok 68 - :36<aZ> (value)
ok 69 - :2<11> (type)
ok 70 - :2<11> (value)
ok 71 - +":2<2>" fails
ok 72 - +":37<8>" fails
ok 73 - +":10<8_>" fails
ok 74 - +":10<_8>" fails
ok 75 - +":18<>" fails
ok 76 - +":10<8" fails
ok 77 - +"123." fails
ok 78 - 123.0 (type)
ok 79 - 123.0 (value)
ok 80 - -123.0 (type)
ok 81 - -123.0 (value)
ok 82 - +123.0 (type)
ok 83 - +123.0 (value)
ok 84 - +1_2_3.0_0 (type)
ok 85 - +1_2_3.0_0 (value)
ok 86 - 3/2 (type)
ok 87 - 3/2 (value)
ok 88 - +3/2 (type)
ok 89 - +3/2 (value)
ok 90 - -3/2 (type)
ok 91 - -3/2 (value)
not ok 92 - +"-3/-2" fails # TODO Unsure of what val() should accept
# Failed test '+"-3/-2" fails'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-str/numeric.rakudo line 82
not ok 93 - +"3/-2" fails # TODO Unsure of what val() should accept
# Failed test '+"3/-2" fails'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-str/numeric.rakudo line 83
not ok 94 - +"+3/-2" fails # TODO Unsure of what val() should accept
# Failed test '+"+3/-2" fails'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-str/numeric.rakudo line 84
not ok 95 - +"3.0/2" fails # TODO Unsure of what val() should accept
# Failed test '+"3.0/2" fails'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-str/numeric.rakudo line 85
not ok 96 - +"3/2.0" fails # TODO Unsure of what val() should accept
# Failed test '+"3/2.0" fails'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-str/numeric.rakudo line 86
ok 97 - -:10<4_2.3_5> (type)
ok 98 - -:10<4_2.3_5> (value)
ok 99 - -:8<4_2.3_5> (type)
ok 100 - -:8<4_2.3_5> (value)
ok 101 - +":2.4<01>" fails
ok 102 - +":10<12f>" fails
ok 103 - +":1b<10>" fails
ok 104 - +":10<>" fails
ok 105 - +":_2<01>" fails
ok 106 - +":2<_01>" fails
ok 107 - +":2<01_>" fails
ok 108 - +":_2_<_0_1_>_" fails
ok 109 - +":2<1.3>" fails
ok 110 - +"0b1.1e10" fails
ok 111 - +":2<10dlk" fails
ok 112 - +":2lks01>" fails
ok 113 - 123e0 (type)
ok 114 - 123e0 (value)
ok 115 - -123e0 (type)
ok 116 - -123e0 (value)
ok 117 - −123e0 (type)
ok 118 - −123e0 (value)
ok 119 - +123e0 (type)
ok 120 - +123e0 (value)
ok 121 - +123.0e0 (type)
ok 122 - +123.0e0 (value)
ok 123 - +123.0_1e2 (type)
ok 124 - +123.0_1e2 (value)
ok 125 - +123.0_1e0_2 (type)
ok 126 - +123.0_1e0_2 (value)
ok 127 - 123e-0 (type)
ok 128 - 123e-0 (value)
ok 129 - -123e+0 (type)
ok 130 - -123e+0 (value)
ok 131 - −123e+0 (type)
ok 132 - −123e+0 (value)
ok 133 - 123E0 (type)
ok 134 - 123E0 (value)
ok 135 - 1_2_3E0_0 (type)
ok 136 - 1_2_3E0_0 (value)
ok 137 - -123E0 (type)
ok 138 - -123E0 (value)
ok 139 - −123E0 (type)
ok 140 - −123E0 (value)
ok 141 - +123E0 (type)
ok 142 - +123E0 (value)
ok 143 - 123E-0 (type)
ok 144 - 123E-0 (value)
ok 145 - 123E−0 (type)
ok 146 - 123E−0 (value)
ok 147 - -123E+0 (type)
ok 148 - -123E+0 (value)
ok 149 - -123E+0_1 (type)
ok 150 - -123E+0_1 (value)
ok 151 - 1230E-1 (type)
ok 152 - 1230E-1 (value)
ok 153 - 1230E−1 (type)
ok 154 - 1230E−1 (value)
ok 155 - -12E+1 (type)
ok 156 - -12E+1 (value)
ok 157 - −12E+1 (type)
ok 158 - −12E+1 (value)
ok 159 - +"120e" fails
ok 160 - +"120e2_" fails
ok 161 - Inf
ok 162 - +Inf
ok 163 - -Inf
ok 164 - NaN
ok 165 - 1+2i (type)
ok 166 - 1+2i (value)
ok 167 - -1-2i (type)
ok 168 - -1-2i (value)
ok 169 - -1-2\i (type)
ok 170 - -1-2\i (value)
ok 171 - -1.0-2.0\i (type)
ok 172 - -1.0-2.0\i (value)
ok 173 - -1.0e0-2.0e0\i (type)
ok 174 - -1.0e0-2.0e0\i (value)
ok 175 - -1.0e0_0-2.0e0_0\i (type)
ok 176 - -1.0e0_0-2.0e0_0\i (value)
ok 177 - 3+Inf\i (type)
ok 178 - 3+Inf\i (value)
ok 179 - Inf+2e2i (type)
ok 180 - Inf+2e2i (value)
ok 181 - +"3+3i+4i" fails
ok 182 - +"3+3+4i" fails
ok 183 - +"3+Infi" fails
ok 184 - RT  \#100778
    1..2
    ok 1 - '"34\x[308]5".Int' died
    ok 2 - right exception type (X::Str::Numeric)
ok 185 - .Int on strings with numerics with combining characters throws
ok 186 - "a".Int lives...
ok 187 - "a".Int produces a failure
ok 188 - cannot do math with a Failure
    1..2
    ok 1 - code returned a Failure
        1..2
        ok 1 - code dies
        ok 2 - right exception type (X::Str::Numeric)
    ok 2 - Failure threw when sunk
ok 189 - "a".UInt produces a Failure
    1..4
    ok 1 - Int
    ok 2 - Rat
        1..3
        ok 1 - base
        ok 2 - exponent
        ok 3 - both base and exponent
    ok 3 - Num (minus in...)
        1..4
        ok 1 - # SKIP cannot handle lone i yet
        ok 2 - # SKIP cannot handle lone i yet
            1..3
            ok 1 - # SKIP cannot handle lone i yet
            ok 2 - # SKIP cannot handle lone i yet
            ok 3 - # SKIP cannot handle lone i yet
        ok 3 - numberless i (minus in ...)
            1..3
            ok 1 - real
            ok 2 - imaginary
            ok 3 - both real and imaginary
        ok 4 - i with number (minus in ...)
    ok 4 - Complex
ok 190 - can handle − (U+2212) minus as regular minus
# FUDGED!
1..65
    1..41
    ok 1 - split("","abcde")
    ok 2 - "abcde".split("")
    ok 3 - split("","abcde",:v)
    ok 4 - "abcde".split("",:v)
    ok 5 - split("","abcde",:k)
    ok 6 - "abcde".split("",:k)
    ok 7 - split("","abcde",:kv)
    ok 8 - "abcde".split("",:kv)
    ok 9 - split("","abcde",:p)
    ok 10 - "abcde".split("",:p)
    ok 11 - split("","abcde",:skip-empty)
    ok 12 - "abcde".split("",:skip-empty)
    ok 13 - split("","abcde",:v,:skip-empty)
    ok 14 - "abcde".split("",:v,:skip-empty)
    ok 15 - split("","abcde",:k,:skip-empty)
    ok 16 - "abcde".split("",:k,:skip-empty)
    ok 17 - split("","abcde",:kv,:skip-empty)
    ok 18 - "abcde".split("",:kv,:skip-empty)
    ok 19 - split("","abcde",:p,:skip-empty)
    ok 20 - "abcde".split("",:p,:skip-empty)
    ok 21 - split("","abcde",3)
    ok 22 - "abcde".split("",3)
    ok 23 - split("","abcde",3,:v)
    ok 24 - "abcde".split("",3,:v)
    ok 25 - split("","abcde",3,:k)
    ok 26 - "abcde".split("",3,:k)
    ok 27 - split("","abcde",3,:kv)
    ok 28 - "abcde".split("",3,:kv)
    ok 29 - split("","abcde",3,:p)
    ok 30 - "abcde".split("",3,:p)
    ok 31 - split("","abcde",3,:split-empty)
    ok 32 - "abcde".split("",3,:split-empty)
    ok 33 - split("","abcde",3,:v,:skip-empty)
    ok 34 - "abcde".split("",3,:v,:skip-empty)
    ok 35 - split("","abcde",3,:k,:skip-empty)
    ok 36 - "abcde".split("",3,:k,:skip-empty)
    ok 37 - split("","abcde",3,:kv,:skip-empty)
    ok 38 - "abcde".split("",3,:kv,:skip-empty)
    ok 39 - split("","abcde",3,:p,:skip-empty)
    ok 40 - "abcde".split("",3,:p,:skip-empty)
    ok 41 - string did not get changed
ok 1 - tested "abcde" with "empty string"
    1..41
    ok 1 - split(/./,"abcd")
    ok 2 - "abcd".split(/./)
    ok 3 - split(/./,"abcd",:v)
    ok 4 - "abcd".split(/./,:v)
    ok 5 - split(/./,"abcd",:k)
    ok 6 - "abcd".split(/./,:k)
    ok 7 - split(/./,"abcd",:kv)
    ok 8 - "abcd".split(/./,:kv)
    ok 9 - split(/./,"abcd",:p)
    ok 10 - "abcd".split(/./,:p)
    ok 11 - split(/./,"abcd",:skip-empty)
    ok 12 - "abcd".split(/./,:skip-empty)
    ok 13 - split(/./,"abcd",:v,:skip-empty)
    ok 14 - "abcd".split(/./,:v,:skip-empty)
    ok 15 - split(/./,"abcd",:k,:skip-empty)
    ok 16 - "abcd".split(/./,:k,:skip-empty)
    ok 17 - split(/./,"abcd",:kv,:skip-empty)
    ok 18 - "abcd".split(/./,:kv,:skip-empty)
    ok 19 - split(/./,"abcd",:p,:skip-empty)
    ok 20 - "abcd".split(/./,:p,:skip-empty)
    ok 21 - split(/./,"abcd",3)
    ok 22 - "abcd".split(/./,3)
    ok 23 - split(/./,"abcd",3,:v)
    ok 24 - "abcd".split(/./,3,:v)
    ok 25 - split(/./,"abcd",3,:k)
    ok 26 - "abcd".split(/./,3,:k)
    ok 27 - split(/./,"abcd",3,:kv)
    ok 28 - "abcd".split(/./,3,:kv)
    ok 29 - split(/./,"abcd",3,:p)
    ok 30 - "abcd".split(/./,3,:p)
    ok 31 - split(/./,"abcd",3,:split-empty)
    ok 32 - "abcd".split(/./,3,:split-empty)
    ok 33 - split(/./,"abcd",3,:v,:skip-empty)
    ok 34 - "abcd".split(/./,3,:v,:skip-empty)
    ok 35 - split(/./,"abcd",3,:k,:skip-empty)
    ok 36 - "abcd".split(/./,3,:k,:skip-empty)
    ok 37 - split(/./,"abcd",3,:kv,:skip-empty)
    ok 38 - "abcd".split(/./,3,:kv,:skip-empty)
    ok 39 - split(/./,"abcd",3,:p,:skip-empty)
    ok 40 - "abcd".split(/./,3,:p,:skip-empty)
    ok 41 - string did not get changed
ok 2 - tested "abcd" with "any character"
    1..41
    ok 1 - split("a","aaaa")
    ok 2 - "aaaa".split("a")
    ok 3 - split("a","aaaa",:v)
    ok 4 - "aaaa".split("a",:v)
    ok 5 - split("a","aaaa",:k)
    ok 6 - "aaaa".split("a",:k)
    ok 7 - split("a","aaaa",:kv)
    ok 8 - "aaaa".split("a",:kv)
    ok 9 - split("a","aaaa",:p)
    ok 10 - "aaaa".split("a",:p)
    ok 11 - split("a","aaaa",:skip-empty)
    ok 12 - "aaaa".split("a",:skip-empty)
    ok 13 - split("a","aaaa",:v,:skip-empty)
    ok 14 - "aaaa".split("a",:v,:skip-empty)
    ok 15 - split("a","aaaa",:k,:skip-empty)
    ok 16 - "aaaa".split("a",:k,:skip-empty)
    ok 17 - split("a","aaaa",:kv,:skip-empty)
    ok 18 - "aaaa".split("a",:kv,:skip-empty)
    ok 19 - split("a","aaaa",:p,:skip-empty)
    ok 20 - "aaaa".split("a",:p,:skip-empty)
    ok 21 - split("a","aaaa",3)
    ok 22 - "aaaa".split("a",3)
    ok 23 - split("a","aaaa",3,:v)
    ok 24 - "aaaa".split("a",3,:v)
    ok 25 - split("a","aaaa",3,:k)
    ok 26 - "aaaa".split("a",3,:k)
    ok 27 - split("a","aaaa",3,:kv)
    ok 28 - "aaaa".split("a",3,:kv)
    ok 29 - split("a","aaaa",3,:p)
    ok 30 - "aaaa".split("a",3,:p)
    ok 31 - split("a","aaaa",3,:split-empty)
    ok 32 - "aaaa".split("a",3,:split-empty)
    ok 33 - split("a","aaaa",3,:v,:skip-empty)
    ok 34 - "aaaa".split("a",3,:v,:skip-empty)
    ok 35 - split("a","aaaa",3,:k,:skip-empty)
    ok 36 - "aaaa".split("a",3,:k,:skip-empty)
    ok 37 - split("a","aaaa",3,:kv,:skip-empty)
    ok 38 - "aaaa".split("a",3,:kv,:skip-empty)
    ok 39 - split("a","aaaa",3,:p,:skip-empty)
    ok 40 - "aaaa".split("a",3,:p,:skip-empty)
    ok 41 - string did not get changed
ok 3 - tested "aaaa" with "only chars matching \"a\""
    1..41
    ok 1 - split(/a/,"aaaa")
    ok 2 - "aaaa".split(/a/)
    ok 3 - split(/a/,"aaaa",:v)
    ok 4 - "aaaa".split(/a/,:v)
    ok 5 - split(/a/,"aaaa",:k)
    ok 6 - "aaaa".split(/a/,:k)
    ok 7 - split(/a/,"aaaa",:kv)
    ok 8 - "aaaa".split(/a/,:kv)
    ok 9 - split(/a/,"aaaa",:p)
    ok 10 - "aaaa".split(/a/,:p)
    ok 11 - split(/a/,"aaaa",:skip-empty)
    ok 12 - "aaaa".split(/a/,:skip-empty)
    ok 13 - split(/a/,"aaaa",:v,:skip-empty)
    ok 14 - "aaaa".split(/a/,:v,:skip-empty)
    ok 15 - split(/a/,"aaaa",:k,:skip-empty)
    ok 16 - "aaaa".split(/a/,:k,:skip-empty)
    ok 17 - split(/a/,"aaaa",:kv,:skip-empty)
    ok 18 - "aaaa".split(/a/,:kv,:skip-empty)
    ok 19 - split(/a/,"aaaa",:p,:skip-empty)
    ok 20 - "aaaa".split(/a/,:p,:skip-empty)
    ok 21 - split(/a/,"aaaa",3)
    ok 22 - "aaaa".split(/a/,3)
    ok 23 - split(/a/,"aaaa",3,:v)
    ok 24 - "aaaa".split(/a/,3,:v)
    ok 25 - split(/a/,"aaaa",3,:k)
    ok 26 - "aaaa".split(/a/,3,:k)
    ok 27 - split(/a/,"aaaa",3,:kv)
    ok 28 - "aaaa".split(/a/,3,:kv)
    ok 29 - split(/a/,"aaaa",3,:p)
    ok 30 - "aaaa".split(/a/,3,:p)
    ok 31 - split(/a/,"aaaa",3,:split-empty)
    ok 32 - "aaaa".split(/a/,3,:split-empty)
    ok 33 - split(/a/,"aaaa",3,:v,:skip-empty)
    ok 34 - "aaaa".split(/a/,3,:v,:skip-empty)
    ok 35 - split(/a/,"aaaa",3,:k,:skip-empty)
    ok 36 - "aaaa".split(/a/,3,:k,:skip-empty)
    ok 37 - split(/a/,"aaaa",3,:kv,:skip-empty)
    ok 38 - "aaaa".split(/a/,3,:kv,:skip-empty)
    ok 39 - split(/a/,"aaaa",3,:p,:skip-empty)
    ok 40 - "aaaa".split(/a/,3,:p,:skip-empty)
    ok 41 - string did not get changed
ok 4 - tested "aaaa" with "only chars matching /a/"
    1..41
    ok 1 - split(rx:Perl5/a/,"aaaa")
    ok 2 - "aaaa".split(rx:Perl5/a/)
    ok 3 - split(rx:Perl5/a/,"aaaa",:v)
    ok 4 - "aaaa".split(rx:Perl5/a/,:v)
    ok 5 - split(rx:Perl5/a/,"aaaa",:k)
    ok 6 - "aaaa".split(rx:Perl5/a/,:k)
    ok 7 - split(rx:Perl5/a/,"aaaa",:kv)
    ok 8 - "aaaa".split(rx:Perl5/a/,:kv)
    ok 9 - split(rx:Perl5/a/,"aaaa",:p)
    ok 10 - "aaaa".split(rx:Perl5/a/,:p)
    ok 11 - split(rx:Perl5/a/,"aaaa",:skip-empty)
    ok 12 - "aaaa".split(rx:Perl5/a/,:skip-empty)
    ok 13 - split(rx:Perl5/a/,"aaaa",:v,:skip-empty)
    ok 14 - "aaaa".split(rx:Perl5/a/,:v,:skip-empty)
    ok 15 - split(rx:Perl5/a/,"aaaa",:k,:skip-empty)
    ok 16 - "aaaa".split(rx:Perl5/a/,:k,:skip-empty)
    ok 17 - split(rx:Perl5/a/,"aaaa",:kv,:skip-empty)
    ok 18 - "aaaa".split(rx:Perl5/a/,:kv,:skip-empty)
    ok 19 - split(rx:Perl5/a/,"aaaa",:p,:skip-empty)
    ok 20 - "aaaa".split(rx:Perl5/a/,:p,:skip-empty)
    ok 21 - split(rx:Perl5/a/,"aaaa",3)
    ok 22 - "aaaa".split(rx:Perl5/a/,3)
    ok 23 - split(rx:Perl5/a/,"aaaa",3,:v)
    ok 24 - "aaaa".split(rx:Perl5/a/,3,:v)
    ok 25 - split(rx:Perl5/a/,"aaaa",3,:k)
    ok 26 - "aaaa".split(rx:Perl5/a/,3,:k)
    ok 27 - split(rx:Perl5/a/,"aaaa",3,:kv)
    ok 28 - "aaaa".split(rx:Perl5/a/,3,:kv)
    ok 29 - split(rx:Perl5/a/,"aaaa",3,:p)
    ok 30 - "aaaa".split(rx:Perl5/a/,3,:p)
    ok 31 - split(rx:Perl5/a/,"aaaa",3,:split-empty)
    ok 32 - "aaaa".split(rx:Perl5/a/,3,:split-empty)
    ok 33 - split(rx:Perl5/a/,"aaaa",3,:v,:skip-empty)
    ok 34 - "aaaa".split(rx:Perl5/a/,3,:v,:skip-empty)
    ok 35 - split(rx:Perl5/a/,"aaaa",3,:k,:skip-empty)
    ok 36 - "aaaa".split(rx:Perl5/a/,3,:k,:skip-empty)
    ok 37 - split(rx:Perl5/a/,"aaaa",3,:kv,:skip-empty)
    ok 38 - "aaaa".split(rx:Perl5/a/,3,:kv,:skip-empty)
    ok 39 - split(rx:Perl5/a/,"aaaa",3,:p,:skip-empty)
    ok 40 - "aaaa".split(rx:Perl5/a/,3,:p,:skip-empty)
    ok 41 - string did not get changed
ok 5 - tested "aaaa" with "only chars matching rx:Perl5/a/"
    1..41
    ok 1 - split(" ","foo bar baz")
    ok 2 - "foo bar baz".split(" ")
    ok 3 - split(" ","foo bar baz",:v)
    ok 4 - "foo bar baz".split(" ",:v)
    ok 5 - split(" ","foo bar baz",:k)
    ok 6 - "foo bar baz".split(" ",:k)
    ok 7 - split(" ","foo bar baz",:kv)
    ok 8 - "foo bar baz".split(" ",:kv)
    ok 9 - split(" ","foo bar baz",:p)
    ok 10 - "foo bar baz".split(" ",:p)
    ok 11 - split(" ","foo bar baz",:skip-empty)
    ok 12 - "foo bar baz".split(" ",:skip-empty)
    ok 13 - split(" ","foo bar baz",:v,:skip-empty)
    ok 14 - "foo bar baz".split(" ",:v,:skip-empty)
    ok 15 - split(" ","foo bar baz",:k,:skip-empty)
    ok 16 - "foo bar baz".split(" ",:k,:skip-empty)
    ok 17 - split(" ","foo bar baz",:kv,:skip-empty)
    ok 18 - "foo bar baz".split(" ",:kv,:skip-empty)
    ok 19 - split(" ","foo bar baz",:p,:skip-empty)
    ok 20 - "foo bar baz".split(" ",:p,:skip-empty)
    ok 21 - split(" ","foo bar baz",2)
    ok 22 - "foo bar baz".split(" ",2)
    ok 23 - split(" ","foo bar baz",2,:v)
    ok 24 - "foo bar baz".split(" ",2,:v)
    ok 25 - split(" ","foo bar baz",2,:k)
    ok 26 - "foo bar baz".split(" ",2,:k)
    ok 27 - split(" ","foo bar baz",2,:kv)
    ok 28 - "foo bar baz".split(" ",2,:kv)
    ok 29 - split(" ","foo bar baz",2,:p)
    ok 30 - "foo bar baz".split(" ",2,:p)
    ok 31 - split(" ","foo bar baz",2,:split-empty)
    ok 32 - "foo bar baz".split(" ",2,:split-empty)
    ok 33 - split(" ","foo bar baz",2,:v,:skip-empty)
    ok 34 - "foo bar baz".split(" ",2,:v,:skip-empty)
    ok 35 - split(" ","foo bar baz",2,:k,:skip-empty)
    ok 36 - "foo bar baz".split(" ",2,:k,:skip-empty)
    ok 37 - split(" ","foo bar baz",2,:kv,:skip-empty)
    ok 38 - "foo bar baz".split(" ",2,:kv,:skip-empty)
    ok 39 - split(" ","foo bar baz",2,:p,:skip-empty)
    ok 40 - "foo bar baz".split(" ",2,:p,:skip-empty)
    ok 41 - string did not get changed
ok 6 - tested "foo bar baz" with " "
    1..41
    ok 1 - split(/ " " /,"foo bar baz")
    ok 2 - "foo bar baz".split(/ " " /)
    ok 3 - split(/ " " /,"foo bar baz",:v)
    ok 4 - "foo bar baz".split(/ " " /,:v)
    ok 5 - split(/ " " /,"foo bar baz",:k)
    ok 6 - "foo bar baz".split(/ " " /,:k)
    ok 7 - split(/ " " /,"foo bar baz",:kv)
    ok 8 - "foo bar baz".split(/ " " /,:kv)
    ok 9 - split(/ " " /,"foo bar baz",:p)
    ok 10 - "foo bar baz".split(/ " " /,:p)
    ok 11 - split(/ " " /,"foo bar baz",:skip-empty)
    ok 12 - "foo bar baz".split(/ " " /,:skip-empty)
    ok 13 - split(/ " " /,"foo bar baz",:v,:skip-empty)
    ok 14 - "foo bar baz".split(/ " " /,:v,:skip-empty)
    ok 15 - split(/ " " /,"foo bar baz",:k,:skip-empty)
    ok 16 - "foo bar baz".split(/ " " /,:k,:skip-empty)
    ok 17 - split(/ " " /,"foo bar baz",:kv,:skip-empty)
    ok 18 - "foo bar baz".split(/ " " /,:kv,:skip-empty)
    ok 19 - split(/ " " /,"foo bar baz",:p,:skip-empty)
    ok 20 - "foo bar baz".split(/ " " /,:p,:skip-empty)
    ok 21 - split(/ " " /,"foo bar baz",2)
    ok 22 - "foo bar baz".split(/ " " /,2)
    ok 23 - split(/ " " /,"foo bar baz",2,:v)
    ok 24 - "foo bar baz".split(/ " " /,2,:v)
    ok 25 - split(/ " " /,"foo bar baz",2,:k)
    ok 26 - "foo bar baz".split(/ " " /,2,:k)
    ok 27 - split(/ " " /,"foo bar baz",2,:kv)
    ok 28 - "foo bar baz".split(/ " " /,2,:kv)
    ok 29 - split(/ " " /,"foo bar baz",2,:p)
    ok 30 - "foo bar baz".split(/ " " /,2,:p)
    ok 31 - split(/ " " /,"foo bar baz",2,:split-empty)
    ok 32 - "foo bar baz".split(/ " " /,2,:split-empty)
    ok 33 - split(/ " " /,"foo bar baz",2,:v,:skip-empty)
    ok 34 - "foo bar baz".split(/ " " /,2,:v,:skip-empty)
    ok 35 - split(/ " " /,"foo bar baz",2,:k,:skip-empty)
    ok 36 - "foo bar baz".split(/ " " /,2,:k,:skip-empty)
    ok 37 - split(/ " " /,"foo bar baz",2,:kv,:skip-empty)
    ok 38 - "foo bar baz".split(/ " " /,2,:kv,:skip-empty)
    ok 39 - split(/ " " /,"foo bar baz",2,:p,:skip-empty)
    ok 40 - "foo bar baz".split(/ " " /,2,:p,:skip-empty)
    ok 41 - string did not get changed
ok 7 - tested "foo bar baz" with / " " /
    1..41
    ok 1 - split(/ \s /,"foo bar baz")
    ok 2 - "foo bar baz".split(/ \s /)
    ok 3 - split(/ \s /,"foo bar baz",:v)
    ok 4 - "foo bar baz".split(/ \s /,:v)
    ok 5 - split(/ \s /,"foo bar baz",:k)
    ok 6 - "foo bar baz".split(/ \s /,:k)
    ok 7 - split(/ \s /,"foo bar baz",:kv)
    ok 8 - "foo bar baz".split(/ \s /,:kv)
    ok 9 - split(/ \s /,"foo bar baz",:p)
    ok 10 - "foo bar baz".split(/ \s /,:p)
    ok 11 - split(/ \s /,"foo bar baz",:skip-empty)
    ok 12 - "foo bar baz".split(/ \s /,:skip-empty)
    ok 13 - split(/ \s /,"foo bar baz",:v,:skip-empty)
    ok 14 - "foo bar baz".split(/ \s /,:v,:skip-empty)
    ok 15 - split(/ \s /,"foo bar baz",:k,:skip-empty)
    ok 16 - "foo bar baz".split(/ \s /,:k,:skip-empty)
    ok 17 - split(/ \s /,"foo bar baz",:kv,:skip-empty)
    ok 18 - "foo bar baz".split(/ \s /,:kv,:skip-empty)
    ok 19 - split(/ \s /,"foo bar baz",:p,:skip-empty)
    ok 20 - "foo bar baz".split(/ \s /,:p,:skip-empty)
    ok 21 - split(/ \s /,"foo bar baz",2)
    ok 22 - "foo bar baz".split(/ \s /,2)
    ok 23 - split(/ \s /,"foo bar baz",2,:v)
    ok 24 - "foo bar baz".split(/ \s /,2,:v)
    ok 25 - split(/ \s /,"foo bar baz",2,:k)
    ok 26 - "foo bar baz".split(/ \s /,2,:k)
    ok 27 - split(/ \s /,"foo bar baz",2,:kv)
    ok 28 - "foo bar baz".split(/ \s /,2,:kv)
    ok 29 - split(/ \s /,"foo bar baz",2,:p)
    ok 30 - "foo bar baz".split(/ \s /,2,:p)
    ok 31 - split(/ \s /,"foo bar baz",2,:split-empty)
    ok 32 - "foo bar baz".split(/ \s /,2,:split-empty)
    ok 33 - split(/ \s /,"foo bar baz",2,:v,:skip-empty)
    ok 34 - "foo bar baz".split(/ \s /,2,:v,:skip-empty)
    ok 35 - split(/ \s /,"foo bar baz",2,:k,:skip-empty)
    ok 36 - "foo bar baz".split(/ \s /,2,:k,:skip-empty)
    ok 37 - split(/ \s /,"foo bar baz",2,:kv,:skip-empty)
    ok 38 - "foo bar baz".split(/ \s /,2,:kv,:skip-empty)
    ok 39 - split(/ \s /,"foo bar baz",2,:p,:skip-empty)
    ok 40 - "foo bar baz".split(/ \s /,2,:p,:skip-empty)
    ok 41 - string did not get changed
ok 8 - tested "foo bar baz" with / \s /
    1..41
    ok 1 - split(/ \s+ /,"foo bar baz")
    ok 2 - "foo bar baz".split(/ \s+ /)
    ok 3 - split(/ \s+ /,"foo bar baz",:v)
    ok 4 - "foo bar baz".split(/ \s+ /,:v)
    ok 5 - split(/ \s+ /,"foo bar baz",:k)
    ok 6 - "foo bar baz".split(/ \s+ /,:k)
    ok 7 - split(/ \s+ /,"foo bar baz",:kv)
    ok 8 - "foo bar baz".split(/ \s+ /,:kv)
    ok 9 - split(/ \s+ /,"foo bar baz",:p)
    ok 10 - "foo bar baz".split(/ \s+ /,:p)
    ok 11 - split(/ \s+ /,"foo bar baz",:skip-empty)
    ok 12 - "foo bar baz".split(/ \s+ /,:skip-empty)
    ok 13 - split(/ \s+ /,"foo bar baz",:v,:skip-empty)
    ok 14 - "foo bar baz".split(/ \s+ /,:v,:skip-empty)
    ok 15 - split(/ \s+ /,"foo bar baz",:k,:skip-empty)
    ok 16 - "foo bar baz".split(/ \s+ /,:k,:skip-empty)
    ok 17 - split(/ \s+ /,"foo bar baz",:kv,:skip-empty)
    ok 18 - "foo bar baz".split(/ \s+ /,:kv,:skip-empty)
    ok 19 - split(/ \s+ /,"foo bar baz",:p,:skip-empty)
    ok 20 - "foo bar baz".split(/ \s+ /,:p,:skip-empty)
    ok 21 - split(/ \s+ /,"foo bar baz",2)
    ok 22 - "foo bar baz".split(/ \s+ /,2)
    ok 23 - split(/ \s+ /,"foo bar baz",2,:v)
    ok 24 - "foo bar baz".split(/ \s+ /,2,:v)
    ok 25 - split(/ \s+ /,"foo bar baz",2,:k)
    ok 26 - "foo bar baz".split(/ \s+ /,2,:k)
    ok 27 - split(/ \s+ /,"foo bar baz",2,:kv)
    ok 28 - "foo bar baz".split(/ \s+ /,2,:kv)
    ok 29 - split(/ \s+ /,"foo bar baz",2,:p)
    ok 30 - "foo bar baz".split(/ \s+ /,2,:p)
    ok 31 - split(/ \s+ /,"foo bar baz",2,:split-empty)
    ok 32 - "foo bar baz".split(/ \s+ /,2,:split-empty)
    ok 33 - split(/ \s+ /,"foo bar baz",2,:v,:skip-empty)
    ok 34 - "foo bar baz".split(/ \s+ /,2,:v,:skip-empty)
    ok 35 - split(/ \s+ /,"foo bar baz",2,:k,:skip-empty)
    ok 36 - "foo bar baz".split(/ \s+ /,2,:k,:skip-empty)
    ok 37 - split(/ \s+ /,"foo bar baz",2,:kv,:skip-empty)
    ok 38 - "foo bar baz".split(/ \s+ /,2,:kv,:skip-empty)
    ok 39 - split(/ \s+ /,"foo bar baz",2,:p,:skip-empty)
    ok 40 - "foo bar baz".split(/ \s+ /,2,:p,:skip-empty)
    ok 41 - string did not get changed
ok 9 - tested "foo bar baz" with / \s+ /
    1..41
    ok 1 - split(rx:Perl5/ /,"foo bar baz")
    ok 2 - "foo bar baz".split(rx:Perl5/ /)
    ok 3 - split(rx:Perl5/ /,"foo bar baz",:v)
    ok 4 - "foo bar baz".split(rx:Perl5/ /,:v)
    ok 5 - split(rx:Perl5/ /,"foo bar baz",:k)
    ok 6 - "foo bar baz".split(rx:Perl5/ /,:k)
    ok 7 - split(rx:Perl5/ /,"foo bar baz",:kv)
    ok 8 - "foo bar baz".split(rx:Perl5/ /,:kv)
    ok 9 - split(rx:Perl5/ /,"foo bar baz",:p)
    ok 10 - "foo bar baz".split(rx:Perl5/ /,:p)
    ok 11 - split(rx:Perl5/ /,"foo bar baz",:skip-empty)
    ok 12 - "foo bar baz".split(rx:Perl5/ /,:skip-empty)
    ok 13 - split(rx:Perl5/ /,"foo bar baz",:v,:skip-empty)
    ok 14 - "foo bar baz".split(rx:Perl5/ /,:v,:skip-empty)
    ok 15 - split(rx:Perl5/ /,"foo bar baz",:k,:skip-empty)
    ok 16 - "foo bar baz".split(rx:Perl5/ /,:k,:skip-empty)
    ok 17 - split(rx:Perl5/ /,"foo bar baz",:kv,:skip-empty)
    ok 18 - "foo bar baz".split(rx:Perl5/ /,:kv,:skip-empty)
    ok 19 - split(rx:Perl5/ /,"foo bar baz",:p,:skip-empty)
    ok 20 - "foo bar baz".split(rx:Perl5/ /,:p,:skip-empty)
    ok 21 - split(rx:Perl5/ /,"foo bar baz",2)
    ok 22 - "foo bar baz".split(rx:Perl5/ /,2)
    ok 23 - split(rx:Perl5/ /,"foo bar baz",2,:v)
    ok 24 - "foo bar baz".split(rx:Perl5/ /,2,:v)
    ok 25 - split(rx:Perl5/ /,"foo bar baz",2,:k)
    ok 26 - "foo bar baz".split(rx:Perl5/ /,2,:k)
    ok 27 - split(rx:Perl5/ /,"foo bar baz",2,:kv)
    ok 28 - "foo bar baz".split(rx:Perl5/ /,2,:kv)
    ok 29 - split(rx:Perl5/ /,"foo bar baz",2,:p)
    ok 30 - "foo bar baz".split(rx:Perl5/ /,2,:p)
    ok 31 - split(rx:Perl5/ /,"foo bar baz",2,:split-empty)
    ok 32 - "foo bar baz".split(rx:Perl5/ /,2,:split-empty)
    ok 33 - split(rx:Perl5/ /,"foo bar baz",2,:v,:skip-empty)
    ok 34 - "foo bar baz".split(rx:Perl5/ /,2,:v,:skip-empty)
    ok 35 - split(rx:Perl5/ /,"foo bar baz",2,:k,:skip-empty)
    ok 36 - "foo bar baz".split(rx:Perl5/ /,2,:k,:skip-empty)
    ok 37 - split(rx:Perl5/ /,"foo bar baz",2,:kv,:skip-empty)
    ok 38 - "foo bar baz".split(rx:Perl5/ /,2,:kv,:skip-empty)
    ok 39 - split(rx:Perl5/ /,"foo bar baz",2,:p,:skip-empty)
    ok 40 - "foo bar baz".split(rx:Perl5/ /,2,:p,:skip-empty)
    ok 41 - string did not get changed
ok 10 - tested "foo bar baz" with rx:Perl5/ /
    1..41
    ok 1 - split(rx:Perl5/\s/,"foo bar baz")
    ok 2 - "foo bar baz".split(rx:Perl5/\s/)
    ok 3 - split(rx:Perl5/\s/,"foo bar baz",:v)
    ok 4 - "foo bar baz".split(rx:Perl5/\s/,:v)
    ok 5 - split(rx:Perl5/\s/,"foo bar baz",:k)
    ok 6 - "foo bar baz".split(rx:Perl5/\s/,:k)
    ok 7 - split(rx:Perl5/\s/,"foo bar baz",:kv)
    ok 8 - "foo bar baz".split(rx:Perl5/\s/,:kv)
    ok 9 - split(rx:Perl5/\s/,"foo bar baz",:p)
    ok 10 - "foo bar baz".split(rx:Perl5/\s/,:p)
    ok 11 - split(rx:Perl5/\s/,"foo bar baz",:skip-empty)
    ok 12 - "foo bar baz".split(rx:Perl5/\s/,:skip-empty)
    ok 13 - split(rx:Perl5/\s/,"foo bar baz",:v,:skip-empty)
    ok 14 - "foo bar baz".split(rx:Perl5/\s/,:v,:skip-empty)
    ok 15 - split(rx:Perl5/\s/,"foo bar baz",:k,:skip-empty)
    ok 16 - "foo bar baz".split(rx:Perl5/\s/,:k,:skip-empty)
    ok 17 - split(rx:Perl5/\s/,"foo bar baz",:kv,:skip-empty)
    ok 18 - "foo bar baz".split(rx:Perl5/\s/,:kv,:skip-empty)
    ok 19 - split(rx:Perl5/\s/,"foo bar baz",:p,:skip-empty)
    ok 20 - "foo bar baz".split(rx:Perl5/\s/,:p,:skip-empty)
    ok 21 - split(rx:Perl5/\s/,"foo bar baz",2)
    ok 22 - "foo bar baz".split(rx:Perl5/\s/,2)
    ok 23 - split(rx:Perl5/\s/,"foo bar baz",2,:v)
    ok 24 - "foo bar baz".split(rx:Perl5/\s/,2,:v)
    ok 25 - split(rx:Perl5/\s/,"foo bar baz",2,:k)
    ok 26 - "foo bar baz".split(rx:Perl5/\s/,2,:k)
    ok 27 - split(rx:Perl5/\s/,"foo bar baz",2,:kv)
    ok 28 - "foo bar baz".split(rx:Perl5/\s/,2,:kv)
    ok 29 - split(rx:Perl5/\s/,"foo bar baz",2,:p)
    ok 30 - "foo bar baz".split(rx:Perl5/\s/,2,:p)
    ok 31 - split(rx:Perl5/\s/,"foo bar baz",2,:split-empty)
    ok 32 - "foo bar baz".split(rx:Perl5/\s/,2,:split-empty)
    ok 33 - split(rx:Perl5/\s/,"foo bar baz",2,:v,:skip-empty)
    ok 34 - "foo bar baz".split(rx:Perl5/\s/,2,:v,:skip-empty)
    ok 35 - split(rx:Perl5/\s/,"foo bar baz",2,:k,:skip-empty)
    ok 36 - "foo bar baz".split(rx:Perl5/\s/,2,:k,:skip-empty)
    ok 37 - split(rx:Perl5/\s/,"foo bar baz",2,:kv,:skip-empty)
    ok 38 - "foo bar baz".split(rx:Perl5/\s/,2,:kv,:skip-empty)
    ok 39 - split(rx:Perl5/\s/,"foo bar baz",2,:p,:skip-empty)
    ok 40 - "foo bar baz".split(rx:Perl5/\s/,2,:p,:skip-empty)
    ok 41 - string did not get changed
ok 11 - tested "foo bar baz" with rx:Perl5/\s/
    1..41
    ok 1 - split(rx:Perl5/\s+/,"foo bar baz")
    ok 2 - "foo bar baz".split(rx:Perl5/\s+/)
    ok 3 - split(rx:Perl5/\s+/,"foo bar baz",:v)
    ok 4 - "foo bar baz".split(rx:Perl5/\s+/,:v)
    ok 5 - split(rx:Perl5/\s+/,"foo bar baz",:k)
    ok 6 - "foo bar baz".split(rx:Perl5/\s+/,:k)
    ok 7 - split(rx:Perl5/\s+/,"foo bar baz",:kv)
    ok 8 - "foo bar baz".split(rx:Perl5/\s+/,:kv)
    ok 9 - split(rx:Perl5/\s+/,"foo bar baz",:p)
    ok 10 - "foo bar baz".split(rx:Perl5/\s+/,:p)
    ok 11 - split(rx:Perl5/\s+/,"foo bar baz",:skip-empty)
    ok 12 - "foo bar baz".split(rx:Perl5/\s+/,:skip-empty)
    ok 13 - split(rx:Perl5/\s+/,"foo bar baz",:v,:skip-empty)
    ok 14 - "foo bar baz".split(rx:Perl5/\s+/,:v,:skip-empty)
    ok 15 - split(rx:Perl5/\s+/,"foo bar baz",:k,:skip-empty)
    ok 16 - "foo bar baz".split(rx:Perl5/\s+/,:k,:skip-empty)
    ok 17 - split(rx:Perl5/\s+/,"foo bar baz",:kv,:skip-empty)
    ok 18 - "foo bar baz".split(rx:Perl5/\s+/,:kv,:skip-empty)
    ok 19 - split(rx:Perl5/\s+/,"foo bar baz",:p,:skip-empty)
    ok 20 - "foo bar baz".split(rx:Perl5/\s+/,:p,:skip-empty)
    ok 21 - split(rx:Perl5/\s+/,"foo bar baz",2)
    ok 22 - "foo bar baz".split(rx:Perl5/\s+/,2)
    ok 23 - split(rx:Perl5/\s+/,"foo bar baz",2,:v)
    ok 24 - "foo bar baz".split(rx:Perl5/\s+/,2,:v)
    ok 25 - split(rx:Perl5/\s+/,"foo bar baz",2,:k)
    ok 26 - "foo bar baz".split(rx:Perl5/\s+/,2,:k)
    ok 27 - split(rx:Perl5/\s+/,"foo bar baz",2,:kv)
    ok 28 - "foo bar baz".split(rx:Perl5/\s+/,2,:kv)
    ok 29 - split(rx:Perl5/\s+/,"foo bar baz",2,:p)
    ok 30 - "foo bar baz".split(rx:Perl5/\s+/,2,:p)
    ok 31 - split(rx:Perl5/\s+/,"foo bar baz",2,:split-empty)
    ok 32 - "foo bar baz".split(rx:Perl5/\s+/,2,:split-empty)
    ok 33 - split(rx:Perl5/\s+/,"foo bar baz",2,:v,:skip-empty)
    ok 34 - "foo bar baz".split(rx:Perl5/\s+/,2,:v,:skip-empty)
    ok 35 - split(rx:Perl5/\s+/,"foo bar baz",2,:k,:skip-empty)
    ok 36 - "foo bar baz".split(rx:Perl5/\s+/,2,:k,:skip-empty)
    ok 37 - split(rx:Perl5/\s+/,"foo bar baz",2,:kv,:skip-empty)
    ok 38 - "foo bar baz".split(rx:Perl5/\s+/,2,:kv,:skip-empty)
    ok 39 - split(rx:Perl5/\s+/,"foo bar baz",2,:p,:skip-empty)
    ok 40 - "foo bar baz".split(rx:Perl5/\s+/,2,:p,:skip-empty)
    ok 41 - string did not get changed
ok 12 - tested "foo bar baz" with rx:Perl5/\s+/
    1..41
    ok 1 - split("s","thisisit")
    ok 2 - "thisisit".split("s")
    ok 3 - split("s","thisisit",:v)
    ok 4 - "thisisit".split("s",:v)
    ok 5 - split("s","thisisit",:k)
    ok 6 - "thisisit".split("s",:k)
    ok 7 - split("s","thisisit",:kv)
    ok 8 - "thisisit".split("s",:kv)
    ok 9 - split("s","thisisit",:p)
    ok 10 - "thisisit".split("s",:p)
    ok 11 - split("s","thisisit",:skip-empty)
    ok 12 - "thisisit".split("s",:skip-empty)
    ok 13 - split("s","thisisit",:v,:skip-empty)
    ok 14 - "thisisit".split("s",:v,:skip-empty)
    ok 15 - split("s","thisisit",:k,:skip-empty)
    ok 16 - "thisisit".split("s",:k,:skip-empty)
    ok 17 - split("s","thisisit",:kv,:skip-empty)
    ok 18 - "thisisit".split("s",:kv,:skip-empty)
    ok 19 - split("s","thisisit",:p,:skip-empty)
    ok 20 - "thisisit".split("s",:p,:skip-empty)
    ok 21 - split("s","thisisit",2)
    ok 22 - "thisisit".split("s",2)
    ok 23 - split("s","thisisit",2,:v)
    ok 24 - "thisisit".split("s",2,:v)
    ok 25 - split("s","thisisit",2,:k)
    ok 26 - "thisisit".split("s",2,:k)
    ok 27 - split("s","thisisit",2,:kv)
    ok 28 - "thisisit".split("s",2,:kv)
    ok 29 - split("s","thisisit",2,:p)
    ok 30 - "thisisit".split("s",2,:p)
    ok 31 - split("s","thisisit",2,:split-empty)
    ok 32 - "thisisit".split("s",2,:split-empty)
    ok 33 - split("s","thisisit",2,:v,:skip-empty)
    ok 34 - "thisisit".split("s",2,:v,:skip-empty)
    ok 35 - split("s","thisisit",2,:k,:skip-empty)
    ok 36 - "thisisit".split("s",2,:k,:skip-empty)
    ok 37 - split("s","thisisit",2,:kv,:skip-empty)
    ok 38 - "thisisit".split("s",2,:kv,:skip-empty)
    ok 39 - split("s","thisisit",2,:p,:skip-empty)
    ok 40 - "thisisit".split("s",2,:p,:skip-empty)
    ok 41 - string did not get changed
ok 13 - tested "thisisit" with "s"
    1..41
    ok 1 - split(/s/,"thisisit")
    ok 2 - "thisisit".split(/s/)
    ok 3 - split(/s/,"thisisit",:v)
    ok 4 - "thisisit".split(/s/,:v)
    ok 5 - split(/s/,"thisisit",:k)
    ok 6 - "thisisit".split(/s/,:k)
    ok 7 - split(/s/,"thisisit",:kv)
    ok 8 - "thisisit".split(/s/,:kv)
    ok 9 - split(/s/,"thisisit",:p)
    ok 10 - "thisisit".split(/s/,:p)
    ok 11 - split(/s/,"thisisit",:skip-empty)
    ok 12 - "thisisit".split(/s/,:skip-empty)
    ok 13 - split(/s/,"thisisit",:v,:skip-empty)
    ok 14 - "thisisit".split(/s/,:v,:skip-empty)
    ok 15 - split(/s/,"thisisit",:k,:skip-empty)
    ok 16 - "thisisit".split(/s/,:k,:skip-empty)
    ok 17 - split(/s/,"thisisit",:kv,:skip-empty)
    ok 18 - "thisisit".split(/s/,:kv,:skip-empty)
    ok 19 - split(/s/,"thisisit",:p,:skip-empty)
    ok 20 - "thisisit".split(/s/,:p,:skip-empty)
    ok 21 - split(/s/,"thisisit",2)
    ok 22 - "thisisit".split(/s/,2)
    ok 23 - split(/s/,"thisisit",2,:v)
    ok 24 - "thisisit".split(/s/,2,:v)
    ok 25 - split(/s/,"thisisit",2,:k)
    ok 26 - "thisisit".split(/s/,2,:k)
    ok 27 - split(/s/,"thisisit",2,:kv)
    ok 28 - "thisisit".split(/s/,2,:kv)
    ok 29 - split(/s/,"thisisit",2,:p)
    ok 30 - "thisisit".split(/s/,2,:p)
    ok 31 - split(/s/,"thisisit",2,:split-empty)
    ok 32 - "thisisit".split(/s/,2,:split-empty)
    ok 33 - split(/s/,"thisisit",2,:v,:skip-empty)
    ok 34 - "thisisit".split(/s/,2,:v,:skip-empty)
    ok 35 - split(/s/,"thisisit",2,:k,:skip-empty)
    ok 36 - "thisisit".split(/s/,2,:k,:skip-empty)
    ok 37 - split(/s/,"thisisit",2,:kv,:skip-empty)
    ok 38 - "thisisit".split(/s/,2,:kv,:skip-empty)
    ok 39 - split(/s/,"thisisit",2,:p,:skip-empty)
    ok 40 - "thisisit".split(/s/,2,:p,:skip-empty)
    ok 41 - string did not get changed
ok 14 - tested "thisisit" with /s/
    1..41
    ok 1 - split("|","|foo|bar|baz|zoo")
    ok 2 - "|foo|bar|baz|zoo".split("|")
    ok 3 - split("|","|foo|bar|baz|zoo",:v)
    ok 4 - "|foo|bar|baz|zoo".split("|",:v)
    ok 5 - split("|","|foo|bar|baz|zoo",:k)
    ok 6 - "|foo|bar|baz|zoo".split("|",:k)
    ok 7 - split("|","|foo|bar|baz|zoo",:kv)
    ok 8 - "|foo|bar|baz|zoo".split("|",:kv)
    ok 9 - split("|","|foo|bar|baz|zoo",:p)
    ok 10 - "|foo|bar|baz|zoo".split("|",:p)
    ok 11 - split("|","|foo|bar|baz|zoo",:skip-empty)
    ok 12 - "|foo|bar|baz|zoo".split("|",:skip-empty)
    ok 13 - split("|","|foo|bar|baz|zoo",:v,:skip-empty)
    ok 14 - "|foo|bar|baz|zoo".split("|",:v,:skip-empty)
    ok 15 - split("|","|foo|bar|baz|zoo",:k,:skip-empty)
    ok 16 - "|foo|bar|baz|zoo".split("|",:k,:skip-empty)
    ok 17 - split("|","|foo|bar|baz|zoo",:kv,:skip-empty)
    ok 18 - "|foo|bar|baz|zoo".split("|",:kv,:skip-empty)
    ok 19 - split("|","|foo|bar|baz|zoo",:p,:skip-empty)
    ok 20 - "|foo|bar|baz|zoo".split("|",:p,:skip-empty)
    ok 21 - split("|","|foo|bar|baz|zoo",3)
    ok 22 - "|foo|bar|baz|zoo".split("|",3)
    ok 23 - split("|","|foo|bar|baz|zoo",3,:v)
    ok 24 - "|foo|bar|baz|zoo".split("|",3,:v)
    ok 25 - split("|","|foo|bar|baz|zoo",3,:k)
    ok 26 - "|foo|bar|baz|zoo".split("|",3,:k)
    ok 27 - split("|","|foo|bar|baz|zoo",3,:kv)
    ok 28 - "|foo|bar|baz|zoo".split("|",3,:kv)
    ok 29 - split("|","|foo|bar|baz|zoo",3,:p)
    ok 30 - "|foo|bar|baz|zoo".split("|",3,:p)
    ok 31 - split("|","|foo|bar|baz|zoo",3,:split-empty)
    ok 32 - "|foo|bar|baz|zoo".split("|",3,:split-empty)
    ok 33 - split("|","|foo|bar|baz|zoo",3,:v,:skip-empty)
    ok 34 - "|foo|bar|baz|zoo".split("|",3,:v,:skip-empty)
    ok 35 - split("|","|foo|bar|baz|zoo",3,:k,:skip-empty)
    ok 36 - "|foo|bar|baz|zoo".split("|",3,:k,:skip-empty)
    ok 37 - split("|","|foo|bar|baz|zoo",3,:kv,:skip-empty)
    ok 38 - "|foo|bar|baz|zoo".split("|",3,:kv,:skip-empty)
    ok 39 - split("|","|foo|bar|baz|zoo",3,:p,:skip-empty)
    ok 40 - "|foo|bar|baz|zoo".split("|",3,:p,:skip-empty)
    ok 41 - string did not get changed
ok 15 - tested "|foo|bar|baz|zoo" with "|"
    1..41
    ok 1 - split(/ \| /,"|foo|bar|baz|zoo")
    ok 2 - "|foo|bar|baz|zoo".split(/ \| /)
    ok 3 - split(/ \| /,"|foo|bar|baz|zoo",:v)
    ok 4 - "|foo|bar|baz|zoo".split(/ \| /,:v)
    ok 5 - split(/ \| /,"|foo|bar|baz|zoo",:k)
    ok 6 - "|foo|bar|baz|zoo".split(/ \| /,:k)
    ok 7 - split(/ \| /,"|foo|bar|baz|zoo",:kv)
    ok 8 - "|foo|bar|baz|zoo".split(/ \| /,:kv)
    ok 9 - split(/ \| /,"|foo|bar|baz|zoo",:p)
    ok 10 - "|foo|bar|baz|zoo".split(/ \| /,:p)
    ok 11 - split(/ \| /,"|foo|bar|baz|zoo",:skip-empty)
    ok 12 - "|foo|bar|baz|zoo".split(/ \| /,:skip-empty)
    ok 13 - split(/ \| /,"|foo|bar|baz|zoo",:v,:skip-empty)
    ok 14 - "|foo|bar|baz|zoo".split(/ \| /,:v,:skip-empty)
    ok 15 - split(/ \| /,"|foo|bar|baz|zoo",:k,:skip-empty)
    ok 16 - "|foo|bar|baz|zoo".split(/ \| /,:k,:skip-empty)
    ok 17 - split(/ \| /,"|foo|bar|baz|zoo",:kv,:skip-empty)
    ok 18 - "|foo|bar|baz|zoo".split(/ \| /,:kv,:skip-empty)
    ok 19 - split(/ \| /,"|foo|bar|baz|zoo",:p,:skip-empty)
    ok 20 - "|foo|bar|baz|zoo".split(/ \| /,:p,:skip-empty)
    ok 21 - split(/ \| /,"|foo|bar|baz|zoo",3)
    ok 22 - "|foo|bar|baz|zoo".split(/ \| /,3)
    ok 23 - split(/ \| /,"|foo|bar|baz|zoo",3,:v)
    ok 24 - "|foo|bar|baz|zoo".split(/ \| /,3,:v)
    ok 25 - split(/ \| /,"|foo|bar|baz|zoo",3,:k)
    ok 26 - "|foo|bar|baz|zoo".split(/ \| /,3,:k)
    ok 27 - split(/ \| /,"|foo|bar|baz|zoo",3,:kv)
    ok 28 - "|foo|bar|baz|zoo".split(/ \| /,3,:kv)
    ok 29 - split(/ \| /,"|foo|bar|baz|zoo",3,:p)
    ok 30 - "|foo|bar|baz|zoo".split(/ \| /,3,:p)
    ok 31 - split(/ \| /,"|foo|bar|baz|zoo",3,:split-empty)
    ok 32 - "|foo|bar|baz|zoo".split(/ \| /,3,:split-empty)
    ok 33 - split(/ \| /,"|foo|bar|baz|zoo",3,:v,:skip-empty)
    ok 34 - "|foo|bar|baz|zoo".split(/ \| /,3,:v,:skip-empty)
    ok 35 - split(/ \| /,"|foo|bar|baz|zoo",3,:k,:skip-empty)
    ok 36 - "|foo|bar|baz|zoo".split(/ \| /,3,:k,:skip-empty)
    ok 37 - split(/ \| /,"|foo|bar|baz|zoo",3,:kv,:skip-empty)
    ok 38 - "|foo|bar|baz|zoo".split(/ \| /,3,:kv,:skip-empty)
    ok 39 - split(/ \| /,"|foo|bar|baz|zoo",3,:p,:skip-empty)
    ok 40 - "|foo|bar|baz|zoo".split(/ \| /,3,:p,:skip-empty)
    ok 41 - string did not get changed
ok 16 - tested "|foo|bar|baz|zoo" with / \| /
    1..41
    ok 1 - split("|","foo|bar|baz|zoo|")
    ok 2 - "foo|bar|baz|zoo|".split("|")
    ok 3 - split("|","foo|bar|baz|zoo|",:v)
    ok 4 - "foo|bar|baz|zoo|".split("|",:v)
    ok 5 - split("|","foo|bar|baz|zoo|",:k)
    ok 6 - "foo|bar|baz|zoo|".split("|",:k)
    ok 7 - split("|","foo|bar|baz|zoo|",:kv)
    ok 8 - "foo|bar|baz|zoo|".split("|",:kv)
    ok 9 - split("|","foo|bar|baz|zoo|",:p)
    ok 10 - "foo|bar|baz|zoo|".split("|",:p)
    ok 11 - split("|","foo|bar|baz|zoo|",:skip-empty)
    ok 12 - "foo|bar|baz|zoo|".split("|",:skip-empty)
    ok 13 - split("|","foo|bar|baz|zoo|",:v,:skip-empty)
    ok 14 - "foo|bar|baz|zoo|".split("|",:v,:skip-empty)
    ok 15 - split("|","foo|bar|baz|zoo|",:k,:skip-empty)
    ok 16 - "foo|bar|baz|zoo|".split("|",:k,:skip-empty)
    ok 17 - split("|","foo|bar|baz|zoo|",:kv,:skip-empty)
    ok 18 - "foo|bar|baz|zoo|".split("|",:kv,:skip-empty)
    ok 19 - split("|","foo|bar|baz|zoo|",:p,:skip-empty)
    ok 20 - "foo|bar|baz|zoo|".split("|",:p,:skip-empty)
    ok 21 - split("|","foo|bar|baz|zoo|",2)
    ok 22 - "foo|bar|baz|zoo|".split("|",2)
    ok 23 - split("|","foo|bar|baz|zoo|",2,:v)
    ok 24 - "foo|bar|baz|zoo|".split("|",2,:v)
    ok 25 - split("|","foo|bar|baz|zoo|",2,:k)
    ok 26 - "foo|bar|baz|zoo|".split("|",2,:k)
    ok 27 - split("|","foo|bar|baz|zoo|",2,:kv)
    ok 28 - "foo|bar|baz|zoo|".split("|",2,:kv)
    ok 29 - split("|","foo|bar|baz|zoo|",2,:p)
    ok 30 - "foo|bar|baz|zoo|".split("|",2,:p)
    ok 31 - split("|","foo|bar|baz|zoo|",2,:split-empty)
    ok 32 - "foo|bar|baz|zoo|".split("|",2,:split-empty)
    ok 33 - split("|","foo|bar|baz|zoo|",2,:v,:skip-empty)
    ok 34 - "foo|bar|baz|zoo|".split("|",2,:v,:skip-empty)
    ok 35 - split("|","foo|bar|baz|zoo|",2,:k,:skip-empty)
    ok 36 - "foo|bar|baz|zoo|".split("|",2,:k,:skip-empty)
    ok 37 - split("|","foo|bar|baz|zoo|",2,:kv,:skip-empty)
    ok 38 - "foo|bar|baz|zoo|".split("|",2,:kv,:skip-empty)
    ok 39 - split("|","foo|bar|baz|zoo|",2,:p,:skip-empty)
    ok 40 - "foo|bar|baz|zoo|".split("|",2,:p,:skip-empty)
    ok 41 - string did not get changed
ok 17 - tested "foo|bar|baz|zoo|" with "|"
    1..41
    ok 1 - split(/ \| /,"foo|bar|baz|zoo|")
    ok 2 - "foo|bar|baz|zoo|".split(/ \| /)
    ok 3 - split(/ \| /,"foo|bar|baz|zoo|",:v)
    ok 4 - "foo|bar|baz|zoo|".split(/ \| /,:v)
    ok 5 - split(/ \| /,"foo|bar|baz|zoo|",:k)
    ok 6 - "foo|bar|baz|zoo|".split(/ \| /,:k)
    ok 7 - split(/ \| /,"foo|bar|baz|zoo|",:kv)
    ok 8 - "foo|bar|baz|zoo|".split(/ \| /,:kv)
    ok 9 - split(/ \| /,"foo|bar|baz|zoo|",:p)
    ok 10 - "foo|bar|baz|zoo|".split(/ \| /,:p)
    ok 11 - split(/ \| /,"foo|bar|baz|zoo|",:skip-empty)
    ok 12 - "foo|bar|baz|zoo|".split(/ \| /,:skip-empty)
    ok 13 - split(/ \| /,"foo|bar|baz|zoo|",:v,:skip-empty)
    ok 14 - "foo|bar|baz|zoo|".split(/ \| /,:v,:skip-empty)
    ok 15 - split(/ \| /,"foo|bar|baz|zoo|",:k,:skip-empty)
    ok 16 - "foo|bar|baz|zoo|".split(/ \| /,:k,:skip-empty)
    ok 17 - split(/ \| /,"foo|bar|baz|zoo|",:kv,:skip-empty)
    ok 18 - "foo|bar|baz|zoo|".split(/ \| /,:kv,:skip-empty)
    ok 19 - split(/ \| /,"foo|bar|baz|zoo|",:p,:skip-empty)
    ok 20 - "foo|bar|baz|zoo|".split(/ \| /,:p,:skip-empty)
    ok 21 - split(/ \| /,"foo|bar|baz|zoo|",2)
    ok 22 - "foo|bar|baz|zoo|".split(/ \| /,2)
    ok 23 - split(/ \| /,"foo|bar|baz|zoo|",2,:v)
    ok 24 - "foo|bar|baz|zoo|".split(/ \| /,2,:v)
    ok 25 - split(/ \| /,"foo|bar|baz|zoo|",2,:k)
    ok 26 - "foo|bar|baz|zoo|".split(/ \| /,2,:k)
    ok 27 - split(/ \| /,"foo|bar|baz|zoo|",2,:kv)
    ok 28 - "foo|bar|baz|zoo|".split(/ \| /,2,:kv)
    ok 29 - split(/ \| /,"foo|bar|baz|zoo|",2,:p)
    ok 30 - "foo|bar|baz|zoo|".split(/ \| /,2,:p)
    ok 31 - split(/ \| /,"foo|bar|baz|zoo|",2,:split-empty)
    ok 32 - "foo|bar|baz|zoo|".split(/ \| /,2,:split-empty)
    ok 33 - split(/ \| /,"foo|bar|baz|zoo|",2,:v,:skip-empty)
    ok 34 - "foo|bar|baz|zoo|".split(/ \| /,2,:v,:skip-empty)
    ok 35 - split(/ \| /,"foo|bar|baz|zoo|",2,:k,:skip-empty)
    ok 36 - "foo|bar|baz|zoo|".split(/ \| /,2,:k,:skip-empty)
    ok 37 - split(/ \| /,"foo|bar|baz|zoo|",2,:kv,:skip-empty)
    ok 38 - "foo|bar|baz|zoo|".split(/ \| /,2,:kv,:skip-empty)
    ok 39 - split(/ \| /,"foo|bar|baz|zoo|",2,:p,:skip-empty)
    ok 40 - "foo|bar|baz|zoo|".split(/ \| /,2,:p,:skip-empty)
    ok 41 - string did not get changed
ok 18 - tested "foo|bar|baz|zoo|" with / \| /
    1..41
    ok 1 - split(rx:Perl5/\|/,"foo|bar|baz|zoo|")
    ok 2 - "foo|bar|baz|zoo|".split(rx:Perl5/\|/)
    ok 3 - split(rx:Perl5/\|/,"foo|bar|baz|zoo|",:v)
    ok 4 - "foo|bar|baz|zoo|".split(rx:Perl5/\|/,:v)
    ok 5 - split(rx:Perl5/\|/,"foo|bar|baz|zoo|",:k)
    ok 6 - "foo|bar|baz|zoo|".split(rx:Perl5/\|/,:k)
    ok 7 - split(rx:Perl5/\|/,"foo|bar|baz|zoo|",:kv)
    ok 8 - "foo|bar|baz|zoo|".split(rx:Perl5/\|/,:kv)
    ok 9 - split(rx:Perl5/\|/,"foo|bar|baz|zoo|",:p)
    ok 10 - "foo|bar|baz|zoo|".split(rx:Perl5/\|/,:p)
    ok 11 - split(rx:Perl5/\|/,"foo|bar|baz|zoo|",:skip-empty)
    ok 12 - "foo|bar|baz|zoo|".split(rx:Perl5/\|/,:skip-empty)
    ok 13 - split(rx:Perl5/\|/,"foo|bar|baz|zoo|",:v,:skip-empty)
    ok 14 - "foo|bar|baz|zoo|".split(rx:Perl5/\|/,:v,:skip-empty)
    ok 15 - split(rx:Perl5/\|/,"foo|bar|baz|zoo|",:k,:skip-empty)
    ok 16 - "foo|bar|baz|zoo|".split(rx:Perl5/\|/,:k,:skip-empty)
    ok 17 - split(rx:Perl5/\|/,"foo|bar|baz|zoo|",:kv,:skip-empty)
    ok 18 - "foo|bar|baz|zoo|".split(rx:Perl5/\|/,:kv,:skip-empty)
    ok 19 - split(rx:Perl5/\|/,"foo|bar|baz|zoo|",:p,:skip-empty)
    ok 20 - "foo|bar|baz|zoo|".split(rx:Perl5/\|/,:p,:skip-empty)
    ok 21 - split(rx:Perl5/\|/,"foo|bar|baz|zoo|",2)
    ok 22 - "foo|bar|baz|zoo|".split(rx:Perl5/\|/,2)
    ok 23 - split(rx:Perl5/\|/,"foo|bar|baz|zoo|",2,:v)
    ok 24 - "foo|bar|baz|zoo|".split(rx:Perl5/\|/,2,:v)
    ok 25 - split(rx:Perl5/\|/,"foo|bar|baz|zoo|",2,:k)
    ok 26 - "foo|bar|baz|zoo|".split(rx:Perl5/\|/,2,:k)
    ok 27 - split(rx:Perl5/\|/,"foo|bar|baz|zoo|",2,:kv)
    ok 28 - "foo|bar|baz|zoo|".split(rx:Perl5/\|/,2,:kv)
    ok 29 - split(rx:Perl5/\|/,"foo|bar|baz|zoo|",2,:p)
    ok 30 - "foo|bar|baz|zoo|".split(rx:Perl5/\|/,2,:p)
    ok 31 - split(rx:Perl5/\|/,"foo|bar|baz|zoo|",2,:split-empty)
    ok 32 - "foo|bar|baz|zoo|".split(rx:Perl5/\|/,2,:split-empty)
    ok 33 - split(rx:Perl5/\|/,"foo|bar|baz|zoo|",2,:v,:skip-empty)
    ok 34 - "foo|bar|baz|zoo|".split(rx:Perl5/\|/,2,:v,:skip-empty)
    ok 35 - split(rx:Perl5/\|/,"foo|bar|baz|zoo|",2,:k,:skip-empty)
    ok 36 - "foo|bar|baz|zoo|".split(rx:Perl5/\|/,2,:k,:skip-empty)
    ok 37 - split(rx:Perl5/\|/,"foo|bar|baz|zoo|",2,:kv,:skip-empty)
    ok 38 - "foo|bar|baz|zoo|".split(rx:Perl5/\|/,2,:kv,:skip-empty)
    ok 39 - split(rx:Perl5/\|/,"foo|bar|baz|zoo|",2,:p,:skip-empty)
    ok 40 - "foo|bar|baz|zoo|".split(rx:Perl5/\|/,2,:p,:skip-empty)
    ok 41 - string did not get changed
ok 19 - tested "foo|bar|baz|zoo|" with rx:Perl5/\|/
    1..41
    ok 1 - split(", ","comma, separated, values")
    ok 2 - "comma, separated, values".split(", ")
    ok 3 - split(", ","comma, separated, values",:v)
    ok 4 - "comma, separated, values".split(", ",:v)
    ok 5 - split(", ","comma, separated, values",:k)
    ok 6 - "comma, separated, values".split(", ",:k)
    ok 7 - split(", ","comma, separated, values",:kv)
    ok 8 - "comma, separated, values".split(", ",:kv)
    ok 9 - split(", ","comma, separated, values",:p)
    ok 10 - "comma, separated, values".split(", ",:p)
    ok 11 - split(", ","comma, separated, values",:skip-empty)
    ok 12 - "comma, separated, values".split(", ",:skip-empty)
    ok 13 - split(", ","comma, separated, values",:v,:skip-empty)
    ok 14 - "comma, separated, values".split(", ",:v,:skip-empty)
    ok 15 - split(", ","comma, separated, values",:k,:skip-empty)
    ok 16 - "comma, separated, values".split(", ",:k,:skip-empty)
    ok 17 - split(", ","comma, separated, values",:kv,:skip-empty)
    ok 18 - "comma, separated, values".split(", ",:kv,:skip-empty)
    ok 19 - split(", ","comma, separated, values",:p,:skip-empty)
    ok 20 - "comma, separated, values".split(", ",:p,:skip-empty)
    ok 21 - split(", ","comma, separated, values",2)
    ok 22 - "comma, separated, values".split(", ",2)
    ok 23 - split(", ","comma, separated, values",2,:v)
    ok 24 - "comma, separated, values".split(", ",2,:v)
    ok 25 - split(", ","comma, separated, values",2,:k)
    ok 26 - "comma, separated, values".split(", ",2,:k)
    ok 27 - split(", ","comma, separated, values",2,:kv)
    ok 28 - "comma, separated, values".split(", ",2,:kv)
    ok 29 - split(", ","comma, separated, values",2,:p)
    ok 30 - "comma, separated, values".split(", ",2,:p)
    ok 31 - split(", ","comma, separated, values",2,:split-empty)
    ok 32 - "comma, separated, values".split(", ",2,:split-empty)
    ok 33 - split(", ","comma, separated, values",2,:v,:skip-empty)
    ok 34 - "comma, separated, values".split(", ",2,:v,:skip-empty)
    ok 35 - split(", ","comma, separated, values",2,:k,:skip-empty)
    ok 36 - "comma, separated, values".split(", ",2,:k,:skip-empty)
    ok 37 - split(", ","comma, separated, values",2,:kv,:skip-empty)
    ok 38 - "comma, separated, values".split(", ",2,:kv,:skip-empty)
    ok 39 - split(", ","comma, separated, values",2,:p,:skip-empty)
    ok 40 - "comma, separated, values".split(", ",2,:p,:skip-empty)
    ok 41 - string did not get changed
ok 20 - tested "comma, separated, values" with ", "
    1..41
    ok 1 - split(/ ", " /,"comma, separated, values")
    ok 2 - "comma, separated, values".split(/ ", " /)
    ok 3 - split(/ ", " /,"comma, separated, values",:v)
    ok 4 - "comma, separated, values".split(/ ", " /,:v)
    ok 5 - split(/ ", " /,"comma, separated, values",:k)
    ok 6 - "comma, separated, values".split(/ ", " /,:k)
    ok 7 - split(/ ", " /,"comma, separated, values",:kv)
    ok 8 - "comma, separated, values".split(/ ", " /,:kv)
    ok 9 - split(/ ", " /,"comma, separated, values",:p)
    ok 10 - "comma, separated, values".split(/ ", " /,:p)
    ok 11 - split(/ ", " /,"comma, separated, values",:skip-empty)
    ok 12 - "comma, separated, values".split(/ ", " /,:skip-empty)
    ok 13 - split(/ ", " /,"comma, separated, values",:v,:skip-empty)
    ok 14 - "comma, separated, values".split(/ ", " /,:v,:skip-empty)
    ok 15 - split(/ ", " /,"comma, separated, values",:k,:skip-empty)
    ok 16 - "comma, separated, values".split(/ ", " /,:k,:skip-empty)
    ok 17 - split(/ ", " /,"comma, separated, values",:kv,:skip-empty)
    ok 18 - "comma, separated, values".split(/ ", " /,:kv,:skip-empty)
    ok 19 - split(/ ", " /,"comma, separated, values",:p,:skip-empty)
    ok 20 - "comma, separated, values".split(/ ", " /,:p,:skip-empty)
    ok 21 - split(/ ", " /,"comma, separated, values",2)
    ok 22 - "comma, separated, values".split(/ ", " /,2)
    ok 23 - split(/ ", " /,"comma, separated, values",2,:v)
    ok 24 - "comma, separated, values".split(/ ", " /,2,:v)
    ok 25 - split(/ ", " /,"comma, separated, values",2,:k)
    ok 26 - "comma, separated, values".split(/ ", " /,2,:k)
    ok 27 - split(/ ", " /,"comma, separated, values",2,:kv)
    ok 28 - "comma, separated, values".split(/ ", " /,2,:kv)
    ok 29 - split(/ ", " /,"comma, separated, values",2,:p)
    ok 30 - "comma, separated, values".split(/ ", " /,2,:p)
    ok 31 - split(/ ", " /,"comma, separated, values",2,:split-empty)
    ok 32 - "comma, separated, values".split(/ ", " /,2,:split-empty)
    ok 33 - split(/ ", " /,"comma, separated, values",2,:v,:skip-empty)
    ok 34 - "comma, separated, values".split(/ ", " /,2,:v,:skip-empty)
    ok 35 - split(/ ", " /,"comma, separated, values",2,:k,:skip-empty)
    ok 36 - "comma, separated, values".split(/ ", " /,2,:k,:skip-empty)
    ok 37 - split(/ ", " /,"comma, separated, values",2,:kv,:skip-empty)
    ok 38 - "comma, separated, values".split(/ ", " /,2,:kv,:skip-empty)
    ok 39 - split(/ ", " /,"comma, separated, values",2,:p,:skip-empty)
    ok 40 - "comma, separated, values".split(/ ", " /,2,:p,:skip-empty)
    ok 41 - string did not get changed
ok 21 - tested "comma, separated, values" with / ", " /
    1..41
    ok 1 - split(/ "," \s /,"comma, separated, values")
    ok 2 - "comma, separated, values".split(/ "," \s /)
    ok 3 - split(/ "," \s /,"comma, separated, values",:v)
    ok 4 - "comma, separated, values".split(/ "," \s /,:v)
    ok 5 - split(/ "," \s /,"comma, separated, values",:k)
    ok 6 - "comma, separated, values".split(/ "," \s /,:k)
    ok 7 - split(/ "," \s /,"comma, separated, values",:kv)
    ok 8 - "comma, separated, values".split(/ "," \s /,:kv)
    ok 9 - split(/ "," \s /,"comma, separated, values",:p)
    ok 10 - "comma, separated, values".split(/ "," \s /,:p)
    ok 11 - split(/ "," \s /,"comma, separated, values",:skip-empty)
    ok 12 - "comma, separated, values".split(/ "," \s /,:skip-empty)
    ok 13 - split(/ "," \s /,"comma, separated, values",:v,:skip-empty)
    ok 14 - "comma, separated, values".split(/ "," \s /,:v,:skip-empty)
    ok 15 - split(/ "," \s /,"comma, separated, values",:k,:skip-empty)
    ok 16 - "comma, separated, values".split(/ "," \s /,:k,:skip-empty)
    ok 17 - split(/ "," \s /,"comma, separated, values",:kv,:skip-empty)
    ok 18 - "comma, separated, values".split(/ "," \s /,:kv,:skip-empty)
    ok 19 - split(/ "," \s /,"comma, separated, values",:p,:skip-empty)
    ok 20 - "comma, separated, values".split(/ "," \s /,:p,:skip-empty)
    ok 21 - split(/ "," \s /,"comma, separated, values",2)
    ok 22 - "comma, separated, values".split(/ "," \s /,2)
    ok 23 - split(/ "," \s /,"comma, separated, values",2,:v)
    ok 24 - "comma, separated, values".split(/ "," \s /,2,:v)
    ok 25 - split(/ "," \s /,"comma, separated, values",2,:k)
    ok 26 - "comma, separated, values".split(/ "," \s /,2,:k)
    ok 27 - split(/ "," \s /,"comma, separated, values",2,:kv)
    ok 28 - "comma, separated, values".split(/ "," \s /,2,:kv)
    ok 29 - split(/ "," \s /,"comma, separated, values",2,:p)
    ok 30 - "comma, separated, values".split(/ "," \s /,2,:p)
    ok 31 - split(/ "," \s /,"comma, separated, values",2,:split-empty)
    ok 32 - "comma, separated, values".split(/ "," \s /,2,:split-empty)
    ok 33 - split(/ "," \s /,"comma, separated, values",2,:v,:skip-empty)
    ok 34 - "comma, separated, values".split(/ "," \s /,2,:v,:skip-empty)
    ok 35 - split(/ "," \s /,"comma, separated, values",2,:k,:skip-empty)
    ok 36 - "comma, separated, values".split(/ "," \s /,2,:k,:skip-empty)
    ok 37 - split(/ "," \s /,"comma, separated, values",2,:kv,:skip-empty)
    ok 38 - "comma, separated, values".split(/ "," \s /,2,:kv,:skip-empty)
    ok 39 - split(/ "," \s /,"comma, separated, values",2,:p,:skip-empty)
    ok 40 - "comma, separated, values".split(/ "," \s /,2,:p,:skip-empty)
    ok 41 - string did not get changed
ok 22 - tested "comma, separated, values" with / "," \s /
    1..41
    ok 1 - split(/ "," \s+ /,"comma, separated, values")
    ok 2 - "comma, separated, values".split(/ "," \s+ /)
    ok 3 - split(/ "," \s+ /,"comma, separated, values",:v)
    ok 4 - "comma, separated, values".split(/ "," \s+ /,:v)
    ok 5 - split(/ "," \s+ /,"comma, separated, values",:k)
    ok 6 - "comma, separated, values".split(/ "," \s+ /,:k)
    ok 7 - split(/ "," \s+ /,"comma, separated, values",:kv)
    ok 8 - "comma, separated, values".split(/ "," \s+ /,:kv)
    ok 9 - split(/ "," \s+ /,"comma, separated, values",:p)
    ok 10 - "comma, separated, values".split(/ "," \s+ /,:p)
    ok 11 - split(/ "," \s+ /,"comma, separated, values",:skip-empty)
    ok 12 - "comma, separated, values".split(/ "," \s+ /,:skip-empty)
    ok 13 - split(/ "," \s+ /,"comma, separated, values",:v,:skip-empty)
    ok 14 - "comma, separated, values".split(/ "," \s+ /,:v,:skip-empty)
    ok 15 - split(/ "," \s+ /,"comma, separated, values",:k,:skip-empty)
    ok 16 - "comma, separated, values".split(/ "," \s+ /,:k,:skip-empty)
    ok 17 - split(/ "," \s+ /,"comma, separated, values",:kv,:skip-empty)
    ok 18 - "comma, separated, values".split(/ "," \s+ /,:kv,:skip-empty)
    ok 19 - split(/ "," \s+ /,"comma, separated, values",:p,:skip-empty)
    ok 20 - "comma, separated, values".split(/ "," \s+ /,:p,:skip-empty)
    ok 21 - split(/ "," \s+ /,"comma, separated, values",2)
    ok 22 - "comma, separated, values".split(/ "," \s+ /,2)
    ok 23 - split(/ "," \s+ /,"comma, separated, values",2,:v)
    ok 24 - "comma, separated, values".split(/ "," \s+ /,2,:v)
    ok 25 - split(/ "," \s+ /,"comma, separated, values",2,:k)
    ok 26 - "comma, separated, values".split(/ "," \s+ /,2,:k)
    ok 27 - split(/ "," \s+ /,"comma, separated, values",2,:kv)
    ok 28 - "comma, separated, values".split(/ "," \s+ /,2,:kv)
    ok 29 - split(/ "," \s+ /,"comma, separated, values",2,:p)
    ok 30 - "comma, separated, values".split(/ "," \s+ /,2,:p)
    ok 31 - split(/ "," \s+ /,"comma, separated, values",2,:split-empty)
    ok 32 - "comma, separated, values".split(/ "," \s+ /,2,:split-empty)
    ok 33 - split(/ "," \s+ /,"comma, separated, values",2,:v,:skip-empty)
    ok 34 - "comma, separated, values".split(/ "," \s+ /,2,:v,:skip-empty)
    ok 35 - split(/ "," \s+ /,"comma, separated, values",2,:k,:skip-empty)
    ok 36 - "comma, separated, values".split(/ "," \s+ /,2,:k,:skip-empty)
    ok 37 - split(/ "," \s+ /,"comma, separated, values",2,:kv,:skip-empty)
    ok 38 - "comma, separated, values".split(/ "," \s+ /,2,:kv,:skip-empty)
    ok 39 - split(/ "," \s+ /,"comma, separated, values",2,:p,:skip-empty)
    ok 40 - "comma, separated, values".split(/ "," \s+ /,2,:p,:skip-empty)
    ok 41 - string did not get changed
ok 23 - tested "comma, separated, values" with / "," \s+ /
    1..41
    ok 1 - split(rx:Perl5/, /,"comma, separated, values")
    ok 2 - "comma, separated, values".split(rx:Perl5/, /)
    ok 3 - split(rx:Perl5/, /,"comma, separated, values",:v)
    ok 4 - "comma, separated, values".split(rx:Perl5/, /,:v)
    ok 5 - split(rx:Perl5/, /,"comma, separated, values",:k)
    ok 6 - "comma, separated, values".split(rx:Perl5/, /,:k)
    ok 7 - split(rx:Perl5/, /,"comma, separated, values",:kv)
    ok 8 - "comma, separated, values".split(rx:Perl5/, /,:kv)
    ok 9 - split(rx:Perl5/, /,"comma, separated, values",:p)
    ok 10 - "comma, separated, values".split(rx:Perl5/, /,:p)
    ok 11 - split(rx:Perl5/, /,"comma, separated, values",:skip-empty)
    ok 12 - "comma, separated, values".split(rx:Perl5/, /,:skip-empty)
    ok 13 - split(rx:Perl5/, /,"comma, separated, values",:v,:skip-empty)
    ok 14 - "comma, separated, values".split(rx:Perl5/, /,:v,:skip-empty)
    ok 15 - split(rx:Perl5/, /,"comma, separated, values",:k,:skip-empty)
    ok 16 - "comma, separated, values".split(rx:Perl5/, /,:k,:skip-empty)
    ok 17 - split(rx:Perl5/, /,"comma, separated, values",:kv,:skip-empty)
    ok 18 - "comma, separated, values".split(rx:Perl5/, /,:kv,:skip-empty)
    ok 19 - split(rx:Perl5/, /,"comma, separated, values",:p,:skip-empty)
    ok 20 - "comma, separated, values".split(rx:Perl5/, /,:p,:skip-empty)
    ok 21 - split(rx:Perl5/, /,"comma, separated, values",2)
    ok 22 - "comma, separated, values".split(rx:Perl5/, /,2)
    ok 23 - split(rx:Perl5/, /,"comma, separated, values",2,:v)
    ok 24 - "comma, separated, values".split(rx:Perl5/, /,2,:v)
    ok 25 - split(rx:Perl5/, /,"comma, separated, values",2,:k)
    ok 26 - "comma, separated, values".split(rx:Perl5/, /,2,:k)
    ok 27 - split(rx:Perl5/, /,"comma, separated, values",2,:kv)
    ok 28 - "comma, separated, values".split(rx:Perl5/, /,2,:kv)
    ok 29 - split(rx:Perl5/, /,"comma, separated, values",2,:p)
    ok 30 - "comma, separated, values".split(rx:Perl5/, /,2,:p)
    ok 31 - split(rx:Perl5/, /,"comma, separated, values",2,:split-empty)
    ok 32 - "comma, separated, values".split(rx:Perl5/, /,2,:split-empty)
    ok 33 - split(rx:Perl5/, /,"comma, separated, values",2,:v,:skip-empty)
    ok 34 - "comma, separated, values".split(rx:Perl5/, /,2,:v,:skip-empty)
    ok 35 - split(rx:Perl5/, /,"comma, separated, values",2,:k,:skip-empty)
    ok 36 - "comma, separated, values".split(rx:Perl5/, /,2,:k,:skip-empty)
    ok 37 - split(rx:Perl5/, /,"comma, separated, values",2,:kv,:skip-empty)
    ok 38 - "comma, separated, values".split(rx:Perl5/, /,2,:kv,:skip-empty)
    ok 39 - split(rx:Perl5/, /,"comma, separated, values",2,:p,:skip-empty)
    ok 40 - "comma, separated, values".split(rx:Perl5/, /,2,:p,:skip-empty)
    ok 41 - string did not get changed
ok 24 - tested "comma, separated, values" with rx:Perl5/, /
    1..41
    ok 1 - split(rx:Perl5/,\s/,"comma, separated, values")
    ok 2 - "comma, separated, values".split(rx:Perl5/,\s/)
    ok 3 - split(rx:Perl5/,\s/,"comma, separated, values",:v)
    ok 4 - "comma, separated, values".split(rx:Perl5/,\s/,:v)
    ok 5 - split(rx:Perl5/,\s/,"comma, separated, values",:k)
    ok 6 - "comma, separated, values".split(rx:Perl5/,\s/,:k)
    ok 7 - split(rx:Perl5/,\s/,"comma, separated, values",:kv)
    ok 8 - "comma, separated, values".split(rx:Perl5/,\s/,:kv)
    ok 9 - split(rx:Perl5/,\s/,"comma, separated, values",:p)
    ok 10 - "comma, separated, values".split(rx:Perl5/,\s/,:p)
    ok 11 - split(rx:Perl5/,\s/,"comma, separated, values",:skip-empty)
    ok 12 - "comma, separated, values".split(rx:Perl5/,\s/,:skip-empty)
    ok 13 - split(rx:Perl5/,\s/,"comma, separated, values",:v,:skip-empty)
    ok 14 - "comma, separated, values".split(rx:Perl5/,\s/,:v,:skip-empty)
    ok 15 - split(rx:Perl5/,\s/,"comma, separated, values",:k,:skip-empty)
    ok 16 - "comma, separated, values".split(rx:Perl5/,\s/,:k,:skip-empty)
    ok 17 - split(rx:Perl5/,\s/,"comma, separated, values",:kv,:skip-empty)
    ok 18 - "comma, separated, values".split(rx:Perl5/,\s/,:kv,:skip-empty)
    ok 19 - split(rx:Perl5/,\s/,"comma, separated, values",:p,:skip-empty)
    ok 20 - "comma, separated, values".split(rx:Perl5/,\s/,:p,:skip-empty)
    ok 21 - split(rx:Perl5/,\s/,"comma, separated, values",2)
    ok 22 - "comma, separated, values".split(rx:Perl5/,\s/,2)
    ok 23 - split(rx:Perl5/,\s/,"comma, separated, values",2,:v)
    ok 24 - "comma, separated, values".split(rx:Perl5/,\s/,2,:v)
    ok 25 - split(rx:Perl5/,\s/,"comma, separated, values",2,:k)
    ok 26 - "comma, separated, values".split(rx:Perl5/,\s/,2,:k)
    ok 27 - split(rx:Perl5/,\s/,"comma, separated, values",2,:kv)
    ok 28 - "comma, separated, values".split(rx:Perl5/,\s/,2,:kv)
    ok 29 - split(rx:Perl5/,\s/,"comma, separated, values",2,:p)
    ok 30 - "comma, separated, values".split(rx:Perl5/,\s/,2,:p)
    ok 31 - split(rx:Perl5/,\s/,"comma, separated, values",2,:split-empty)
    ok 32 - "comma, separated, values".split(rx:Perl5/,\s/,2,:split-empty)
    ok 33 - split(rx:Perl5/,\s/,"comma, separated, values",2,:v,:skip-empty)
    ok 34 - "comma, separated, values".split(rx:Perl5/,\s/,2,:v,:skip-empty)
    ok 35 - split(rx:Perl5/,\s/,"comma, separated, values",2,:k,:skip-empty)
    ok 36 - "comma, separated, values".split(rx:Perl5/,\s/,2,:k,:skip-empty)
    ok 37 - split(rx:Perl5/,\s/,"comma, separated, values",2,:kv,:skip-empty)
    ok 38 - "comma, separated, values".split(rx:Perl5/,\s/,2,:kv,:skip-empty)
    ok 39 - split(rx:Perl5/,\s/,"comma, separated, values",2,:p,:skip-empty)
    ok 40 - "comma, separated, values".split(rx:Perl5/,\s/,2,:p,:skip-empty)
    ok 41 - string did not get changed
ok 25 - tested "comma, separated, values" with rx:Perl5/,\s/
    1..41
    ok 1 - split(rx:Perl5/,\s+/,"comma, separated, values")
    ok 2 - "comma, separated, values".split(rx:Perl5/,\s+/)
    ok 3 - split(rx:Perl5/,\s+/,"comma, separated, values",:v)
    ok 4 - "comma, separated, values".split(rx:Perl5/,\s+/,:v)
    ok 5 - split(rx:Perl5/,\s+/,"comma, separated, values",:k)
    ok 6 - "comma, separated, values".split(rx:Perl5/,\s+/,:k)
    ok 7 - split(rx:Perl5/,\s+/,"comma, separated, values",:kv)
    ok 8 - "comma, separated, values".split(rx:Perl5/,\s+/,:kv)
    ok 9 - split(rx:Perl5/,\s+/,"comma, separated, values",:p)
    ok 10 - "comma, separated, values".split(rx:Perl5/,\s+/,:p)
    ok 11 - split(rx:Perl5/,\s+/,"comma, separated, values",:skip-empty)
    ok 12 - "comma, separated, values".split(rx:Perl5/,\s+/,:skip-empty)
    ok 13 - split(rx:Perl5/,\s+/,"comma, separated, values",:v,:skip-empty)
    ok 14 - "comma, separated, values".split(rx:Perl5/,\s+/,:v,:skip-empty)
    ok 15 - split(rx:Perl5/,\s+/,"comma, separated, values",:k,:skip-empty)
    ok 16 - "comma, separated, values".split(rx:Perl5/,\s+/,:k,:skip-empty)
    ok 17 - split(rx:Perl5/,\s+/,"comma, separated, values",:kv,:skip-empty)
    ok 18 - "comma, separated, values".split(rx:Perl5/,\s+/,:kv,:skip-empty)
    ok 19 - split(rx:Perl5/,\s+/,"comma, separated, values",:p,:skip-empty)
    ok 20 - "comma, separated, values".split(rx:Perl5/,\s+/,:p,:skip-empty)
    ok 21 - split(rx:Perl5/,\s+/,"comma, separated, values",2)
    ok 22 - "comma, separated, values".split(rx:Perl5/,\s+/,2)
    ok 23 - split(rx:Perl5/,\s+/,"comma, separated, values",2,:v)
    ok 24 - "comma, separated, values".split(rx:Perl5/,\s+/,2,:v)
    ok 25 - split(rx:Perl5/,\s+/,"comma, separated, values",2,:k)
    ok 26 - "comma, separated, values".split(rx:Perl5/,\s+/,2,:k)
    ok 27 - split(rx:Perl5/,\s+/,"comma, separated, values",2,:kv)
    ok 28 - "comma, separated, values".split(rx:Perl5/,\s+/,2,:kv)
    ok 29 - split(rx:Perl5/,\s+/,"comma, separated, values",2,:p)
    ok 30 - "comma, separated, values".split(rx:Perl5/,\s+/,2,:p)
    ok 31 - split(rx:Perl5/,\s+/,"comma, separated, values",2,:split-empty)
    ok 32 - "comma, separated, values".split(rx:Perl5/,\s+/,2,:split-empty)
    ok 33 - split(rx:Perl5/,\s+/,"comma, separated, values",2,:v,:skip-empty)
    ok 34 - "comma, separated, values".split(rx:Perl5/,\s+/,2,:v,:skip-empty)
    ok 35 - split(rx:Perl5/,\s+/,"comma, separated, values",2,:k,:skip-empty)
    ok 36 - "comma, separated, values".split(rx:Perl5/,\s+/,2,:k,:skip-empty)
    ok 37 - split(rx:Perl5/,\s+/,"comma, separated, values",2,:kv,:skip-empty)
    ok 38 - "comma, separated, values".split(rx:Perl5/,\s+/,2,:kv,:skip-empty)
    ok 39 - split(rx:Perl5/,\s+/,"comma, separated, values",2,:p,:skip-empty)
    ok 40 - "comma, separated, values".split(rx:Perl5/,\s+/,2,:p,:skip-empty)
    ok 41 - string did not get changed
ok 26 - tested "comma, separated, values" with rx:Perl5/,\s+/
    1..41
    ok 1 - split("a","")
    ok 2 - "".split("a")
    ok 3 - split("a","",:v)
    ok 4 - "".split("a",:v)
    ok 5 - split("a","",:k)
    ok 6 - "".split("a",:k)
    ok 7 - split("a","",:kv)
    ok 8 - "".split("a",:kv)
    ok 9 - split("a","",:p)
    ok 10 - "".split("a",:p)
    ok 11 - split("a","",:skip-empty)
    ok 12 - "".split("a",:skip-empty)
    ok 13 - split("a","",:v,:skip-empty)
    ok 14 - "".split("a",:v,:skip-empty)
    ok 15 - split("a","",:k,:skip-empty)
    ok 16 - "".split("a",:k,:skip-empty)
    ok 17 - split("a","",:kv,:skip-empty)
    ok 18 - "".split("a",:kv,:skip-empty)
    ok 19 - split("a","",:p,:skip-empty)
    ok 20 - "".split("a",:p,:skip-empty)
    ok 21 - split("a","",2)
    ok 22 - "".split("a",2)
    ok 23 - split("a","",2,:v)
    ok 24 - "".split("a",2,:v)
    ok 25 - split("a","",2,:k)
    ok 26 - "".split("a",2,:k)
    ok 27 - split("a","",2,:kv)
    ok 28 - "".split("a",2,:kv)
    ok 29 - split("a","",2,:p)
    ok 30 - "".split("a",2,:p)
    ok 31 - split("a","",2,:split-empty)
    ok 32 - "".split("a",2,:split-empty)
    ok 33 - split("a","",2,:v,:skip-empty)
    ok 34 - "".split("a",2,:v,:skip-empty)
    ok 35 - split("a","",2,:k,:skip-empty)
    ok 36 - "".split("a",2,:k,:skip-empty)
    ok 37 - split("a","",2,:kv,:skip-empty)
    ok 38 - "".split("a",2,:kv,:skip-empty)
    ok 39 - split("a","",2,:p,:skip-empty)
    ok 40 - "".split("a",2,:p,:skip-empty)
    ok 41 - string did not get changed
ok 27 - tested "" with "a"
    1..41
    ok 1 - split(/a/,"")
    ok 2 - "".split(/a/)
    ok 3 - split(/a/,"",:v)
    ok 4 - "".split(/a/,:v)
    ok 5 - split(/a/,"",:k)
    ok 6 - "".split(/a/,:k)
    ok 7 - split(/a/,"",:kv)
    ok 8 - "".split(/a/,:kv)
    ok 9 - split(/a/,"",:p)
    ok 10 - "".split(/a/,:p)
    ok 11 - split(/a/,"",:skip-empty)
    ok 12 - "".split(/a/,:skip-empty)
    ok 13 - split(/a/,"",:v,:skip-empty)
    ok 14 - "".split(/a/,:v,:skip-empty)
    ok 15 - split(/a/,"",:k,:skip-empty)
    ok 16 - "".split(/a/,:k,:skip-empty)
    ok 17 - split(/a/,"",:kv,:skip-empty)
    ok 18 - "".split(/a/,:kv,:skip-empty)
    ok 19 - split(/a/,"",:p,:skip-empty)
    ok 20 - "".split(/a/,:p,:skip-empty)
    ok 21 - split(/a/,"",2)
    ok 22 - "".split(/a/,2)
    ok 23 - split(/a/,"",2,:v)
    ok 24 - "".split(/a/,2,:v)
    ok 25 - split(/a/,"",2,:k)
    ok 26 - "".split(/a/,2,:k)
    ok 27 - split(/a/,"",2,:kv)
    ok 28 - "".split(/a/,2,:kv)
    ok 29 - split(/a/,"",2,:p)
    ok 30 - "".split(/a/,2,:p)
    ok 31 - split(/a/,"",2,:split-empty)
    ok 32 - "".split(/a/,2,:split-empty)
    ok 33 - split(/a/,"",2,:v,:skip-empty)
    ok 34 - "".split(/a/,2,:v,:skip-empty)
    ok 35 - split(/a/,"",2,:k,:skip-empty)
    ok 36 - "".split(/a/,2,:k,:skip-empty)
    ok 37 - split(/a/,"",2,:kv,:skip-empty)
    ok 38 - "".split(/a/,2,:kv,:skip-empty)
    ok 39 - split(/a/,"",2,:p,:skip-empty)
    ok 40 - "".split(/a/,2,:p,:skip-empty)
    ok 41 - string did not get changed
ok 28 - tested "" with /a/
    1..41
    ok 1 - split("ab","")
    ok 2 - "".split("ab")
    ok 3 - split("ab","",:v)
    ok 4 - "".split("ab",:v)
    ok 5 - split("ab","",:k)
    ok 6 - "".split("ab",:k)
    ok 7 - split("ab","",:kv)
    ok 8 - "".split("ab",:kv)
    ok 9 - split("ab","",:p)
    ok 10 - "".split("ab",:p)
    ok 11 - split("ab","",:skip-empty)
    ok 12 - "".split("ab",:skip-empty)
    ok 13 - split("ab","",:v,:skip-empty)
    ok 14 - "".split("ab",:v,:skip-empty)
    ok 15 - split("ab","",:k,:skip-empty)
    ok 16 - "".split("ab",:k,:skip-empty)
    ok 17 - split("ab","",:kv,:skip-empty)
    ok 18 - "".split("ab",:kv,:skip-empty)
    ok 19 - split("ab","",:p,:skip-empty)
    ok 20 - "".split("ab",:p,:skip-empty)
    ok 21 - split("ab","",2)
    ok 22 - "".split("ab",2)
    ok 23 - split("ab","",2,:v)
    ok 24 - "".split("ab",2,:v)
    ok 25 - split("ab","",2,:k)
    ok 26 - "".split("ab",2,:k)
    ok 27 - split("ab","",2,:kv)
    ok 28 - "".split("ab",2,:kv)
    ok 29 - split("ab","",2,:p)
    ok 30 - "".split("ab",2,:p)
    ok 31 - split("ab","",2,:split-empty)
    ok 32 - "".split("ab",2,:split-empty)
    ok 33 - split("ab","",2,:v,:skip-empty)
    ok 34 - "".split("ab",2,:v,:skip-empty)
    ok 35 - split("ab","",2,:k,:skip-empty)
    ok 36 - "".split("ab",2,:k,:skip-empty)
    ok 37 - split("ab","",2,:kv,:skip-empty)
    ok 38 - "".split("ab",2,:kv,:skip-empty)
    ok 39 - split("ab","",2,:p,:skip-empty)
    ok 40 - "".split("ab",2,:p,:skip-empty)
    ok 41 - string did not get changed
ok 29 - tested "" with "ab"
    1..41
    ok 1 - split(/ab/,"")
    ok 2 - "".split(/ab/)
    ok 3 - split(/ab/,"",:v)
    ok 4 - "".split(/ab/,:v)
    ok 5 - split(/ab/,"",:k)
    ok 6 - "".split(/ab/,:k)
    ok 7 - split(/ab/,"",:kv)
    ok 8 - "".split(/ab/,:kv)
    ok 9 - split(/ab/,"",:p)
    ok 10 - "".split(/ab/,:p)
    ok 11 - split(/ab/,"",:skip-empty)
    ok 12 - "".split(/ab/,:skip-empty)
    ok 13 - split(/ab/,"",:v,:skip-empty)
    ok 14 - "".split(/ab/,:v,:skip-empty)
    ok 15 - split(/ab/,"",:k,:skip-empty)
    ok 16 - "".split(/ab/,:k,:skip-empty)
    ok 17 - split(/ab/,"",:kv,:skip-empty)
    ok 18 - "".split(/ab/,:kv,:skip-empty)
    ok 19 - split(/ab/,"",:p,:skip-empty)
    ok 20 - "".split(/ab/,:p,:skip-empty)
    ok 21 - split(/ab/,"",2)
    ok 22 - "".split(/ab/,2)
    ok 23 - split(/ab/,"",2,:v)
    ok 24 - "".split(/ab/,2,:v)
    ok 25 - split(/ab/,"",2,:k)
    ok 26 - "".split(/ab/,2,:k)
    ok 27 - split(/ab/,"",2,:kv)
    ok 28 - "".split(/ab/,2,:kv)
    ok 29 - split(/ab/,"",2,:p)
    ok 30 - "".split(/ab/,2,:p)
    ok 31 - split(/ab/,"",2,:split-empty)
    ok 32 - "".split(/ab/,2,:split-empty)
    ok 33 - split(/ab/,"",2,:v,:skip-empty)
    ok 34 - "".split(/ab/,2,:v,:skip-empty)
    ok 35 - split(/ab/,"",2,:k,:skip-empty)
    ok 36 - "".split(/ab/,2,:k,:skip-empty)
    ok 37 - split(/ab/,"",2,:kv,:skip-empty)
    ok 38 - "".split(/ab/,2,:kv,:skip-empty)
    ok 39 - split(/ab/,"",2,:p,:skip-empty)
    ok 40 - "".split(/ab/,2,:p,:skip-empty)
    ok 41 - string did not get changed
ok 30 - tested "" with /ab/
    1..41
    ok 1 - split($("a", "b"),"")
    ok 2 - "".split($("a", "b"))
    ok 3 - split($("a", "b"),"",:v)
    ok 4 - "".split($("a", "b"),:v)
    ok 5 - split($("a", "b"),"",:k)
    ok 6 - "".split($("a", "b"),:k)
    ok 7 - split($("a", "b"),"",:kv)
    ok 8 - "".split($("a", "b"),:kv)
    ok 9 - split($("a", "b"),"",:p)
    ok 10 - "".split($("a", "b"),:p)
    ok 11 - split($("a", "b"),"",:skip-empty)
    ok 12 - "".split($("a", "b"),:skip-empty)
    ok 13 - split($("a", "b"),"",:v,:skip-empty)
    ok 14 - "".split($("a", "b"),:v,:skip-empty)
    ok 15 - split($("a", "b"),"",:k,:skip-empty)
    ok 16 - "".split($("a", "b"),:k,:skip-empty)
    ok 17 - split($("a", "b"),"",:kv,:skip-empty)
    ok 18 - "".split($("a", "b"),:kv,:skip-empty)
    ok 19 - split($("a", "b"),"",:p,:skip-empty)
    ok 20 - "".split($("a", "b"),:p,:skip-empty)
    ok 21 - split($("a", "b"),"",2)
    ok 22 - "".split($("a", "b"),2)
    ok 23 - split($("a", "b"),"",2,:v)
    ok 24 - "".split($("a", "b"),2,:v)
    ok 25 - split($("a", "b"),"",2,:k)
    ok 26 - "".split($("a", "b"),2,:k)
    ok 27 - split($("a", "b"),"",2,:kv)
    ok 28 - "".split($("a", "b"),2,:kv)
    ok 29 - split($("a", "b"),"",2,:p)
    ok 30 - "".split($("a", "b"),2,:p)
    ok 31 - split($("a", "b"),"",2,:split-empty)
    ok 32 - "".split($("a", "b"),2,:split-empty)
    ok 33 - split($("a", "b"),"",2,:v,:skip-empty)
    ok 34 - "".split($("a", "b"),2,:v,:skip-empty)
    ok 35 - split($("a", "b"),"",2,:k,:skip-empty)
    ok 36 - "".split($("a", "b"),2,:k,:skip-empty)
    ok 37 - split($("a", "b"),"",2,:kv,:skip-empty)
    ok 38 - "".split($("a", "b"),2,:kv,:skip-empty)
    ok 39 - split($("a", "b"),"",2,:p,:skip-empty)
    ok 40 - "".split($("a", "b"),2,:p,:skip-empty)
    ok 41 - string did not get changed
ok 31 - tested "" with $("a", "b")
    1..41
    ok 1 - split(/a|b/,"")
    ok 2 - "".split(/a|b/)
    ok 3 - split(/a|b/,"",:v)
    ok 4 - "".split(/a|b/,:v)
    ok 5 - split(/a|b/,"",:k)
    ok 6 - "".split(/a|b/,:k)
    ok 7 - split(/a|b/,"",:kv)
    ok 8 - "".split(/a|b/,:kv)
    ok 9 - split(/a|b/,"",:p)
    ok 10 - "".split(/a|b/,:p)
    ok 11 - split(/a|b/,"",:skip-empty)
    ok 12 - "".split(/a|b/,:skip-empty)
    ok 13 - split(/a|b/,"",:v,:skip-empty)
    ok 14 - "".split(/a|b/,:v,:skip-empty)
    ok 15 - split(/a|b/,"",:k,:skip-empty)
    ok 16 - "".split(/a|b/,:k,:skip-empty)
    ok 17 - split(/a|b/,"",:kv,:skip-empty)
    ok 18 - "".split(/a|b/,:kv,:skip-empty)
    ok 19 - split(/a|b/,"",:p,:skip-empty)
    ok 20 - "".split(/a|b/,:p,:skip-empty)
    ok 21 - split(/a|b/,"",2)
    ok 22 - "".split(/a|b/,2)
    ok 23 - split(/a|b/,"",2,:v)
    ok 24 - "".split(/a|b/,2,:v)
    ok 25 - split(/a|b/,"",2,:k)
    ok 26 - "".split(/a|b/,2,:k)
    ok 27 - split(/a|b/,"",2,:kv)
    ok 28 - "".split(/a|b/,2,:kv)
    ok 29 - split(/a|b/,"",2,:p)
    ok 30 - "".split(/a|b/,2,:p)
    ok 31 - split(/a|b/,"",2,:split-empty)
    ok 32 - "".split(/a|b/,2,:split-empty)
    ok 33 - split(/a|b/,"",2,:v,:skip-empty)
    ok 34 - "".split(/a|b/,2,:v,:skip-empty)
    ok 35 - split(/a|b/,"",2,:k,:skip-empty)
    ok 36 - "".split(/a|b/,2,:k,:skip-empty)
    ok 37 - split(/a|b/,"",2,:kv,:skip-empty)
    ok 38 - "".split(/a|b/,2,:kv,:skip-empty)
    ok 39 - split(/a|b/,"",2,:p,:skip-empty)
    ok 40 - "".split(/a|b/,2,:p,:skip-empty)
    ok 41 - string did not get changed
ok 32 - tested "" with /a|b/
    1..41
    ok 1 - split(/\s/,"")
    ok 2 - "".split(/\s/)
    ok 3 - split(/\s/,"",:v)
    ok 4 - "".split(/\s/,:v)
    ok 5 - split(/\s/,"",:k)
    ok 6 - "".split(/\s/,:k)
    ok 7 - split(/\s/,"",:kv)
    ok 8 - "".split(/\s/,:kv)
    ok 9 - split(/\s/,"",:p)
    ok 10 - "".split(/\s/,:p)
    ok 11 - split(/\s/,"",:skip-empty)
    ok 12 - "".split(/\s/,:skip-empty)
    ok 13 - split(/\s/,"",:v,:skip-empty)
    ok 14 - "".split(/\s/,:v,:skip-empty)
    ok 15 - split(/\s/,"",:k,:skip-empty)
    ok 16 - "".split(/\s/,:k,:skip-empty)
    ok 17 - split(/\s/,"",:kv,:skip-empty)
    ok 18 - "".split(/\s/,:kv,:skip-empty)
    ok 19 - split(/\s/,"",:p,:skip-empty)
    ok 20 - "".split(/\s/,:p,:skip-empty)
    ok 21 - split(/\s/,"",2)
    ok 22 - "".split(/\s/,2)
    ok 23 - split(/\s/,"",2,:v)
    ok 24 - "".split(/\s/,2,:v)
    ok 25 - split(/\s/,"",2,:k)
    ok 26 - "".split(/\s/,2,:k)
    ok 27 - split(/\s/,"",2,:kv)
    ok 28 - "".split(/\s/,2,:kv)
    ok 29 - split(/\s/,"",2,:p)
    ok 30 - "".split(/\s/,2,:p)
    ok 31 - split(/\s/,"",2,:split-empty)
    ok 32 - "".split(/\s/,2,:split-empty)
    ok 33 - split(/\s/,"",2,:v,:skip-empty)
    ok 34 - "".split(/\s/,2,:v,:skip-empty)
    ok 35 - split(/\s/,"",2,:k,:skip-empty)
    ok 36 - "".split(/\s/,2,:k,:skip-empty)
    ok 37 - split(/\s/,"",2,:kv,:skip-empty)
    ok 38 - "".split(/\s/,2,:kv,:skip-empty)
    ok 39 - split(/\s/,"",2,:p,:skip-empty)
    ok 40 - "".split(/\s/,2,:p,:skip-empty)
    ok 41 - string did not get changed
ok 33 - tested "" with /\s/
    1..41
    ok 1 - split(rx:Perl5/\s/,"")
    ok 2 - "".split(rx:Perl5/\s/)
    ok 3 - split(rx:Perl5/\s/,"",:v)
    ok 4 - "".split(rx:Perl5/\s/,:v)
    ok 5 - split(rx:Perl5/\s/,"",:k)
    ok 6 - "".split(rx:Perl5/\s/,:k)
    ok 7 - split(rx:Perl5/\s/,"",:kv)
    ok 8 - "".split(rx:Perl5/\s/,:kv)
    ok 9 - split(rx:Perl5/\s/,"",:p)
    ok 10 - "".split(rx:Perl5/\s/,:p)
    ok 11 - split(rx:Perl5/\s/,"",:skip-empty)
    ok 12 - "".split(rx:Perl5/\s/,:skip-empty)
    ok 13 - split(rx:Perl5/\s/,"",:v,:skip-empty)
    ok 14 - "".split(rx:Perl5/\s/,:v,:skip-empty)
    ok 15 - split(rx:Perl5/\s/,"",:k,:skip-empty)
    ok 16 - "".split(rx:Perl5/\s/,:k,:skip-empty)
    ok 17 - split(rx:Perl5/\s/,"",:kv,:skip-empty)
    ok 18 - "".split(rx:Perl5/\s/,:kv,:skip-empty)
    ok 19 - split(rx:Perl5/\s/,"",:p,:skip-empty)
    ok 20 - "".split(rx:Perl5/\s/,:p,:skip-empty)
    ok 21 - split(rx:Perl5/\s/,"",2)
    ok 22 - "".split(rx:Perl5/\s/,2)
    ok 23 - split(rx:Perl5/\s/,"",2,:v)
    ok 24 - "".split(rx:Perl5/\s/,2,:v)
    ok 25 - split(rx:Perl5/\s/,"",2,:k)
    ok 26 - "".split(rx:Perl5/\s/,2,:k)
    ok 27 - split(rx:Perl5/\s/,"",2,:kv)
    ok 28 - "".split(rx:Perl5/\s/,2,:kv)
    ok 29 - split(rx:Perl5/\s/,"",2,:p)
    ok 30 - "".split(rx:Perl5/\s/,2,:p)
    ok 31 - split(rx:Perl5/\s/,"",2,:split-empty)
    ok 32 - "".split(rx:Perl5/\s/,2,:split-empty)
    ok 33 - split(rx:Perl5/\s/,"",2,:v,:skip-empty)
    ok 34 - "".split(rx:Perl5/\s/,2,:v,:skip-empty)
    ok 35 - split(rx:Perl5/\s/,"",2,:k,:skip-empty)
    ok 36 - "".split(rx:Perl5/\s/,2,:k,:skip-empty)
    ok 37 - split(rx:Perl5/\s/,"",2,:kv,:skip-empty)
    ok 38 - "".split(rx:Perl5/\s/,2,:kv,:skip-empty)
    ok 39 - split(rx:Perl5/\s/,"",2,:p,:skip-empty)
    ok 40 - "".split(rx:Perl5/\s/,2,:p,:skip-empty)
    ok 41 - string did not get changed
ok 34 - tested "" with rx:Perl5/\s/
    1..41
    ok 1 - split("","")
    ok 2 - "".split("")
    ok 3 - split("","",:v)
    ok 4 - "".split("",:v)
    ok 5 - split("","",:k)
    ok 6 - "".split("",:k)
    ok 7 - split("","",:kv)
    ok 8 - "".split("",:kv)
    ok 9 - split("","",:p)
    ok 10 - "".split("",:p)
    ok 11 - split("","",:skip-empty)
    ok 12 - "".split("",:skip-empty)
    ok 13 - split("","",:v,:skip-empty)
    ok 14 - "".split("",:v,:skip-empty)
    ok 15 - split("","",:k,:skip-empty)
    ok 16 - "".split("",:k,:skip-empty)
    ok 17 - split("","",:kv,:skip-empty)
    ok 18 - "".split("",:kv,:skip-empty)
    ok 19 - split("","",:p,:skip-empty)
    ok 20 - "".split("",:p,:skip-empty)
    ok 21 - split("","",2)
    ok 22 - "".split("",2)
    ok 23 - split("","",2,:v)
    ok 24 - "".split("",2,:v)
    ok 25 - split("","",2,:k)
    ok 26 - "".split("",2,:k)
    ok 27 - split("","",2,:kv)
    ok 28 - "".split("",2,:kv)
    ok 29 - split("","",2,:p)
    ok 30 - "".split("",2,:p)
    ok 31 - split("","",2,:split-empty)
    ok 32 - "".split("",2,:split-empty)
    ok 33 - split("","",2,:v,:skip-empty)
    ok 34 - "".split("",2,:v,:skip-empty)
    ok 35 - split("","",2,:k,:skip-empty)
    ok 36 - "".split("",2,:k,:skip-empty)
    ok 37 - split("","",2,:kv,:skip-empty)
    ok 38 - "".split("",2,:kv,:skip-empty)
    ok 39 - split("","",2,:p,:skip-empty)
    ok 40 - "".split("",2,:p,:skip-empty)
    ok 41 - string did not get changed
ok 35 - tested "" with "empty string"
    1..41
    ok 1 - split("foo","")
    ok 2 - "".split("foo")
    ok 3 - split("foo","",:v)
    ok 4 - "".split("foo",:v)
    ok 5 - split("foo","",:k)
    ok 6 - "".split("foo",:k)
    ok 7 - split("foo","",:kv)
    ok 8 - "".split("foo",:kv)
    ok 9 - split("foo","",:p)
    ok 10 - "".split("foo",:p)
    ok 11 - split("foo","",:skip-empty)
    ok 12 - "".split("foo",:skip-empty)
    ok 13 - split("foo","",:v,:skip-empty)
    ok 14 - "".split("foo",:v,:skip-empty)
    ok 15 - split("foo","",:k,:skip-empty)
    ok 16 - "".split("foo",:k,:skip-empty)
    ok 17 - split("foo","",:kv,:skip-empty)
    ok 18 - "".split("foo",:kv,:skip-empty)
    ok 19 - split("foo","",:p,:skip-empty)
    ok 20 - "".split("foo",:p,:skip-empty)
    ok 21 - split("foo","",2)
    ok 22 - "".split("foo",2)
    ok 23 - split("foo","",2,:v)
    ok 24 - "".split("foo",2,:v)
    ok 25 - split("foo","",2,:k)
    ok 26 - "".split("foo",2,:k)
    ok 27 - split("foo","",2,:kv)
    ok 28 - "".split("foo",2,:kv)
    ok 29 - split("foo","",2,:p)
    ok 30 - "".split("foo",2,:p)
    ok 31 - split("foo","",2,:split-empty)
    ok 32 - "".split("foo",2,:split-empty)
    ok 33 - split("foo","",2,:v,:skip-empty)
    ok 34 - "".split("foo",2,:v,:skip-empty)
    ok 35 - split("foo","",2,:k,:skip-empty)
    ok 36 - "".split("foo",2,:k,:skip-empty)
    ok 37 - split("foo","",2,:kv,:skip-empty)
    ok 38 - "".split("foo",2,:kv,:skip-empty)
    ok 39 - split("foo","",2,:p,:skip-empty)
    ok 40 - "".split("foo",2,:p,:skip-empty)
    ok 41 - string did not get changed
ok 36 - tested "" with "empty string"
    1..41
    ok 1 - split("a","zzzzz")
    ok 2 - "zzzzz".split("a")
    ok 3 - split("a","zzzzz",:v)
    ok 4 - "zzzzz".split("a",:v)
    ok 5 - split("a","zzzzz",:k)
    ok 6 - "zzzzz".split("a",:k)
    ok 7 - split("a","zzzzz",:kv)
    ok 8 - "zzzzz".split("a",:kv)
    ok 9 - split("a","zzzzz",:p)
    ok 10 - "zzzzz".split("a",:p)
    ok 11 - split("a","zzzzz",:skip-empty)
    ok 12 - "zzzzz".split("a",:skip-empty)
    ok 13 - split("a","zzzzz",:v,:skip-empty)
    ok 14 - "zzzzz".split("a",:v,:skip-empty)
    ok 15 - split("a","zzzzz",:k,:skip-empty)
    ok 16 - "zzzzz".split("a",:k,:skip-empty)
    ok 17 - split("a","zzzzz",:kv,:skip-empty)
    ok 18 - "zzzzz".split("a",:kv,:skip-empty)
    ok 19 - split("a","zzzzz",:p,:skip-empty)
    ok 20 - "zzzzz".split("a",:p,:skip-empty)
    ok 21 - split("a","zzzzz",2)
    ok 22 - "zzzzz".split("a",2)
    ok 23 - split("a","zzzzz",2,:v)
    ok 24 - "zzzzz".split("a",2,:v)
    ok 25 - split("a","zzzzz",2,:k)
    ok 26 - "zzzzz".split("a",2,:k)
    ok 27 - split("a","zzzzz",2,:kv)
    ok 28 - "zzzzz".split("a",2,:kv)
    ok 29 - split("a","zzzzz",2,:p)
    ok 30 - "zzzzz".split("a",2,:p)
    ok 31 - split("a","zzzzz",2,:split-empty)
    ok 32 - "zzzzz".split("a",2,:split-empty)
    ok 33 - split("a","zzzzz",2,:v,:skip-empty)
    ok 34 - "zzzzz".split("a",2,:v,:skip-empty)
    ok 35 - split("a","zzzzz",2,:k,:skip-empty)
    ok 36 - "zzzzz".split("a",2,:k,:skip-empty)
    ok 37 - split("a","zzzzz",2,:kv,:skip-empty)
    ok 38 - "zzzzz".split("a",2,:kv,:skip-empty)
    ok 39 - split("a","zzzzz",2,:p,:skip-empty)
    ok 40 - "zzzzz".split("a",2,:p,:skip-empty)
    ok 41 - string did not get changed
ok 37 - tested "zzzzz" with "no match"
    1..41
    ok 1 - split($("a", "e", "i", "o", "u"),"hello world")
    ok 2 - "hello world".split($("a", "e", "i", "o", "u"))
    ok 3 - split($("a", "e", "i", "o", "u"),"hello world",:v)
    ok 4 - "hello world".split($("a", "e", "i", "o", "u"),:v)
    ok 5 - split($("a", "e", "i", "o", "u"),"hello world",:k)
    ok 6 - "hello world".split($("a", "e", "i", "o", "u"),:k)
    ok 7 - split($("a", "e", "i", "o", "u"),"hello world",:kv)
    ok 8 - "hello world".split($("a", "e", "i", "o", "u"),:kv)
    ok 9 - split($("a", "e", "i", "o", "u"),"hello world",:p)
    ok 10 - "hello world".split($("a", "e", "i", "o", "u"),:p)
    ok 11 - split($("a", "e", "i", "o", "u"),"hello world",:skip-empty)
    ok 12 - "hello world".split($("a", "e", "i", "o", "u"),:skip-empty)
    ok 13 - split($("a", "e", "i", "o", "u"),"hello world",:v,:skip-empty)
    ok 14 - "hello world".split($("a", "e", "i", "o", "u"),:v,:skip-empty)
    ok 15 - split($("a", "e", "i", "o", "u"),"hello world",:k,:skip-empty)
    ok 16 - "hello world".split($("a", "e", "i", "o", "u"),:k,:skip-empty)
    ok 17 - split($("a", "e", "i", "o", "u"),"hello world",:kv,:skip-empty)
    ok 18 - "hello world".split($("a", "e", "i", "o", "u"),:kv,:skip-empty)
    ok 19 - split($("a", "e", "i", "o", "u"),"hello world",:p,:skip-empty)
    ok 20 - "hello world".split($("a", "e", "i", "o", "u"),:p,:skip-empty)
    ok 21 - split($("a", "e", "i", "o", "u"),"hello world",3)
    ok 22 - "hello world".split($("a", "e", "i", "o", "u"),3)
    ok 23 - split($("a", "e", "i", "o", "u"),"hello world",3,:v)
    ok 24 - "hello world".split($("a", "e", "i", "o", "u"),3,:v)
    ok 25 - split($("a", "e", "i", "o", "u"),"hello world",3,:k)
    ok 26 - "hello world".split($("a", "e", "i", "o", "u"),3,:k)
    ok 27 - split($("a", "e", "i", "o", "u"),"hello world",3,:kv)
    ok 28 - "hello world".split($("a", "e", "i", "o", "u"),3,:kv)
    ok 29 - split($("a", "e", "i", "o", "u"),"hello world",3,:p)
    ok 30 - "hello world".split($("a", "e", "i", "o", "u"),3,:p)
    ok 31 - split($("a", "e", "i", "o", "u"),"hello world",3,:split-empty)
    ok 32 - "hello world".split($("a", "e", "i", "o", "u"),3,:split-empty)
    ok 33 - split($("a", "e", "i", "o", "u"),"hello world",3,:v,:skip-empty)
    ok 34 - "hello world".split($("a", "e", "i", "o", "u"),3,:v,:skip-empty)
    ok 35 - split($("a", "e", "i", "o", "u"),"hello world",3,:k,:skip-empty)
    ok 36 - "hello world".split($("a", "e", "i", "o", "u"),3,:k,:skip-empty)
    ok 37 - split($("a", "e", "i", "o", "u"),"hello world",3,:kv,:skip-empty)
    ok 38 - "hello world".split($("a", "e", "i", "o", "u"),3,:kv,:skip-empty)
    ok 39 - split($("a", "e", "i", "o", "u"),"hello world",3,:p,:skip-empty)
    ok 40 - "hello world".split($("a", "e", "i", "o", "u"),3,:p,:skip-empty)
    ok 41 - string did not get changed
ok 38 - tested "hello world" with $("a", "e", "i", "o", "u")
    1..41
    ok 1 - split(/<[aeiou]>/,"hello world")
    ok 2 - "hello world".split(/<[aeiou]>/)
    ok 3 - split(/<[aeiou]>/,"hello world",:v)
    ok 4 - "hello world".split(/<[aeiou]>/,:v)
    ok 5 - split(/<[aeiou]>/,"hello world",:k)
    ok 6 - "hello world".split(/<[aeiou]>/,:k)
    ok 7 - split(/<[aeiou]>/,"hello world",:kv)
    ok 8 - "hello world".split(/<[aeiou]>/,:kv)
    ok 9 - split(/<[aeiou]>/,"hello world",:p)
    ok 10 - "hello world".split(/<[aeiou]>/,:p)
    ok 11 - split(/<[aeiou]>/,"hello world",:skip-empty)
    ok 12 - "hello world".split(/<[aeiou]>/,:skip-empty)
    ok 13 - split(/<[aeiou]>/,"hello world",:v,:skip-empty)
    ok 14 - "hello world".split(/<[aeiou]>/,:v,:skip-empty)
    ok 15 - split(/<[aeiou]>/,"hello world",:k,:skip-empty)
    ok 16 - "hello world".split(/<[aeiou]>/,:k,:skip-empty)
    ok 17 - split(/<[aeiou]>/,"hello world",:kv,:skip-empty)
    ok 18 - "hello world".split(/<[aeiou]>/,:kv,:skip-empty)
    ok 19 - split(/<[aeiou]>/,"hello world",:p,:skip-empty)
    ok 20 - "hello world".split(/<[aeiou]>/,:p,:skip-empty)
    ok 21 - split(/<[aeiou]>/,"hello world",3)
    ok 22 - "hello world".split(/<[aeiou]>/,3)
    ok 23 - split(/<[aeiou]>/,"hello world",3,:v)
    ok 24 - "hello world".split(/<[aeiou]>/,3,:v)
    ok 25 - split(/<[aeiou]>/,"hello world",3,:k)
    ok 26 - "hello world".split(/<[aeiou]>/,3,:k)
    ok 27 - split(/<[aeiou]>/,"hello world",3,:kv)
    ok 28 - "hello world".split(/<[aeiou]>/,3,:kv)
    ok 29 - split(/<[aeiou]>/,"hello world",3,:p)
    ok 30 - "hello world".split(/<[aeiou]>/,3,:p)
    ok 31 - split(/<[aeiou]>/,"hello world",3,:split-empty)
    ok 32 - "hello world".split(/<[aeiou]>/,3,:split-empty)
    ok 33 - split(/<[aeiou]>/,"hello world",3,:v,:skip-empty)
    ok 34 - "hello world".split(/<[aeiou]>/,3,:v,:skip-empty)
    ok 35 - split(/<[aeiou]>/,"hello world",3,:k,:skip-empty)
    ok 36 - "hello world".split(/<[aeiou]>/,3,:k,:skip-empty)
    ok 37 - split(/<[aeiou]>/,"hello world",3,:kv,:skip-empty)
    ok 38 - "hello world".split(/<[aeiou]>/,3,:kv,:skip-empty)
    ok 39 - split(/<[aeiou]>/,"hello world",3,:p,:skip-empty)
    ok 40 - "hello world".split(/<[aeiou]>/,3,:p,:skip-empty)
    ok 41 - string did not get changed
ok 39 - tested "hello world" with /<[aeiou]>/
    1..41
    ok 1 - split(rx:Perl5/[aeiou]/,"hello world")
    ok 2 - "hello world".split(rx:Perl5/[aeiou]/)
    ok 3 - split(rx:Perl5/[aeiou]/,"hello world",:v)
    ok 4 - "hello world".split(rx:Perl5/[aeiou]/,:v)
    ok 5 - split(rx:Perl5/[aeiou]/,"hello world",:k)
    ok 6 - "hello world".split(rx:Perl5/[aeiou]/,:k)
    ok 7 - split(rx:Perl5/[aeiou]/,"hello world",:kv)
    ok 8 - "hello world".split(rx:Perl5/[aeiou]/,:kv)
    ok 9 - split(rx:Perl5/[aeiou]/,"hello world",:p)
    ok 10 - "hello world".split(rx:Perl5/[aeiou]/,:p)
    ok 11 - split(rx:Perl5/[aeiou]/,"hello world",:skip-empty)
    ok 12 - "hello world".split(rx:Perl5/[aeiou]/,:skip-empty)
    ok 13 - split(rx:Perl5/[aeiou]/,"hello world",:v,:skip-empty)
    ok 14 - "hello world".split(rx:Perl5/[aeiou]/,:v,:skip-empty)
    ok 15 - split(rx:Perl5/[aeiou]/,"hello world",:k,:skip-empty)
    ok 16 - "hello world".split(rx:Perl5/[aeiou]/,:k,:skip-empty)
    ok 17 - split(rx:Perl5/[aeiou]/,"hello world",:kv,:skip-empty)
    ok 18 - "hello world".split(rx:Perl5/[aeiou]/,:kv,:skip-empty)
    ok 19 - split(rx:Perl5/[aeiou]/,"hello world",:p,:skip-empty)
    ok 20 - "hello world".split(rx:Perl5/[aeiou]/,:p,:skip-empty)
    ok 21 - split(rx:Perl5/[aeiou]/,"hello world",3)
    ok 22 - "hello world".split(rx:Perl5/[aeiou]/,3)
    ok 23 - split(rx:Perl5/[aeiou]/,"hello world",3,:v)
    ok 24 - "hello world".split(rx:Perl5/[aeiou]/,3,:v)
    ok 25 - split(rx:Perl5/[aeiou]/,"hello world",3,:k)
    ok 26 - "hello world".split(rx:Perl5/[aeiou]/,3,:k)
    ok 27 - split(rx:Perl5/[aeiou]/,"hello world",3,:kv)
    ok 28 - "hello world".split(rx:Perl5/[aeiou]/,3,:kv)
    ok 29 - split(rx:Perl5/[aeiou]/,"hello world",3,:p)
    ok 30 - "hello world".split(rx:Perl5/[aeiou]/,3,:p)
    ok 31 - split(rx:Perl5/[aeiou]/,"hello world",3,:split-empty)
    ok 32 - "hello world".split(rx:Perl5/[aeiou]/,3,:split-empty)
    ok 33 - split(rx:Perl5/[aeiou]/,"hello world",3,:v,:skip-empty)
    ok 34 - "hello world".split(rx:Perl5/[aeiou]/,3,:v,:skip-empty)
    ok 35 - split(rx:Perl5/[aeiou]/,"hello world",3,:k,:skip-empty)
    ok 36 - "hello world".split(rx:Perl5/[aeiou]/,3,:k,:skip-empty)
    ok 37 - split(rx:Perl5/[aeiou]/,"hello world",3,:kv,:skip-empty)
    ok 38 - "hello world".split(rx:Perl5/[aeiou]/,3,:kv,:skip-empty)
    ok 39 - split(rx:Perl5/[aeiou]/,"hello world",3,:p,:skip-empty)
    ok 40 - "hello world".split(rx:Perl5/[aeiou]/,3,:p,:skip-empty)
    ok 41 - string did not get changed
ok 40 - tested "hello world" with rx:Perl5/[aeiou]/
ok 41 - split:v resulted in seven pieces
ok 42 - second is a Match object
ok 43 - fourth is a Match object
ok 44 - sixth is a Match object
ok 45 - split:v resulted in seven pieces
ok 46 - First capture worked
ok 47 - Second capture worked
ok 48 - Third capture worked
ok 49 - Fourth capture worked
    1..41
    ok 1 - split(/<.ws>/,"hello-world")
    ok 2 - "hello-world".split(/<.ws>/)
    ok 3 - split(/<.ws>/,"hello-world",:v)
    ok 4 - "hello-world".split(/<.ws>/,:v)
    ok 5 - split(/<.ws>/,"hello-world",:k)
    ok 6 - "hello-world".split(/<.ws>/,:k)
    ok 7 - split(/<.ws>/,"hello-world",:kv)
    ok 8 - "hello-world".split(/<.ws>/,:kv)
    ok 9 - split(/<.ws>/,"hello-world",:p)
    ok 10 - "hello-world".split(/<.ws>/,:p)
    ok 11 - split(/<.ws>/,"hello-world",:skip-empty)
    ok 12 - "hello-world".split(/<.ws>/,:skip-empty)
    ok 13 - split(/<.ws>/,"hello-world",:v,:skip-empty)
    ok 14 - "hello-world".split(/<.ws>/,:v,:skip-empty)
    ok 15 - split(/<.ws>/,"hello-world",:k,:skip-empty)
    ok 16 - "hello-world".split(/<.ws>/,:k,:skip-empty)
    ok 17 - split(/<.ws>/,"hello-world",:kv,:skip-empty)
    ok 18 - "hello-world".split(/<.ws>/,:kv,:skip-empty)
    ok 19 - split(/<.ws>/,"hello-world",:p,:skip-empty)
    ok 20 - "hello-world".split(/<.ws>/,:p,:skip-empty)
    ok 21 - split(/<.ws>/,"hello-world",3)
    ok 22 - "hello-world".split(/<.ws>/,3)
    ok 23 - split(/<.ws>/,"hello-world",3,:v)
    ok 24 - "hello-world".split(/<.ws>/,3,:v)
    ok 25 - split(/<.ws>/,"hello-world",3,:k)
    ok 26 - "hello-world".split(/<.ws>/,3,:k)
    ok 27 - split(/<.ws>/,"hello-world",3,:kv)
    ok 28 - "hello-world".split(/<.ws>/,3,:kv)
    ok 29 - split(/<.ws>/,"hello-world",3,:p)
    ok 30 - "hello-world".split(/<.ws>/,3,:p)
    ok 31 - split(/<.ws>/,"hello-world",3,:split-empty)
    ok 32 - "hello-world".split(/<.ws>/,3,:split-empty)
    ok 33 - split(/<.ws>/,"hello-world",3,:v,:skip-empty)
    ok 34 - "hello-world".split(/<.ws>/,3,:v,:skip-empty)
    ok 35 - split(/<.ws>/,"hello-world",3,:k,:skip-empty)
    ok 36 - "hello-world".split(/<.ws>/,3,:k,:skip-empty)
    ok 37 - split(/<.ws>/,"hello-world",3,:kv,:skip-empty)
    ok 38 - "hello-world".split(/<.ws>/,3,:kv,:skip-empty)
    ok 39 - split(/<.ws>/,"hello-world",3,:p,:skip-empty)
    ok 40 - "hello-world".split(/<.ws>/,3,:p,:skip-empty)
    ok 41 - string did not get changed
ok 50 - tested "hello-world" with /<.ws>/
    1..41
    ok 1 - split(/<.wb>/,"hello-world")
    ok 2 - "hello-world".split(/<.wb>/)
    ok 3 - split(/<.wb>/,"hello-world",:v)
    ok 4 - "hello-world".split(/<.wb>/,:v)
    ok 5 - split(/<.wb>/,"hello-world",:k)
    ok 6 - "hello-world".split(/<.wb>/,:k)
    ok 7 - split(/<.wb>/,"hello-world",:kv)
    ok 8 - "hello-world".split(/<.wb>/,:kv)
    ok 9 - split(/<.wb>/,"hello-world",:p)
    ok 10 - "hello-world".split(/<.wb>/,:p)
    ok 11 - split(/<.wb>/,"hello-world",:skip-empty)
    ok 12 - "hello-world".split(/<.wb>/,:skip-empty)
    ok 13 - split(/<.wb>/,"hello-world",:v,:skip-empty)
    ok 14 - "hello-world".split(/<.wb>/,:v,:skip-empty)
    ok 15 - split(/<.wb>/,"hello-world",:k,:skip-empty)
    ok 16 - "hello-world".split(/<.wb>/,:k,:skip-empty)
    ok 17 - split(/<.wb>/,"hello-world",:kv,:skip-empty)
    ok 18 - "hello-world".split(/<.wb>/,:kv,:skip-empty)
    ok 19 - split(/<.wb>/,"hello-world",:p,:skip-empty)
    ok 20 - "hello-world".split(/<.wb>/,:p,:skip-empty)
    ok 21 - split(/<.wb>/,"hello-world",3)
    ok 22 - "hello-world".split(/<.wb>/,3)
    ok 23 - split(/<.wb>/,"hello-world",3,:v)
    ok 24 - "hello-world".split(/<.wb>/,3,:v)
    ok 25 - split(/<.wb>/,"hello-world",3,:k)
    ok 26 - "hello-world".split(/<.wb>/,3,:k)
    ok 27 - split(/<.wb>/,"hello-world",3,:kv)
    ok 28 - "hello-world".split(/<.wb>/,3,:kv)
    ok 29 - split(/<.wb>/,"hello-world",3,:p)
    ok 30 - "hello-world".split(/<.wb>/,3,:p)
    ok 31 - split(/<.wb>/,"hello-world",3,:split-empty)
    ok 32 - "hello-world".split(/<.wb>/,3,:split-empty)
    ok 33 - split(/<.wb>/,"hello-world",3,:v,:skip-empty)
    ok 34 - "hello-world".split(/<.wb>/,3,:v,:skip-empty)
    ok 35 - split(/<.wb>/,"hello-world",3,:k,:skip-empty)
    ok 36 - "hello-world".split(/<.wb>/,3,:k,:skip-empty)
    ok 37 - split(/<.wb>/,"hello-world",3,:kv,:skip-empty)
    ok 38 - "hello-world".split(/<.wb>/,3,:kv,:skip-empty)
    ok 39 - split(/<.wb>/,"hello-world",3,:p,:skip-empty)
    ok 40 - "hello-world".split(/<.wb>/,3,:p,:skip-empty)
    ok 41 - string did not get changed
ok 51 - tested "hello-world" with /<.wb>/
    1..41
    ok 1 - split(/<.ws>/,"-a-b-c-")
    ok 2 - "-a-b-c-".split(/<.ws>/)
    ok 3 - split(/<.ws>/,"-a-b-c-",:v)
    ok 4 - "-a-b-c-".split(/<.ws>/,:v)
    ok 5 - split(/<.ws>/,"-a-b-c-",:k)
    ok 6 - "-a-b-c-".split(/<.ws>/,:k)
    ok 7 - split(/<.ws>/,"-a-b-c-",:kv)
    ok 8 - "-a-b-c-".split(/<.ws>/,:kv)
    ok 9 - split(/<.ws>/,"-a-b-c-",:p)
    ok 10 - "-a-b-c-".split(/<.ws>/,:p)
    ok 11 - split(/<.ws>/,"-a-b-c-",:skip-empty)
    ok 12 - "-a-b-c-".split(/<.ws>/,:skip-empty)
    ok 13 - split(/<.ws>/,"-a-b-c-",:v,:skip-empty)
    ok 14 - "-a-b-c-".split(/<.ws>/,:v,:skip-empty)
    ok 15 - split(/<.ws>/,"-a-b-c-",:k,:skip-empty)
    ok 16 - "-a-b-c-".split(/<.ws>/,:k,:skip-empty)
    ok 17 - split(/<.ws>/,"-a-b-c-",:kv,:skip-empty)
    ok 18 - "-a-b-c-".split(/<.ws>/,:kv,:skip-empty)
    ok 19 - split(/<.ws>/,"-a-b-c-",:p,:skip-empty)
    ok 20 - "-a-b-c-".split(/<.ws>/,:p,:skip-empty)
    ok 21 - split(/<.ws>/,"-a-b-c-",4)
    ok 22 - "-a-b-c-".split(/<.ws>/,4)
    ok 23 - split(/<.ws>/,"-a-b-c-",4,:v)
    ok 24 - "-a-b-c-".split(/<.ws>/,4,:v)
    ok 25 - split(/<.ws>/,"-a-b-c-",4,:k)
    ok 26 - "-a-b-c-".split(/<.ws>/,4,:k)
    ok 27 - split(/<.ws>/,"-a-b-c-",4,:kv)
    ok 28 - "-a-b-c-".split(/<.ws>/,4,:kv)
    ok 29 - split(/<.ws>/,"-a-b-c-",4,:p)
    ok 30 - "-a-b-c-".split(/<.ws>/,4,:p)
    ok 31 - split(/<.ws>/,"-a-b-c-",4,:split-empty)
    ok 32 - "-a-b-c-".split(/<.ws>/,4,:split-empty)
    ok 33 - split(/<.ws>/,"-a-b-c-",4,:v,:skip-empty)
    ok 34 - "-a-b-c-".split(/<.ws>/,4,:v,:skip-empty)
    ok 35 - split(/<.ws>/,"-a-b-c-",4,:k,:skip-empty)
    ok 36 - "-a-b-c-".split(/<.ws>/,4,:k,:skip-empty)
    ok 37 - split(/<.ws>/,"-a-b-c-",4,:kv,:skip-empty)
    ok 38 - "-a-b-c-".split(/<.ws>/,4,:kv,:skip-empty)
    ok 39 - split(/<.ws>/,"-a-b-c-",4,:p,:skip-empty)
    ok 40 - "-a-b-c-".split(/<.ws>/,4,:p,:skip-empty)
    ok 41 - string did not get changed
ok 52 - tested "-a-b-c-" with /<.ws>/
    1..41
    ok 1 - split(/<.wb>/,"-a-b-c-")
    ok 2 - "-a-b-c-".split(/<.wb>/)
    ok 3 - split(/<.wb>/,"-a-b-c-",:v)
    ok 4 - "-a-b-c-".split(/<.wb>/,:v)
    ok 5 - split(/<.wb>/,"-a-b-c-",:k)
    ok 6 - "-a-b-c-".split(/<.wb>/,:k)
    ok 7 - split(/<.wb>/,"-a-b-c-",:kv)
    ok 8 - "-a-b-c-".split(/<.wb>/,:kv)
    ok 9 - split(/<.wb>/,"-a-b-c-",:p)
    ok 10 - "-a-b-c-".split(/<.wb>/,:p)
    ok 11 - split(/<.wb>/,"-a-b-c-",:skip-empty)
    ok 12 - "-a-b-c-".split(/<.wb>/,:skip-empty)
    ok 13 - split(/<.wb>/,"-a-b-c-",:v,:skip-empty)
    ok 14 - "-a-b-c-".split(/<.wb>/,:v,:skip-empty)
    ok 15 - split(/<.wb>/,"-a-b-c-",:k,:skip-empty)
    ok 16 - "-a-b-c-".split(/<.wb>/,:k,:skip-empty)
    ok 17 - split(/<.wb>/,"-a-b-c-",:kv,:skip-empty)
    ok 18 - "-a-b-c-".split(/<.wb>/,:kv,:skip-empty)
    ok 19 - split(/<.wb>/,"-a-b-c-",:p,:skip-empty)
    ok 20 - "-a-b-c-".split(/<.wb>/,:p,:skip-empty)
    ok 21 - split(/<.wb>/,"-a-b-c-",4)
    ok 22 - "-a-b-c-".split(/<.wb>/,4)
    ok 23 - split(/<.wb>/,"-a-b-c-",4,:v)
    ok 24 - "-a-b-c-".split(/<.wb>/,4,:v)
    ok 25 - split(/<.wb>/,"-a-b-c-",4,:k)
    ok 26 - "-a-b-c-".split(/<.wb>/,4,:k)
    ok 27 - split(/<.wb>/,"-a-b-c-",4,:kv)
    ok 28 - "-a-b-c-".split(/<.wb>/,4,:kv)
    ok 29 - split(/<.wb>/,"-a-b-c-",4,:p)
    ok 30 - "-a-b-c-".split(/<.wb>/,4,:p)
    ok 31 - split(/<.wb>/,"-a-b-c-",4,:split-empty)
    ok 32 - "-a-b-c-".split(/<.wb>/,4,:split-empty)
    ok 33 - split(/<.wb>/,"-a-b-c-",4,:v,:skip-empty)
    ok 34 - "-a-b-c-".split(/<.wb>/,4,:v,:skip-empty)
    ok 35 - split(/<.wb>/,"-a-b-c-",4,:k,:skip-empty)
    ok 36 - "-a-b-c-".split(/<.wb>/,4,:k,:skip-empty)
    ok 37 - split(/<.wb>/,"-a-b-c-",4,:kv,:skip-empty)
    ok 38 - "-a-b-c-".split(/<.wb>/,4,:kv,:skip-empty)
    ok 39 - split(/<.wb>/,"-a-b-c-",4,:p,:skip-empty)
    ok 40 - "-a-b-c-".split(/<.wb>/,4,:p,:skip-empty)
    ok 41 - string did not get changed
ok 53 - tested "-a-b-c-" with /<.wb>/
ok 54 - Str.split() disallowed
ok 55 - "a.b".split(/\./)
ok 56 - # SKIP No such method null for invocant of type Cursor RT  \#124685
    1..5
    ok 1 - code dies
    ok 2 - right exception type (X::Adverb)
    ok 3 - .source matches Str
    ok 4 - .nogo matches (k v)
    ok 5 - .what matches split
ok 57 - clashing named parameters
ok 58 - overlapping needles
ok 59 - *.split result is HLLized
    1..11
    ok 1 - :v; Cool
    ok 2 - :v; Regex
    ok 3 - :kv; Cool
    ok 4 - :kv; Regex
    ok 5 - :p; Cool
    ok 6 - :p; Regex
    ok 7 - :k; Cool
    ok 8 - :k; Regex
    ok 9 - :skip-empty; Cool
    ok 10 - :skip-empty; Regex
    ok 11 - @needles form
ok 60 - .split works on Cool same as it works on Str
ok 61 - Split with alternates completes and doesn't give an exception
    1..5
    ok 1 - .split(";", :skip-empty)
    ok 2 - .split("", :skip-empty)
    ok 3 - .split(rx/^/, :skip-empty)
    ok 4 - .split(/$/, :skip-empty)
    ok 5 - ;.split(";", :skip-empty)
ok 62 - split skip-empty skips all empty chunks
ok 63 - did we get aa
ok 64 - did we get bb
ok 65 - did the array stay empty
# FUDGED!
1..25
ok 1 - $*TZ is defined
ok 2 - DateTime.now uses $*TZ
ok 3 - DateTime.local uses $*TZ
ok 4 - UTC -> local -> UTC (2003-08-01T02:22:00Z)
ok 5 - UTC -> local -> UTC (1984-02-29T05:55:22Z)
ok 6 - UTC -> local -> UTC (1998-12-31T23:59:60Z)
not ok 7 - DateTime.in-timezone($*TZ) (from UTC, outside of DST) # TODO 
# Failed test 'DateTime.in-timezone($*TZ) (from UTC, outside of DST)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-temporal/local.rakudo line 42
# expected: '2007-01-01T21:22:00-05:00'
#      got: '2007-01-01T22:22:00-04:00'
not ok 8 - DateTime.local (from UTC, outside of DST) # TODO 
# Failed test 'DateTime.local (from UTC, outside of DST)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-temporal/local.rakudo line 47
# expected: '2007-01-01T21:22:00-05:00'
#      got: '2007-01-01T22:22:00-04:00'
ok 9 - DateTime.local (from UTC, during DST)
not ok 10 - DateTime.local (from UTC, just before DST begins) # TODO 
# Failed test 'DateTime.local (from UTC, just before DST begins)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-temporal/local.rakudo line 53
# expected: '1984-04-29T01:55:00-05:00'
#      got: '1984-04-29T02:55:00-04:00'
ok 11 - DateTime.local (from UTC, just after DST begins)
ok 12 - DateTime.local (from UTC, just before DST ends)
ok 13 - DateTime.local (from UTC, just before DST ends, .raku)
not ok 14 - DateTime.local (from UTC, just after DST ends) # TODO 
# Failed test 'DateTime.local (from UTC, just after DST ends)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-temporal/local.rakudo line 62
# expected: '2008-11-02T01:55:00-05:00'
#      got: '2008-11-02T02:55:00-04:00'
not ok 15 - DateTime.local (from UTC, just after DST ends, .raku) # TODO 
# Failed test 'DateTime.local (from UTC, just after DST ends, .raku)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-temporal/local.rakudo line 65
# expected: '2008-11-02T01:55:00-05:00'
#      got: '2008-11-02T02:55:00-04:00'
ok 16 - DateTime.local (from +0303, just before DST ends)
not ok 17 - DateTime.local (from -1612, just after DST ends) # TODO 
# Failed test 'DateTime.local (from -1612, just after DST ends)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-temporal/local.rakudo line 71
# expected: '2008-11-02T01:55:00-05:00'
#      got: '2008-11-02T02:55:00-04:00'
not ok 18 - DateTime.utc (from local, outside of DST) # TODO 
# Failed test 'DateTime.utc (from local, outside of DST)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-temporal/local.rakudo line 78
# expected: '1995-01-02T02:22:00Z'
#      got: '1995-01-02T01:22:00Z'
ok 19 - DateTime.utc (from local, during DST)
not ok 20 - DateTime.utc (from local, just before DST starts) # TODO 
# Failed test 'DateTime.utc (from local, just before DST starts)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-temporal/local.rakudo line 84
# expected: '2007-03-11T06:55:00Z'
#      got: '2007-03-11T05:55:00Z'
ok 21 - DateTime.in-timezone (local to -1612, just after DST starts)
ok 22 - DateTime.utc (from local, ambiguous)
ok 23 - DateTime.utc (from local, with leap second)
ok 24 - Local time zone rejects bogus leap second
not ok 25 - DateTime.local (from UTC, with leap second) # TODO 
# Failed test 'DateTime.local (from UTC, with leap second)'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-temporal/local.rakudo line 98
# expected: '1998-12-31T18:59:60-05:00'
#      got: '1998-12-31T19:59:60-04:00'
# FUDGED!
1..4
not ok 1 -  # TODO feed fails to parse
# Failed test at /Users/tobiuo/class/seminar/Abyss-Server/roast/integration/advent2010-day10.rakudo line 15
# Unable to parse expression in quote words; couldn't find final '>' (corresponding starter was at line 1)
not ok 2 - left feed # TODO feed fails to parse
# Failed test 'left feed'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/integration/advent2010-day10.rakudo line 16
# expected: '1 9 25 49 81 121 169 225 289 361 441 529 625 729 841 961 1089 1225 1369 1521 1681 1849 2025 2209 2401 2601 2809 3025 3249 3481 3721 3969 4225 4489 4761 5041 5329 5625 5929 6241 6561 6889 7225 7569 7921 8281 8649 9025 9409 9801'
#      got: ''
ok 3 - left feed
ok 4 - right feed
# FUDGED!
1..8
ok 1 - fibonacci
ok 2 - largest prime factor
not ok 3 - Pascal's triangle # TODO failing during 2015.09 release...
# Failed test 'Pascal's triangle'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/integration/advent2012-day04.rakudo line 21
# expected: 4075
#      got: 0
ok 4 - Pythagorean triplet products (gathered)
ok 5 - Pythagorean triplet products (dataflow)
ok 6 - consecutive prime factors
ok 7 - distinct term count
ok 8 - distinct term count - optimized
# FUDGED!
1..7
ok 1 - do we have right number of elements
ok 2 - did we get the right string
ok 3 - # SKIP sometimes hangs, sometimes segfaults
ok 4 - do we have right number of elements
ok 5 - did we get the right string
ok 6 - do we have right number of elements
ok 7 - did we get the right string
# FUDGED!
1..10
ok 1 - Test class inherited from the same role caused infinite loop bug
ok 2 - did we see the Int private attribute from the role
ok 3 - did we update the Int private attribute from the role
ok 4 - # SKIP alas, no visibility of native private attributes yet
ok 5 - # SKIP alas, no visibility of native private attributes yet
ok 6 - did we see the Int private attribute from the embedded role
ok 7 - did we update the Int private attribute from the embedded role
ok 8 - # SKIP alas, no visibility of private attributes in other role
ok 9 - # SKIP alas, no visibility of private attributes in other role
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Attribute::Undeclared)
ok 10 - unknown attribute dies at compile time
# FUDGED!
1..35
ok 1 - Can stringify $!.WHAT without segfault
ok 2 - Can say $!.WHAT in a CATCH block
ok 3 - Can [].WHAT.say
ok 4 - presence of postcircumfix does not lead to redeclaration warnings
ok 5 - multi sub with where clause + temp stress
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Undeclared::Symbols)
ok 6 - time() with arguments dies
ok 7 - can use >>.method on result of introspection
    1..3
    ok 1 - 'Any .= ()' died
    ok 2 - right exception type (Exception)
    ok 3 - .message matches -> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140690269764768) ... }
ok 8 - typed, non-internal exception
ok 9 - can recurse many times into &EVAL
    1..2
    ok 1 - code dies
    ok 2 - right exception type (X::Undeclared::Symbols)
ok 10 - weird string that once parsed in rakudo
()([])
ok 11 - weird code that used to parsefail rakudo
ok 12 - still able to parse statement after sub decl ending in newline
ok 13 - fails correctly
ok 14 - at one point rakudo evaluated the first expression to 0
ok 15 - sorting method list does not segfault
ok 16 - empty code block does not crash (used to do that on JVM)
ok 17 - useless use of is rw reported on meaningful line
ok 18 - concise error message when sinking last statement in a file
    1..2
    not ok 1 - code dies # TODO Feels like a bogus test in light of recent changes
    # Failed test 'code dies'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/integration/weird-errors.rakudo line 155
    ok 2 - # SKIP Code did not die, can not check exception
not ok 19 - Doesn't die with weird internal error # TODO Feels like a bogus test in light of recent changes
# Failed test 'Doesn't die with weird internal error'
# at /Users/tobiuo/class/seminar/Abyss-Server/roast/integration/weird-errors.rakudo line 155
    1..3
    ok 1 - code dies
    ok 2 - right exception type (X::NoSuchSymbol)
    ok 3 - .symbol matches a
ok 20 - test throwing for ::a
ok 21 - Correct result instead of SEGV
ok 22 - Can decode and work with interesting byte sequences
ok 23 - SPESH inline works correctly after 158 iterations
ok 24 - (;) does not explode the compiler
ok 25 - (;;) does not explode the compiler
ok 26 - [;] does not explode the compiler
ok 27 - [;0] does not explode the compiler
ok 28 - # SKIP non-deterministic segfaults in parallel code
    1..2
    ok 1 - 'class A114672 {};
    # class B114672 is A114672 {
    #     has $!x = 5;
    #     our method foo(A114672:) { say $!x }
    # };
    # &B114672::foo(A114672.new)
    # ' died
    ok 2 - right exception type (Exception)
ok 29 - no segfault
ok 30 - using a null string to access a hash does not segfault
ok 31 - No SEGV/crash on reduction in grep using %%
ok 32 - new Foo: calling form does not produce unwanted output
ok 33 - no segfault when using `hash` in a function
ok 34 - no miscompilation issue with chain ops
ok 35 - no segfault when using coercers
# FUDGED!
