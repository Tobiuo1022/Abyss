1..3
ok 1 - No VM crash on enormous number of combiners
ok 2 - native strings can be as large as regular strings
    1..8
    ok 1 - Multi-role mix with value constrained parameter
    ok 2 - Multis from diferent roles with value constrained parameter
    ok 3 - Multi-role mix with only where clauses different
    ok 4 - Multis from same role declaration order tiebreaker (TEST USES UNSUPPORTED FEATURES)
    ok 5 - Multis from different roles with only where clauses different
    not ok 6 - Multis from different roles declaration order tiebreaker (TEST USES UNSUPPORTED FEATURES) # TODO Wrong tiebreaker order (S12, actually)
    # Failed test 'Multis from different roles declaration order tiebreaker (TEST USES UNSUPPORTED FEATURES)'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/APPENDICES/A01-limits/misc.rakudo line 23
    ok 7 - Multis from different roles with only where clauses different (2)
    not ok 8 - Multis from different roles declaration order tiebreaker (TEST USES UNSUPPORTED FEATURES) # TODO Wrong tiebreaker order (S12, actually)
    # Failed test 'Multis from different roles declaration order tiebreaker (TEST USES UNSUPPORTED FEATURES)'
    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/APPENDICES/A01-limits/misc.rakudo line 23
ok 3 - role multi tiebreaking (TEST USES UNSUPPORTED FEATURES)
# FUDGED!
1..9
    1..2
        1..3
        ok 1 - returned handle is STDOUT
        ok 2 - set binary mode
        ok 3 - changed encoding
    ok 1 - STDOUT
        1..3
        ok 1 - returned handle is STDIN
        ok 2 - set binary mode
        ok 3 - changed encoding
    ok 2 - STDIN
ok 4 - .open with "-" as path uses $*IN/$*OUT
    1..3
        1..4
        ok 1 - returned handle is STDOUT
        ok 2 - $*OUT is now opened
        ok 3 - set binary mode
        ok 4 - changed encoding
    ok 1 - STDOUT
        1..4
        ok 1 - returned handle is STDIN
        ok 2 - $*IN is now opened
        ok 3 - set binary mode
        ok 4 - changed encoding
    ok 2 - STDIN
    ok 3 - can use unopened handle with path '-'.IO
ok 5 - .open with "-" as path can open closed $*IN/$*OUT
ok 6 - can .slurp from "-".IO path
    1..7
        1..64
        ok 1 - correct return value when using \("", "")
        ok 2 - correct modification when using \("", "")
        ok 3 - correct return value when using \("", "", :g)
        ok 4 - correct modification when using \("", "", :g)
        ok 5 - correct return value when using \("", "", :global)
        ok 6 - correct modification when using \("", "", :global)
        ok 7 - correct return value when using \("a", "")
        ok 8 - correct modification when using \("a", "")
        ok 9 - correct return value when using \("a", "", :g)
        ok 10 - correct modification when using \("a", "", :g)
        ok 11 - correct return value when using \("a", "", :global)
        ok 12 - correct modification when using \("a", "", :global)
        ok 13 - correct return value when using \("b", "")
        ok 14 - correct modification when using \("b", "")
        ok 15 - correct return value when using \("b", "", :g)
        ok 16 - correct modification when using \("b", "", :g)
        ok 17 - correct return value when using \("b", "", :global)
        ok 18 - correct modification when using \("b", "", :global)
        ok 19 - correct return value when using \(/<[abc]>/, "")
        ok 20 - correct modification when using \(/<[abc]>/, "")
        ok 21 - correct return value when using \(/<[abc]>/, "", :g)
        ok 22 - correct modification when using \(/<[abc]>/, "", :g)
        ok 23 - correct return value when using \(/<[abc]>/, "", :global)
        ok 24 - correct modification when using \(/<[abc]>/, "", :global)
        ok 25 - correct return value when using \(/<[abc]>/, "", :st(1))
        ok 26 - correct modification when using \(/<[abc]>/, "", :st(1))
        ok 27 - correct return value when using \(/<[abc]>/, "", :st(-> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140195820679512) ... }))
        ok 28 - correct modification when using \(/<[abc]>/, "", :st(-> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140195820679512) ... }))
        ok 29 - correct return value when using \(/<[abc]>/, "", :nd(2))
        ok 30 - correct modification when using \(/<[abc]>/, "", :nd(2))
        ok 31 - correct return value when using \(/<[abc]>/, "", :nd(-> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140195820684336) ... }))
        ok 32 - correct modification when using \(/<[abc]>/, "", :nd(-> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140195820684336) ... }))
        ok 33 - correct return value when using \(/<[abc]>/, "", :rd(3))
        ok 34 - correct modification when using \(/<[abc]>/, "", :rd(3))
        ok 35 - correct return value when using \(/<[abc]>/, "", :rd(-> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140195820684696) ... }))
        ok 36 - correct modification when using \(/<[abc]>/, "", :rd(-> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140195820684696) ... }))
        ok 37 - correct return value when using \(/<[abc]>/, "", :th(4))
        ok 38 - correct modification when using \(/<[abc]>/, "", :th(4))
        ok 39 - correct return value when using \(/<[abc]>/, "", :th(-> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140195820685056) ... }))
        ok 40 - correct modification when using \(/<[abc]>/, "", :th(-> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140195820685056) ... }))
        ok 41 - correct return value when using \(/<[abc]>/, "", :nth(5))
        ok 42 - correct modification when using \(/<[abc]>/, "", :nth(5))
        ok 43 - correct return value when using \(/<[abc]>/, "", :nth(-> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140195820685416) ... }))
        ok 44 - correct modification when using \(/<[abc]>/, "", :nth(-> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140195820685416) ... }))
        ok 45 - correct return value when using \(/<[abc]>/, "", :x(5))
        ok 46 - correct modification when using \(/<[abc]>/, "", :x(5))
        ok 47 - correct return value when using \(/<[abc]>/, "", :x(1..5))
        ok 48 - correct modification when using \(/<[abc]>/, "", :x(1..5))
        ok 49 - correct return value when using \(/<[cz]> \s+ <[xy]>/, "Z P", :ss)
        ok 50 - correct modification when using \(/<[cz]> \s+ <[xy]>/, "Z P", :ss)
        ok 51 - correct return value when using \(/<[cz]> \s+ <[xy]>/, "Z P", :global, :ss)
        ok 52 - correct modification when using \(/<[cz]> \s+ <[xy]>/, "Z P", :global, :ss)
        ok 53 - correct return value when using \("a", "Z", :ii)
        ok 54 - correct modification when using \("a", "Z", :ii)
        ok 55 - correct return value when using \("a", "Z", :global, :ii)
        ok 56 - correct modification when using \("a", "Z", :global, :ii)
        ok 57 - correct return value when using \(/<[b]+[b\x[308]]>/, "Z", :mm)
        ok 58 - correct modification when using \(/<[b]+[b\x[308]]>/, "Z", :mm)
        ok 59 - correct return value when using \(/<[b]+[b\x[308]]>/, "Z", :global, :mm)
        ok 60 - correct modification when using \(/<[b]+[b\x[308]]>/, "Z", :global, :mm)
        ok 61 - correct return value when using \(/<[b]+[b\x[308]]>/, "Z", :ii, :mm)
        ok 62 - correct modification when using \(/<[b]+[b\x[308]]>/, "Z", :ii, :mm)
        ok 63 - correct return value when using \(/<[b]+[b\x[308]]>/, "Z", :global, :ii, :mm)
        ok 64 - correct modification when using \(/<[b]+[b\x[308]]>/, "Z", :global, :ii, :mm)
    ok 1 - Cool.subst-mutate works same as on .Str
        1..68
        ok 1 - :g with Regex matcher on Str
        ok 2 - :x with Regex matcher on Str
        ok 3 - :nth(List) with Regex matcher on Str
        ok 4 - :nth(Seq) with Regex matcher on Str
        ok 5 - :nth(Range) with Regex matcher on Str
        ok 6 - :th(List) with Regex matcher on Str
        ok 7 - :th(Seq) with Regex matcher on Str
        ok 8 - :th(Range) with Regex matcher on Str
        ok 9 - :st(List) with Regex matcher on Str
        ok 10 - :st(Seq) with Regex matcher on Str
        ok 11 - :st(Range) with Regex matcher on Str
        ok 12 - :nd(List) with Regex matcher on Str
        ok 13 - :nd(Seq) with Regex matcher on Str
        ok 14 - :nd(Range) with Regex matcher on Str
        ok 15 - :rd(List) with Regex matcher on Str
        ok 16 - :rd(Seq) with Regex matcher on Str
        ok 17 - :rd(Range) with Regex matcher on Str
        ok 18 - :g with Regex matcher on Int
        ok 19 - :x with Regex matcher on Int
        ok 20 - :nth(List) with Regex matcher on Int
        ok 21 - :nth(Seq) with Regex matcher on Int
        ok 22 - :nth(Range) with Regex matcher on Int
        ok 23 - :th(List) with Regex matcher on Int
        ok 24 - :th(Seq) with Regex matcher on Int
        ok 25 - :th(Range) with Regex matcher on Int
        ok 26 - :st(List) with Regex matcher on Int
        ok 27 - :st(Seq) with Regex matcher on Int
        ok 28 - :st(Range) with Regex matcher on Int
        ok 29 - :nd(List) with Regex matcher on Int
        ok 30 - :nd(Seq) with Regex matcher on Int
        ok 31 - :nd(Range) with Regex matcher on Int
        ok 32 - :rd(List) with Regex matcher on Int
        ok 33 - :rd(Seq) with Regex matcher on Int
        ok 34 - :rd(Range) with Regex matcher on Int
        ok 35 - :g with Str matcher on Str
        ok 36 - :x with Str matcher on Str
        ok 37 - :nth(List) with Str matcher on Str
        ok 38 - :nth(Seq) with Str matcher on Str
        ok 39 - :nth(Range) with Str matcher on Str
        ok 40 - :th(List) with Str matcher on Str
        ok 41 - :th(Seq) with Str matcher on Str
        ok 42 - :th(Range) with Str matcher on Str
        ok 43 - :st(List) with Str matcher on Str
        ok 44 - :st(Seq) with Str matcher on Str
        ok 45 - :st(Range) with Str matcher on Str
        ok 46 - :nd(List) with Str matcher on Str
        ok 47 - :nd(Seq) with Str matcher on Str
        ok 48 - :nd(Range) with Str matcher on Str
        ok 49 - :rd(List) with Str matcher on Str
        ok 50 - :rd(Seq) with Str matcher on Str
        ok 51 - :rd(Range) with Str matcher on Str
        ok 52 - :g with Str matcher on Int
        ok 53 - :x with Str matcher on Int
        ok 54 - :nth(List) with Str matcher on Int
        ok 55 - :nth(Seq) with Str matcher on Int
        ok 56 - :nth(Range) with Str matcher on Int
        ok 57 - :th(List) with Str matcher on Int
        ok 58 - :th(Seq) with Str matcher on Int
        ok 59 - :th(Range) with Str matcher on Int
        ok 60 - :st(List) with Str matcher on Int
        ok 61 - :st(Seq) with Str matcher on Int
        ok 62 - :st(Range) with Str matcher on Int
        ok 63 - :nd(List) with Str matcher on Int
        ok 64 - :nd(Seq) with Str matcher on Int
        ok 65 - :nd(Range) with Str matcher on Int
        ok 66 - :rd(List) with Str matcher on Int
        ok 67 - :rd(Seq) with Str matcher on Int
        ok 68 - :rd(Range) with Str matcher on Int
    ok 2 - .subst-mutate returns a List for things .match return a List for
        1..68
        ok 1 - :g with Regex matcher on Str
        ok 2 - :x with Regex matcher on Str
        ok 3 - :nth(List) with Regex matcher on Str
        ok 4 - :nth(Seq) with Regex matcher on Str
        ok 5 - :nth(Range) with Regex matcher on Str
        ok 6 - :th(List) with Regex matcher on Str
        ok 7 - :th(Seq) with Regex matcher on Str
        ok 8 - :th(Range) with Regex matcher on Str
        ok 9 - :st(List) with Regex matcher on Str
        ok 10 - :st(Seq) with Regex matcher on Str
        ok 11 - :st(Range) with Regex matcher on Str
        ok 12 - :nd(List) with Regex matcher on Str
        ok 13 - :nd(Seq) with Regex matcher on Str
        ok 14 - :nd(Range) with Regex matcher on Str
        ok 15 - :rd(List) with Regex matcher on Str
        ok 16 - :rd(Seq) with Regex matcher on Str
        ok 17 - :rd(Range) with Regex matcher on Str
        ok 18 - :g with Regex matcher on Int
        ok 19 - :x with Regex matcher on Int
        ok 20 - :nth(List) with Regex matcher on Int
        ok 21 - :nth(Seq) with Regex matcher on Int
        ok 22 - :nth(Range) with Regex matcher on Int
        ok 23 - :th(List) with Regex matcher on Int
        ok 24 - :th(Seq) with Regex matcher on Int
        ok 25 - :th(Range) with Regex matcher on Int
        ok 26 - :st(List) with Regex matcher on Int
        ok 27 - :st(Seq) with Regex matcher on Int
        ok 28 - :st(Range) with Regex matcher on Int
        ok 29 - :nd(List) with Regex matcher on Int
        ok 30 - :nd(Seq) with Regex matcher on Int
        ok 31 - :nd(Range) with Regex matcher on Int
        ok 32 - :rd(List) with Regex matcher on Int
        ok 33 - :rd(Seq) with Regex matcher on Int
        ok 34 - :rd(Range) with Regex matcher on Int
        ok 35 - :g with Str matcher on Str
        ok 36 - :x with Str matcher on Str
        ok 37 - :nth(List) with Str matcher on Str
        ok 38 - :nth(Seq) with Str matcher on Str
        ok 39 - :nth(Range) with Str matcher on Str
        ok 40 - :th(List) with Str matcher on Str
        ok 41 - :th(Seq) with Str matcher on Str
        ok 42 - :th(Range) with Str matcher on Str
        ok 43 - :st(List) with Str matcher on Str
        ok 44 - :st(Seq) with Str matcher on Str
        ok 45 - :st(Range) with Str matcher on Str
        ok 46 - :nd(List) with Str matcher on Str
        ok 47 - :nd(Seq) with Str matcher on Str
        ok 48 - :nd(Range) with Str matcher on Str
        ok 49 - :rd(List) with Str matcher on Str
        ok 50 - :rd(Seq) with Str matcher on Str
        ok 51 - :rd(Range) with Str matcher on Str
        ok 52 - :g with Str matcher on Int
        ok 53 - :x with Str matcher on Int
        ok 54 - :nth(List) with Str matcher on Int
        ok 55 - :nth(Seq) with Str matcher on Int
        ok 56 - :nth(Range) with Str matcher on Int
        ok 57 - :th(List) with Str matcher on Int
        ok 58 - :th(Seq) with Str matcher on Int
        ok 59 - :th(Range) with Str matcher on Int
        ok 60 - :st(List) with Str matcher on Int
        ok 61 - :st(Seq) with Str matcher on Int
        ok 62 - :st(Range) with Str matcher on Int
        ok 63 - :nd(List) with Str matcher on Int
        ok 64 - :nd(Seq) with Str matcher on Int
        ok 65 - :nd(Range) with Str matcher on Int
        ok 66 - :rd(List) with Str matcher on Int
        ok 67 - :rd(Seq) with Str matcher on Int
        ok 68 - :rd(Range) with Str matcher on Int
    ok 3 - no-matches .subst-mutate: with multi-match opts = empty List
        1..14
            1..4
            ok 1 - $/ is a List…
            ok 2 - …with 3 items…
            ok 3 - …all are Match…
            ok 4 - …all have right values
        ok 1 - Int.subst-mutate: :g
            1..4
            ok 1 - $/ is a List…
            ok 2 - …with 2 items…
            ok 3 - …all are Match…
            ok 4 - …all have right values
        ok 2 - .subst-mutate: :x
            1..4
            ok 1 - $/ is a List…
            ok 2 - …with 3 items…
            ok 3 - …all are Match…
            ok 4 - …all have right values
        ok 3 - .subst-mutate: :nth
            1..4
            ok 1 - $/ is a List…
            ok 2 - …with 3 items…
            ok 3 - …all are Match…
            ok 4 - …all have right values
        ok 4 - .subst-mutate: :st
            1..4
            ok 1 - $/ is a List…
            ok 2 - …with 3 items…
            ok 3 - …all are Match…
            ok 4 - …all have right values
        ok 5 - .subst-mutate: :nd
            1..4
            ok 1 - $/ is a List…
            ok 2 - …with 3 items…
            ok 3 - …all are Match…
            ok 4 - …all have right values
        ok 6 - .subst-mutate: :rd
            1..4
            ok 1 - $/ is a List…
            ok 2 - …with 3 items…
            ok 3 - …all are Match…
            ok 4 - …all have right values
        ok 7 - .subst-mutate: :th
            1..4
            ok 1 - $/ is a List…
            ok 2 - …with 3 items…
            ok 3 - …all are Match…
            ok 4 - …all have right values
        ok 8 - Str.subst-mutate: :g
            1..4
            ok 1 - $/ is a List…
            ok 2 - …with 2 items…
            ok 3 - …all are Match…
            ok 4 - …all have right values
        ok 9 - .subst-mutate: :x
            1..4
            ok 1 - $/ is a List…
            ok 2 - …with 3 items…
            ok 3 - …all are Match…
            ok 4 - …all have right values
        ok 10 - .subst-mutate: :nth
            1..4
            ok 1 - $/ is a List…
            ok 2 - …with 3 items…
            ok 3 - …all are Match…
            ok 4 - …all have right values
        ok 11 - .subst-mutate: :st
            1..4
            ok 1 - $/ is a List…
            ok 2 - …with 3 items…
            ok 3 - …all are Match…
            ok 4 - …all have right values
        ok 12 - .subst-mutate: :nd
            1..4
            ok 1 - $/ is a List…
            ok 2 - …with 3 items…
            ok 3 - …all are Match…
            ok 4 - …all have right values
        ok 13 - .subst-mutate: :rd
            1..4
            ok 1 - $/ is a List…
            ok 2 - …with 3 items…
            ok 3 - …all are Match…
            ok 4 - …all have right values
        ok 14 - .subst-mutate: :th
    ok 4 - .subst-mutate with multi-match args set $/ to a List of matches
        1..2
        ok 1 - code dies
        ok 2 - right exception type (X::Str::Match::x)
    ok 5 - giving .subst-mutate invalid args throws
    ok 6 - Cool.subst-mutate with wrong args does not hang
        1..2
        ok 1 - Str.subst-mutate
        ok 2 - Cool.subst-mutate
    ok 7 - $/ is set when matching in a loop
ok 7 - now-deprecated subst-mutate
    1..7
    ok 1 - The object is-a 'Int'
    ok 2 - can assign integer value and return that
    ok 3 - the expected Int value was set
        1..2
        ok 1 - code dies
        ok 2 - right exception type (X::TypeCheck::Assignment)
    ok 4 - cannot assign a Str to an Int
        1..2
        ok 1 - code dies
        ok 2 - right exception type (X::Assignment::RO)
    ok 5 - cannot assign an Int to a frozen
    ok 6 - did not change integer value
    ok 7 - Pair.freeze doesn't change object identity
ok 8 - Pair.freeze
    1..2
    ok 1 - lines(Str, :count)
    ok 2 - Str.lines(:count)
ok 9 - :count arg on &lines/Str.lines
    1..5
        1..4
        ok 1 - no version pragma
        ok 2 - 6.c version pragma
        ok 3 - 6.d version pragma
        ok 4 - 6.d version pragma
    ok 1 - version as first thing
        1..4
        ok 1 - no version pragma
        ok 2 - 6.c version pragma
        ok 3 - 6.d version pragma
        ok 4 - 6.d version pragma
    ok 2 - version after comments
        1..4
        ok 1 - no version pragma
        ok 2 - 6.c version pragma
        ok 3 - 6.d version pragma
        ok 4 - 6.d version pragma
    ok 3 - version after POD
        1..3
        ok 1 - 6.c version pragma
        ok 2 - 6.d version pragma
        ok 3 - 6.d version pragma
    ok 4 - error out when trying to switch version too late
        1..4
        ok 1 - no version pragma
        ok 2 - 6.c version pragma
        ok 3 - 6.d version pragma
        ok 4 - 6.d version pragma
    ok 5 - versions without dot
ok 10 - language switching
    1..1
        1..4
        ok 1 - defaults
        ok 2 - :nl-out set to ♥
        ok 3 - :nl-out set to a string (via .new)
        ok 4 - :nl-out set via .new, then via .open, then via attribute assignment
    ok 1 - .print-nl method
ok 11 - IO::Handle.new can take a bunch of options
    1..12
    ok 1 - CALLER:: string arg
    ok 2 - CALLER:: number arg
assign requires a concrete object (got a Rakudo::Internals::LoweredAwayLexical type object instead)
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/APPENDICES/A03-older-specs/01-misc.rakudo line 409
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/APPENDICES/A03-older-specs/01-misc.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

    1..19
    ok 3 - native types and where clauses do not cause spurious circularities
        1..8
        ok 1 - type
        ok 2 - :D smiley
        ok 3 - implied Any
        ok 4 - # SKIP :D/:U coerces NYI
        ok 5 - type
        ok 6 - :D smiley
        ok 7 - implied Any
        ok 8 - # SKIP :D/:U coerces NYI
    ok 4 - :D DefiniteHow target (core types)
        1..3
        ok 1 - type
        ok 2 - :U smiley
        ok 3 - implied Any
    ok 5 - :U DefiniteHow target (core types)
        1..4
            1..2
            ok 1 - '-> Date:D(DateTime)   {}(DateTime)' died
            ok 2 - right exception type (X::Parameter::InvalidConcreteness)
        ok 1 - type, bad source # TODO no proper concreteness check in coerces
            1..2
            ok 1 - '-> Date:D(DateTime:D) {}(DateTime)' died
            not ok 2 - right exception type (X::Parameter::InvalidConcreteness) # TODO no proper concreteness check in coerces
            # Failed test 'right exception type (X::Parameter::InvalidConcreteness)'
            # at SETTING::src/core.c/Exception.pm6 line 62
            # Expected: X::Parameter::InvalidConcreteness
            # Got:      X::TypeCheck::Binding::Parameter
            # Exception message: Type check failed in binding to parameter '<anon>'; expected Date:D(DateTime:D) but got DateTime (DateTime)
        not ok 2 - :D, bad source # TODO no proper concreteness check in coerces
        # Failed test ':D, bad source'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/APPENDICES/A04-experimental/01-misc.rakudo line 57
            1..2
            ok 1 - '-> Date:D(DateTime:U) {}(DateTime)' died
            ok 2 - right exception type (X::Parameter::InvalidConcreteness)
        ok 3 - :U, bad target # TODO no proper concreteness check in coerces
            1..2
            ok 1 - '-> Date:D() {}(DateTime)' died
            ok 2 - right exception type (X::Parameter::InvalidConcreteness)
        ok 4 - implied, bad target # TODO no proper concreteness check in coerces
    ok 6 - DefiniteHow target, errors
        1..4
            1..2
            ok 1 - '-> Date:D(DateTime)   {}(Date)' died
            not ok 2 - right exception type (X::Parameter::InvalidConcreteness) # TODO no proper concreteness check in coerces
            # Failed test 'right exception type (X::Parameter::InvalidConcreteness)'
            # at SETTING::src/core.c/Exception.pm6 line 62
            # Expected: X::Parameter::InvalidConcreteness
            # Got:      X::TypeCheck::Binding::Parameter
            # Exception message: Type check failed in binding to parameter '<anon>'; expected Date:D(DateTime) but got Date (Date)
        not ok 1 - type # TODO no proper concreteness check in coerces
        # Failed test 'type'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/APPENDICES/A04-experimental/01-misc.rakudo line 71
            1..2
            ok 1 - '-> Date:D(DateTime:D) {}(Date)' died
            not ok 2 - right exception type (X::Parameter::InvalidConcreteness) # TODO no proper concreteness check in coerces
            # Failed test 'right exception type (X::Parameter::InvalidConcreteness)'
            # at SETTING::src/core.c/Exception.pm6 line 62
            # Expected: X::Parameter::InvalidConcreteness
            # Got:      X::TypeCheck::Binding::Parameter
            # Exception message: Type check failed in binding to parameter '<anon>'; expected Date:D(DateTime:D) but got Date (Date)
        not ok 2 - :D # TODO no proper concreteness check in coerces
        # Failed test ':D'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/APPENDICES/A04-experimental/01-misc.rakudo line 72
            1..2
            ok 1 - '-> Date:D(DateTime:U) {}(Date)' died
            not ok 2 - right exception type (X::Parameter::InvalidConcreteness) # TODO no proper concreteness check in coerces
            # Failed test 'right exception type (X::Parameter::InvalidConcreteness)'
            # at SETTING::src/core.c/Exception.pm6 line 62
            # Expected: X::Parameter::InvalidConcreteness
            # Got:      X::TypeCheck::Binding::Parameter
            # Exception message: Type check failed in binding to parameter '<anon>'; expected Date:D(DateTime:U) but got Date (Date)
        not ok 3 - :U # TODO no proper concreteness check in coerces
        # Failed test ':U'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/APPENDICES/A04-experimental/01-misc.rakudo line 73
            1..2
            ok 1 - '-> Date:D() {}(Date)' died
            ok 2 - right exception type (X::Parameter::InvalidConcreteness)
        ok 4 - implied # TODO no proper concreteness check in coerces
    ok 7 - DefiniteHow target, errors, source is already target
        1..6
Impossible coercion from 'Abyss::Server::Mod::Source' into 'Abyss::Server::Mod::Target:D': no acceptable coercion method found
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/APPENDICES/A04-experimental/01-misc.rakudo line 92
  in sub subtest at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 435
  in sub subtest at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 424
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/APPENDICES/A04-experimental/01-misc.rakudo line 90
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/APPENDICES/A04-experimental/01-misc.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

        1..14
            1..2
            ok 1 - program did not hang
            ok 2 - STDOUT
        ok 1 - no deadlock while acquiring mutex
        ok 2 - Supply.merge on signals does not crash
        ok 3 - Supply.merge on signals does not crash
        ok 4 - Supply.merge on signals handles signal
        ok 5 - dir() does not produce wrong results under concurrent load
        ok 6 - no issues when piping one Proc's STDOUT to another's STDIN
        ok 7 - supply inside sock does not hang
        ok 8 - no serialization crashes with roles and traits
        ok 9 - no crashes with giant enums in packages
        ok 10 - no segfault in a `for` loop + some ops
        ok 11 - no crashes with Whatever curries in topics of for/given statement modifiers
        not ok 12 - collected right amount of characters (with &foo) # TODO https://github.com/rakudo/rakudo/issues/1535
        # Failed test 'collected right amount of characters (with &foo)'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/MISC/bug-coverage-stress.rakudo line 190
        # expected: '4000'
        #      got: '0'
        ok 13 - collected right amount of characters (with { foo })
        ok 14 - no SEGV in curries + with
# FUDGED!
        1..7
            1..6
                1..2
                ok 1 - 'use v6.d; sub meow:sym<bar> {}' died
                ok 2 - right exception type (X::Syntax::Reserved)
            ok 1 - :sym<...>
                1..2
                ok 1 - 'use v6.d; sub meow:sym«bar» {}' died
                ok 2 - right exception type (X::Syntax::Reserved)
            ok 2 - :sym«...»
                1..2
                ok 1 - 'use v6.d; sub meow:foo<bar>:sym<bar> {}' died
                ok 2 - right exception type (X::Syntax::Reserved)
            ok 3 - :foo<bar>:sym<...>
                1..2
                ok 1 - 'use v6.d; sub meow:foo<bar>:sym«bar» {}' died
                ok 2 - right exception type (X::Syntax::Reserved)
            ok 4 - :foo<bar>:sym«...»
                1..2
                ok 1 - 'use v6.d; sub meow:sym<bar>:foo<bar> {}' died
                ok 2 - right exception type (X::Syntax::Reserved)
            ok 5 - :sym<...>:foo<bar>
                1..2
                ok 1 - 'use v6.d; sub meow:sym«bar»:foo<bar> {}' died
                ok 2 - right exception type (X::Syntax::Reserved)
            ok 6 - :sym«...»:foo<bar>
        ok 15 - :sym<> colonpair on subroutine names is reserved
            1..5
            ok 1 - inside MAIN in 6.c language (with @*ARGS content)
            ok 2 - inside MAIN in 6.c language (without @*ARGS content)
            ok 3 - MAIN is an only sub
            ok 4 - MAIN is a multi sub
            ok 5 - no MAIN
        ok 16 - $*ARGFILES is set to $*IN inside sub MAIN
            1..8
            ok 1 - `my` variable
            ok 2 - class attribute
            ok 3 - role attribute
            ok 4 - submethod param
            ok 5 - method param
            ok 6 - sub param
            ok 7 - block param
            ok 8 - native num array unset element
        ok 17 - native num defaults to 0e0
        ok 18 - use of `undefine` issues deprecation warning in 6.d
            1..6
            ok 1 - $() is a List
            ok 2 - $() is a containerized List
            ok 3 - @() is a List
            ok 4 - @() is NOT a containerized List
            ok 5 - %() is a Hash
            ok 6 - @() is NOT a containerized Hash
        ok 19 - $()/@()/%() have no magick
            1..3
                1..14
                ok 1 - sigilless-constant
                ok 2 - $-constant
                ok 3 - sigilless-variable
                ok 4 - $-variable
                ok 5 - @-variable's holes
                ok 6 - %-variable's missing keys
                ok 7 - $ attribute
                ok 8 - @ attribute
                ok 9 - % attribute
                ok 10 - @ param in block
                ok 11 - % param in block
                ok 12 - @ param in sub
                ok 13 - % param in sub
                ok 14 - parametarized Callables are parametarized with smiley
            ok 1 - :D
                1..14
                ok 1 - sigilless-constant
                ok 2 - $-constant
                ok 3 - sigilless-variable
                ok 4 - $-variable
                ok 5 - @-variable's holes
                ok 6 - %-variable's missing keys
                ok 7 - $ attribute
                ok 8 - @ attribute
                ok 9 - % attribute
                ok 10 - # SKIP crashes https://github.com/rakudo/rakudo/issues/2298
                ok 11 - # SKIP crashes https://github.com/rakudo/rakudo/issues/2298
                ok 12 - # SKIP crashes https://github.com/rakudo/rakudo/issues/2298
                ok 13 - # SKIP crashes https://github.com/rakudo/rakudo/issues/2298
                ok 14 - parametarized Callables are parametarized with smiley
            ok 2 - :U
                1..14
                ok 1 - sigilless-constant
                ok 2 - $-constant
                ok 3 - sigilless-variable
                ok 4 - $-variable
                ok 5 - @-variable's holes
                ok 6 - %-variable's missing keys
                ok 7 - $ attribute
                ok 8 - @ attribute
                ok 9 - % attribute
                ok 10 - @ param in block
                ok 11 - % param in block
                ok 12 - @ param in sub
                ok 13 - % param in sub
                ok 14 - parametarized Callables are parametarized with smiley
            ok 3 - :_
        ok 20 - smiley constraints default to type object without smiley
        ok 21 - no crashes when accessing outer lexicals
# FUDGED!
        1..17
        ok 22 - elems
        ok 23 - exists
        ok 24 - nonexists fail
        ok 25 - fetch
        ok 26 - can retro fetch
        ok 27 - retro fetch
        ok 28 - retro elems
        ok 29 - retro exists
        ok 30 - retro nonexists
        ok 31 - can push
        ok 32 - push result via obj
        not ok 33 - push result via array # TODO doesn't work yet due to copying of arrays
        # Failed test 'push result via array'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S01-perl-5-integration/array.rakudo line 81
        # expected: '9'
        #      got: (Any)
Use of uninitialized value of type Any in numeric context
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S01-perl-5-integration/array.rakudo line 88
        not ok 34 - retro push result # TODO doesn't work yet due to copying of arrays
        # Failed test 'retro push result'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S01-perl-5-integration/array.rakudo line 88
        # expected: '9'
        #      got: '0'
        not ok 35 - retro push result # TODO doesn't work yet due to copying of arrays
        # Failed test 'retro push result'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S01-perl-5-integration/array.rakudo line 89
        # expected: '9'
        #      got: (Any)
        ok 36 - can store
        not ok 37 - store result # TODO doesn't work yet due to copying of arrays
        # Failed test 'store result'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S01-perl-5-integration/array.rakudo line 96
        # expected: '3'
        #      got: '5'
        ok 38 - store result
# FUDGED!
        1..3
        ok 39 - # SKIP 
        ok 40 - 
        ok 41 - CLASS:from<Perl5>.new
# FUDGED!
        1..10
        not ok 42 - :context<void> sets void context # TODO 
        # Failed test ':context<void> sets void context'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S01-perl-5-integration/context.rakudo line 21
        # expected: '1'
        #      got: '0'
        ok 43 - :context<scalar> doesn't set void context
        ok 44 - :context<list> doesn't set void context
        not ok 45 - :context<scalar> sets scalar context # TODO 
        # Failed test ':context<scalar> sets scalar context'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S01-perl-5-integration/context.rakudo line 37
        # expected: '1'
        #      got: '0'
        ok 46 - :context<void> doesn't set scalar context
        ok 47 - :context<list> doesn't set scalar context
        ok 48 - :context<list> sets list context
        not ok 49 - :context<scalar> doesn't set list context # TODO 
        # Failed test ':context<scalar> doesn't set list context'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S01-perl-5-integration/context.rakudo line 55
        # expected: '0'
        #      got: '1'
        not ok 50 - :context<void> doesn't set list context # TODO 
        # Failed test ':context<void> doesn't set list context'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S01-perl-5-integration/context.rakudo line 57
        # expected: '0'
        #      got: '1'
        not ok 51 - a p5 sub called in void context returns a Nil # TODO 
        # Failed test 'a p5 sub called in void context returns a Nil'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S01-perl-5-integration/context.rakudo line 60
        # expected: Nil
        #  matcher: 'infix:<===>'
        #      got: [1, 2, 3, 4]
# FUDGED!
        1..2
        not ok 52 - lexical inside an EVAL # TODO 
        # Failed test 'lexical inside an EVAL'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S01-perl-5-integration/eval_lex.rakudo line 15
        # expected: 'self is some text'
        #      got: 'self is '
            1..2
                1..3
                ok 1 - STDOUT has right data
                ok 2 - STDERR is empty
                ok 3 - exitcode is correct
            ok 1 - EVAL
                1..3
                ok 1 - STDOUT has right data
                ok 2 - STDERR is empty
                ok 3 - exitcode is correct
            ok 2 - EVALFILE
        ok 53 - EVAL/EVALFILE evals Buf like perl would execute source file
# FUDGED!
        1..13
        ok 54 - class method
        ok 55 - class is shadowed in Raku
        ok 56 - blessed
        ok 57 - invoke method
        ok 58 - invoke method with Perl arg
        ok 59 - returning a coderef
        ok 60 - invoking p5 coderef
        ok 61 - invoke with p5 coderef
        ok 62 - 
        ok 63 - 
        ok 64 - invoke method with callback
        ok 65 - invoke Raku method from Perl
        not ok 66 - modify a scalar ref # TODO doesn't work yet due to copying of arrays
        # Failed test 'modify a scalar ref'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S01-perl-5-integration/method.rakudo line 136
        # expected: '99'
        #      got: '1'
# FUDGED!
        1..6
        ok 67 - 
        not ok 68 - Null Bytes in the middle of a converted string # TODO NativeCall strings not yet Null safe
        # Failed test 'Null Bytes in the middle of a converted string'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S01-perl-5-integration/strings.rakudo line 14
        # expected: 'Yet Ano ther P erl Hacker'
        #      got: 'Yet Ano'
        ok 69 - utf8 in literals
        ok 70 - Passing simple strings to p5 land
        ok 71 - Passing strings with null bytes to p5 land
        ok 72 - Passing strings with unicode to p5 land
# FUDGED!
        1..110
        ok 73 - unspace with numbers
        ok 74 - unspace with comments
        ok 75 - unspace with strings
        ok 76 - unspace with strings + parens
        ok 77 - (short) unspace with postfix inc
        ok 78 - (short) unspace with postfix inc really postfix
        ok 79 - unspace with postfix inc
        ok 80 - unspace with postfix inc really postfix
        ok 81 - unspace with postfix dec
        ok 82 - unspace with postfix dec really postfix
        ok 83 - unspace without spaces
        ok 84 - unspace with newline
        ok 85 - unspace with adverb
        ok 86 - unspace on postfix subscript
        ok 87 - unspace with postfix pre-dot hyperops
        ok 88 - unspace with postfix pre- and/or post-dot hyperops
assign requires a concrete object (got a Rakudo::Internals::LoweredAwayLexical type object instead)
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-lexical-conventions/unspace.rakudo line 62
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

        1..35
        ok 89 - Basic boolean adverb works
        ok 90 - Negated boolean adverb works
        ok 91 - Adverb with value in parens works
        ok 92 - Adverb with angle quote value works
        ok 93 - ...and does the right thing with the value list
        ok 94 - Adverb with postfix:<[ ]> works
        ok 95 - :abcd works
        ok 96 - :@a works
        ok 97 - :%a works
        ok 98 - :&a works
        ok 99 - Basic numeric adverb works
        ok 100 - Unicode numeric adverb works
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Comp)
        ok 101 - Numeric adverb can't have an extra value
Use of Nil in string context
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-literals/adverbs.rakudo line 32
        ok 102 - Adverb with postfix:<> makes code object
        ok 103 - Adverb with $= twigil works
        ok 104 - Adverb with $? twigil works
        ok 105 - Adverb with $* twigil works
        ok 106 - Adverb with @* twigil works
        ok 107 - Adverb with %* twigil works
        ok 108 - Adverb with $^ twigil works
        ok 109 - Adverb with @^ twigil works
        ok 110 - Adverb with %^ twigil works
        ok 111 - Adverb with $: twigil works
        ok 112 - Adverb with @: twigil works
        ok 113 - Adverb with %: twigil works
        ok 114 - Adverb with $< twigil works
        not ok 115 - Adverb with @< twigil works # TODO :@<...> and :%<...> broken needs RT
        # Failed test 'Adverb with @< twigil works'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-literals/adverbs.rakudo line 58
        # expected: :fie((Match.new(:orig("aaaa"), :from(1), :pos(2)), Match.new(:orig("aaaa"), :from(2), :pos(3))))
        #      got: :fie(Match.new(:orig("aaaa"), :from(1), :pos(3), :list((Match.new(:orig("aaaa"), :from(1), :pos(2)), Match.new(:orig("aaaa"), :from(2), :pos(3))))))
        not ok 116 - Adverb with %< twigil works # TODO :@<...> and :%<...> broken needs RT
        # Failed test 'Adverb with %< twigil works'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-literals/adverbs.rakudo line 59
        # expected: :foe(Map.new((:fum(Match.new(:orig("aaaa"), :from(3), :pos(4))))))
        #      got: :foe(Match.new(:orig("aaaa"), :from(3), :pos(4), :hash(Map.new((:fum(Match.new(:orig("aaaa"), :from(3), :pos(4))))))))
        ok 117 - Adverb with $~ twigil works
        ok 118 - Adverb with @~ twigil works
        ok 119 - Adverb with %~ twigil works
        ok 120 - Adverbs without punctuations is allowed
        ok 121 - Adverbs without punctuations is allowed
        ok 122 - Large numeric adverbs don't error out, and also give the correct value
        ok 123 - lack of comma does not cause LTA error
# FUDGED!
        1..33
        ok 124 - q:to// is singular
        ok 125 - here doc interpolated
        ok 126 - here doc interpolating with indentation
        ok 127 - q:to// is singular, also when indented
        ok 128 - indentation stripped
        ok 129 - q:heredoc// is singular
        ok 130 - backslashes
        ok 131 - indent with multiline interpolation
        ok 132 - indent with multiline interpolation with spaces at the beginning
        ok 133 - extra spaces after interpolation will be kept
        ok 134 - interpolations without constant strings in the middle
        ok 135 - interpolations at the very end
        ok 136 - empty lines
        ok 137 - Tabs get correctly removed
        ok 138 - mixed tabs and spaces get correctly removed
        ok 139 - mixing tabs and spaces even more evil-ly
        ok 140 - Constant heredocs work
        ok 141 - Heredoc leading and trailing empty lines
        ok 142 - Completely empty heredoc
        ok 143 - Heredoc one empty line
        ok 144 - Heredoc two empty lines
        ok 145 - Heredoc tab explosion makefile use case is usesul.
        ok 146 - # SKIP RT  \#131927
        ok 147 - # SKIP RT  \#131927
        ok 148 - # SKIP RT  \#131927
        ok 149 - # SKIP RT  \#131927
        ok 150 - # SKIP RT  \#131927
        ok 151 - # SKIP RT  \#131927
        ok 152 - # SKIP RT  \#131927
        ok 153 - # SKIP RT  \#131927
        ok 154 - # SKIP RT  \#131927
        ok 155 - # SKIP RT  \#131927
        ok 156 - # SKIP RT  \#131927
# FUDGED!
        1..24
        ok 157 - list context <list>
        not ok 158 - listop |<< <list> # TODO meta operators RT #124558
        # Failed test 'listop |<< <list>'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-literals/listquote.rakudo line 16
        # expected: 'xayaz'
        #      got: ''
        ok 159 - .join<abc> parses and fails
        ok 160 - {...}<a b c> is hash subscript
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Syntax::Confused)
        ok 161 - {...} <...> parsefail
        ok 162 - (...) < 3 no parsefail
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Comp)
        ok 163 - ()<3 parsefail
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Syntax::Confused)
        ok 164 - :foo <1 2 3> parsefail
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Multi::NoMatch)
        ok 165 - <3 is comparison, but dies at run time
        ok 166 - :foo<1 2 3> is pair of list
        ok 167 - Hashes with embedded newlines in the list (1)
        ok 168 - Hashes with embedded newlines in the list (2)
        ok 169 - Hashes with embedded newlines in the list (3)
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Obsolete)
        ok 170 - bare <> is disallowed
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Obsolete)
        ok 171 - <STDIN> is disallowed
        ok 172 - <a b c> produces a List
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Immutable)
        ok 173 - ... which is immutable
        ok 174 - <...> numeric literals stringify correctly
        ok 175 - <foo ...> is a Str
        ok 176 - < ... 3 ...> is an Int
        ok 177 - < ... 4.5 ...> is a Rat
        ok 178 - < ... 1.2e1 ...> is a Num
        ok 179 - < ... -2+3i ...> is a Complex
        ok 180 - function call with assignment to list
# FUDGED!
        1..69
        ok 181 - 1 produces a Int
        ok 182 - 1 does Numeric
        ok 183 - 1 does Real
        ok 184 - 1.Num produces a Int
        ok 185 - 1.Num does Numeric
        ok 186 - 1.Num does Real
        ok 187 - <1/2> Rat literal
        ok 188 - <1/2> produces a Rat
        ok 189 - <1/2> does Numeric
        ok 190 - <1/2> does Real
        ok 191 - same with hexadecimal numbers
        not ok 192 - negative allowed only on numerator # TODO Unsure of what's acceptable for val()
        # Failed test 'negative allowed only on numerator'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-literals/numeric.rakudo line 23
        not ok 193 - negative allowed only on numerator # TODO Unsure of what's acceptable for val()
        # Failed test 'negative allowed only on numerator'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-literals/numeric.rakudo line 24
        ok 194 - negative Rat literal
        ok 195 - negative Rat literal
        ok 196 - Rat works with hexadecimal numbers
        ok 197 - Rat works with binary numbers
        not ok 198 - Rat works with colon radix numbers # TODO Adverbial numbers in Rat literals not supported
        # Failed test 'Rat works with colon radix numbers'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-literals/numeric.rakudo line 33
        # expected: '0.142857'
        #      got: ':13<01>/:13<07>'
        not ok 199 - Rat works with colon radix numbers # TODO Adverbial numbers in Rat literals not supported
        # Failed test 'Rat works with colon radix numbers'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-literals/numeric.rakudo line 34
        # expected: '0.231579'
        #      got: ':12<1a>/:12<7b>'
        ok 200 - <1+1i> is a Complex literal
        ok 201 - <+2+2i> is a Complex literal
        ok 202 - <-3+3i> is a Complex literal
        ok 203 - <+4-4i> is a Complex literal
        ok 204 - <-5-5i> is a Complex literal
        ok 205 - 1+1i does Numeric
        ok 206 - 1+1i doesn't do Real
        ok 207 - 1*1i is a Str
        ok 208 - <3+2i> produces correct value
        ok 209 - <+3+2i> produces correct value
        ok 210 - <-3+2i> produces correct value
        ok 211 - <+3-2i> produces correct value
        ok 212 - <-3-2i> produces correct value
        ok 213 - <3.1+2.9i> produces correct value
        ok 214 - +<3.2+2.8i> produces correct value
        ok 215 - -<3.3+2.7i> produces correct value
        ok 216 - +<3.4-2.6i> produces correct value
        ok 217 - -<3.5-2.5i> produces correct value
        ok 218 - <3.1e10+2.9e10i> produces correct value
        ok 219 - <+3.1e+11+2.9e+11i> produces correct value
        ok 220 - <-3.1e+12-2.9e+12i> produces correct value
        ok 221 - <-3.1e-23-2.9e-23i> produces correct real value
        ok 222 - <-3.1e-23-2.9e-23i> produces correct imaginary value
        ok 223 - <3.1e-99+2.9e-99i> produces correct real value
        ok 224 - <3.1e-99+2.9e-99i> produces correct imaginary value
        ok 225 - <NaN+Inf\i> produces correct value
        ok 226 - <NaN-Inf\i> produces correct value
        ok 227 - 0--Inf\i is a Str
        ok 228 - 0++Inf\i is a Str
        ok 229 - 0+-Inf\i is a Str
        ok 230 - 0-+Inf\i is a Str
        ok 231 - --Inf-1i is a Str
        ok 232 - ++Inf-1i is a Str
        ok 233 - +-Inf-1i is a Str
        ok 234 - -+Inf-1i is a Str
        ok 235 - very long Num literals
        ok 236 - parsing 0.000... with 19 decimal places lives
        ok 237 - parsing 0.000... with 20 decimal places lives
        ok 238 - parsing 0.000... with 63 decimal places lives
        ok 239 - parsing 0.000... with 66 decimal places lives
        ok 240 - parsing 0.000... with 1024 decimal places lives
        ok 241 - 0e999999999999 equals zero
        ok 242 - We can handle Unicode digits
        ok 243 - We can handle Unicode non-digit numerics
        ok 244 - We can handle vulgar fractions
        ok 245 - We can multiply cuneiform :-)
        ok 246 - We can write 1 in funny ways too
        ok 247 - yeah, we do that too...
            1..6
            ok 1 - use negation as postfix
            ok 2 - use ~ as postfix
            ok 3 - use « » to wrap the prefix
            ok 4 - use << >> to wrap the prefix
            ok 5 - use [" "] to wrap the prefix
            ok 6 - use <<' '>> to wrap the prefix
        ok 248 -  \#2094 prefix as post fix works on number literals
WARNING: unhandled Failure detected in DESTROY. If you meant to ignore it, you can mark it as handled by calling .Bool, .so, .not, or .defined methods. The Failure was:
Type Str does not support associative indexing.
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-literals/listquote.rakudo line 19
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

            ok 1 - is '123'.Numeric ok?
            ok 2 - is '123'.Int ok?
            ok 3 - is '١٢٣'.Numeric ok?
            ok 4 - is '١٢٣'.Int ok?
            ok 5 - is '۱۲۳'.Numeric ok?
            ok 6 - is '۱۲۳'.Int ok?
            ok 7 - is '߁߂߃'.Numeric ok?
            ok 8 - is '߁߂߃'.Int ok?
            ok 9 - is '१२३'.Numeric ok?
            ok 10 - is '१२३'.Int ok?
            ok 11 - is '১২৩'.Numeric ok?
            ok 12 - is '১২৩'.Int ok?
            ok 13 - is '੧੨੩'.Numeric ok?
            ok 14 - is '੧੨੩'.Int ok?
            ok 15 - is '૧૨૩'.Numeric ok?
            ok 16 - is '૧૨૩'.Int ok?
            ok 17 - is '୧୨୩'.Numeric ok?
            ok 18 - is '୧୨୩'.Int ok?
            ok 19 - is '௧௨௩'.Numeric ok?
            ok 20 - is '௧௨௩'.Int ok?
            ok 21 - is '౧౨౩'.Numeric ok?
            ok 22 - is '౧౨౩'.Int ok?
            ok 23 - is '೧೨೩'.Numeric ok?
            ok 24 - is '೧೨೩'.Int ok?
            ok 25 - is '൧൨൩'.Numeric ok?
            ok 26 - is '൧൨൩'.Int ok?
            ok 27 - is '෧෨෩'.Numeric ok?
            ok 28 - is '෧෨෩'.Int ok?
            ok 29 - is '๑๒๓'.Numeric ok?
            ok 30 - is '๑๒๓'.Int ok?
            ok 31 - is '໑໒໓'.Numeric ok?
            ok 32 - is '໑໒໓'.Int ok?
            ok 33 - is '༡༢༣'.Numeric ok?
            ok 34 - is '༡༢༣'.Int ok?
            1..34
        ok 249 - check simple non-ascii numerification
# FUDGED!
        1..6
        ok 250 - # SKIP postcircumfix:<{ }> not defined for type Array RT  \#125130
        ok 251 - # SKIP postcircumfix:<{ }> not defined for type Array RT  \#125130
        ok 252 - # SKIP isn't the iterator exhausted already, since it's been used previously?
        ok 253 - # SKIP isn't the iterator exhausted already, since it's been used previously?
        ok 254 - # SKIP isn't the iterator exhausted already, since it's been used previously?
        ok 255 - custom named paras with `-` in identifiers works
# FUDGED!
        1..158
        ok 256 - 0xffffffff is parsed right (covers bug on 32bit compilers)
        ok 257 - got the correct int value from decimal 0
        ok 258 - got the correct int value from decimal 1
        ok 259 - got the correct int value from decimal 2
        ok 260 - got the correct int value from decimal 3
        ok 261 - 42 and 0d42 are the same
        ok 262 - :10<42> and 42 are the same
        ok 263 - :10<42> and 0d42 are the same
        ok 264 - :10('01110') is default decimal
        ok 265 - :10('0b1110') overrides default decimal
        ok 266 - :10(':2<1110>') overrides default decimal
        ok 267 - :10('0x20') overrides default decimal
        ok 268 - :10(':16<20>') overrides default decimal
        ok 269 - :10('0o255') overrides default decimal
        ok 270 - :10(':8<255>') overrides default decimal
        ok 271 - :10('0d37') overrides default decimal
        ok 272 - :10(':10<37>') overrides default decimal
            1..5
            ok 1 - ':10(42)' died
            ok 2 - right exception type (X::Numeric::Confused)
            ok 3 - .num matches 42
            ok 4 - .message matches /Int/
            ok 5 - .base matches 10
        ok 273 - :10() really wants a string, not an integer
            1..5
            ok 1 - ':12(42.2)' died
            ok 2 - right exception type (X::Numeric::Confused)
            ok 3 - .base matches 12
            ok 4 - .message matches /Rat/
            ok 5 - .num matches 42.2
        ok 274 - :10() really wants a string, not a rational
            1..5
            ok 1 - ':16(6.02e23)' died
            ok 2 - right exception type (X::Numeric::Confused)
            ok 3 - .base matches 16
            ok 4 - .message matches /Num/
            ok 5 - .num matches 6.02e+23
        ok 275 - :10() really wants a string, not a num
            1..4
            ok 1 - ':10([1,2,3])' died
            ok 2 - right exception type (X::Numeric::Confused)
            ok 3 - .message matches /Array/
            ok 4 - .base matches 10
        ok 276 - :10() really wants a string, not an array
        ok 277 - got the correct int value from hex 0
        ok 278 - got the correct int value from hex 1
        ok 279 - got the correct int value from hex 2
        ok 280 - got the correct int value from hex 3
        ok 281 - got the correct int value from hex 4
        ok 282 - got the correct int value from hex 5
        ok 283 - got the correct int value from hex 6
        ok 284 - got the correct int value from hex 7
        ok 285 - got the correct int value from hex 8
        ok 286 - got the correct int value from hex 9
        ok 287 - got the correct int value from hex A
        ok 288 - got the correct int value from hex B
        ok 289 - got the correct int value from hex C
        ok 290 - got the correct int value from hex D
        ok 291 - got the correct int value from hex E
        ok 292 - got the correct int value from hex F
        ok 293 - got the correct int value from hex a
        ok 294 - got the correct int value from hex b
        ok 295 - got the correct int value from hex c
        ok 296 - got the correct int value from hex d
        ok 297 - got the correct int value from hex e
        ok 298 - got the correct int value from hex f
        ok 299 - got the correct int value from hex 10
        ok 300 - got the correct int value from hex 20
        ok 301 - got the correct int value from hex 30
        ok 302 - got the correct int value from hex 40
        ok 303 - got the correct int value from hex 50
        ok 304 - got the correct int value from hex 100
        ok 305 - got the correct int value from hex FF
        ok 306 - got the correct int value from (mixed case) hex fF
        ok 307 - got the correct int value from hex 2_F_A_C_E_D
        ok 308 - :16('0b1110') uses b as hex digit
        ok 309 - :16('0d37') uses d as hex digit
        ok 310 - :16("0d..") is hex, not decimal
        ok 311 - :16('0fff') defaults to hexadecimal
        ok 312 - :16('0x20') stays hexadecimal
        ok 313 - :16('0o255') converts from octal
        ok 314 - :16(':8<255>') converts from octal
        ok 315 - :16(':2<1110>') overrides default hex
        ok 316 - :16(':10<37>') overrides default hex
        ok 317 - Powers outside same as powers inside
        ok 318 - Zero powers inside
        ok 319 - # SKIP RT  \#123862 - negative radix
        ok 320 - Fractional base 16 works
        ok 321 - got the correct int value from oct 0
        ok 322 - got the correct int value from oct 1
        ok 323 - got the correct int value from oct 2
        ok 324 - got the correct int value from oct 3
        ok 325 - got the correct int value from oct 4
        ok 326 - got the correct int value from oct 5
        ok 327 - got the correct int value from oct 6
        ok 328 - got the correct int value from oct 7
        ok 329 - got the correct int value from oct 10
        ok 330 - got the correct int value from oct 20
        ok 331 - got the correct int value from oct 30
        ok 332 - got the correct int value from oct 40
        ok 333 - got the correct int value from oct 50
        ok 334 - got the correct int value from oct 100
        ok 335 - got the correct int value from oct 77
        ok 336 - got the correct int value from oct 377
        ok 337 - got the correct int value from oct 400
        ok 338 - got the correct int value from oct 177777
        ok 339 - got the correct int value from oct 200000
        ok 340 - :8(0b1110) overrides from default octal
        ok 341 - :8(:2<1110>) overrides from default octal
        ok 342 - :8(0x20) overrides from default octal
        ok 343 - :8(:16<20>) overrides from default octal
        ok 344 - :8(0o377) stays octal
        ok 345 - :8(:8<377>) stays octal
        ok 346 - :8(0d37) overrides from default octal
        ok 347 - :8(:10<37>) overrides from default octal
        ok 348 - got the correct int value from bin 0
        ok 349 - got the correct int value from bin 1
        ok 350 - got the correct int value from bin 10
        ok 351 - got the correct int value from bin 1010
        ok 352 - got the correct int value from bin 11111111111111111111111111111111
        ok 353 - :2<0b1110> stays binary
        ok 354 - :2<0x20> converts from hexadecimal
        ok 355 - :2<0o255> converts from octal
        ok 356 - :2<0d37> converts from decimal
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Syntax::Malformed)
        ok 357 - Ambiguous, illegal syntax doesn't work
        ok 358 - binary number to power of 2
        ok 359 - multiplication and exponentiation
        ok 360 - Power of two in <> works
        ok 361 - # SKIP Really?!
        ok 362 - List of numbers works
        ok 363 - Decimal point in list works
        ok 364 - Adverbial form of base 100 integer works
        ok 365 - Adverbial form of base 100 fraction works
        ok 366 - List of expressions works
        not ok 367 - 32bit and 64bit large radix literals work # TODO This needs an RT
        # Failed test '32bit and 64bit large radix literals work'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-literals/radix.rakudo line 252
        # expected: '18446744073709551617 4294967297'
        #      got: '1 4294967297'
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Method::NotFound)
        ok 368 - 2.e123 parses as method call
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Method::NotFound)
        ok 369 - 2.foo  parses as method call
        ok 370 - Leading zeroes stringify correctly
            1..2
            ok 1 - code dies
            ok 2 - right exception type (Exception)
        ok 371 - :2<2> is illegal
            1..2
            ok 1 - code dies
            ok 2 - right exception type (Exception)
        ok 372 - :10<3a> is illegal
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Syntax::Number::RadixOutOfRange)
        ok 373 - :0<...> is illegal
        ok 374 - Adverbial form of base 2 works
        ok 375 - Adverbial form of base 3 works
        ok 376 - Adverbial form of base 4 works
        ok 377 - Adverbial form of base 5 works
        ok 378 - Adverbial form of base 6 works
        ok 379 - Adverbial form of base 7 works
        ok 380 - Adverbial form of base 8 works
        ok 381 - Adverbial form of base 9 works
        ok 382 - Adverbial form of base 10 works
        ok 383 - Adverbial form of base 11 works
        ok 384 - Adverbial form of base 12 works
        ok 385 - Adverbial form of base 13 works
        ok 386 - Adverbial form of base 14 works
        ok 387 - Adverbial form of base 15 works
        ok 388 - Adverbial form of base 16 works
        ok 389 - Adverbial form of base 17 works
        ok 390 - Adverbial form of base 18 works
        ok 391 - Adverbial form of base 19 works
        ok 392 - Adverbial form of base 20 works
        ok 393 - Adverbial form of base 21 works
        ok 394 - Adverbial form of base 22 works
        ok 395 - Adverbial form of base 23 works
        ok 396 - Adverbial form of base 24 works
        ok 397 - Adverbial form of base 25 works
        ok 398 - Adverbial form of base 26 works
        ok 399 - Adverbial form of base 27 works
        ok 400 - Adverbial form of base 28 works
        ok 401 - Adverbial form of base 29 works
        ok 402 - Adverbial form of base 30 works
        ok 403 - Adverbial form of base 31 works
        ok 404 - Adverbial form of base 32 works
        ok 405 - Adverbial form of base 33 works
        ok 406 - Adverbial form of base 34 works
        ok 407 - Adverbial form of base 35 works
        ok 408 - Adverbial form of base 36 works
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Numeric::Confused)
        ok 409 - :2() is Confused
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Syntax::Malformed)
        ok 410 - :2 is Malformed
        ok 411 - Unicode digit radix bases work
            1..12
                1..3
                ok 1 - ':3<a11>' died
                ok 2 - right exception type (X::Str::Numeric)
                ok 3 - .pos matches 0
            ok 1 - whole part only, start
                1..3
                ok 1 - ':3<1a1>' died
                ok 2 - right exception type (X::Str::Numeric)
                ok 3 - .pos matches 1
            ok 2 - whole part only, middle
                1..3
                ok 1 - ':3<11a>' died
                ok 2 - right exception type (X::Str::Numeric)
                ok 3 - .pos matches 2
            ok 3 - whole part only, end
                1..3
                ok 1 - ':3<a11.111>' died
                ok 2 - right exception type (X::Str::Numeric)
                ok 3 - .pos matches 0
            ok 4 - with fractional part, error in whole part, start
                1..3
                ok 1 - ':3<1a1.111>' died
                ok 2 - right exception type (X::Str::Numeric)
                ok 3 - .pos matches 1
            ok 5 - with fractional part, error in whole part, middle
                1..3
                ok 1 - ':3<11a.111>' died
                ok 2 - right exception type (X::Str::Numeric)
                ok 3 - .pos matches 2
            ok 6 - with fractional part, error in whole part, end
                1..3
                ok 1 - ':3<111.a11>' died
                ok 2 - right exception type (X::Str::Numeric)
                ok 3 - .pos matches 4
            ok 7 - with fractional part, error in fractional part, start
                1..3
                ok 1 - ':3<111.1a1>' died
                ok 2 - right exception type (X::Str::Numeric)
                ok 3 - .pos matches 5
            ok 8 - with fractional part, error in fractional part, middle
                1..3
                ok 1 - ':3<111.11a>' died
                ok 2 - right exception type (X::Str::Numeric)
                ok 3 - .pos matches 6
            ok 9 - with fractional part, error in fractional part, end
                1..3
                ok 1 - ':3<a11.a11>' died
                ok 2 - right exception type (X::Str::Numeric)
                ok 3 - .pos matches 0
            ok 10 - with fractional part, error in both parts, start
                1..3
                ok 1 - ':3<1a1.1a1>' died
                ok 2 - right exception type (X::Str::Numeric)
                ok 3 - .pos matches 1
            ok 11 - with fractional part, error in both parts, middle
                1..3
                ok 1 - ':3<11a.1a1>' died
                ok 2 - right exception type (X::Str::Numeric)
                ok 3 - .pos matches 2
            ok 12 - with fractional part, error in both parts, end
        ok 412 - sane errors on failures to parse rad numbers
            1..10
            ok 1 - bad digit in whole part (1)
            ok 2 - bad digit in whole part (2)
            ok 3 - bad digit in whole part (3)
            ok 4 - bad digit in fractional part (1)
            ok 5 - bad digit in fractional part (2)
            ok 6 - bad digit in fractional part (3)
            ok 7 - bad digit in both parts (1)
            ok 8 - bad digit in both part (2)
            ok 9 - bad digit in both part (3)
            ok 10 - .substr with Num arg does not hang
        ok 413 - no hangs in bad digits in rad numbers / in .substr
# FUDGED!
        1..31
        ok 414 - version literal stringification
        ok 415 - version literal stringification
        ok 416 - version literal stringification
        ok 417 - eqv works on version literals (+)
        ok 418 - eqv works on version literals (-)
        ok 419 - + makes a difference in eqv
        ok 420 - version literals are value types
        ok 421 - === (-)
        ok 422 - smart-matching (same)
        ok 423 - smart-matching (different)
        ok 424 - smart-matching treats trailing 0 correctly (left)
        ok 425 - smart-matching treats trailing 0 correctly (right)
        ok 426 - smart-matching and plus (+1)
        ok 427 - smart-matching and plus (+2)
        ok 428 - + scopes to the whole version, not just the last chunk
        ok 429 - * wildcard (1+)
        ok 430 - * wildcard (2+)
        ok 431 - * wildcard (-)
        ok 432 - smart-matching and plus (-)
        ok 433 - smart-matching only cares about the length of the LHS
        ok 434 - ... but it can still fail
        ok 435 - cmp: Same
        ok 436 - cmp: Less
        ok 437 - cmp: More
        ok 438 - cmp isn't Stringy-based
        not ok 439 - trailing zeroes are equivalent # TODO trailing zeroes fail
        # Failed test 'trailing zeroes are equivalent'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-literals/version.rakudo line 31
        not ok 440 - trailing zeroes are equivalent # TODO trailing zeroes fail
        # Failed test 'trailing zeroes are equivalent'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-literals/version.rakudo line 32
        not ok 441 - trailing zeroes are equivalent # TODO trailing zeroes fail
        # Failed test 'trailing zeroes are equivalent'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-literals/version.rakudo line 33
        ok 442 - can we handle empty string versions
        ok 443 - can we handle empty string versions
        ok 444 - can we handle a bare Whatever
# FUDGED!
        1..28
        ok 445 - # SKIP unimpl $?DISTRO RT  \#124624
        ok 446 - # SKIP unimpl $?DISTRO RT  \#124624
        ok 447 - # SKIP unimpl $?DISTRO RT  \#124624
        ok 448 - # SKIP unimpl $?DISTRO RT  \#124624
        ok 449 - # SKIP unimpl $?DISTRO RT  \#124624
        ok 450 - # SKIP unimpl $?DISTRO RT  \#124624
        ok 451 - # SKIP unimpl $?DISTRO RT  \#124624
        ok 452 - # SKIP unimpl $?DISTRO RT  \#124624
        ok 453 - # SKIP unimpl $?DISTRO RT  \#124624
        ok 454 - # SKIP unimpl $?DISTRO RT  \#124624
        ok 455 - # SKIP unimpl $?DISTRO RT  \#124624
        ok 456 - # SKIP unimpl $?DISTRO RT  \#124624
        ok 457 - # SKIP unimpl $?DISTRO RT  \#124624
        ok 458 - # SKIP unimpl $?DISTRO RT  \#124624
        ok 459 - We are running under 'macos'
        ok 460 - Authority is 'Apple Inc.'
        ok 461 - Version is '11.2'
Use of uninitialized value of type Blob in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-magicals/DISTRO.rakudo line 47
        not ok 462 - Signature is '' # TODO no Distro.signature yet RT #124624
        # Failed test 'Signature is '''
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-magicals/DISTRO.rakudo line 47
        ok 463 - Description is 'unknown'
        ok 464 - Release info is '20D64'
        ok 465 - Path separator is ':'
        ok 466 - We can do a $*DISTRO.raku
        ok 467 - We can do a $*DISTRO.gist
        ok 468 - We can do a $*DISTRO.Str
        ok 469 - Non-empty $*DISTRO.name
        ok 470 - The object is-a 'Version'
        ok 471 - The object is-a 'Blob'
        ok 472 - The object is-a 'Bool'
# FUDGED!
        1..42
        ok 473 - # SKIP unimpl $?KERNEL RT  \#124624
        ok 474 - # SKIP unimpl $?KERNEL RT  \#124624
        ok 475 - # SKIP unimpl $?KERNEL RT  \#124624
        ok 476 - # SKIP unimpl $?KERNEL RT  \#124624
        ok 477 - # SKIP unimpl $?KERNEL RT  \#124624
        ok 478 - # SKIP unimpl $?KERNEL RT  \#124624
        ok 479 - # SKIP unimpl $?KERNEL RT  \#124624
        ok 480 - # SKIP unimpl $?KERNEL RT  \#124624
        ok 481 - # SKIP unimpl $?KERNEL RT  \#124624
        ok 482 - # SKIP unimpl $?KERNEL RT  \#124624
        ok 483 - # SKIP unimpl $?KERNEL RT  \#124624
        ok 484 - # SKIP unimpl $?KERNEL RT  \#124624
        ok 485 - # SKIP unimpl $?KERNEL RT  \#124624
        ok 486 - # SKIP unimpl $?KERNEL RT  \#124624
        ok 487 - # SKIP unimpl $?KERNEL RT  \#124624
        ok 488 - # SKIP unimpl $?KERNEL RT  \#124624
        ok 489 - We are running under 'darwin'
        ok 490 - Authority is 'unknown'
        ok 491 - Version is 'Darwin.Kernel.Version.20.3.0.Thu.Jan.21.00.07.06.PST.2021.root.xnu.7195.81.3.1.RELEASE_X.86._.64'
Use of uninitialized value of type Blob in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-magicals/KERNEL.rakudo line 39
        not ok 492 - Signature is '' # TODO no Kernel.signature yet RT #124624
        # Failed test 'Signature is '''
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-magicals/KERNEL.rakudo line 39
Use of uninitialized value of type Str in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-magicals/KERNEL.rakudo line 42
        not ok 493 - Description is '' # TODO no Kernel.desc yet RT #124624
        # Failed test 'Description is '''
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-magicals/KERNEL.rakudo line 42
        ok 494 - Release info is '20.3.0'
        ok 495 - Hardware info is 'x86_64'
        ok 496 - Architecture info is 'i386'
        ok 497 - Number of bits is '64'
        ok 498 - Hostname is 'ookurakaitonoMacBook-Pro-2.local'
        ok 499 - We can do a $*KERNEL.raku
        ok 500 - We can do a $*KERNEL.gist
        ok 501 - We can do a $*KERNEL.Str
        ok 502 - We know of the KERNEL we are running under
        ok 503 - The object is-a 'Version'
        ok 504 - The object is-a 'Blob'
        ok 505 - The object is-a 'Int'
        ok 506 - did Kernel.signals return a list
        ok 507 - do we have Signals only?  and Any's of course
        ok 508 - did we get an Int back
        ok 509 - was the Int defined
        ok 510 - no signal should come out as 0
        ok 511 - also ok as string?
        ok 512 - also ok as partial string?
        ok 513 - also ok as Int?
        ok 514 - .signal: Str:D works with un-initialized $*KERNEL.signals
# FUDGED!
        1..46
        ok 515 - # SKIP unimpl $?PERL RT  \#124624
        ok 516 - # SKIP unimpl $?PERL RT  \#124624
        ok 517 - # SKIP unimpl $?PERL RT  \#124624
        ok 518 - # SKIP unimpl $?PERL RT  \#124624
        ok 519 - # SKIP unimpl $?PERL RT  \#124624
        ok 520 - # SKIP unimpl $?PERL RT  \#124624
        ok 521 - # SKIP unimpl $?PERL RT  \#124624
        ok 522 - # SKIP unimpl $?PERL RT  \#124624
        ok 523 - # SKIP unimpl $?PERL RT  \#124624
        ok 524 - # SKIP unimpl $?PERL RT  \#124624
        ok 525 - # SKIP unimpl $?PERL RT  \#124624
        ok 526 - # SKIP unimpl $?PERL RT  \#124624
        ok 527 - # SKIP unimpl $?PERL RT  \#124624
        ok 528 - # SKIP unimpl $?PERL RT  \#124624
        ok 529 - # SKIP unimpl $?PERL RT  \#124624
        ok 530 - # SKIP unimpl $?PERL RT  \#124624
        ok 531 - # SKIP unimpl $?PERL RT  \#124624
        ok 532 - # SKIP unimpl $?PERL RT  \#124624
        ok 533 - # SKIP unimpl $?PERL RT  \#124624
        ok 534 - # SKIP unimpl $?PERL RT  \#124624
        ok 535 - # SKIP unimpl $?PERL RT  \#124624
        ok 536 - # SKIP unimpl $?PERL RT  \#124624
        ok 537 - # SKIP unimpl $?PERL RT  \#124624
        ok 538 - We are running under 'Raku'
        ok 539 - Authority is 'The Perl Foundation'
        ok 540 - Version is '6.d'
Use of uninitialized value of type Blob in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-magicals/PERL.rakudo line 47
        not ok 541 - Signature is '' # TODO no Perl.signature yet RT #124624
        # Failed test 'Signature is '''
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-magicals/PERL.rakudo line 47
Use of uninitialized value of type Str in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-magicals/PERL.rakudo line 50
        not ok 542 - Description is '' # TODO no Perl.desc yet RT #124624
        # Failed test 'Description is '''
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-magicals/PERL.rakudo line 50
        ok 543 - Has compiler info
        ok 544 - We can do a $*PERL.raku
        ok 545 - We can do a $*PERL.gist
        ok 546 - We can do a $*PERL.Str
        ok 547 - The object is-a 'Version'
        ok 548 - The object is-a 'Blob'
        ok 549 - The object is-a 'Compiler'
        ok 550 - We were compiled in 'rakudo'
        ok 551 - Authority is 'The Perl Foundation'
        ok 552 - Version is '2020.12.108.g.297.cba.1.a.1'
Use of uninitialized value of type Blob in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-magicals/PERL.rakudo line 68
        not ok 553 - Signature is '' # TODO no Perl.compiler.signature yet RT #124624
        # Failed test 'Signature is '''
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-magicals/PERL.rakudo line 68
Use of uninitialized value of type Str in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-magicals/PERL.rakudo line 71
        not ok 554 - Description is '' # TODO no Perl.compiler.desc yet RT #124624
        # Failed test 'Description is '''
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-magicals/PERL.rakudo line 71
        not ok 555 - Release is '' # TODO no Perl.compiler.release yet RT #124624
        # Failed test 'Release is '''
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-magicals/PERL.rakudo line 74
        not ok 556 - Codename is '' # TODO no Perl.compiler.codename yet RT #124624
        # Failed test 'Codename is '''
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-magicals/PERL.rakudo line 77
        ok 557 - We can do a $?PERL.compiler.raku
        ok 558 - We can do a $?PERL.compiler.gist
        ok 559 - The object is-a 'Version'
        ok 560 - The object is-a 'Blob'
# FUDGED!
        1..46
        ok 561 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 562 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 563 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 564 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 565 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 566 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 567 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 568 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 569 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 570 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 571 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 572 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 573 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 574 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 575 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 576 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 577 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 578 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 579 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 580 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 581 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 582 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 583 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 584 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 585 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 586 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 587 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 588 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 589 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 590 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 591 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 592 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 593 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 594 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 595 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 596 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 597 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 598 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 599 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 600 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 601 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 602 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 603 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 604 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 605 - # SKIP $*RAKU and $?RAKU aren't implemented yet
        ok 606 - # SKIP $*RAKU and $?RAKU aren't implemented yet
# FUDGED!
        1..32
        ok 607 - # SKIP unimpl $?VM
No such method 'properties' for invocant of type 'VM'
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-magicals/VM.rakudo line 14
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-magicals/VM.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

WARNINGS for /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-magicals/env.rakudo:
Useless use of constant integer 1 in sink context (line 74)
        1..18
        ok 608 - %*ENV has keys
        ok 609 - %*ENV was successfully copied into another variable
        ok 610 - modifying a copy of %*ENV didn't affect the environment
        # %*ENV<PUGS_ROCKS>=
        ok 611 - there's no env variable 'PUGS_ROCKS'
        # %*ENV<PUGS_ROCKS>=
        ok 612 - there's still no env variable 'PUGS_ROCKS'
        ok 613 - %*ENV is rw
        ok 614 - We can remove keys from %*ENV
        ok 615 - exists() returns false on a not defined env var
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Undeclared)
        ok 616 - %ENV not visible by default
        ok 617 - # SKIP import fails, ENV not available: RT  \#122339
        ok 618 - %ENV not visible by after lexical import scope
        ok 619 - non-existing vars are undefined
        ok 620 - non-existing vars do not exist
        ok 621 - ENV members persist to child processes
        ok 622 - %*ENV.gist generates something with ABC in it
        ok 623 - %*ENV.raku generates something with ABC in it
        ok 624 - itemizer works on %*ENV.
Welcome to Rakudo(tm) v2020.12-108-g297cba1a1.
Implementing the Raku(tm) programming language v6.d.
Built on MoarVM version 2020.12-90-g1082d8893.
        ok 625 - call run($command) after setting non-strings into %*ENV does not die
# FUDGED!
        1..156
        ok 626 - basic variable name
        ok 627 - variable name with package
        ok 628 - # SKIP package variable autovivification
        ok 629 - variable name with 2 deep package
        ok 630 - # SKIP package variable autovivification
        ok 631 - variable name with a package name partially given by a variable 
        ok 632 - variable name with package name completely given by variable
        ok 633 - simple variable lookup
        ok 634 - # SKIP this kind of lookup NYI RT  \#125659
        ok 635 - variable lookup using ::{'$foo'}
        ok 636 - # SKIP this kind of lookup NYI RT  \#125659
        ok 637 - variable lookup using ::<$foo>
        ok 638 - # SKIP ::{ } package lookup NYI
        ok 639 - # SKIP ::{ } package lookup NYI
        ok 640 - # SKIP ::{ } package lookup NYI
        ok 641 - # SKIP ::{ } package lookup NYI
        ok 642 - A::_b() call works
        ok 643 - :: is a valid PseudoStash
            1..2
            ok 1 - 'OscarMikeGolf::whiskey_tango_foxtrot()' died
            ok 2 - right exception type (Exception)
        ok 644 - dies when calling non-existent sub in non-existent package
            1..2
            ok 1 - 'Test::bravo_bravo_quebec()' died
            ok 2 - right exception type (Exception)
        ok 645 - dies when calling non-existent sub in existing package
            1..2
            ok 1 - 'TestA::frobnosticate(3, :foo)' died
            ok 2 - right exception type (Exception)
        ok 646 - calling non-existing function in foreign class dies
        not ok 647 - can define and call a sub self()
        # Failed test 'can define and call a sub self()'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names-vars/names.rakudo line 83
        # expected: '4'
        #      got: (Rakudo::Internals::LoweredAwayLexical(Any))
        ok 648 - sub named "foo" called with parentheses
        ok 649 - sub whose name starts with "foo-"
        ok 650 - sub whose name starts with "foo'"
        ok 651 - sub named "package" called with parentheses
        ok 652 - sub whose name starts with "package-"
        ok 653 - sub whose name starts with "package'"
        ok 654 - sub named "module" called with parentheses
        ok 655 - sub whose name starts with "module-"
        ok 656 - sub whose name starts with "module'"
        ok 657 - sub named "class" called with parentheses
        ok 658 - sub whose name starts with "class-"
        ok 659 - sub whose name starts with "class'"
        ok 660 - sub named "role" called with parentheses
        ok 661 - sub whose name starts with "role-"
        ok 662 - sub whose name starts with "role'"
        ok 663 - sub named "grammar" called with parentheses
        ok 664 - sub whose name starts with "grammar-"
        ok 665 - sub whose name starts with "grammar'"
        ok 666 - sub named "my" called with parentheses
        ok 667 - sub whose name starts with "my-"
        ok 668 - sub whose name starts with "my'"
        ok 669 - sub named "our" called with parentheses
        ok 670 - sub whose name starts with "our-"
        ok 671 - sub whose name starts with "our'"
        ok 672 - sub named "state" called with parentheses
        ok 673 - sub whose name starts with "state-"
        ok 674 - sub whose name starts with "state'"
        ok 675 - sub named "let" called with parentheses
        ok 676 - sub whose name starts with "let-"
        ok 677 - sub whose name starts with "let'"
        ok 678 - sub named "temp" called with parentheses
        ok 679 - sub whose name starts with "temp-"
        ok 680 - sub whose name starts with "temp'"
        ok 681 - sub named "has" called with parentheses
        ok 682 - sub whose name starts with "has-"
        ok 683 - sub whose name starts with "has'"
        ok 684 - sub named "augment" called with parentheses
        ok 685 - sub whose name starts with "augment-"
        ok 686 - sub whose name starts with "augment'"
        ok 687 - sub named "anon" called with parentheses
        ok 688 - sub whose name starts with "anon-"
        ok 689 - sub whose name starts with "anon'"
        ok 690 - sub named "supersede" called with parentheses
        ok 691 - sub whose name starts with "supersede-"
        ok 692 - sub whose name starts with "supersede'"
        ok 693 - sub named "sub" called with parentheses
        ok 694 - sub whose name starts with "sub-"
        ok 695 - sub whose name starts with "sub'"
        ok 696 - sub named "method" called with parentheses
        ok 697 - sub whose name starts with "method-"
        ok 698 - sub whose name starts with "method'"
        ok 699 - sub named "submethod" called with parentheses
        ok 700 - sub whose name starts with "submethod-"
        ok 701 - sub whose name starts with "submethod'"
        ok 702 - sub named "macro" called with parentheses
        ok 703 - sub whose name starts with "macro-"
        ok 704 - sub whose name starts with "macro'"
        ok 705 - sub named "multi" called with parentheses
        ok 706 - sub whose name starts with "multi-"
        ok 707 - sub whose name starts with "multi'"
        ok 708 - sub named "proto" called with parentheses
        ok 709 - sub whose name starts with "proto-"
        ok 710 - sub whose name starts with "proto'"
        ok 711 - sub named "only" called with parentheses
        ok 712 - sub whose name starts with "only-"
        ok 713 - sub whose name starts with "only'"
        ok 714 - sub named "regex" called with parentheses
        ok 715 - sub whose name starts with "regex-"
        ok 716 - sub whose name starts with "regex'"
        ok 717 - sub named "token" called with parentheses
        ok 718 - sub whose name starts with "token-"
        ok 719 - sub whose name starts with "token'"
        ok 720 - sub named "rule" called with parentheses
        ok 721 - sub whose name starts with "rule-"
        ok 722 - sub whose name starts with "rule'"
        ok 723 - sub named "constant" called with parentheses
        ok 724 - sub whose name starts with "constant-"
        ok 725 - sub whose name starts with "constant'"
        ok 726 - sub named "enum" called with parentheses
        ok 727 - sub whose name starts with "enum-"
        ok 728 - sub whose name starts with "enum'"
        ok 729 - sub named "subset" called with parentheses
        ok 730 - sub whose name starts with "subset-"
        ok 731 - sub whose name starts with "subset'"
        ok 732 - sub named "if" called with parentheses
        ok 733 - sub whose name starts with "if-"
        ok 734 - sub whose name starts with "if'"
        ok 735 - sub named "unless" called with parentheses
        ok 736 - sub whose name starts with "unless-"
        ok 737 - sub whose name starts with "unless'"
        ok 738 - sub named "while" called with parentheses
        ok 739 - sub whose name starts with "while-"
        ok 740 - sub whose name starts with "while'"
        ok 741 - sub named "repeat" called with parentheses
        ok 742 - sub whose name starts with "repeat-"
        ok 743 - sub whose name starts with "repeat'"
        ok 744 - sub named "for" called with parentheses
        ok 745 - sub whose name starts with "for-"
        ok 746 - sub whose name starts with "for'"
        ok 747 - sub named "foreach" called with parentheses
        ok 748 - sub whose name starts with "foreach-"
        ok 749 - sub whose name starts with "foreach'"
        ok 750 - sub named "loop" called with parentheses
        ok 751 - sub whose name starts with "loop-"
        ok 752 - sub whose name starts with "loop'"
        ok 753 - sub named "given" called with parentheses
        ok 754 - sub whose name starts with "given-"
        ok 755 - sub whose name starts with "given'"
        ok 756 - sub named "when" called with parentheses
        ok 757 - sub whose name starts with "when-"
        ok 758 - sub whose name starts with "when'"
        ok 759 - sub named "default" called with parentheses
        ok 760 - sub whose name starts with "default-"
        ok 761 - sub whose name starts with "default'"
        ok 762 - local terms override quoters
        ok 763 - local subs override quoters
        ok 764 - rule => something creates a Pair
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Undeclared::Symbols)
        ok 765 - error message mentions name not recognized, no maximum recursion depth exceeded
        ok 766 - class names can start with Q
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Redeclaration)
        ok 767 - can *not* redefine a class in EVAL -- classes are package scoped
        ok 768 - can call a class Class
            1..2
            ok 1 - 'my ::foo $x, say $x' died
            ok 2 - right exception type (Exception)
        ok 769 - no Null PMC access when printing a variable typed as ::foo 
        ok 770 - when enum and sub Day exported, Day(0) is enum coercer
        ok 771 - can get sub using & to disamgibuate
        ok 772 - when module and sub foo, bare foo is module type object
        ok 773 - when module and sub foo, foo() is coercion type
        ok 774 - can get sub using & to disambiguate
            1..2
            ok 1 - variable lookup
            ok 2 - literal lookup
        ok 775 - can use compile-time variables in names
        ok 776 - properly short name Metamodel instances
        ok 777 - properly short name Metamodel instances with braces
        ok 778 - properly short name Metamodel instances with colons and braces
        ok 779 - properly short name Metamodel instances with braces and commas
        ok 780 - properly short name Metamodel instances with colons, braces, and commas
        ok 781 - properly short name Metamodel instances with nested colons, braces, and commas
# FUDGED!
        1..116
        ok 782 - ("42").raku returned something whose EVAL()ed stringification is unchanged
        ok 783 - ("42").raku returned something whose EVAL()ed .WHAT is unchanged
        ok 784 - ("4.2").raku returned something whose EVAL()ed stringification is unchanged
        ok 785 - ("4.2").raku returned something whose EVAL()ed .WHAT is unchanged
        ok 786 - ("4.2").raku returned something whose EVAL()ed stringification is unchanged
        ok 787 - ("4.2").raku returned something whose EVAL()ed .WHAT is unchanged
        ok 788 - ("1.4142135623730951").raku returned something whose EVAL()ed stringification is unchanged
        ok 789 - ("1.4142135623730951").raku returned something whose EVAL()ed .WHAT is unchanged
        ok 790 - ("300000").raku returned something whose EVAL()ed stringification is unchanged
        ok 791 - ("300000").raku returned something whose EVAL()ed .WHAT is unchanged
        ok 792 - ("Inf").raku returned something whose EVAL()ed stringification is unchanged
        ok 793 - ("Inf").raku returned something whose EVAL()ed .WHAT is unchanged
        ok 794 - ("-Inf").raku returned something whose EVAL()ed stringification is unchanged
        ok 795 - ("-Inf").raku returned something whose EVAL()ed .WHAT is unchanged
        ok 796 - ("NaN").raku returned something whose EVAL()ed stringification is unchanged
        ok 797 - ("NaN").raku returned something whose EVAL()ed .WHAT is unchanged
        ok 798 - ("a string").raku returned something whose EVAL()ed stringification is unchanged
        ok 799 - ("a string").raku returned something whose EVAL()ed .WHAT is unchanged
        ok 800 - ("").raku returned something whose EVAL()ed stringification is unchanged
        ok 801 - ("").raku returned something whose EVAL()ed .WHAT is unchanged
        ok 802 - ("\0").raku returned something whose EVAL()ed stringification is unchanged
        ok 803 - ("\0").raku returned something whose EVAL()ed .WHAT is unchanged
        ok 804 - ("\t").raku returned something whose EVAL()ed stringification is unchanged
        ok 805 - ("\t").raku returned something whose EVAL()ed .WHAT is unchanged
        ok 806 - ("␤").raku returned something whose EVAL()ed stringification is unchanged
        ok 807 - ("␤").raku returned something whose EVAL()ed .WHAT is unchanged
        ok 808 - ("␤").raku returned something whose EVAL()ed stringification is unchanged
        ok 809 - ("␤").raku returned something whose EVAL()ed .WHAT is unchanged
        ok 810 - ("\x[7]").raku returned something whose EVAL()ed stringification is unchanged
        ok 811 - ("\x[7]").raku returned something whose EVAL()ed .WHAT is unchanged
        ok 812 - ("\{").raku returned something whose EVAL()ed stringification is unchanged
        ok 813 - ("\{").raku returned something whose EVAL()ed .WHAT is unchanged
        ok 814 - ("}").raku returned something whose EVAL()ed stringification is unchanged
        ok 815 - ("}").raku returned something whose EVAL()ed .WHAT is unchanged
        ok 816 - ("\$a \@string \%with \&sigils()").raku returned something whose EVAL()ed stringification is unchanged
        ok 817 - ("\$a \@string \%with \&sigils()").raku returned something whose EVAL()ed .WHAT is unchanged
        ok 818 - ("שלום").raku returned something whose EVAL()ed stringification is unchanged
        ok 819 - ("שלום").raku returned something whose EVAL()ed .WHAT is unchanged
        ok 820 - ("True").raku returned something whose EVAL()ed stringification is unchanged
        ok 821 - ("True").raku returned something whose EVAL()ed .WHAT is unchanged
        ok 822 - ("False").raku returned something whose EVAL()ed stringification is unchanged
        ok 823 - ("False").raku returned something whose EVAL()ed .WHAT is unchanged
Regex object coerced to string (please use .gist or .raku to do that)
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names-vars/perl.rakudo line 56
        ok 824 - ("").raku returned something whose EVAL()ed stringification is unchanged
        ok 825 - ("").raku returned something whose EVAL()ed .WHAT is unchanged
Regex object coerced to string (please use .gist or .raku to do that)
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names-vars/perl.rakudo line 56
        ok 826 - ("").raku returned something whose EVAL()ed stringification is unchanged
        ok 827 - ("").raku returned something whose EVAL()ed .WHAT is unchanged
Regex object coerced to string (please use .gist or .raku to do that)
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names-vars/perl.rakudo line 56
        ok 828 - ("").raku returned something whose EVAL()ed stringification is unchanged
        ok 829 - ("").raku returned something whose EVAL()ed .WHAT is unchanged
        ok 830 - ("42").raku returned something whose EVAL()ed stringification is unchanged
        ok 831 - ("42").raku returned something whose EVAL()ed .WHAT is unchanged
        ok 832 - ("Inf").raku returned something whose EVAL()ed stringification is unchanged
        ok 833 - ("Inf").raku returned something whose EVAL()ed .WHAT is unchanged
        ok 834 - ("-Inf").raku returned something whose EVAL()ed stringification is unchanged
        ok 835 - ("-Inf").raku returned something whose EVAL()ed .WHAT is unchanged
        ok 836 - ("NaN").raku returned something whose EVAL()ed stringification is unchanged
        ok 837 - ("NaN").raku returned something whose EVAL()ed .WHAT is unchanged
        ok 838 - ("string").raku returned something whose EVAL()ed stringification is unchanged
        ok 839 - ("string").raku returned something whose EVAL()ed .WHAT is unchanged
        ok 840 - ("").raku returned something whose EVAL()ed stringification is unchanged
        ok 841 - ("").raku returned something whose EVAL()ed .WHAT is unchanged
        ok 842 - ("True").raku returned something whose EVAL()ed stringification is unchanged
        ok 843 - ("True").raku returned something whose EVAL()ed .WHAT is unchanged
        ok 844 - ("False").raku returned something whose EVAL()ed stringification is unchanged
        ok 845 - ("False").raku returned something whose EVAL()ed .WHAT is unchanged
Use of uninitialized value of type Mu in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names-vars/perl.rakudo line 56
        ok 846 - ("").raku returned something whose EVAL()ed stringification is unchanged
        ok 847 - ("").raku returned something whose EVAL()ed .WHAT is unchanged
        ok 848 - ("a\t1").raku returned something whose EVAL()ed stringification is unchanged
        ok 849 - ("a\t1").raku returned something whose EVAL()ed .WHAT is unchanged
        ok 850 - ("b\t2").raku returned something whose EVAL()ed stringification is unchanged
        ok 851 - ("b\t2").raku returned something whose EVAL()ed .WHAT is unchanged
        ok 852 - ("").raku returned something whose EVAL()ed stringification is unchanged
        ok 853 - ("").raku returned something whose EVAL()ed .WHAT is unchanged
        ok 854 - ("a\t42").raku returned something whose EVAL()ed stringification is unchanged
        ok 855 - ("a\t42").raku returned something whose EVAL()ed .WHAT is unchanged
        ok 856 - ("a\t1␤b\t2\nc\t3").raku returned something whose EVAL()ed stringification is unchanged
        ok 857 - ("a\t1␤b\t2\nc\t3").raku returned something whose EVAL()ed .WHAT is unchanged
        ok 858 - ("a\t1 2 3").raku returned something whose EVAL()ed stringification is unchanged
        ok 859 - ("a\t1 2 3").raku returned something whose EVAL()ed .WHAT is unchanged
        ok 860 - ("a\t1 2 3␤b\t4 5 6").raku returned something whose EVAL()ed stringification is unchanged
        ok 861 - ("a\t1 2 3␤b\t4 5 6").raku returned something whose EVAL()ed .WHAT is unchanged
        ok 862 - ("a\t1 b\t2␤c\t3").raku returned something whose EVAL()ed stringification is unchanged
        ok 863 - ("a\t1 b\t2␤c\t3").raku returned something whose EVAL()ed .WHAT is unchanged
        ok 864 - ("a b c").raku returned something whose EVAL()ed stringification is unchanged
        ok 865 - ("a b c").raku returned something whose EVAL()ed .WHAT is unchanged
        ok 866 - basic recursive hashitem
        ok 867 - .raku worked correctly on a recursive hashitem
        ok 868 - mixed arrayitem/hashitem recursive structure
        ok 869 - .raku worked correctly on a mixed arrayitem/hashitem recursive structure
(my \Abyss::Server::Mod::Bug_140195772882936 = Abyss::Server::Mod::Bug.new(myself => [Abyss::Server::Mod::Bug_140195772882936]))
        ok 870 - survived saying a self-referencing object
(my \Abyss::Server::Mod::Location_140195772883056 = Abyss::Server::Mod::Location.new(items => Array[Abyss::Server::Mod::Item].new(Abyss::Server::Mod::Item.new(loc => Abyss::Server::Mod::Location_140195772883056))))
        ok 871 - survived saying two mutually referencing objects
        ok 872 - .raku on a .keys list
        ok 873 - changing object changes .raku output
        ok 874 - attribute value appears in .raku output
Could not find symbol '&RT61918' in 'Abyss::Server::Mod'
  in block <unit> at EVAL_343 line 1
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names-vars/perl.rakudo line 155
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names-vars/perl.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

        1..29
        ok 875 - $! can be declared again
        ok 876 - as can $/
        ok 877 - S05: Raku's $/ variable may not be assigned to directly.
        ok 878 - $! can be declared again if proto is used though
        ok 879 - as can $/
            1..2
            ok 1 - code dies
            ok 2 - right exception type (Exception)
        ok 880 - normal varnames can't have ! in their name
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Syntax::Confused)
        ok 881 - var names can't have double colons in their adverb
            1..3
            ok 1 - 'my Int a = 10;' died
            ok 2 - right exception type (X::Syntax::Malformed)
            ok 3 - .message matches / sigilless /
        ok 882 - did we throws-like X::Syntax::Malformed?
            1..3
            ok 1 - 'my Int a;' died
            ok 2 - right exception type (X::Syntax::Malformed)
            ok 3 - .message matches / sigilless /
        ok 883 - did we throws-like X::Syntax::Malformed?
            1..3
            ok 1 - 'my a = 10;' died
            ok 2 - right exception type (X::Syntax::Malformed)
            ok 3 - .message matches / sigilless /
        ok 884 - did we throws-like X::Syntax::Malformed?
            1..3
            ok 1 - 'my a;' died
            ok 2 - right exception type (X::Syntax::Malformed)
            ok 3 - .message matches / sigilless /
        ok 885 - did we throws-like X::Syntax::Malformed?
        not ok 886 - Aliasing of $0 into $/ (1) # TODO cannot easily override [] at the moment
        # Failed test 'Aliasing of $0 into $/ (1)'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names-vars/varnames.rakudo line 44
        # expected: 'foo0'
        #      got: 'Abyss::Server::Mod::MyMatch<140195587552928>'
        not ok 887 - Aliasing of $0 into $/ (2) # TODO cannot easily override [] at the moment
        # Failed test 'Aliasing of $0 into $/ (2)'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names-vars/varnames.rakudo line 45
        # expected: 'foo4'
        #      got: (Failure)
        ok 888 - with <> def, multiple adverbs allowed on end, canonicalizing < >
        ok 889 - with <> def, multiple adverbs allowed on end, canonicalizing « »
        ok 890 - with <> def, multiple adverbs allowed on end, canonicalizing [ ]
        ok 891 - with <> def, multiple adverbs allowed on end, canonicalizing [ ]
        ok 892 - with «» def, multiple adverbs allowed on end, canonicalizing < >
        ok 893 - with «» def, multiple adverbs allowed on end, canonicalizing « »
        ok 894 - with «» def, multiple adverbs allowed on end, canonicalizing [ ]
        ok 895 - with «» def, multiple adverbs allowed on end, canonicalizing [ ]
        ok 896 - with [] def, multiple adverbs allowed on end, canonicalizing < >
        ok 897 - with [] def, multiple adverbs allowed on end, canonicalizing « »
        ok 898 - with [] def, multiple adverbs allowed on end, canonicalizing [ ]
        ok 899 - with [] def, multiple adverbs allowed on end, canonicalizing [ ]
        ok 900 - with () def, multiple adverbs allowed on end, canonicalizing < >
        ok 901 - with () def, multiple adverbs allowed on end, canonicalizing « »
        ok 902 - with () def, multiple adverbs allowed on end, canonicalizing [ ]
        ok 903 - with () def, multiple adverbs allowed on end, canonicalizing [ ]
# FUDGED!
        1..6
        ok 904 - SETTING:: works
        ok 905 - ::("SETTING") works
        ok 906 - # SKIP NYI
        ok 907 - # SKIP NYI
        ok 908 - # SKIP NYI
        ok 909 - # SKIP NYI
# FUDGED!
        1..12
        ok 910 - basic $CALLER:: works
        ok 911 - $CALLER:: with nested subs works
        ok 912 - $CALLER::CALLER:: is recalculated on each access (1)
        ok 913 - $CALLER::CALLER:: is recalculated on each access (2)
Use of Nil in string context
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names/caller.rakudo line 61
        ok 914 - vars not declared "is dynamic" are not accessible via $CALLER::
        ok 915 - "is dynamic" vars are rw in the creating scope (1)
        ok 916 - "is dynamic" vars are rw in the creating scope (2)
        ok 917 - # SKIP ::= NYI
        ok 918 - "is dynamic" vars declared "is rw" are rw when accessed with $CALLER:: (2)
        ok 919 - $DYNAMIC:: searches call stack
        ok 920 - rebinding $CALLER:: variables works (2)
        ok 921 - rebinding $CALLER:: variables works (3)
# FUDGED!
        1..187
        ok 922 - uninitialized untyped variable should have its default
        ok 923 - is the default set correctly for $a
        ok 924 - should be able to update untyped variable
        ok 925 - update of untyped variable to 43 was successful
        ok 926 - should be able to assign Nil to untyped variable
        ok 927 - untyped variable returned to its default with Nil
        ok 928 - should be able to update untyped variable
        ok 929 - update of untyped variable to 314 was successful
        ok 930 - untyped variable should be initialized
        ok 931 - is the default set correctly for $b
        ok 932 - is the default set correctly for $c
        ok 933 - should be able to increment untyped variable
        ok 934 - untyped variable should be incremented
        ok 935 - should be able to assign Nil to untyped variable
        ok 936 - is the default value correctly reset for $c
        ok 937 - untyped variable should be initialized
        ok 938 - is the default set correctly for $d
        ok 939 - uninitialized untyped attribute should have its default
        ok 940 - is the default set correctly for $!a
        ok 941 - should be able to update untyped attribute
        ok 942 - update of untyped attribute to 43 was successful
        ok 943 - should be able to assign Nil to untyped attribute
        ok 944 - untyped attribute returned to its default with Nil
        ok 945 - should be able to update untyped attribute
        ok 946 - update of untyped attribute to 314 was successful
        ok 947 - untyped attribute should be initialized
        ok 948 - is the default set correctly for $!b
        ok 949 - is the default set correctly for $!c
        ok 950 - should be able to increment untyped attribute
        ok 951 - untyped attribute should be incremented
        ok 952 - should be able to assign Nil to untyped attribute
        ok 953 - is the default value correctly reset for $!c
        ok 954 - untyped attribute should be initialized
        ok 955 - is the default set correctly for $!d
        ok 956 - is default() works on a group of variables too (1)
        ok 957 - is default() works on a group of variables too (2)
        ok 958 - is default on attributes: basic sanity
        ok 959 - is default on attributes applies to all in a list
        ok 960 - uninitialized typed variable should have its default
        ok 961 - is the default set correctly for Int $a
        ok 962 - should be able to update typed variable
        ok 963 - update of typed variable to 43 was successful
        ok 964 - should be able to assign Nil to typed variable
        ok 965 - typed variable returned to its default with Nil
        ok 966 - should be able to update typed variable
        ok 967 - update of typed variable to 314 was successful
        ok 968 - typed variable should be initialized
        ok 969 - is the default set correctly for Int $b
        ok 970 - uninitialized typed attribute should have its default
        ok 971 - is the default set correctly for Int $!a
        ok 972 - should be able to update typed attribute
        ok 973 - update of typed attribute to 43 was successful
        ok 974 - should be able to assign Nil to typed attribute
        ok 975 - typed attribute returned to its default with Nil
        ok 976 - should be able to update typed attribute
        ok 977 - update of typed attribute to 314 was successful
        ok 978 - typed attribute should be initialized
        ok 979 - is the default set correctly for Int $!b
        ok 980 - uninitialized untyped array element should have its default
        ok 981 - is the default set correctly for @a
        ok 982 - should be able to update untyped array element
        ok 983 - update of untyped array element to 43 was successful
        ok 984 - assign Nil to untyped array element
        ok 985 - untyped array element returned to its default with Nil
        ok 986 - should be able to update untyped array element
        ok 987 - update of untyped array element to 314 was successful
        ok 988 - untyped array element should be initialized
        ok 989 - is the default set correctly for @b
        ok 990 - is the default set correctly for @c
        ok 991 - should be able to increment untyped variable
        ok 992 - untyped variable should be incremented
        ok 993 - able to assign Nil to untyped variable
        ok 994 - is the default value correctly reset for @c[0]
        ok 995 - untyped variable should be initialized
        ok 996 - is the default set correctly for @d
        ok 997 - uninitialized untyped attrib element should have its default
        ok 998 - is the default set correctly for @!a
        ok 999 - should be able to update untyped attrib element
        ok 1000 - update of untyped attrib element to 43 was successful
        ok 1001 - assign Nil to untyped attrib element
        ok 1002 - untyped attrib element returned to its default with Nil
        ok 1003 - should be able to update untyped attrib element
        ok 1004 - update of untyped attrib element to 314 was successful
        ok 1005 - untyped attrib element should be initialized
        ok 1006 - is the default set correctly for @!b
        ok 1007 - is the default set correctly for @!c
        ok 1008 - should be able to increment untyped variable
        ok 1009 - untyped variable should be incremented
        ok 1010 - able to assign Nil to untyped variable
        ok 1011 - is the default value correctly reset for @!c[0]
        ok 1012 - untyped variable should be initialized
        ok 1013 - is the default set correctly for @!d
        ok 1014 - uninitialized typed array element should have its default
        ok 1015 - is the default set correctly for Int @a
        ok 1016 - should be able to update typed array element
        ok 1017 - update of typed array element to 43 was successful
        ok 1018 - assign Nil to typed array element
        ok 1019 - typed array element returned to its default with Nil
        ok 1020 - should be able to update typed array element
        ok 1021 - update of typed array element to 314 was successful
        ok 1022 - typed array element should be initialized
        ok 1023 - is the default set correctly for Int @b
        ok 1024 - uninitialized typed attrib element should have its default
        ok 1025 - is the default set correctly for Int @!a
        ok 1026 - should be able to update typed attrib element
        ok 1027 - update of typed attrib element to 43 was successful
        ok 1028 - assign Nil to typed attrib element
        ok 1029 - typed attrib element returned to its default with Nil
        ok 1030 - should be able to update typed attrib element
        ok 1031 - update of typed attrib element to 314 was successful
        ok 1032 - typed attrib element should be initialized
        ok 1033 - is the default set correctly for Int @!b
        ok 1034 - uninitialized untyped hash element should have its default
        ok 1035 - is the default set correctly for %a
        ok 1036 - should be able to update untyped hash element
        ok 1037 - update of untyped hash element to 43 was successful
        ok 1038 - assign Nil to untyped hash element
        ok 1039 - untyped hash element returned to its default with Nil
        ok 1040 - should be able to update untyped hash element
        ok 1041 - update of untyped hash element to 314 was successful
        ok 1042 - untyped hash element should be initialized
        ok 1043 - is the default set correctly for %b
        ok 1044 - is the default set correctly for %c
        ok 1045 - should be able to increment untyped variable
        ok 1046 - untyped variable should be incremented
        ok 1047 - able to assign Nil to untyped variable
        ok 1048 - is the default value correctly reset for %c<o>
        ok 1049 - untyped variable should be initialized
        ok 1050 - is the default set correctly for %d
        ok 1051 - uninitialized untyped attrib hash element should have its default
        ok 1052 - is the default set correctly for %!a
        ok 1053 - should be able to update untyped attrib hash element
        ok 1054 - update of untyped attrib hash element to 43 was successful
        ok 1055 - assign Nil to untyped attrib hash element
        ok 1056 - untyped attrib hash element returned to its default with Nil
        ok 1057 - should be able to update untyped attrib hash element
        ok 1058 - update of untyped attrib hash element to 314 was successful
        ok 1059 - untyped attrib hash element should be initialized
        ok 1060 - is the default set correctly for %!b
        ok 1061 - is the default set correctly for %!c
        ok 1062 - should be able to increment untyped attrib hash element
        ok 1063 - untyped attrib hash element should be incremented
        ok 1064 - able to assign Nil to untyped attrib hash element
        ok 1065 - is the default value correctly reset for %!c<o>
        ok 1066 - untyped attrib hash element should be initialized
        ok 1067 - is the default set correctly for %!d
        ok 1068 - uninitialized typed hash element should have its default
        ok 1069 - is the default set correctly for Int %a
        ok 1070 - should be able to update typed hash element
        ok 1071 - update of hash array element to 43 was successful
        ok 1072 - assign Nil to hash array element
        ok 1073 - typed hash element returned to its default with Nil
        ok 1074 - should be able to update typed hash element
        ok 1075 - update of typed hash element to 314 was successful
        ok 1076 - typed hash element should be initialized
        ok 1077 - is the default set correctly for Int %b
        ok 1078 - uninitialized type attrib hash element should have its default
        ok 1079 - is the default set correctly for Int %!a
        ok 1080 - should be able to update type attrib hash element
        ok 1081 - update of hash array element to 43 was successful
        ok 1082 - assign Nil to hash array element
        ok 1083 - type attrib hash element returned to its default with Nil
        ok 1084 - should be able to update type attrib hash element
        ok 1085 - update of type attrib hash element to 314 was successful
        ok 1086 - type attrib hash element should be initialized
        ok 1087 - is the default set correctly for Int %!b
            1..4
            ok 1 - 'my Int $a is default("foo")' died
            ok 2 - right exception type (X::Parameter::Default::TypeCheck)
            ok 3 - .got matches foo
            ok 4 - .expected matches (Int)
        ok 1088 - did we throws-like X::Parameter::Default::TypeCheck?
            1..4
            ok 1 - 'my Int $a is default(Nil)' died
            ok 2 - right exception type (X::Parameter::Default::TypeCheck)
            ok 3 - .expected matches (Int)
            ok 4 - .got matches Nil
        ok 1089 - did we throws-like X::Parameter::Default::TypeCheck?
            1..4
            ok 1 - 'my Int @a is default("foo")' died
            ok 2 - right exception type (X::Parameter::Default::TypeCheck)
            ok 3 - .got matches foo
            ok 4 - .expected matches (Array[Int])
        ok 1090 - did we throws-like X::Parameter::Default::TypeCheck?
            1..4
            ok 1 - 'my Int @a is default(Nil)' died
            ok 2 - right exception type (X::Parameter::Default::TypeCheck)
            ok 3 - .got matches Nil
            ok 4 - .expected matches (Array[Int])
        ok 1091 - did we throws-like X::Parameter::Default::TypeCheck?
            1..4
            ok 1 - 'my Int %a is default("foo")' died
            ok 2 - right exception type (X::Parameter::Default::TypeCheck)
            ok 3 - .got matches foo
            ok 4 - .expected matches (Hash[Int])
        ok 1092 - did we throws-like X::Parameter::Default::TypeCheck?
            1..4
            ok 1 - 'my Int %a is default(Nil)' died
            ok 2 - right exception type (X::Parameter::Default::TypeCheck)
            ok 3 - .got matches Nil
            ok 4 - .expected matches (Hash[Int])
        ok 1093 - did we throws-like X::Parameter::Default::TypeCheck?
            1..4
            ok 1 - 'class IntFoo { has Int $!a is default("foo") }' died
            not ok 2 - right exception type (X::Parameter::Default::TypeCheck) # TODO LTA wrong kind of exception
            # Failed test 'right exception type (X::Parameter::Default::TypeCheck)'
            # at SETTING::src/core.c/Exception.pm6 line 71
            # Expected: X::Parameter::Default::TypeCheck
            # Got:      X::TypeCheck::Assignment+{X::Comp}
            # Exception message: Type check failed in assignment to $!a; expected Int but got Str ("foo")
            ok 3 - # SKIP wrong exception type
            ok 4 - # SKIP wrong exception type
        not ok 1094 - did we throws-like X::Parameter::Default::TypeCheck? # TODO LTA wrong kind of exception
        # Failed test 'did we throws-like X::Parameter::Default::TypeCheck?'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names/is_default.rakudo line 347
            1..4
            ok 1 - 'class IntNil { has Int $!a is default(Nil) }' died
            not ok 2 - right exception type (X::Parameter::Default::TypeCheck) # TODO LTA wrong kind of exception
            # Failed test 'right exception type (X::Parameter::Default::TypeCheck)'
            # at SETTING::src/core.c/Exception.pm6 line 71
            # Expected: X::Parameter::Default::TypeCheck
            # Got:      X::TypeCheck::Assignment+{X::Comp}
            # Exception message: Type check failed in assignment to $!a; expected Int but got Nil (Nil)
            ok 3 - # SKIP wrong exception type
            ok 4 - # SKIP wrong exception type
        not ok 1095 - did we throws-like X::Parameter::Default::TypeCheck? # TODO LTA wrong kind of exception
        # Failed test 'did we throws-like X::Parameter::Default::TypeCheck?'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names/is_default.rakudo line 351
            1..4
            ok 1 - 'my int $a is default(42)' died
            ok 2 - right exception type (X::Comp::Trait::NotOnNative)
            ok 3 - .type matches is
            ok 4 - .subtype matches default
        ok 1096 - did we throws-like X::Comp::Trait::NotOnNative?
            1..4
            ok 1 - 'my int @a is default(42)' died
            ok 2 - right exception type (X::Comp::Trait::NotOnNative)
            ok 3 - .type matches is
            ok 4 - .subtype matches default
        ok 1097 - did we throws-like X::Comp::Trait::NotOnNative?
            1..4
            ok 1 - 'my int %a is default(42)' died
            not ok 2 - right exception type (X::Comp::Trait::NotOnNative) # TODO fails first on native int hashes being NYI
            # Failed test 'right exception type (X::Comp::Trait::NotOnNative)'
            # at SETTING::src/core.c/Exception.pm6 line 62
            # Expected: X::Comp::Trait::NotOnNative
            # Got:      X::Comp::NYI
            # Exception message: native value types for hashes not yet implemented. Sorry.
            ok 3 - # SKIP wrong exception type
            ok 4 - # SKIP wrong exception type
        not ok 1098 - did we throws-like X::Comp::Trait::NotOnNative? # TODO fails first on native int hashes being NYI
        # Failed test 'did we throws-like X::Comp::Trait::NotOnNative?'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names/is_default.rakudo line 368
        ok 1099 - Default value that is subtype of constraint works fine
        ok 1100 - Default value that is subtype of attribute constraint works fine
        ok 1101 - Mu as a default value on an unconstrained Scalar works
            1..3
            ok 1 - defaults to default value on instantiation
            ok 2 - constructor sets the value
            ok 3 - assigning Nil restores Mu default
        ok 1102 - can use `Mu` as default for attributes
        ok 1103 - Failure.new as a default value on an unconstrained Scalar works
        ok 1104 - Failure.new as a default value on an unconstrained Scalar attribute works
            1..2
                1..3
                    1..2
                    ok 1 - 'my $a is default("foo") of Int' died
                    ok 2 - right exception type (X::Parameter::Default::TypeCheck)
                ok 1 - is default() + of
                    1..2
                    ok 1 - 'my $a of Int is default("foo")' died
                    ok 2 - right exception type (X::Parameter::Default::TypeCheck)
                ok 2 - of is default()
                    1..2
                    ok 1 - 'my Int $a is default("foo")' died
                    ok 2 - right exception type (X::Parameter::Default::TypeCheck)
                ok 3 - Type $ is default()
            ok 1 - variable
                1..3
                    1..2
                    ok 1 - 'class { has $.a is default("foo") of Int }' died
                    ok 2 - right exception type (X::TypeCheck::Assignment)
                ok 1 - is default() + of
                    1..2
                    ok 1 - 'class { has $.a of Int is default("foo") }' died
                    ok 2 - right exception type (X::TypeCheck::Assignment)
                ok 2 - of is default()
                    1..2
                    ok 1 - 'class { has Int $.a is default("foo") }' died
                    ok 2 - right exception type (X::TypeCheck::Assignment)
                ok 3 - Type $ is default()
            ok 2 - attribute
        ok 1105 - is default() respects type constraint
            1..2
                1..3
                ok 1 - uninitialized read
                ok 2 - set a value
                ok 3 - setting to Nil restores correct default
            ok 1 - variable
                1..4
                ok 1 - uninitialized read (rw attr)
                ok 2 - uninitialized read (ro attr)
                ok 3 - set a value
                ok 4 - setting to Nil restores correct default
            ok 2 - attribute
        ok 1106 - default `is default()` gets adjusted to type constraint
        ok 1107 - uninitialized typed:D attribute should have its default
            1..2
            ok 1 - 'class NilDefaultTyped { has Int:D $.a is rw is default(Nil) }' died
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 1108 - did we throws-like X::TypeCheck::Assignment?
# FUDGED!
        1..10
        ok 1109 - can define a sub in eval
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Undeclared::Symbols)
        ok 1110 - call to eval-born sub outside eval dies
        ok 1111 - call to eval-born our sub via OUR works
        ok 1112 - c is 2 from enum
        ok 1113 - can define my sub c in eval after c defined in enum
        ok 1114 - c is still 2 from enum
        ok 1115 - # SKIP OUR::subname() does not work
        ok 1116 - can compile a class that modifies our variable
        ok 1117 - can instantiate class that modifies our variable
        not ok 1118 - class can modify our variable
        # Failed test 'class can modify our variable'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names/our.rakudo line 35
        # expected: '2'
        #      got: '1'
# FUDGED!
        1..159
        ok 1119 - # SKIP the binding in here is NYI
        ok 1120 - # SKIP the binding in here is NYI
        ok 1121 - # SKIP the binding in here is NYI
        ok 1122 - # SKIP the binding in here is NYI
        ok 1123 - # SKIP various issues, skipping all for now
        ok 1124 - # SKIP various issues, skipping all for now
        ok 1125 - # SKIP various issues, skipping all for now
        ok 1126 - # SKIP various issues, skipping all for now
        ok 1127 - # SKIP various issues, skipping all for now
        ok 1128 - # SKIP various issues, skipping all for now
        ok 1129 - # SKIP various issues, skipping all for now
        ok 1130 - # SKIP various issues, skipping all for now
        ok 1131 - # SKIP various issues, skipping all for now
        ok 1132 - # SKIP various issues, skipping all for now
        ok 1133 - # SKIP various issues, skipping all for now
        ok 1134 - # SKIP various issues, skipping all for now
        ok 1135 - # SKIP various issues, skipping all for now
        ok 1136 - # SKIP various issues, skipping all for now
        ok 1137 - # SKIP various issues, skipping all for now
        ok 1138 - # SKIP various issues, skipping all for now
        ok 1139 - # SKIP various issues, skipping all for now
        ok 1140 - # SKIP various issues, skipping all for now
        ok 1141 - # SKIP various issues, skipping all for now
        ok 1142 - # SKIP various issues, skipping all for now
        ok 1143 - # SKIP various issues, skipping all for now
        ok 1144 - # SKIP various issues, skipping all for now
        ok 1145 - # SKIP various issues, skipping all for now
        ok 1146 - # SKIP various issues, skipping all for now
        ok 1147 - # SKIP various issues, skipping all for now
        ok 1148 - # SKIP various issues, skipping all for now
        ok 1149 - # SKIP various issues, skipping all for now
        ok 1150 - # SKIP various issues, skipping all for now
        ok 1151 - # SKIP various issues, skipping all for now
        ok 1152 - # SKIP various issues, skipping all for now
        ok 1153 - # SKIP various issues, skipping all for now
        ok 1154 - # SKIP various issues, skipping all for now
        ok 1155 - # SKIP various issues, skipping all for now
        ok 1156 - # SKIP various issues, skipping all for now
        ok 1157 - # SKIP various issues, skipping all for now
        ok 1158 - # SKIP various issues, skipping all for now
        ok 1159 - basic OUR:: testing
        ok 1160 - can bind through OUR::
        ok 1161 - basic OUR::.{} works
        ok 1162 - can bind through OUR::.{}
        ok 1163 - OUR works when indirectly accessed
        ok 1164 - $OUR:: does not find GLOBAL
        ok 1165 - $OUR:: does find current package
        ok 1166 - OUR::.{} does not find GLOBAL
        ok 1167 - OUR::.{} does find current package
        ok 1168 - ::("OUR") does not find GLOBAL
        ok 1169 - ::("OUR") does find current package
        ok 1170 - $OUR:: syntax can indirect through a package
        ok 1171 - ::("OUR") can also indirect
        ok 1172 - $OUR:: can autovivify packages (reference)
        ok 1173 - $OUR:: can autovivify packages (binding)
        not ok 1174 - ::("OUR") can autovivify packages (r) # TODO interpolation and auto-viv NYI
        # Failed test '::("OUR") can autovivify packages (r)'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names/pseudo-6c.rakudo line 181
        # expected: '43'
        #      got: (Any)
        not ok 1175 - ::("OUR") can autovivify packages (b) # TODO binding and interpolation together NYI
        # Failed test '::("OUR") can autovivify packages (b)'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names/pseudo-6c.rakudo line 185
        # expected: '44'
        #      got: (Any)
        not ok 1176 - ::("OUR") can follow aliased packages # TODO binding and interpolation together NYI
        # Failed test '::("OUR") can follow aliased packages'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names/pseudo-6c.rakudo line 189
        # expected: '41'
        #      got: (Failure)
        ok 1177 - &CORE:: works
        ok 1178 - CORE::.{} works
        ok 1179 - ::("CORE") works
        ok 1180 - &CORE:: works when shadowed
        ok 1181 - CORE::.{} works when shadowed
        ok 1182 - ::("CORE") works when shadowed
        ok 1183 - &CORE:: is not &SETTING::
        ok 1184 - CORE::.{} is not SETTING::
        ok 1185 - ::("CORE") is not SETTING
        ok 1186 - &CORE:: binding lives
        ok 1187 - ... and works
        ok 1188 - CORE::.{} binding lives
        ok 1189 - ... and works
        ok 1190 - # SKIP Cannot bind to &::("CORE")::foo
        ok 1191 - # SKIP Cannot bind to &::("CORE")::foo
        ok 1192 - Binding to $CORE::_ lives
        ok 1193 - Accessing $CORE::_ works
        ok 1194 - # SKIP Cannot bind to &::("CORE")::foo
        ok 1195 - # SKIP Cannot bind to &::("CORE")::foo
        not ok 1196 - $GLOBAL:: works
        # Failed test '$GLOBAL:: works'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names/pseudo-6c.rakudo line 239
        # expected: '60'
        #      got: (Any)
        not ok 1197 - ::("GLOBAL") works
        # Failed test '::("GLOBAL") works'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names/pseudo-6c.rakudo line 240
        # expected: '60'
        #      got: (Failure)
        not ok 1198 - GLOBAL::.{} works
        # Failed test 'GLOBAL::.{} works'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names/pseudo-6c.rakudo line 241
        # expected: '60'
        #      got: (Any)
        ok 1199 - GLOBAL:: does not find CORE symbols
        ok 1200 - $PROCESS:: works
        ok 1201 - PROCESS::.{} works
        ok 1202 - ::("PROCESS") works
Cannot modify an immutable Str (other/startup.p6)
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names/pseudo-6c.rakudo line 257
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names/pseudo-6c.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

        1..159
        ok 1203 - # SKIP the binding in here is NYI
        ok 1204 - # SKIP the binding in here is NYI
        ok 1205 - # SKIP the binding in here is NYI
        ok 1206 - # SKIP the binding in here is NYI
        ok 1207 - # SKIP various issues, skipping all for now
        ok 1208 - # SKIP various issues, skipping all for now
        ok 1209 - # SKIP various issues, skipping all for now
        ok 1210 - # SKIP various issues, skipping all for now
        ok 1211 - # SKIP various issues, skipping all for now
        ok 1212 - # SKIP various issues, skipping all for now
        ok 1213 - # SKIP various issues, skipping all for now
        ok 1214 - # SKIP various issues, skipping all for now
        ok 1215 - # SKIP various issues, skipping all for now
        ok 1216 - # SKIP various issues, skipping all for now
        ok 1217 - # SKIP various issues, skipping all for now
        ok 1218 - # SKIP various issues, skipping all for now
        ok 1219 - # SKIP various issues, skipping all for now
        ok 1220 - # SKIP various issues, skipping all for now
        ok 1221 - # SKIP various issues, skipping all for now
        ok 1222 - # SKIP various issues, skipping all for now
        ok 1223 - # SKIP various issues, skipping all for now
        ok 1224 - # SKIP various issues, skipping all for now
        ok 1225 - # SKIP various issues, skipping all for now
        ok 1226 - # SKIP various issues, skipping all for now
        ok 1227 - # SKIP various issues, skipping all for now
        ok 1228 - # SKIP various issues, skipping all for now
        ok 1229 - # SKIP various issues, skipping all for now
        ok 1230 - # SKIP various issues, skipping all for now
        ok 1231 - # SKIP various issues, skipping all for now
        ok 1232 - # SKIP various issues, skipping all for now
        ok 1233 - # SKIP various issues, skipping all for now
        ok 1234 - # SKIP various issues, skipping all for now
        ok 1235 - # SKIP various issues, skipping all for now
        ok 1236 - # SKIP various issues, skipping all for now
        ok 1237 - # SKIP various issues, skipping all for now
        ok 1238 - # SKIP various issues, skipping all for now
        ok 1239 - # SKIP various issues, skipping all for now
        ok 1240 - # SKIP various issues, skipping all for now
        ok 1241 - # SKIP various issues, skipping all for now
        ok 1242 - # SKIP various issues, skipping all for now
        ok 1243 - basic OUR:: testing
        ok 1244 - can bind through OUR::
        ok 1245 - basic OUR::.{} works
        ok 1246 - can bind through OUR::.{}
        ok 1247 - OUR works when indirectly accessed
        ok 1248 - $OUR:: does not find GLOBAL
        ok 1249 - $OUR:: does find current package
        ok 1250 - OUR::.{} does not find GLOBAL
        ok 1251 - OUR::.{} does find current package
        ok 1252 - ::("OUR") does not find GLOBAL
        ok 1253 - ::("OUR") does find current package
        ok 1254 - $OUR:: syntax can indirect through a package
        ok 1255 - ::("OUR") can also indirect
Cannot assign to an immutable value
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names/pseudo-6d.rakudo line 175
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names/pseudo-6d.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

        1..7
        ok 1256 - variable gets auto-declared when strict is turned off
        ok 1257 - variable gets auto-declared in packages
        ok 1258 - lax declared variable is package scoped
            1..3
            ok 1 - '$foo = 10;' died
            ok 2 - right exception type (X::Undeclared)
            ok 3 - .suggestions matches Foo
        ok 1259 - did we throws-like X::Undeclared?
        ok 1260 - # SKIP lax mode does not propagate into EVAL yet
        ok 1261 - "6;" no longer means "no strict;" and "(6;)" no longer results in a compile time error
            1..4
            ok 1 - `temp` on Hash key
            ok 2 - `let`  on Hash key
            ok 3 - postcircumfix {} on Hash key
            ok 4 - non-existent keys are `Any`
        ok 1262 - `no strict` does not cause autovivification container issues
# FUDGED!
WARNINGS for /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names/symbolic-deref.rakudo:
Useless use of constant string "c" in sink context (lines 19, 19)
Useless use of constant string "b" in sink context (lines 19, 19)
        1..36
        ok 1263 - basic symbolic scalar dereferentiation works
        ok 1264 - can use $::(...) as lvalue
        ok 1265 - and the assignment worked
        ok 1266 - ... and it is item assignment
        ok 1267 - basic symbolic array dereferentiation works
        ok 1268 - can assign to symbolic deref
        ok 1269 - ... and it is list assignment when the sigil is @
        ok 1270 - basic symbolic hash dereferentiation works
        ok 1271 - basic symbolic code dereferentiation works
        ok 1272 - can look up a type object with ::()
        ok 1273 - can look up lexical from same block
        ok 1274 - can look up lexical from outer block
        ok 1275 - Can use ::() as lvalue
        ok 1276 - and the assignment worked
        ok 1277 - can look up lexical sub
        ok 1278 - Can look up numerical constants
        ok 1279 - can look up name with :: (1)
        ok 1280 - can look up name with :: (1)
        ok 1281 - not so basic symbolic dereferentiation works
        ok 1282 - symbolic derefertiation with multiple packages in one variable works
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Syntax::Confused)
        ok 1283 - $::($foo)bar is illegal
        ok 1284 - symbolic dereferentation works with ::CALLER, too
        ok 1285 - symbolic dereferentiation of Unicode vars works
        ok 1286 - # SKIP NYI
        ok 1287 - # SKIP NYI
        not ok 1288 - symbolic dereferentiation of globals works (3) # TODO no such symbol
        # Failed test 'symbolic dereferentiation of globals works (3)'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names/symbolic-deref.rakudo line 123
        ok 1289 - symbolic dereferentiation of CORE subs works (1)
        ok 1290 - symbolic dereferentiation of CORE subs works (2)
        ok 1291 - symbolic dereferentiation of CORE subs works (3)
        ok 1292 - symbolic dereferentiation of type vars works (1)
        not ok 1293 - symbolic dereferentiation of (own) type vars works (2)
        # Failed test 'symbolic dereferentiation of (own) type vars works (2)'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names/symbolic-deref.rakudo line 143
        ok 1294 - symbolic dereferentiation works with special chars (1)
        not ok 1295 - symbolic dereferentiation works with special chars (3) # TODO NYI
        # Failed test 'symbolic dereferentiation works with special chars (3)'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names/symbolic-deref.rakudo line 154
        ok 1296 - symbolic dereferentiation works with package vars
            1..2
            ok 1 - code dies
            ok 2 - right exception type (Exception)
        ok 1297 - Cannot look up empty name
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Undeclared)
        ok 1298 - name with trailing :: not same as sans
# FUDGED!
        1..42
        ok 1299 - The object is-a 'Sub'
        ok 1300 - sub { } works
        ok 1301 - The object is-a 'Sub'
        ok 1302 - sub ($arg) {} works
        ok 1303 - The object is-a 'Block'
        ok 1304 - {} <anon block> works
        not ok 1305 - too many parameters # TODO Parrot support for zero-arg subs?
        # Failed test 'too many parameters'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/anon_block.rakudo line 37
        ok 1306 - # SKIP tests don't work if previous test fails
        ok 1307 - # SKIP tests don't work if previous test fails
        ok 1308 - The object is-a 'Block'
        ok 1309 - -> {} <"pointy" block> works
        ok 1310 - The object is-a 'Block'
        ok 1311 - -> $arg {} <"pointy" block w/args> works
        ok 1312 - The object is-a 'Block'
        ok 1313 - -> $arg1, $arg2 {} <"pointy" block w/multiple args> works
        ok 1314 - The object is-a 'Block'
        ok 1315 - The object is-a 'Block'
        ok 1316 - -> $a { -> $b { $a+$b }} nested <"pointy" block> works
        ok 1317 - lone block actually executes it's content
        ok 1318 - lone block w/out a semicolon actually executes it's content
        ok 1319 - block enclosed by parentheses should not auto-execute (2)
        ok 1320 - two blocks ({} {}) no semicolon after either,.. first block does not execute
        ok 1321 - ... but second block does (parsed as hash subscript)
        ok 1322 - ... two blocks ({}; {}) semicolon after the first only,.. first block does execute
        ok 1323 - ... and second block does too
        ok 1324 - ... two stand-alone blocks ({\n...\n}\n{\n...\n}),.. first block does execute
        ok 1325 - ... and second block does too
        ok 1326 - ... two blocks ({}; {};) semicolon after both,.. first block does execute
        ok 1327 - ... and second block does too
        ok 1328 - bare blocks immediately runs even as the last statement
        ok 1329 - ditto for anonymous subs
        ok 1330 - ditto, even if nested
            1..2
            ok 1 - code dies
            ok 2 - right exception type (Exception)
        ok 1331 - implicit params become errors
Block object coerced to string (please use .gist or .raku to do that)
  in sub isnt at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 239
        ok 1332 - as are pointies
        ok 1333 - check that sub is callable via &
        ok 1334 - call via { &^pos() }( &s ) works for sub
        ok 1335 - call via -> &point { &point() }.( &s ) works for sub
        ok 1336 - call via (sub (&x) { &x() }).( &s ) works for sub
        ok 1337 - check that mutli is callable via &
        ok 1338 - call via { &^pos() }( &s ) works for multi
        ok 1339 - call via -> &point { &point() }.( &s ) works for multi
        ok 1340 - call via (sub (&x) { &x() }).( &s ) works for multi
# FUDGED!
        1..40
        ok 1341 - my @arr[*] autoextends like my @arr
        ok 1342 - my @arr[num] can hold num things
            1..3
            ok 1 - 'push @arr, 'h'' died
            ok 2 - right exception type (X::IllegalOnFixedDimensionArray)
            ok 3 - .operation matches push
        ok 1343 - adding past num items in my @arr[num] dies
            1..2
            ok 1 - '@arr[7]' died
            ok 2 - right exception type (Exception)
        ok 1344 - accessing past num items in my @arr[num] dies
        ok 1345 - array with fixed size with unspace
            1..2
            not ok 1 - 'my @arr.[8]' died # TODO code does not die, array shapes
            # Failed test ''my @arr.[8]' died'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/array-shapes.rakudo line 30
            ok 2 - # SKIP Code did not die, can not check exception
        not ok 1346 - array with dot form dies # TODO code does not die, array shapes
        # Failed test 'array with dot form dies'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/array-shapes.rakudo line 30
            1..2
            not ok 1 - 'my @arr\    .[8]' died # TODO code does not die, array shapes
            # Failed test ''my @arr\    .[8]' died'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/array-shapes.rakudo line 33
            ok 2 - # SKIP Code did not die, can not check exception
        not ok 1347 - array with dot form and unspace dies # TODO code does not die, array shapes
        # Failed test 'array with dot form and unspace dies'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/array-shapes.rakudo line 33
        ok 1348 - my @arr of Type works
            1..2
            ok 1 - 'push @arr, 's'' died
            ok 2 - right exception type (X::TypeCheck)
        ok 1349 - type constraints on my @arr of Type works (1)
            1..2
            ok 1 - 'push @arr, 4.2' died
            ok 2 - right exception type (X::TypeCheck)
        ok 1350 - type constraints on my @arr of Type works (2)
        ok 1351 - my Type @arr works
            1..2
            ok 1 - 'push @arr, 's'' died
            ok 2 - right exception type (X::TypeCheck)
        ok 1352 - type constraints on my Type @arr works (1)
            1..2
            ok 1 - 'push @arr, 4.2' died
            ok 2 - right exception type (X::TypeCheck)
        ok 1353 - type constraints on my Type @arr works (2)
        ok 1354 - my @arr[Int] of Type works
            1..2
            ok 1 - 'push @arr, 123' died
            ok 2 - right exception type (Exception)
        ok 1355 - boundary constraints on my @arr[Int] of Type works
        ok 1356 - my type @arr works
        ok 1357 - push on native @arr works
            1..2
            ok 1 - 'push @arr, "s"' died
            ok 2 - right exception type (X::TypeCheck)
        ok 1358 - type constraints on my type @arr works (1)
            1..2
            ok 1 - 'push @arr, 4.2' died
            ok 2 - right exception type (X::TypeCheck)
        ok 1359 - type constraints on my type @arr works (2)
        ok 1360 - my Type @arr[num] works
            1..3
            ok 1 - 'push @arr, 123' died
            ok 2 - right exception type (X::IllegalOnFixedDimensionArray)
            ok 3 - .operation matches push
        ok 1361 - did we throws-like X::IllegalOnFixedDimensionArray?
            1..3
            ok 1 - 'pop @arr' died
            ok 2 - right exception type (X::IllegalOnFixedDimensionArray)
            ok 3 - .operation matches pop
        ok 1362 - did we throws-like X::IllegalOnFixedDimensionArray?
            1..3
            ok 1 - 'push @arr, 's'' died
            ok 2 - right exception type (X::IllegalOnFixedDimensionArray)
            ok 3 - .operation matches push
        ok 1363 - did we throws-like X::IllegalOnFixedDimensionArray?
            1..3
            ok 1 - 'push @arr, 4.2' died
            ok 2 - right exception type (X::IllegalOnFixedDimensionArray)
            ok 3 - .operation matches push
WARNING: unhandled Failure detected in DESTROY. If you meant to ignore it, you can mark it as handled by calling .Bool, .so, .not, or .defined methods. The Failure was:
Type Block does not support associative indexing.
  in block <unit> at EVAL_391 line 1
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/anon_block.rakudo line 94
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/anon_block.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

WARNING: unhandled Failure detected in DESTROY. If you meant to ignore it, you can mark it as handled by calling .Bool, .so, .not, or .defined methods. The Failure was:
No such symbol 'A::B::C'
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names/symbolic-deref.rakudo line 142
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names/symbolic-deref.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

WARNING: unhandled Failure detected in DESTROY. If you meant to ignore it, you can mark it as handled by calling .Bool, .so, .not, or .defined methods. The Failure was:
No such symbol '$*IN'
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names/symbolic-deref.rakudo line 123
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names/symbolic-deref.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

WARNING: unhandled Failure detected in DESTROY. If you meant to ignore it, you can mark it as handled by calling .Bool, .so, .not, or .defined methods. The Failure was:
No such symbol 'OUR::A43'
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names/pseudo-6c.rakudo line 185
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names/pseudo-6c.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

WARNING: unhandled Failure detected in DESTROY. If you meant to ignore it, you can mark it as handled by calling .Bool, .so, .not, or .defined methods. The Failure was:
No such symbol 'OUR::A42'
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names/pseudo-6c.rakudo line 181
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names/pseudo-6c.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

        ok 1364 - did we throws-like X::IllegalOnFixedDimensionArray?
            1..2
            ok 1 - 'my @a[0]' died
            ok 2 - right exception type (X::IllegalDimensionInShape)
        ok 1365 - did we throws-like X::IllegalDimensionInShape?
            1..2
            ok 1 - 'my @a[-9999999999999999]' died
            ok 2 - right exception type (X::IllegalDimensionInShape)
        ok 1366 - did we throws-like X::IllegalDimensionInShape?
            1..2
            ok 1 - 'my @a[-9223372036854775808,-2]' died
            ok 2 - right exception type (X::IllegalDimensionInShape)
        ok 1367 - did we throws-like X::IllegalDimensionInShape?
            1..2
            ok 1 - does not die
            ok 2 - gives correct results
        ok 1368 - .List on uninited shaped array
            1..3
            ok 1 - does not die
            ok 2 - gives correct results
            ok 3 - and is mutable
        ok 1369 - .Array on uninited shaped array
        ok 1370 - @c[some shape] accepts a .new: :shape(same shape)...
        ok 1371 - @shaped-array.pairs provides with writable container in .value
        ok 1372 - @shaped-array.values provides with writable containers
        ok 1373 - For statement across simple uninitialized shaped array
        ok 1374 - For loop across simple uninitialized shaped array
        ok 1375 - .map of simple uninitialized shaped array
        ok 1376 - Z= shape filling
        ok 1377 - Z= shape filling
        ok 1378 - Z= shape filling
        ok 1379 - # SKIP coercion of shaped array indicesdd
        ok 1380 - Accept dynamic shaped arrays
# FUDGED!
        1..105
        ok 1381 - for 1, 2, 3 does three iterations
        ok 1382 - for 0, (1, 2, 3).item does two iteraions
        ok 1383 - for flat 0, $(1, 2, 3) does two iterations
        ok 1384 - for flat 0, $[1, 2, 3] does two iterations
        ok 1385 - @a.raku on uninitialized variable
        ok 1386 - The object is-a 'Array'
        ok 1387 - the array1 has 3 elements
        ok 1388 - got the right value at array1 index 0
        ok 1389 - got the right value at array1 index 1
        ok 1390 - got the right value at array1 index 2
        ok 1391 - got the right value at array1 index 0 using the . notation
        ok 1392 - The object is-a 'Array'
        ok 1393 - the array2 has 3 elements
        ok 1394 - got the right value at array2 index 0
        ok 1395 - got the right value at array2 index 1
        ok 1396 - got the right value at array2 index 2
        ok 1397 - The object is-a 'Array'
        ok 1398 - the array3 has 6 elements
        ok 1399 - got the right value at array3 index 0
        ok 1400 - got the right value at array3 index 1
        ok 1401 - got the right value at array3 index 2
        ok 1402 - got the right value at array3 index 3
        ok 1403 - got the right value at array3 index 4
        ok 1404 - got the right value at array3 index 5
        ok 1405 - The object is-a 'Array'
        ok 1406 - the array4 has 3 elements
        ok 1407 - got the right value at array4 index 0
        ok 1408 - got the right value at array4 index 1
        ok 1409 - got the right value at array4 index 2
        ok 1410 - The object is-a 'Array'
        ok 1411 - the array5 has 6 elements
        ok 1412 - got the right value at array5 index 0
        ok 1413 - got the right value at array5 index 1
        ok 1414 - got the right value at array5 index 2
        ok 1415 - got the right value at array5 index 3
        ok 1416 - got the right value at array5 index 4
        ok 1417 - got the right value at array5 index 5
        ok 1418 - The object is-a 'Array'
        ok 1419 - the array6 has 3 elements
        ok 1420 - got the right value at array6 index 0
        ok 1421 - got the right value at array6 index 1
        ok 1422 - got the right value at array6 index 2
        ok 1423 - The object is-a 'Array'
        ok 1424 - the array7 has 3 elements
        ok 1425 - got the right value at array7 index 0
        ok 1426 - got the right value at array7 index 1
        ok 1427 - got the right value at array7 index 2
        ok 1428 - got the right value from the slice
        ok 1429 - got the right value from the slice
        ok 1430 - The object is-a 'Array'
        ok 1431 - new arrays are empty
        ok 1432 - trailing commas make correct array
        ok 1433 - # SKIP multi-dim arrays NYI
        ok 1434 - # SKIP multi-dim arrays NYI
        ok 1435 - stuffing Ints in an Int array works
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 1436 - stuffing IO in an Int array does not work
        ok 1437 - indexing from the end [*-1]
        ok 1438 - end indices [*-4 .. *-2]
        ok 1439 - assigns to the correct end slice index
        ok 1440 - assignment to end index correctly alters the array
        ok 1441 - end range as lvalue
        ok 1442 - hat trick:
        #         assign to a end-indexed slice array from array
        #         lvalue in assignment is then lvalue to end-indexed slice as rvalue
        ok 1443 - Infinite range subscript as rvalues clip to existing elems
        ok 1444 - Lazy range subscript as rvalues clip to existing elems
        ok 1445 - modifying of array contents (constants) works
        ok 1446 - readonly accessing [*-1] of an empty array is not fatal
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::OutOfRange)
        ok 1447 - readonly accessing [*-1] of an empty array throws X::OutOfRange
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::OutOfRange)
        ok 1448 - assigning to [*-1] of an empty array throws X::OutOfRange
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Bind::Slice)
        ok 1449 - binding [*-1] of an empty array throws X::Bind::Slice
        ok 1450 - readonly accessing [*-2] of an one-elem array is not fatal
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::OutOfRange)
        ok 1451 - readonly accessing [*-2] of an one-elem array throws X::OutOfRange
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::OutOfRange)
        ok 1452 - assigning to [*-2] of an one-elem array throws X::OutOfRange
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Bind::Slice)
        ok 1453 - binding [*-2] of an one-elem array throws X::Bind::Slice
            1..3
            ok 1 - '@arr[-2]' died
            ok 2 - right exception type (X::Obsolete)
            ok 3 - .message matches /^ 'Unsupported use of a negative -2 subscript to index from the end'/
        ok 1454 - readonly accessing [-2] of normal array throws X::Obsolete and is fatal
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::OutOfRange)
        ok 1455 - indirectly accessing [-1] through a variable throws X::OutOfRange
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::OutOfRange)
        ok 1456 - assigning to [-1] of a normal array throws X::OutOfRange
            1..2
            ok 1 - code dies
            not ok 2 - right exception type (X::Subscript::Negative) # TODO bind_pos NYI
            # Failed test 'right exception type (X::Subscript::Negative)'
            # at SETTING::src/core.c/Exception.pm6 line 62
            # Expected: X::Subscript::Negative
            # Got:      X::OutOfRange
            # Exception message: Index out of range. Is: -1, should be in 0..^Inf
        not ok 1457 - binding [-1] of a normal array throws X::Subscript::Negative # TODO bind_pos NYI
        # Failed test 'binding [-1] of a normal array throws X::Subscript::Negative'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/array.rakudo line 265
        ok 1458 - [][] returns empty list/array
        ok 1459 - .[0] is identity operation for scalars (Int)
        ok 1460 - .[0] is identity operation for scalars (Str)
        ok 1461 - .[1] on a scalar is not defined
        ok 1462 - indexing a scalar with other than 0 returns a Failure
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Multi::NoMatch X::TypeCheck::Binding::Parameter)
        ok 1463 - but Mu has no .[]
        ok 1464 - using * to access all array elements works
        ok 1465 - using [] to listify all array elements works
        ok 1466 - using [] decontainerizes
        ok 1467 - Numifying an Array yields an Int
        ok 1468 - modifier form of 'if' within 'for' loop works
        ok 1469 - non-modifier form of 'if' within 'for' loop also works
        ok 1470 - Array.hash created a sensible hash
        ok 1471 - ... and did not consume itself in the process
        ok 1472 - 0..^ *-1 works as an array index
        ok 1473 - Array(...) makes an Array
        ok 1474 - Array(1,2,3) makes correct array
            1..4
            ok 1 - code dies
            not ok 2 - right exception type (X::Item) # TODO regression to AdHoc exception
            # Failed test 'right exception type (X::Item)'
            # at SETTING::src/core.c/Exception.pm6 line 62
Use of uninitialized value element of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 656
            # Expected: X::Item
            # Got:      X::Numeric::CannotConvert
            # Exception message: Cannot convert Inf to Int: 
            ok 3 - # SKIP wrong exception type
            ok 4 - # SKIP wrong exception type
        not ok 1475 - did we throws-like X::Item? # TODO regression to AdHoc exception
        # Failed test 'did we throws-like X::Item?'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/array.rakudo line 347
            1..4
            ok 1 - code dies
            not ok 2 - right exception type (X::Item) # TODO regression to AdHoc exception
            # Failed test 'right exception type (X::Item)'
            # at SETTING::src/core.c/Exception.pm6 line 62
Use of uninitialized value element of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 656
            # Expected: X::Item
            # Got:      X::Numeric::CannotConvert
            # Exception message: Cannot convert NaN to Int: 
            ok 3 - # SKIP wrong exception type
            ok 4 - # SKIP wrong exception type
        not ok 1476 - did we throws-like X::Item? # TODO regression to AdHoc exception
        # Failed test 'did we throws-like X::Item?'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/array.rakudo line 350
Use of uninitialized value @bar of type Str in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/array.rakudo line 359
        ok 1477 - ~@bar containing a Str type object lives
        ok 1478 - ~@bar containing a Str type object gives empty string
        ok 1479 - simple integer sum in array works
        ok 1480 - handle sparse arrays correctly
        ok 1481 - [*-0] index references correct element when autovivifying
            1..4
            ok 1 - method, True
            ok 2 - method, False
            ok 3 - sub, True
            ok 4 - sub, False
        ok 1482 - flat propagates .is-lazy
            1..5
            ok 1 - gist gives useful value
            ok 2 - 100 els
            ok 3 - 101 els
            ok 4 - 102 els
            ok 5 - 1000 els
        ok 1483 - .gist shows only first 100 els
            1..2
            ok 1 - zen slice does not reify
            ok 2 - whatever slice does reify
        ok 1484 - reification of zen and whatever slices
            1..9
            ok 1 - can reference values in an `our` var
            ok 2 - we reified only non-lazy parts on assignment
            ok 3 - eagerizing the array, we reified the rest of the parts
            ok 4 - pushed values get updated
            ok 5 - is default work on Arrays
            ok 6 - can use return value of assignment (1)
            ok 7 - can use return value of assignment (2)
            ok 8 - can use return value of assignment (3)
            ok 9 - works fine when re-entrant
        ok 1485 - no funny business in assignment
# FUDGED!
        1..333
We do get here, right?
        ok 1486 - we got a BagHash
        ok 1487 - ...with the right elements
        ok 1488 - Defaults to 0
        ok 1489 - Single-key subscript (existing element)
        ok 1490 - Single-key subscript yields an Int
        ok 1491 - Single-key subscript (nonexistent element)
        ok 1492 - Single-key subscript yields an Int (nonexistent element)
        ok 1493 - exists with existing element
        ok 1494 - exists with nonexistent element
        ok 1495 - Values returns the correct number of values
        ok 1496 - Values returns the correct sum
        ok 1497 - Bool returns True if there is something in the BagHash
        ok 1498 - Bool returns False if there is nothing in the BagHash
        ok 1499 - .hash doesn't die
        ok 1500 - ...and it returned a Hash
        ok 1501 - ...with the right elements
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Assignment::RO)
        ok 1502 - Can't assign to .keys
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Assignment::RO)
        ok 1503 - Can't assign to .values
        ok 1504 - Multiple-element access
        ok 1505 - Multiple-element access (with nonexistent elements)
        ok 1506 - .total gives sum of values
        ok 1507 - .elems gives number of elements
        ok 1508 - +$bag gives sum of values
        ok 1509 - Can assign to an existing element
        ok 1510 - ... and assignment takes effect
        ok 1511 - Can assign to a new element
        ok 1512 - ... and assignment takes effect
        ok 1513 - Can assign zero to a nonexistent element
        ok 1514 - ... and that didn't create the element
        ok 1515 - Can assign zero to a existing element
        ok 1516 - ... and it goes away
        ok 1517 - Can ++ an existing element
        ok 1518 - ... and the increment happens
        ok 1519 - Can ++ a new element
        ok 1520 - ... and the element is created
        ok 1521 - Can -- an existing element
        ok 1522 - ... and the decrement happens
        ok 1523 - Can -- an element with value 1
        ok 1524 - ... and it goes away
        ok 1525 - Can -- an element that doesn't exist
        ok 1526 - ... but it doesn't create it
        ok 1527 - Identical bags smartmatch with each other
        ok 1528 - Identical bags smartmatch with each other
        ok 1529 - Subset does not smartmatch
        ok 1530 - Subset (only quantity different) does not smartmatch
        ok 1531 - Superset does not smartmatch
        ok 1532 - Superset (only quantity different) does not smartmatch
        ok 1533 - Smartmatch is not element of
        ok 1534 - Type-checking smartmatch works
        ok 1535 - Set smartmatches with equivalent BagHash.new:
        ok 1536 - ... but not if the Bag has greater quantities
        ok 1537 - Type-checking smartmatch works
        ok 1538 - Str.BagHash makes a BagHash
        ok 1539 - 'a'.BagHash is bag a
        ok 1540 - Pair.BagHash makes a BagHash
        ok 1541 - (a => 100000).BagHash is bag a:100000
        ok 1542 - (a => 0).BagHash is the empty bag
        ok 1543 - <a b c>.BagHash makes a BagHash
        ok 1544 - <a b c a>.BagHash makes the bag a:2 b:1 c:1
        ok 1545 - [a b c a].BagHash makes the bag a:2 b:1 c:1
        ok 1546 - [a => 3, b => 0, 'c', 'a'].BagHash makes the bag a:4 c:1
        ok 1547 - a	2 b	4 c	0.BagHash makes a BagHash
        ok 1548 - a	2 b	4 c	0.BagHash makes the bag a:2 b:4
        ok 1549 - :exists with existing element
        ok 1550 - :exists with nonexistent element
        ok 1551 - :delete works on BagHash
        ok 1552 - ...and actually deletes
        ok 1553 - Int keys are left as Ints
        ok 1554 - Bool keys are left as Bools
        ok 1555 - And Str keys are permitted in the same set
        ok 1556 - All keys have the right values
        ok 1557 - BagHash.kv returns list of keys and values
        ok 1558 - &BagHash.new given an array of strings produces a BagHash
        ok 1559 - ...with the right elements
        ok 1560 - &BagHash.new given something and an array of pairs produces a BagHash
        ok 1561 - ... with two elements
        ok 1562 - &BagHash.new given a Hash produces a BagHash
        ok 1563 - ... with four elements
        ok 1564 - ... which are all Pairs
        ok 1565 - &BagHash.new given a Hash and something produces a BagHash
        ok 1566 - ... with one element
        ok 1567 - &BagHash.new given a Set produces a BagHash
        ok 1568 - ... with one element
        ok 1569 - &BagHash.new given a SetHash produces a BagHash
        ok 1570 - ... with one element
        ok 1571 - &BagHash.new given a Bag produces a BagHash
        ok 1572 - ... with one element
        ok 1573 - .list returns 3 things
        ok 1574 - ... all of which are Pairs
        ok 1575 - .pairs returns 3 things
        ok 1576 - ... all of which are Pairs
        ok 1577 - ... the keys of which are Strs
        ok 1578 - ... and the values of which are Ints
        ok 1579 - .raku lives
        ok 1580 - ... and produces a string
        ok 1581 - ... of reasonable length
        ok 1582 - .raku.EVAL lives
        ok 1583 - ... and produces a BagHash
        ok 1584 - ... and it has the correct values
        ok 1585 - .Str lives
        ok 1586 - ... and produces a string
        ok 1587 - ... which only contains bar baz and foo with the proper counts and separated by spaces
        ok 1588 - .gist lives
        ok 1589 - ... and produces a string
        ok 1590 - ... of reasonable length
        ok 1591 - ... which mentions foo
        ok 1592 - ... which mentions bar
        ok 1593 - ... which mentions baz
        ok 1594 - A BagHash bound to a %var is a BagHash
        ok 1595 - ...with the right elements
        ok 1596 - Single-key subscript (existing element)
        ok 1597 - Single-key subscript (nonexistent element)
        ok 1598 - Assign to an element
        ok 1599 - ... and gets the correct value
        ok 1600 - We got one of the two choices
        ok 1601 - .roll(2) returns the right number of items
        ok 1602 - .roll(2) returned "a"s and "b"s
        ok 1603 - .roll(100) returns 100 items
        ok 1604 - .roll(100) (1)
        ok 1605 - .roll(100) (2)
        ok 1606 - .roll(100) (1)
        ok 1607 - .roll(100) (2)
        ok 1608 - .roll should not change BagHash
        ok 1609 - .roll should not change BagHash
        ok 1610 - We got one of the two choices (and this was pretty quick, we hope!)
        ok 1611 - .roll(100) returns 100 items
        ok 1612 - .roll(100) (1)
        ok 1613 - .roll(100) (2)
        ok 1614 - .roll should not change BagHash
        ok 1615 - .roll should not change BagHash
        ok 1616 - We got one of the two choices
        ok 1617 - .pick(2) returns the right number of items
        ok 1618 - .pick(2) returned at most one "a"
        ok 1619 - .pick(2) and the rest are "b"
        ok 1620 - .pick(*) returns the right number of items
        ok 1621 - .pick(*) (1)
        ok 1622 - .pick(*) (2)
        ok 1623 - .pick should not change BagHash
        ok 1624 - .pick should not change BagHash
        ok 1625 - .pick(Callable) returns the right number of items
        ok 1626 - .pick should not change BagHash
        ok 1627 - .pick should not change BagHash
        ok 1628 - .pick(<negative number>) does not return any items
        ok 1629 - .pick int-ifies arg
        ok 1630 - We got one of the two choices (and this was pretty quick, we hope!)
        ok 1631 - .pick(100) returns 100 items
        ok 1632 - .pick(100) (1)
        ok 1633 - .pick(100) (2)
        ok 1634 - .pick should not change BagHash
        ok 1635 - .pick should not change BagHash
:a(:a(1))
        ok 1636 - Did we get a Pair
        ok 1637 - We got one of the two choices
        ok 1638 - .pickpairs(2) returns the right number of items
        ok 1639 - .pickpairs(2) returned one "a"
        ok 1640 - .pickpairs(2) returned one "b"
        ok 1641 - .pickpairs(*) returns the right number of items
        ok 1642 - .pickpairs(*) (1)
        ok 1643 - .pickpairs(*) (2)
        ok 1644 - .pickpairs should not change Bag
        ok 1645 - .pickpairs(<negative number>) does not return any items
        ok 1646 - .pickpairs(Callable) returns the right number of items
        ok 1647 - are they all Pairs
        ok 1648 - and they all have an expected value
        ok 1649 - .pickpairs should not change BagHash
        ok 1650 - .pickpairs should not change BagHash
        ok 1651 - We got one of the two choices
        ok 1652 - .grab(2) returns the right number of items
        ok 1653 - .grab(2) returned at most one "a"
        ok 1654 - .grab(2) and the rest are "b"
        ok 1655 - .grab *should* change BagHash
        ok 1656 - .grab *should* change BagHash
        ok 1657 - .grab(*) returns the right number of items
        ok 1658 - .grab(*) (1)
        ok 1659 - .grab(*) (2)
        ok 1660 - .grab *should* change BagHash
        ok 1661 - .grab *should* change BagHash
        ok 1662 - .grab(Callable) returns the right number of items
        ok 1663 - .grab *should* change BagHash
        ok 1664 - We got one of the two choices (and this was pretty quick, we hope!)
        ok 1665 - .grab(100) returns 100 items
        ok 1666 - .grab(100) (1)
        ok 1667 - .grab(100) (2)
        ok 1668 - .grab *should* change BagHash
        ok 1669 - .grab *should* change BagHash
        ok 1670 - did we get a Pair
        ok 1671 - We got one of the two choices
        ok 1672 - .grabpairs(2) returns the right number of items
        ok 1673 - are they all Pairs
        ok 1674 - We got one of the two choices
        ok 1675 - .grabpairs *should* change BagHash
        ok 1676 - .grabpairs *should* change BagHash
        ok 1677 - .grabpairs(*) returns the right number of items
        ok 1678 - are they all Pairs
        ok 1679 - and they all have an expected value
        ok 1680 - SetHash.grabpairs(*) gets all elements
        ok 1681 - SetHash.grabpairs(*) returns elements in a random order
        ok 1682 - .grabpairs *should* change BagHash
        ok 1683 - .grabpairs *should* change BagHash
        ok 1684 - .grabpairs(Callable) returns the right number of items
        ok 1685 - are they all Pairs
        ok 1686 - and they all have an expected value
        ok 1687 - .grabpairs *should* change BagHash
        ok 1688 - .grabpairs *should* change BagHash
        ok 1689 - can we parameterize for strings?
        ok 1690 - does .keyof return the correct type
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::TypeCheck::Binding)
        ok 1691 - does attempt to add item of wrong type croak
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::TypeCheck::Binding)
        ok 1692 - do wrong values make initialization croak
        ok 1693 - "b", initialized to zero, does not exist
        ok 1694 - Inititalization worked
        ok 1695 - .elems works
        ok 1696 - %h<nonexisting> is an Int
        ok 1697 - %h<nonexisting> is 0
        ok 1698 - can set an item to 0
        ok 1699 - "c", set to zero, does not exist
        ok 1700 - one item left
        ok 1701 - ... and the right one is gone
        ok 1702 - can add (++) an item that was removed
        ok 1703 - ++ on an item reinstates it
        ok 1704 - can "add" (++) an existing item
        ok 1705 - ++ on an existing item increments the counter
        ok 1706 - ++ on an existing item does not add a key
        ok 1707 - can remove an item with decrement (--)
        ok 1708 - decrement (--) removes items
        ok 1709 - item is gone according to exists too
        ok 1710 - removed item is zero
        ok 1711 - remove a missing item lives
        ok 1712 - removing missing item does not change contents
        ok 1713 - item removed again is still zero
        ok 1714 - is the hash really a BagHash
        not ok 1715 - Assigning a Bag to a BagHash # TODO in flux
        # Failed test 'Assigning a Bag to a BagHash'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/baghash.rakudo line 516
        # Type check failed in assignment to %h; expected BagHash but got Int (2)
        not ok 1716 - ... works as expected # TODO in flux
        # Failed test '... works as expected'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/baghash.rakudo line 517
        # expected: 'a:1 b:2 c:2 d:1'
        #      got: ''
        ok 1717 - Method .BagHash works on Int-1
        ok 1718 - Method .BagHash works on Int-2
        ok 1719 - Method .BagHash works on Str-1
        ok 1720 - Method .BagHash works on Str-2
        ok 1721 - Method .BagHash works on Array-1
        ok 1722 - Method .BagHash works on Array-2
        ok 1723 - Method .BagHash works on Hash-1
        ok 1724 - Method .BagHash works on Hash-2
        ok 1725 - Method .BagHash works on List-1
        ok 1726 - Method .BagHash works on List-2
        ok 1727 - .total gives sum of values (non-empty) 10
        ok 1728 - +$bag gives sum of values (non-empty) 10
        ok 1729 - .minpairs works (non-empty) 10
        ok 1730 - .maxpairs works (non-empty) 10
        ok 1731 - .fmt(%s) works (non-empty 10)
        ok 1732 - .fmt(%s,sep) works (non-empty 10)
        ok 1733 - .fmt(%s%s) works (non-empty 10)
        ok 1734 - .fmt(%s%s,sep) works (non-empty 10)
        ok 1735 - .total gives sum of values (non-empty) 8
        ok 1736 - +$bag gives sum of values (non-empty) 8
        ok 1737 - .minpairs works (non-empty) 8
        ok 1738 - .maxpairs works (non-empty) 8
        ok 1739 - .total gives sum of values (non-empty) 4
        ok 1740 - +$bag gives sum of values (non-empty) 4
        ok 1741 - .minpairs works (non-empty) 4
        ok 1742 - .maxpairs works (non-empty) 4
        ok 1743 - .total gives sum of values (empty)
        ok 1744 - +$bag gives sum of values (empty)
        ok 1745 - .minpairs works (empty)
        ok 1746 - .maxpairs works (empty)
        ok 1747 - .fmt(%s) works (empty)
        ok 1748 - .fmt(%s,sep) works (empty)
        ok 1749 - .fmt(%s%s) works (empty)
        ok 1750 - .fmt(%s%s,sep) works (empty)
        ok 1751 - first key of BagHash is a Pair ("a" => "b")
        ok 1752 - again first key of BagHash is a Pair ("a" => "b")
        ok 1753 - named argument is happily eaten by .new method
        ok 1754 - did we set an Int value
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Str::Numeric)
        ok 1755 - Make sure we cannot assign Str on a key
        ok 1756 - did we set an Int value from a .values alias
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Str::Numeric)
        ok 1757 - Make sure we cannot assign Str on a .values alias
        ok 1758 - did we set an Int value from a .pairs alias
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Str::Numeric)
        ok 1759 - Make sure we cannot assign Str on a .pairs alias
        ok 1760 - did we set an Int value from a .kv alias
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Str::Numeric)
        ok 1761 - Make sure we cannot assign Str on a .kv alias
        ok 1762 - did we see all values
        ok 1763 - did we see all keys
        ok 1764 - did we see all the pairs
        ok 1765 - did we see all the kv
        ok 1766 - did we see all the antipairs
        ok 1767 - did we see all the kxxv
            1..2
            ok 1 - BagHash.new
            ok 2 - .BagHash
        ok 1768 - .hash does not cause keys to be stringified
        ok 1769 - .BagHash returns equivalent BagHash
        ok 1770 - .Mix returns a Mix
        ok 1771 - .Mix values are correct
            1..10
            ok 1 - correct return of postfix ++
            ok 2 - correct result of postfix ++
            ok 3 - correct return of postfix --
            ok 4 - correct result of postfix --
            ok 5 - correct return of prefix ++
            ok 6 - correct result of prefix ++
            ok 7 - correct return of prefix --
            ok 8 - correct result of prefix --
            ok 9 - correct return of assignment
            ok 10 - correct result of assignment
        ok 1772 - BagHash autovivification of non-existent keys
        ok 1773 - Can use $_ from .values to remove occurrences from BagHash
        ok 1774 - Can use $_ from .values to set number occurrences in BagHash
        ok 1775 - Can use $_ from .values to remove items from BagHash
        ok 1776 - Can use value from .kv to remove occurrences from BagHash
        ok 1777 - Can use value from .kv to set number occurrences in BagHash
        ok 1778 - Can use $_ from .kv to remove items from BagHash
        ok 1779 - Can use value from .pairs to remove occurrences from BagHash
        ok 1780 - Can use value from .pairs to set number occurrences in BagHash
        ok 1781 - Can use $_ from .pairs to remove items from BagHash
            1..3
            ok 1 - code dies
            ok 2 - right exception type (X::Cannot::Lazy)
            ok 3 - .what matches BagHash
        ok 1782 - did we throws-like X::Cannot::Lazy?
            1..3
            ok 1 - code dies
            ok 2 - right exception type (X::Cannot::Lazy)
            ok 3 - .what matches BagHash
        ok 1783 - did we throws-like X::Cannot::Lazy?
            1..3
            ok 1 - code dies
            ok 2 - right exception type (X::Cannot::Lazy)
            ok 3 - .what matches BagHash
        ok 1784 - did we throws-like X::Cannot::Lazy?
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Str::Numeric)
        ok 1785 - (:a("a")).BagHash throws
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Str::Numeric)
        ok 1786 - BagHash.new-from-pairs( (:a("a")) ) throws
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Numeric::CannotConvert)
        ok 1787 - (:a(Inf)).BagHash throws
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Numeric::CannotConvert)
        ok 1788 - BagHash.new-from-pairs( (:a(Inf)) ) throws
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Numeric::CannotConvert)
        ok 1789 - (:a(-Inf)).BagHash throws
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Numeric::CannotConvert)
        ok 1790 - BagHash.new-from-pairs( (:a(-Inf)) ) throws
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Numeric::CannotConvert)
        ok 1791 - (:a(NaN)).BagHash throws
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Numeric::CannotConvert)
        ok 1792 - BagHash.new-from-pairs( (:a(NaN)) ) throws
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Numeric::CannotConvert)
        ok 1793 - (:a(<0+3i>)).BagHash throws
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Numeric::CannotConvert)
        ok 1794 - BagHash.new-from-pairs( (:a(<0+3i>)) ) throws
            1..3
            ok 1 - weight decrement
            ok 2 - Pair value decrement
            ok 3 - weight set to zero
        ok 1795 - elements with weight zero are removed
            1..2
            ok 1 - weight < 0 removes element
            ok 2 - Pair value < 0 removes element
        ok 1796 - elements with negative weights are removed
        ok 1797 - can .grab() a BagHash key with weight larger than 64 bits
        ok 1798 - did we get right number of elements
        ok 1799 - do we get 1 for a
        ok 1800 - do we get 0 value for e
        ok 1801 - is the %h really a BagHash
        ok 1802 - did we get right number of elements after re-init
        ok 1803 - did we get 5 by removing e
        ok 1804 - did we get right number of elements after :delete
        ok 1805 - can delete from BagHash by assignment
        ok 1806 - did we get right number of elements assignment
        ok 1807 - can successfully set >64-bit value
        ok 1808 - can we smartmatch empty
        ok 1809 - coerce BagHash -> Set
        ok 1810 - coerce BagHash -> SetHash
        ok 1811 - coerce BagHash -> Bag
        ok 1812 - coerce BagHash -> Mix
        ok 1813 - coerce BagHash -> MixHash
        ok 1814 - parameterized BagHash
        ok 1815 - did it parameterize ok
        ok 1816 - adding element of wrong type fails
        ok 1817 - must have Ints on creation
        ok 1818 - does .item work on BagHashes
# FUDGED!
        1..7
        ok 1819 - basic sanity test (1)
        ok 1820 - basic sanity test (2)
        ok 1821 - # SKIP cat NYI
        ok 1822 - # SKIP cat NYI
        ok 1823 - # SKIP cat NYI
        ok 1824 - # SKIP cat NYI
        ok 1825 - # SKIP cat NYI
# FUDGED!
        1..70
        ok 1826 - The object is-a 'Int'
        ok 1827 - The object is-a 'Num'
        ok 1828 - The object is-a 'Complex'
        ok 1829 - The object is-a 'Rat'
        ok 1830 - The object is-a 'Str'
        ok 1831 - # SKIP Bit NYI
        ok 1832 - The object is-a 'Regex'
        ok 1833 - The object is-a 'Set'
        ok 1834 - The object is-a 'Block'
        ok 1835 - The object is-a 'List'
        ok 1836 - The object is-a 'Scalar'
        ok 1837 - The object is-a 'Array'
        ok 1838 - The object is-a 'Hash'
        ok 1839 - 
        ok 1840 - The object is-a 'Routine'
        ok 1841 - The object is-a 'Stash'
        ok 1842 - 
        ok 1843 - # SKIP Integral NYI
            1..3
            ok 1 - code dies
            ok 2 - right exception type (Exception)
            ok 3 - .message matches Cannot unbox 101 bit wide bigint into native integer
        ok 1844 - Assign big bigint to native won't overflow silently
        ok 1845 - num reports as Num
        ok 1846 - num dispatches properly
        ok 1847 - # SKIP complex NYI
        ok 1848 - # SKIP rat NYI
        ok 1849 - # SKIP bit NYI
        ok 1850 - # SKIP buf NYI
        ok 1851 - 
        ok 1852 - The object is-a 'Whatever'
        ok 1853 - 
        ok 1854 - The object is-a 'Failure'
        ok 1855 - The object is-a 'Exception'
        ok 1856 - The object is-a 'Range'
        ok 1857 - The object is-a 'Bag'
        ok 1858 - The object is-a 'Signature'
        ok 1859 - The object is-a 'Capture'
        ok 1860 - 
        ok 1861 - The object is-a 'Instant'
        ok 1862 - The object is-a 'Duration'
        ok 1863 - The object does QuantHash
        ok 1864 - The object is-a 'SetHash'
        ok 1865 - The object is-a 'BagHash'
        ok 1866 - The object is-a 'Pair'
        ok 1867 - The object is-a 'Map'
        ok 1868 - The object is-a 'Routine'
        ok 1869 - The object is-a 'Sub'
        ok 1870 - The object is-a 'Sub'
        ok 1871 - nested sub call
        ok 1872 - nested sub call
        ok 1873 - The object is-a 'Method'
        ok 1874 - The object is-a 'Submethod'
        ok 1875 - The object is-a 'Macro'
        ok 1876 - The object is-a 'Match'
        ok 1877 - The object is-a 'Grammar'
        ok 1878 - The object is-a 'Any'
        ok 1879 - The object is-a 'Bool'
        ok 1880 - The object is-a 'Order'
        ok 1881 - # SKIP Matcher isa NYI
        ok 1882 - The object is-a 'Proxy'
        ok 1883 - Positional exists
        ok 1884 - Associative exists
        ok 1885 - # SKIP Ordering NYI
        ok 1886 - # SKIP KeyExtractor NYI
        ok 1887 - # SKIP Comparator NYI
        ok 1888 - # SKIP OrderingPair NYI
        ok 1889 - The object is-a 'HyperWhatever'
        ok 1890 - The object is-a 'utf8'
        ok 1891 - The object is-a 'utf16'
        ok 1892 - The object is-a 'utf32'
        ok 1893 - # SKIP num16  NYI
        ok 1894 - Array of Int @box
        ok 1895 - Array of Array of Int @box
# FUDGED!
        1..21
        ok 1896 - numeric equal
        ok 1897 - string equal
        ok 1898 - negative numeric equal
        ok 1899 - negative string equal
        ok 1900 - # SKIP integer Inf
        ok 1901 - # SKIP integer Inf
        ok 1902 - # SKIP integer -Inf
        ok 1903 - # SKIP integer -Inf
        ok 1904 - truncate(Inf) ~~ Inf
            1..2
            ok 1 - code returned a Failure
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::Numeric::CannotConvert)
            ok 2 - Failure threw when sunk
        ok 1905 - attempting to convert Inf to Int throws
            1..2
            ok 1 - code returned a Failure
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::Numeric::CannotConvert)
            ok 2 - Failure threw when sunk
        ok 1906 - attempting to convert Inf to Int throws
            1..2
            ok 1 - code returned a Failure
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::Numeric::CannotConvert)
            ok 2 - Failure threw when sunk
        ok 1907 - attempting to convert ∞ to Int throws
            1..2
            ok 1 - code returned a Failure
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::Numeric::CannotConvert)
            ok 2 - Failure threw when sunk
        ok 1908 - attempting to convert -∞ to Int throws
            1..2
            ok 1 - code returned a Failure
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::Numeric::CannotConvert)
            ok 2 - Failure threw when sunk
        ok 1909 - attempting to convert NaN to Int throws
        ok 1910 - multiply rand by Inf without maximum recursion depth exceeded
            1..4
            ok 1 - 'my Int $x = Inf' died
            ok 2 - right exception type (X::Syntax::Number::LiteralType)
            ok 3 - .value matches Inf
            ok 4 - .vartype matches (Int)
        ok 1911 - trying to assign Inf to Int gives a helpful error
        ok 1912 - assigning Inf to Num works without errors
        ok 1913 - -Inf² follows mathematical order of operations
        ok 1914 - -∞² follows mathematical order of operations
        ok 1915 - −Inf² follows mathematical order of operations (U+2212 minus)
        ok 1916 - −∞² follows mathematical order of operations (U+2212 minus)
# FUDGED!
        1..103
        ok 1917 - int8 can be 127
        ok 1918 - int8 can be -128
        ok 1919 - int8 overflows to -128
        ok 1920 - int8 underflows to 127
            1..2
            not ok 1 - code dies # TODO setting more than max throws
            # Failed test 'code dies'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 78
            ok 2 - # SKIP Code did not die, can not check exception
        not ok 1921 - setting int8 to more than 127 throws # TODO setting more than max throws
        # Failed test 'setting int8 to more than 127 throws'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 78
            1..2
            not ok 1 - code dies # TODO setting less than min throws
            # Failed test 'code dies'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 93
            ok 2 - # SKIP Code did not die, can not check exception
        not ok 1922 - setting int8 to less than -128 throws # TODO setting less than min throws
        # Failed test 'setting int8 to less than -128 throws'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 93
            1..2
            ok 1 - code dies
            ok 2 - right exception type (Exception)
        ok 1923 - int8 cannot be a string
            1..2
            ok 1 - code dies
            ok 2 - right exception type (Exception)
        ok 1924 - int8 cannot be non-integer
            1..2
            ok 1 - code dies
            ok 2 - right exception type (Exception)
        ok 1925 - int8 cannot be NaN
        ok 1926 - int8 $var++ works
        ok 1927 - int8 $var-- works
WARNING: unhandled Failure detected in DESTROY. If you meant to ignore it, you can mark it as handled by calling .Bool, .so, .not, or .defined methods. The Failure was:
Index out of range. Is: 1, should be in 0..0
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/array.rakudo line 284
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/array.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

        ok 1928 - int16 can be 32767
        ok 1929 - int16 can be -32768
        ok 1930 - int16 overflows to -32768
        ok 1931 - int16 underflows to 32767
            1..2
            not ok 1 - code dies # TODO setting more than max throws
            # Failed test 'code dies'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 78
            ok 2 - # SKIP Code did not die, can not check exception
        not ok 1932 - setting int16 to more than 32767 throws # TODO setting more than max throws
        # Failed test 'setting int16 to more than 32767 throws'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 78
            1..2
            not ok 1 - code dies # TODO setting less than min throws
            # Failed test 'code dies'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 93
            ok 2 - # SKIP Code did not die, can not check exception
        not ok 1933 - setting int16 to less than -32768 throws # TODO setting less than min throws
        # Failed test 'setting int16 to less than -32768 throws'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 93
            1..2
            ok 1 - code dies
            ok 2 - right exception type (Exception)
        ok 1934 - int16 cannot be a string
            1..2
            ok 1 - code dies
            ok 2 - right exception type (Exception)
        ok 1935 - int16 cannot be non-integer
            1..2
            ok 1 - code dies
            ok 2 - right exception type (Exception)
        ok 1936 - int16 cannot be NaN
        ok 1937 - int16 $var++ works
        ok 1938 - int16 $var-- works
        ok 1939 - int32 can be 2147483647
        ok 1940 - int32 can be -2147483648
        ok 1941 - int32 overflows to -2147483648
        ok 1942 - int32 underflows to 2147483647
            1..2
            not ok 1 - code dies # TODO setting more than max throws
            # Failed test 'code dies'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 78
            ok 2 - # SKIP Code did not die, can not check exception
        not ok 1943 - setting int32 to more than 2147483647 throws # TODO setting more than max throws
        # Failed test 'setting int32 to more than 2147483647 throws'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 78
            1..2
            not ok 1 - code dies # TODO setting less than min throws
            # Failed test 'code dies'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 93
            ok 2 - # SKIP Code did not die, can not check exception
        not ok 1944 - setting int32 to less than -2147483648 throws # TODO setting less than min throws
        # Failed test 'setting int32 to less than -2147483648 throws'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 93
            1..2
            ok 1 - code dies
            ok 2 - right exception type (Exception)
        ok 1945 - int32 cannot be a string
            1..2
            ok 1 - code dies
            ok 2 - right exception type (Exception)
        ok 1946 - int32 cannot be non-integer
            1..2
            ok 1 - code dies
            ok 2 - right exception type (Exception)
        ok 1947 - int32 cannot be NaN
        ok 1948 - int32 $var++ works
        ok 1949 - int32 $var-- works
        ok 1950 - int64 can be 9223372036854775807
        ok 1951 - int64 can be -9223372036854775808
        ok 1952 - int64 overflows to -9223372036854775808
        ok 1953 - int64 underflows to 9223372036854775807
            1..2
            ok 1 - code dies
            ok 2 - right exception type (Exception)
        ok 1954 - setting int64 to more than 9223372036854775807 throws
            1..2
            ok 1 - code dies
            ok 2 - right exception type (Exception)
        ok 1955 - setting int64 to less than -9223372036854775808 throws
            1..2
            ok 1 - code dies
            ok 2 - right exception type (Exception)
        ok 1956 - int64 cannot be a string
            1..2
            ok 1 - code dies
            ok 2 - right exception type (Exception)
        ok 1957 - int64 cannot be non-integer
            1..2
            ok 1 - code dies
            ok 2 - right exception type (Exception)
        ok 1958 - int64 cannot be NaN
        ok 1959 - int64 $var++ works
        ok 1960 - int64 $var-- works
        ok 1961 - uint8 can be 255
        ok 1962 - uint8 can be 0
        ok 1963 - uint8 overflows to 0
        ok 1964 - uint8 underflows to 255
            1..2
            not ok 1 - code dies # TODO setting more than max throws
            # Failed test 'code dies'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 78
            ok 2 - # SKIP Code did not die, can not check exception
        not ok 1965 - setting uint8 to more than 255 throws # TODO setting more than max throws
        # Failed test 'setting uint8 to more than 255 throws'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 78
            1..2
            not ok 1 - code dies # TODO setting less than min throws
            # Failed test 'code dies'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 93
            ok 2 - # SKIP Code did not die, can not check exception
        not ok 1966 - setting uint8 to less than 0 throws # TODO setting less than min throws
        # Failed test 'setting uint8 to less than 0 throws'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 93
            1..2
            ok 1 - code dies
            ok 2 - right exception type (Exception)
        ok 1967 - uint8 cannot be a string
            1..2
            ok 1 - code dies
            ok 2 - right exception type (Exception)
        ok 1968 - uint8 cannot be non-integer
            1..2
            ok 1 - code dies
            ok 2 - right exception type (Exception)
        ok 1969 - uint8 cannot be NaN
        ok 1970 - uint8 $var++ works
        ok 1971 - uint8 $var-- works
        ok 1972 - uint16 can be 65535
        ok 1973 - uint16 can be 0
        ok 1974 - uint16 overflows to 0
        ok 1975 - uint16 underflows to 65535
            1..2
            not ok 1 - code dies # TODO setting more than max throws
            # Failed test 'code dies'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 78
            ok 2 - # SKIP Code did not die, can not check exception
        not ok 1976 - setting uint16 to more than 65535 throws # TODO setting more than max throws
        # Failed test 'setting uint16 to more than 65535 throws'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 78
            1..2
            not ok 1 - code dies # TODO setting less than min throws
            # Failed test 'code dies'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 93
            ok 2 - # SKIP Code did not die, can not check exception
        not ok 1977 - setting uint16 to less than 0 throws # TODO setting less than min throws
        # Failed test 'setting uint16 to less than 0 throws'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 93
            1..2
            ok 1 - code dies
            ok 2 - right exception type (Exception)
        ok 1978 - uint16 cannot be a string
            1..2
            ok 1 - code dies
            ok 2 - right exception type (Exception)
        ok 1979 - uint16 cannot be non-integer
            1..2
            ok 1 - code dies
            ok 2 - right exception type (Exception)
        ok 1980 - uint16 cannot be NaN
        ok 1981 - uint16 $var++ works
        ok 1982 - uint16 $var-- works
        ok 1983 - uint32 can be 4294967295
        ok 1984 - uint32 can be 0
        ok 1985 - uint32 overflows to 0
        ok 1986 - uint32 underflows to 4294967295
            1..2
            not ok 1 - code dies # TODO setting more than max throws
            # Failed test 'code dies'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 78
            ok 2 - # SKIP Code did not die, can not check exception
        not ok 1987 - setting uint32 to more than 4294967295 throws # TODO setting more than max throws
        # Failed test 'setting uint32 to more than 4294967295 throws'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 78
            1..2
            not ok 1 - code dies # TODO setting less than min throws
            # Failed test 'code dies'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 93
            ok 2 - # SKIP Code did not die, can not check exception
        not ok 1988 - setting uint32 to less than 0 throws # TODO setting less than min throws
        # Failed test 'setting uint32 to less than 0 throws'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 93
            1..2
            ok 1 - code dies
            ok 2 - right exception type (Exception)
        ok 1989 - uint32 cannot be a string
            1..2
            ok 1 - code dies
            ok 2 - right exception type (Exception)
        ok 1990 - uint32 cannot be non-integer
            1..2
            ok 1 - code dies
            ok 2 - right exception type (Exception)
        ok 1991 - uint32 cannot be NaN
        ok 1992 - uint32 $var++ works
        ok 1993 - uint32 $var-- works
        not ok 1994 - uint64 can be 18446744073709551615 # TODO getting -1 instead of 18446744073709551615
        # Failed test 'uint64 can be 18446744073709551615'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 28
        # expected: '18446744073709551615'
        #      got: '-1'
        ok 1995 - uint64 can be 0
        ok 1996 - uint64 overflows to 0
        not ok 1997 - uint64 underflows to 18446744073709551615 # TODO getting -1 instead of 0
        # Failed test 'uint64 underflows to 18446744073709551615'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 52
        # expected: '18446744073709551615'
        #      got: '-1'
            1..2
            ok 1 - code dies
            ok 2 - right exception type (Exception)
        ok 1998 - setting uint64 to more than 18446744073709551615 throws
            1..2
            not ok 1 - code dies # TODO setting less than min throws
            # Failed test 'code dies'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 93
            ok 2 - # SKIP Code did not die, can not check exception
        not ok 1999 - setting uint64 to less than 0 throws # TODO setting less than min throws
        # Failed test 'setting uint64 to less than 0 throws'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 93
            1..2
            ok 1 - code dies
            ok 2 - right exception type (Exception)
        ok 2000 - uint64 cannot be a string
            1..2
            ok 1 - code dies
            ok 2 - right exception type (Exception)
        ok 2001 - uint64 cannot be non-integer
            1..2
            ok 1 - code dies
            ok 2 - right exception type (Exception)
        ok 2002 - uint64 cannot be NaN
        ok 2003 - uint64 $var++ works
        ok 2004 - uint64 $var-- works
        ok 2005 - byte can be 255
        ok 2006 - byte can be 0
        ok 2007 - byte overflows to 0
        ok 2008 - byte underflows to 255
            1..2
            not ok 1 - code dies # TODO setting more than max throws
            # Failed test 'code dies'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 78
            ok 2 - # SKIP Code did not die, can not check exception
        not ok 2009 - setting byte to more than 255 throws # TODO setting more than max throws
        # Failed test 'setting byte to more than 255 throws'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 78
            1..2
            not ok 1 - code dies # TODO setting less than min throws
            # Failed test 'code dies'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 93
            ok 2 - # SKIP Code did not die, can not check exception
        not ok 2010 - setting byte to less than 0 throws # TODO setting less than min throws
        # Failed test 'setting byte to less than 0 throws'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 93
            1..2
            ok 1 - code dies
            ok 2 - right exception type (Exception)
        ok 2011 - byte cannot be a string
            1..2
            ok 1 - code dies
            ok 2 - right exception type (Exception)
        ok 2012 - byte cannot be non-integer
            1..2
            ok 1 - code dies
            ok 2 - right exception type (Exception)
        ok 2013 - byte cannot be NaN
        ok 2014 - byte $var++ works
        ok 2015 - byte $var-- works
        ok 2016 - uint32 in union is unsigned
        not ok 2017 - uint16 in union is unsigned # TODO uint behaves like signed int in CUnion
        # Failed test 'uint16 in union is unsigned'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 123
        # expected: '54919'
        #      got: '-10617'
        not ok 2018 - uint8 in union is unsigned # TODO uint behaves like signed int in CUnion
        # Failed test 'uint8 in union is unsigned'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/int-uint.rakudo line 124
        # expected: '135'
        #      got: '-121'
        ok 2019 - byte.Range works
# FUDGED!
        1..14
        ok 2020 - is TypeName on @ sigil has effect (my)
        ok 2021 - is TypeName on % sigil has effect (my)
        ok 2022 - is TypeName on @ sigil has effect (state)
        ok 2023 - is TypeName on % sigil has effect (state)
        ok 2024 - is TypeName on @ sigil has effect (has)
        ok 2025 - is TypeName on % sigil has effect (has)
        ok 2026 - Get fresh BagHash in my variable per iteration (0)
        ok 2027 - Get fresh BagHash in my variable per iteration (1)
        ok 2028 - # SKIP state variables with `is BagHash`
        ok 2029 - # SKIP state variables with `is BagHash`
        ok 2030 - Get fresh BagHash in new object per iteration (0)
        ok 2031 - Get fresh BagHash in new object per iteration (1)
        not ok 2032 - can we have parameterized type
        # Failed test 'can we have parameterized type'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/is-type.rakudo line 59
        # Error: No appropriate parametric role variant available for 'Abyss::Server::Mod::Foo':
        #     Cannot resolve caller (Abyss::Server::Mod::Foo[Int,Str,Instant]:U, Int:U, Str:U, Instant:U); none of these signatures match:
        #         (::$?CLASS ::::?CLASS Mu, Mu \T)
            1..4
            ok 1 - 'my @a is Int is Str' died
            ok 2 - right exception type (X::Syntax::Variable::ConflictingTypes)
            ok 3 - .inner matches (Str)
            ok 4 - .outer matches (Int)
        ok 2033 - did we throw on multiple "is" types
# FUDGED!
        1..13
        ok 2034 - was "a" really called
        not ok 2035 - right deprecation for a()
        # Failed test 'right deprecation for a()'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/isDEPRECATED.rakudo line 22
        # expected: 'Saw 1 occurrence of deprecated code.
        # ================================================================================
        # Sub a (from GLOBAL) seen at:
        #   other/startup.p6, line 20
        # Please use something else instead.
        # --------------------------------------------------------------------------------'
        #      got: 'Saw 1 occurrence of deprecated code.
        # ================================================================================
        # Sub a (from Abyss::Server::Mod) seen at:
        #   /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/isDEPRECATED.rakudo, line 20
        # Please use something else instead.
        # --------------------------------------------------------------------------------'
        ok 2036 - was "awith" really called
        not ok 2037 - right deprecation for awith()
        # Failed test 'right deprecation for awith()'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/isDEPRECATED.rakudo line 34
        # expected: 'Saw 1 occurrence of deprecated code.
        # ================================================================================
        # Sub awith (from GLOBAL) seen at:
        #   other/startup.p6, lines 31,32
        # Please use 'fnorkle' instead.
        # --------------------------------------------------------------------------------'
        #      got: 'Saw 1 occurrence of deprecated code.
        # ================================================================================
        # Sub awith (from Abyss::Server::Mod) seen at:
        #   /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/isDEPRECATED.rakudo, lines 31,32
        # Please use 'fnorkle' instead.
        # --------------------------------------------------------------------------------'
        not ok 2038 - right deprecation for A.new # TODO NYI
        # Failed test 'right deprecation for A.new'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/isDEPRECATED.rakudo line 51
        # expected: 'Saw 1 occurrence of deprecated code.
        # ================================================================================
        # Method new (from A) seen at:
        #   other/startup.p6, line 49
        # Please use something else instead.
        # --------------------------------------------------------------------------------'
        #      got: (Nil)
        not ok 2039 - right deprecation for Awith.new # TODO NYI
        # Failed test 'right deprecation for Awith.new'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/isDEPRECATED.rakudo line 63
        # expected: 'Saw 1 occurrence of deprecated code.
        # ================================================================================
        # Method new (from Awith) seen at:
        #   other/startup.p6, lines 60,61
        # Please use 'Fnorkle.new' instead.
        # --------------------------------------------------------------------------------'
        #      got: (Nil)
        ok 2040 - was "C.new.foo" really called
        not ok 2041 - right deprecation for C.new.foo
        # Failed test 'right deprecation for C.new.foo'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/isDEPRECATED.rakudo line 82
        # expected: 'Saw 1 occurrence of deprecated code.
        # ================================================================================
        # Method foo (from C) seen at:
        #   other/startup.p6, line 80
        # Please use something else instead.
        # --------------------------------------------------------------------------------'
        #      got: 'Saw 1 occurrence of deprecated code.
        # ================================================================================
        # Method foo (from Abyss::Server::Mod::C) seen at:
        #   /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/isDEPRECATED.rakudo, line 80
        # Please use something else instead.
        # --------------------------------------------------------------------------------'
        ok 2042 - was "Cwith.new.foo" really called
        not ok 2043 - right deprecation Cwith.new.foo
        # Failed test 'right deprecation Cwith.new.foo'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/isDEPRECATED.rakudo line 94
        # expected: 'Saw 1 occurrence of deprecated code.
        # ================================================================================
        # Method foo (from Cwith) seen at:
        #   other/startup.p6, lines 91,92
        # Please use 'bar' instead.
        # --------------------------------------------------------------------------------'
        #      got: 'Saw 1 occurrence of deprecated code.
        # ================================================================================
        # Method foo (from Abyss::Server::Mod::Cwith) seen at:
        #   /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/isDEPRECATED.rakudo, lines 91,92
        # Please use 'bar' instead.
        # --------------------------------------------------------------------------------'
        not ok 2044 - right deprecation for D.new.foo
        # Failed test 'right deprecation for D.new.foo'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/isDEPRECATED.rakudo line 110
        # expected: 'Saw 1 occurrence of deprecated code.
        # ================================================================================
        # Method foo (from D) seen at:
        #   other/startup.p6, line 109
        # Please use something else instead.
        # --------------------------------------------------------------------------------'
        #      got: 'Saw 1 occurrence of deprecated code.
        # ================================================================================
        # Method foo (from Abyss::Server::Mod::D) seen at:
        #   /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/isDEPRECATED.rakudo, line 109
        # Please use something else instead.
        # --------------------------------------------------------------------------------'
        not ok 2045 - right deprecation Dwith.new.foo # TODO NYI
        # Failed test 'right deprecation Dwith.new.foo'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/isDEPRECATED.rakudo line 122
        # expected: 'Saw 1 occurrence of deprecated code.
        # ================================================================================
        # Method foo (from Dwith) seen at:
        #   other/startup.p6, lines 119,120
        # Please use 'bar' instead.
        # --------------------------------------------------------------------------------'
        #      got: (Nil)
        not ok 2046 - right deprecation for rt120908()
        # Failed test 'right deprecation for rt120908()'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/isDEPRECATED.rakudo line 136
# FUDGED!
        1..60
        ok 2047 - # SKIP 'is ObjectType' NYI
        ok 2048 - # SKIP 'is ObjectType' NYI
        ok 2049 - # SKIP 'is ObjectType' NYI
        ok 2050 - # SKIP 'is ObjectType' NYI
        ok 2051 - # SKIP 'is ObjectType' NYI
        ok 2052 - # SKIP 'is ObjectType' NYI
        ok 2053 - # SKIP 'is ObjectType' NYI
        ok 2054 - # SKIP 'is ObjectType' NYI
        ok 2055 - # SKIP 'is ObjectType' NYI
        ok 2056 - # SKIP 'is ObjectType' NYI
        ok 2057 - # SKIP 'is ObjectType' NYI
        ok 2058 - # SKIP 'is ObjectType' NYI
        ok 2059 - # SKIP 'is ObjectType' NYI
        ok 2060 - # SKIP 'is ObjectType' NYI
        ok 2061 - # SKIP 'is ObjectType' NYI
        ok 2062 - # SKIP 'is ObjectType' NYI
        ok 2063 - # SKIP 'is ObjectType' NYI
        ok 2064 - # SKIP 'is ObjectType'
        ok 2065 - # SKIP 'is ObjectType'
        ok 2066 - # SKIP 'is ObjectType'
        ok 2067 - # SKIP 'is ObjectType'
        ok 2068 - # SKIP 'is ObjectType'
        ok 2069 - # SKIP 'is ObjectType'
        ok 2070 - # SKIP 'is ObjectType'
        ok 2071 - # SKIP 'is ObjectType'
        ok 2072 - # SKIP 'is ObjectType'
        ok 2073 - # SKIP 'is ObjectType'
        ok 2074 - # SKIP 'is ObjectType'
        ok 2075 - # SKIP 'is ObjectType'
        ok 2076 - # SKIP 'is ObjectType'
        ok 2077 - # SKIP 'is ObjectType'
        ok 2078 - # SKIP 'is ObjectType'
        ok 2079 - # SKIP 'is ObjectType'
        ok 2080 - # SKIP 'is ObjectType'
        ok 2081 - # SKIP 'is ObjectType' NYI
        ok 2082 - # SKIP 'is ObjectType' NYI
        ok 2083 - # SKIP 'is ObjectType' NYI
        ok 2084 - # SKIP 'is ObjectType' NYI
        ok 2085 - # SKIP 'is ObjectType' NYI
        ok 2086 - # SKIP 'is ObjectType' NYI
        ok 2087 - # SKIP 'is ObjectType' NYI
        ok 2088 - # SKIP 'is ObjectType' NYI
        ok 2089 - # SKIP 'is ObjectType' NYI
        ok 2090 - # SKIP 'is ObjectType' NYI
        ok 2091 - # SKIP 'is ObjectType' NYI
        ok 2092 - # SKIP 'is ObjectType' NYI
        ok 2093 - # SKIP 'is ObjectType' NYI
        ok 2094 - # SKIP 'is ObjectType' NYI
        ok 2095 - # SKIP 'is ObjectType' NYI
        ok 2096 - # SKIP 'is ObjectType' NYI
        ok 2097 - # SKIP 'is ObjectType' NYI
        ok 2098 - # SKIP 'is ObjectType' NYI
        ok 2099 - # SKIP 'is ObjectType' NYI
        ok 2100 - # SKIP 'is ObjectType' NYI
        ok 2101 - # SKIP 'is ObjectType' NYI
        ok 2102 - # SKIP 'is ObjectType'
        ok 2103 - # SKIP 'is ObjectType'
        ok 2104 - # SKIP 'is ObjectType'
        ok 2105 - # SKIP 'is ObjectType'
            1..7
            ok 1 - custom QuantHash
            ok 2 - Set
            ok 3 - SetHash
            ok 4 - Bag
            ok 5 - BagHash
            ok 6 - Mix
            ok 7 - MixHash
        ok 2106 - QuantHash.Capture
# FUDGED!
        1..80
        ok 2107 - The object is-a 'Array'
        ok 2108 - The object is-a 'Pair'
        ok 2109 - the array has one value in it
        ok 2110 - The object is-a 'Pair'
        ok 2111 - got the right pair value
        ok 2112 - the array has two values in it
        ok 2113 - The object is-a 'Pair'
        ok 2114 - got the right pair value
        ok 2115 - The object is-a 'Array'
        ok 2116 - The object is-a 'Hash'
        ok 2117 - our hash has two keys
        ok 2118 - the array has one value in it
        ok 2119 - The object is-a 'Hash'
        ok 2120 - got the right value for key
        ok 2121 - got the right value1 for key1
        ok 2122 - The object is-a 'Array'
        ok 2123 - got 4 elements in the Array of Arrays
        ok 2124 - got the right first element
        ok 2125 - The object is-a 'Array'
        ok 2126 - got the right second/first element
        ok 2127 - got the right second/second element
        ok 2128 - The object is-a 'Array'
        ok 2129 - got the right third/first element
        ok 2130 - got the right third/second element
        ok 2131 - got the right fourth element
        ok 2132 - The object is-a 'Array'
        ok 2133 - got three elements in the Array
        ok 2134 - The object is-a 'Sub'
        ok 2135 - The object is-a 'Block'
        ok 2136 - The object is-a 'Block'
        ok 2137 - the first element (when executed) is 1
        ok 2138 - the second element (when executed) is 2
        ok 2139 - the third element (when executed) is 3
        ok 2140 - The object is-a 'Hash'
        ok 2141 - The object is-a 'Array'
        ok 2142 - it should have 3 values in it
        ok 2143 - got the right value
        ok 2144 - got the right value
        ok 2145 - got the right value
        ok 2146 - it should have 3 values in it
        ok 2147 - got the right value (when I pull the array out)
        ok 2148 - got the right value (when I pull the array out)
        ok 2149 - got the right value (when I pull the array out)
        ok 2150 - it should now have 4 values in it
        ok 2151 - got the right value (which we just pushed onto the list)
        ok 2152 - The object is-a 'Hash'
        ok 2153 - The object is-a 'Array'
        ok 2154 - The object is-a 'Array'
        ok 2155 - it should have 3 values in it
        ok 2156 - got the right value
        ok 2157 - got the right value
        ok 2158 - got the right value
        ok 2159 - it should have 3 values in it
        ok 2160 - got the right value (when I pull the array out)
        ok 2161 - got the right value (when I pull the array out)
        ok 2162 - got the right value (when I pull the array out)
        ok 2163 - it should now have 4 values in it
        ok 2164 - got the right value (which we just pushed onto the array)
        ok 2165 - itemized hash should not get decomposed
        ok 2166 - itemized hash should not get decomposed
        ok 2167 - itemized hash should not get decomposed
        ok 2168 - array nested in hashitem in one declaration
        ok 2169 - The object is-a 'Array'
        ok 2170 - The object is-a 'Array'
        ok 2171 - The object is-a 'Array'
        ok 2172 - The object is-a 'Array'
        ok 2173 - The object is-a 'Array'
        ok 2174 - 5 level deep arrays only structure
        ok 2175 - The object is-a 'Array'
        ok 2176 - The object is-a 'Hash'
        ok 2177 - The object is-a 'Array'
        ok 2178 - The object is-a 'Hash'
        ok 2179 - one key at level 4
        ok 2180 - The object is-a 'Array'
        ok 2181 - The object is-a 'Hash'
        ok 2182 - 6 level deep mixed structure
        ok 2183 - The object is-a 'Hash'
        not ok 2184 - The object is-a 'Hash' # TODO isa hash
        # Failed test 'The object is-a 'Hash''
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/mixed_multi_dimensional.rakudo line 198
        # Actual type: Any
        not ok 2185 - two keys at level 4 # TODO unknown
        # Failed test 'two keys at level 4'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/mixed_multi_dimensional.rakudo line 200
        # expected: '2'
        #      got: '1'
        not ok 2186 - more keys at level 4 # TODO unknown
        # Failed test 'more keys at level 4'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/mixed_multi_dimensional.rakudo line 201
        # expected: '5'
        #      got: (Any)
# FUDGED!
        1..284
We do get here, right?
        ok 2187 - we got a MixHash
        ok 2188 - ...with the right elements
        ok 2189 - Defaults to 0
        ok 2190 - Single-key subscript (existing element)
        ok 2191 - Single-key subscript yields an Int
        ok 2192 - Single-key subscript (nonexistent element)
        ok 2193 - Single-key subscript yields an Int (nonexistent element)
        ok 2194 - exists with existing element
        ok 2195 - exists with nonexistent element
        ok 2196 - Values returns the correct number of values
        ok 2197 - Values returns the correct sum
        ok 2198 - Bool returns True if there is something in the MixHash
        ok 2199 - Bool returns False if there is nothing in the MixHash
        ok 2200 - .hash doesn't die
        ok 2201 - ...and it returned a Hash
        ok 2202 - ...with the right elements
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Assignment::RO)
        ok 2203 - Can't assign to .keys
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Assignment::RO)
        ok 2204 - Can't assign to .values
        ok 2205 - Multiple-element access
        ok 2206 - Multiple-element access (with nonexistent elements)
        ok 2207 - .total gives sum of values
        ok 2208 - .total gives sum of values
        ok 2209 - +$mix gives sum of values
        ok 2210 - Can assign to an existing element
        ok 2211 - ... and assignment takes effect
        ok 2212 - Can assign to a new element
        ok 2213 - ... and assignment takes effect
        ok 2214 - Can assign zero to a nonexistent element
        ok 2215 - ... and that didn't create the element
        ok 2216 - Can assign zero to a existing element
        ok 2217 - ... and it goes away
        ok 2218 - Can ++ an existing element
        ok 2219 - ... and the increment happens
        ok 2220 - Can ++ a new element
        ok 2221 - ... and the element is created
        ok 2222 - Can -- an existing element
        ok 2223 - ... and the decrement happens
        ok 2224 - Can -- an element with value 1
        ok 2225 - ... and it goes away
        ok 2226 - Can -- an element that doesn't exist
        ok 2227 - ... and everything is still okay
        ok 2228 - Identical mixs smartmatch with each other
        ok 2229 - Identical mixs smartmatch with each other
        ok 2230 - Subset does not smartmatch
        ok 2231 - Subset (only quantity different) does not smartmatch
        ok 2232 - Superset does not smartmatch
        ok 2233 - Superset (only quantity different) does not smartmatch
        ok 2234 - Smartmatch is not element of
        ok 2235 - Type-checking smartmatch works
        ok 2236 - Set smartmatches with equivalent MixHash.new:
        ok 2237 - ... but not if the Mix has greater quantities
        ok 2238 - Type-checking smartmatch works
        ok 2239 - Str.MixHash makes a MixHash
        ok 2240 - 'a'.MixHash is mix a
        ok 2241 - Pair.MixHash makes a MixHash
        ok 2242 - (a => 100000).MixHash is mix a:100000
        ok 2243 - (a => 0).MixHash is the empty mix
        ok 2244 - <a b c>.MixHash makes a MixHash
        ok 2245 - <a b c a>.MixHash makes the mix a:2 b:1 c:1
        ok 2246 - [a b c a].MixHash makes the mix a:2 b:1 c:1
        ok 2247 - [a => 3, b => 0, 'c', 'a'].MixHash makes the mix a:4 c:1
        ok 2248 - a	2 b	4 c	0.MixHash makes a MixHash
        ok 2249 - a	2 b	4 c	0.MixHash makes the mix a:2 b:4
        ok 2250 - :exists with existing element
        ok 2251 - :exists with nonexistent element
        ok 2252 - :delete works on MixHash
        ok 2253 - ...and actually deletes
        ok 2254 - Int keys are left as Ints
        ok 2255 - Bool keys are left as Bools
        ok 2256 - And Str keys are permitted in the same set
        ok 2257 - All keys have the right values
        ok 2258 - MixHash.kv returns list of keys and values
        ok 2259 - &MixHash.new given an array of strings produces a MixHash
        ok 2260 - ...with the right elements
        ok 2261 - &MixHash.new given an array of pairs produces a MixHash
        ok 2262 - make sure .total is ok
        ok 2263 - make sure .elems is ok
        ok 2264 - &MixHash.new given a Hash produces a MixHash
        ok 2265 - ... with four elements
        ok 2266 - ... which are all Pairs
        ok 2267 - &MixHash.new given a Hash produces a MixHash
        ok 2268 - ... with four elements
        ok 2269 - &MixHash.new given a Set produces a MixHash
        ok 2270 - ... with one element
        ok 2271 - &MixHash.new given a MixHash produces a MixHash
        ok 2272 - ... with one element
        ok 2273 - &MixHash.new given a Mix produces a MixHash
        ok 2274 - ... with one element
        ok 2275 - make sure .total is ok
        ok 2276 - make sure .elems is ok
        ok 2277 - .list returns 3 things
        ok 2278 - ... all of which are Pairs
        ok 2279 - .pairs returns 3 things
        ok 2280 - ... all of which are Pairs
        ok 2281 - ... the keys of which are Strs
        ok 2282 - ... and the values of which are Ints
        ok 2283 - .raku lives
        ok 2284 - ... and produces a string
        ok 2285 - ... of reasonable length
        ok 2286 - .raku.EVAL lives
        ok 2287 - ... and produces a MixHash
        ok 2288 - ... and it has the correct values
        ok 2289 - .Str lives
        ok 2290 - ... and produces a string
        ok 2291 - ... which only contains bar baz and foo with the proper counts and separated by spaces
        ok 2292 - .gist lives
        ok 2293 - ... and produces a string
        ok 2294 - ... of reasonable length
        ok 2295 - ... which mentions foo
        ok 2296 - ... which mentions bar
        ok 2297 - ... which mentions baz
        ok 2298 - A MixHash bound to a %var is a MixHash
        ok 2299 - ...with the right elements
        ok 2300 - Single-key subscript (existing element)
        ok 2301 - Single-key subscript (nonexistent element)
        ok 2302 - Assign to an element
        ok 2303 - ... and gets the correct value
        ok 2304 - We got one of the two choices
        ok 2305 - .roll with no arguments returns a key of the MixHash
        ok 2306 - .roll(0) gives you an Iterable
        ok 2307 - .roll(1) gives you an Iterable
        ok 2308 - .roll(2) gives you an Iterable
        ok 2309 - .roll(0) returns 0 results
        ok 2310 - .roll(1) returns 1 result
        ok 2311 - .roll(2) returns the right number of items
        ok 2312 - .roll(2) returned "a"s and "b"s
        ok 2313 - .roll(100) returns 100 items
        ok 2314 - .roll(100) (1)
        ok 2315 - .roll(100) (2)
        ok 2316 - .roll(*)[^100] (1)
        ok 2317 - .roll(*)[^100] (2)
        ok 2318 - .roll should not change MixHash
        ok 2319 - .roll should not change MixHash
        ok 2320 - make sure total is ok
        ok 2321 - .roll should not change MixHash
        ok 2322 - We got one of the two choices (and this was pretty quick, we hope!)
        ok 2323 - .roll(100) returns 100 items
        ok 2324 - .roll(100) (1)
        ok 2325 - .roll(100) (2)
        ok 2326 - .roll should not change MixHash
        ok 2327 - .roll should not change MixHash
        ok 2328 - did we get a Pair
        ok 2329 - We got one of the two choices
        ok 2330 - .grabpairs(2) returns the right number of items
        ok 2331 - are they all Pairs
        ok 2332 - We got one of the two choices
        ok 2333 - .grabpairs *should* change MixHash
        ok 2334 - .grabpairs *should* change MixHash
        ok 2335 - .grabpairs(*) returns the right number of items
        ok 2336 - are they all Pairs
        ok 2337 - and they all have an expected value
        ok 2338 - MixHash.grabpairs(*) gets all elements
        ok 2339 - MixHash.grabpairs(*) returns elements in a random order
        ok 2340 - .grabpairs *should* change MixHash
        ok 2341 - .grabpairs *should* change MixHash
        ok 2342 - "b", initialized to zero, does not exist
        ok 2343 - Inititalization worked
        ok 2344 - .elems works
        ok 2345 - %h<nonexisting> is an Int
        ok 2346 - %h<nonexisting> is 0
        ok 2347 - can set an item to 0
        ok 2348 - "c", set to zero, does not exist
        ok 2349 - one item left
        ok 2350 - ... and the right one is gone
        ok 2351 - can add (++) an item that was removed
        ok 2352 - ++ on an item reinstates it
        ok 2353 - can "add" (++) an existing item
        ok 2354 - ++ on an existing item increments the counter
        ok 2355 - ++ on an existing item does not add a key
        ok 2356 - can remove an item with decrement (--)
        ok 2357 - decrement (--) removes items
        ok 2358 - item is gone according to exists too
        ok 2359 - removed item is zero
        ok 2360 - going negative returns 0
        ok 2361 - item exists too
        ok 2362 - going negative adds the item
        ok 2363 - item now at -1
        ok 2364 - is the hash really a MixHash
        not ok 2365 - Assigning a Mix to a MixHash # TODO in flux
        # Failed test 'Assigning a Mix to a MixHash'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/mixhash.rakudo line 370
        # Type check failed in assignment to %h; expected MixHash but got Int (1)
        not ok 2366 - ... works as expected # TODO in flux
        # Failed test '... works as expected'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/mixhash.rakudo line 371
        # expected: 'a:1 b:2 c:2 d:1'
        #      got: ''
        ok 2367 - Method .MixHash works on Int-1
        ok 2368 - Method .MixHash works on Int-2
        ok 2369 - Method .MixHash works on Str-1
        ok 2370 - Method .MixHash works on Str-2
        ok 2371 - Method .MixHash works on Array-1
        ok 2372 - Method .MixHash works on Array-2
        ok 2373 - Method .MixHash works on Hash-1
        ok 2374 - Method .MixHash works on Hash-2
        ok 2375 - Method .MixHash works on List-1
        ok 2376 - Method .MixHash works on List-2
        ok 2377 - .total gives sum of values (non-empty) 11
        ok 2378 - +$mix gives sum of values (non-empty) 11
        ok 2379 - .minpairs works (non-empty) 11
        ok 2380 - .maxpairs works (non-empty) 11
        ok 2381 - .fmt(%s) works (non-empty 11)
        ok 2382 - .fmt(%s,sep) works (non-empty 11)
        ok 2383 - .fmt(%s%s) works (non-empty 11)
        ok 2384 - .fmt(%s%s,sep) works (non-empty 11)
        ok 2385 - .total gives sum of values (non-empty) 8.8
        ok 2386 - +$mix gives sum of values (non-empty) 8.8
        ok 2387 - .minpairs works (non-empty) 8.8
        ok 2388 - .maxpairs works (non-empty) 8.8
        ok 2389 - .total gives sum of values (non-empty) 4.4
        ok 2390 - +$mix gives sum of values (non-empty) 4.4
        ok 2391 - .minpairs works (non-empty) 4.4
        ok 2392 - .maxpairs works (non-empty) 4.4
        ok 2393 - .total gives sum of values (empty)
        ok 2394 - +$mix gives sum of values (empty)
        ok 2395 - .minpairs works (empty)
        ok 2396 - .maxpairs works (empty)
        ok 2397 - .fmt(%s) works (empty)
        ok 2398 - .fmt(%s,sep) works (empty)
        ok 2399 - .fmt(%s%s) works (empty)
        ok 2400 - .fmt(%s%s,sep) works (empty)
        ok 2401 - did we set a Real value
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Str::Numeric)
        ok 2402 - Make sure we cannot assign Str on a key
        ok 2403 - did we set a Real value from a .values alias
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Str::Numeric)
        ok 2404 - Make sure we cannot assign Str on a .values alias
        ok 2405 - did we set a Real value from a .pairs alias
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Str::Numeric)
        ok 2406 - Make sure we cannot assign Str on a .pairs alias
        ok 2407 - did we set a Real value from a .kv alias
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Str::Numeric)
        ok 2408 - Make sure we cannot assign Str on a .kv alias
        ok 2409 - did we see all values
        ok 2410 - did we see all keys
        ok 2411 - did we see all the pairs
        ok 2412 - did we see all the kv
        ok 2413 - did we see all the antipairs
            1..2
            ok 1 - MixHash.new
            ok 2 - .MixHash
        ok 2414 - .hash does not cause keys to be stringified
        ok 2415 - .Bag coercer
        ok 2416 - .BagHash coercer
        ok 2417 - negative MixHash weights removed from Bag coercion without warnings
            1..10
            ok 1 - correct return of postfix ++
            ok 2 - correct result of postfix ++
            ok 3 - correct return of postfix --
            ok 4 - correct result of postfix --
            ok 5 - correct return of prefix ++
            ok 6 - correct result of prefix ++
            ok 7 - correct return of prefix --
            ok 8 - correct result of prefix --
            ok 9 - correct return of assignment
            ok 10 - correct result of assignment
        ok 2418 - MixHash autovivification of non-existent keys
        ok 2419 - negative weights remain with  ∪  operator
        ok 2420 - negative weights remain with (|) operator
        ok 2421 - Can use $_ from .values to remove occurrences from MixHash
        ok 2422 - Can use $_ from .values to set number occurrences in MixHash
        ok 2423 - Can use $_ from .values to remove items from MixHash
        ok 2424 - Can use value from .kv to remove occurrences from MixHash
        ok 2425 - Can use value from .kv to set number occurrences in MixHash
        ok 2426 - Can use $_ from .kv to remove items from MixHash
        ok 2427 - Can use value from .pairs to remove occurrences from MixHash
        ok 2428 - Can use value from .pairs to set number occurrences in MixHash
        ok 2429 - Can use $_ from .pairs to remove items from MixHash
            1..3
            ok 1 - code dies
            ok 2 - right exception type (X::Cannot::Lazy)
            ok 3 - .what matches MixHash
        ok 2430 - did we throws-like X::Cannot::Lazy?
            1..3
            ok 1 - code dies
            ok 2 - right exception type (X::Cannot::Lazy)
            ok 3 - .what matches MixHash
        ok 2431 - did we throws-like X::Cannot::Lazy?
            1..3
            ok 1 - code dies
            ok 2 - right exception type (X::Cannot::Lazy)
            ok 3 - .what matches MixHash
        ok 2432 - did we throws-like X::Cannot::Lazy?
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Str::Numeric)
        ok 2433 - (:a("a")).MixHash throws
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Str::Numeric)
        ok 2434 - MixHash.new-from-pairs( (:a("a")) ) throws
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::OutOfRange)
        ok 2435 - (:a(Inf)).MixHash throws
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::OutOfRange)
        ok 2436 - MixHash.new-from-pairs( (:a(Inf)) ) throws
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::OutOfRange)
        ok 2437 - (:a(-Inf)).MixHash throws
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::OutOfRange)
        ok 2438 - MixHash.new-from-pairs( (:a(-Inf)) ) throws
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::OutOfRange)
        ok 2439 - (:a(NaN)).MixHash throws
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::OutOfRange)
        ok 2440 - MixHash.new-from-pairs( (:a(NaN)) ) throws
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Numeric::Real)
        ok 2441 - (:a(<0+3i>)).MixHash throws
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Numeric::Real)
        ok 2442 - MixHash.new-from-pairs( (:a(<0+3i>)) ) throws
        ok 2443 - can we parameterize for strings?
        ok 2444 - does .keyof return the correct type
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::TypeCheck::Binding)
        ok 2445 - does attempt to add item of wrong type croak
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::TypeCheck::Binding)
        ok 2446 - do wrong values make initialization croak
        ok 2447 - final value 0 disappears in MixHash (1)
        ok 2448 - final value 0 disappears in MixHash (2)
            1..3
            ok 1 - weight decrement
            ok 2 - Pair value decrement
            ok 3 - weight set to zero
        ok 2449 - elements with weight zero are removed
            1..2
            ok 1 - negative weights are ok
            ok 2 - negative Pair values are ok
        ok 2450 - elements with negative weights are allowed in MixHashes
        ok 2451 - did we get right number of elements
        ok 2452 - do we get 1 for a
        ok 2453 - do we get 0 value for e
        ok 2454 - is the %h really a BagHash
        ok 2455 - did we get right number of elements after re-init
        ok 2456 - did we get 5 by removing e
        ok 2457 - did we get right number of elements after :delete
        ok 2458 - can delete from MixHash by assignment
        ok 2459 - did we get right number of elements assignment
        ok 2460 - can we smartmatch empty
        ok 2461 - coerce MixHash -> Set
        ok 2462 - coerce MixHash -> SetHash
        ok 2463 - coerce MixHash -> Bag
        ok 2464 - coerce MixHash -> BagHash
        ok 2465 - coerce MixHash -> Mix
        ok 2466 - parameterized MixHash
        ok 2467 - did it parameterize ok
        ok 2468 - adding element of wrong type fails
        ok 2469 - must have Ints on creation
        ok 2470 - does .item work on MixHashes
# FUDGED!
        1..59
        ok 2471 - accessing an array as [0;0] works (1)
        ok 2472 - accessing an array as [0;0] works (2)
        ok 2473 - accessing an array as [0;0] works (3)
        ok 2474 - accessing an array as [0;0] works (4)
            1..2
            ok 1 - code dies
            ok 2 - right exception type (Exception)
        ok 2475 - setting a multi-d array beyond boundaries fails
        ok 2476 - .elems works on multidimensional array
        ok 2477 - # SKIP multi-dim sized arrays NYI
        ok 2478 - # SKIP multi-dim sized arrays NYI
        ok 2479 - # SKIP multi-dim sized arrays NYI
        ok 2480 - # SKIP multi-dim sized arrays NYI
        ok 2481 - the multi1 has 3 elements
        ok 2482 - got the right value at multi1 index 0
        ok 2483 - multi1[1] has 3 elements
        ok 2484 - +$multi1[1] works
        ok 2485 - The object is-a 'List'
        ok 2486 - got the right value at multi1 index 1,0
        ok 2487 - got the right value at multi1 index 1,1
        ok 2488 - got the right value at multi1 index 1,2
        ok 2489 - got the right value at multi1 index 1,0
        ok 2490 - got the right value at multi1 index 1,1
        ok 2491 - got the right value at multi1 index 1,2
        ok 2492 - got the right value at multi1 index 2
        ok 2493 - the multi2 has 2 elements
        ok 2494 - multi2[0] has 3 elements
        ok 2495 - +$multi2[0] works
        ok 2496 - The object is-a 'List'
        ok 2497 - got the right value at multi2 index 0,0
        ok 2498 - got the right value at multi2 index 0,1
        ok 2499 - got the right value at multi2 index 0,2
        ok 2500 - got the right value at multi2 index 0,0
        ok 2501 - got the right value at multi2 index 0,1
        ok 2502 - got the right value at multi2 index 0,2
        ok 2503 - multi2[1] has 3 elements
        ok 2504 - +$multi2[1] works
        ok 2505 - The object is-a 'List'
        ok 2506 - got the right value at multi2 index 1,0
        ok 2507 - got the right value at multi2 index 1,1
        ok 2508 - got the right value at multi2 index 1,2
        ok 2509 - got the right value at multi2 index 1,0
        ok 2510 - got the right value at multi2 index 1,1
        ok 2511 - got the right value at multi2 index 1,2
        ok 2512 - got the right values at multi2 index {0,1},0
        ok 2513 - got the right values at multi2 index {0,1},1
        ok 2514 - got the right values at multi2 index {0,1},2
        ok 2515 - got the right values at multi2 index *,0
        ok 2516 - got the right values at multi2 index *,1
        ok 2517 - got the right values at multi2 index *,2
        ok 2518 - [1 ; 0,1,2 ; 2]
        ok 2519 - [1 ; * ; 2]
        ok 2520 - [0,1 ; 2 ; 2]
        ok 2521 - [1 ; 0,2 ; 1]
        ok 2522 - [1 ; 2 ; 1,2]
        ok 2523 - [0,1 ; 0,2 ; 1,2]
        ok 2524 - can assign to multi-dim slice
        ok 2525 - overall assignment worked
        ok 2526 - assigned the right thing to [0;0;1]
        ok 2527 - assigned the right thing to [0;1;1]
        ok 2528 - assigned the right thing to [0;2;1]
            1..158
            ok 1 - got the right value from array with dim 1 at 0
            ok 2 - .elems for a shaped array (dim 1) returns the first dimension
            ok 3 - got the right value from array with dim 2 at 0 0
            ok 4 - got the right value from array with dim 2 at 1 0
            ok 5 - .elems for a shaped array (dim 2) returns the first dimension
            ok 6 - got the right value from array with dim 3 at 0 0 0
            ok 7 - got the right value from array with dim 3 at 0 1 0
            ok 8 - got the right value from array with dim 3 at 1 0 0
            ok 9 - got the right value from array with dim 3 at 1 1 0
            ok 10 - got the right value from array with dim 3 at 2 0 0
            ok 11 - got the right value from array with dim 3 at 2 1 0
            ok 12 - .elems for a shaped array (dim 3) returns the first dimension
            ok 13 - got the right value from array with dim 4 at 0 0 0 0
            ok 14 - got the right value from array with dim 4 at 0 0 1 0
            ok 15 - got the right value from array with dim 4 at 0 1 0 0
            ok 16 - got the right value from array with dim 4 at 0 1 1 0
            ok 17 - got the right value from array with dim 4 at 0 2 0 0
            ok 18 - got the right value from array with dim 4 at 0 2 1 0
            ok 19 - got the right value from array with dim 4 at 1 0 0 0
            ok 20 - got the right value from array with dim 4 at 1 0 1 0
            ok 21 - got the right value from array with dim 4 at 1 1 0 0
            ok 22 - got the right value from array with dim 4 at 1 1 1 0
            ok 23 - got the right value from array with dim 4 at 1 2 0 0
            ok 24 - got the right value from array with dim 4 at 1 2 1 0
            ok 25 - got the right value from array with dim 4 at 2 0 0 0
            ok 26 - got the right value from array with dim 4 at 2 0 1 0
            ok 27 - got the right value from array with dim 4 at 2 1 0 0
            ok 28 - got the right value from array with dim 4 at 2 1 1 0
            ok 29 - got the right value from array with dim 4 at 2 2 0 0
            ok 30 - got the right value from array with dim 4 at 2 2 1 0
            ok 31 - got the right value from array with dim 4 at 3 0 0 0
            ok 32 - got the right value from array with dim 4 at 3 0 1 0
            ok 33 - got the right value from array with dim 4 at 3 1 0 0
            ok 34 - got the right value from array with dim 4 at 3 1 1 0
            ok 35 - got the right value from array with dim 4 at 3 2 0 0
            ok 36 - got the right value from array with dim 4 at 3 2 1 0
            ok 37 - .elems for a shaped array (dim 4) returns the first dimension
            ok 38 - got the right value from array with dim 5 at 0 0 0 0 0
            ok 39 - got the right value from array with dim 5 at 0 0 0 1 0
            ok 40 - got the right value from array with dim 5 at 0 0 1 0 0
            ok 41 - got the right value from array with dim 5 at 0 0 1 1 0
            ok 42 - got the right value from array with dim 5 at 0 0 2 0 0
            ok 43 - got the right value from array with dim 5 at 0 0 2 1 0
            ok 44 - got the right value from array with dim 5 at 0 1 0 0 0
            ok 45 - got the right value from array with dim 5 at 0 1 0 1 0
            ok 46 - got the right value from array with dim 5 at 0 1 1 0 0
            ok 47 - got the right value from array with dim 5 at 0 1 1 1 0
            ok 48 - got the right value from array with dim 5 at 0 1 2 0 0
            ok 49 - got the right value from array with dim 5 at 0 1 2 1 0
            ok 50 - got the right value from array with dim 5 at 0 2 0 0 0
            ok 51 - got the right value from array with dim 5 at 0 2 0 1 0
            ok 52 - got the right value from array with dim 5 at 0 2 1 0 0
            ok 53 - got the right value from array with dim 5 at 0 2 1 1 0
            ok 54 - got the right value from array with dim 5 at 0 2 2 0 0
            ok 55 - got the right value from array with dim 5 at 0 2 2 1 0
            ok 56 - got the right value from array with dim 5 at 0 3 0 0 0
            ok 57 - got the right value from array with dim 5 at 0 3 0 1 0
            ok 58 - got the right value from array with dim 5 at 0 3 1 0 0
            ok 59 - got the right value from array with dim 5 at 0 3 1 1 0
            ok 60 - got the right value from array with dim 5 at 0 3 2 0 0
            ok 61 - got the right value from array with dim 5 at 0 3 2 1 0
            ok 62 - got the right value from array with dim 5 at 1 0 0 0 0
            ok 63 - got the right value from array with dim 5 at 1 0 0 1 0
            ok 64 - got the right value from array with dim 5 at 1 0 1 0 0
            ok 65 - got the right value from array with dim 5 at 1 0 1 1 0
            ok 66 - got the right value from array with dim 5 at 1 0 2 0 0
            ok 67 - got the right value from array with dim 5 at 1 0 2 1 0
            ok 68 - got the right value from array with dim 5 at 1 1 0 0 0
            ok 69 - got the right value from array with dim 5 at 1 1 0 1 0
            ok 70 - got the right value from array with dim 5 at 1 1 1 0 0
            ok 71 - got the right value from array with dim 5 at 1 1 1 1 0
            ok 72 - got the right value from array with dim 5 at 1 1 2 0 0
            ok 73 - got the right value from array with dim 5 at 1 1 2 1 0
            ok 74 - got the right value from array with dim 5 at 1 2 0 0 0
            ok 75 - got the right value from array with dim 5 at 1 2 0 1 0
            ok 76 - got the right value from array with dim 5 at 1 2 1 0 0
            ok 77 - got the right value from array with dim 5 at 1 2 1 1 0
            ok 78 - got the right value from array with dim 5 at 1 2 2 0 0
            ok 79 - got the right value from array with dim 5 at 1 2 2 1 0
            ok 80 - got the right value from array with dim 5 at 1 3 0 0 0
            ok 81 - got the right value from array with dim 5 at 1 3 0 1 0
            ok 82 - got the right value from array with dim 5 at 1 3 1 0 0
            ok 83 - got the right value from array with dim 5 at 1 3 1 1 0
            ok 84 - got the right value from array with dim 5 at 1 3 2 0 0
            ok 85 - got the right value from array with dim 5 at 1 3 2 1 0
            ok 86 - got the right value from array with dim 5 at 2 0 0 0 0
            ok 87 - got the right value from array with dim 5 at 2 0 0 1 0
            ok 88 - got the right value from array with dim 5 at 2 0 1 0 0
            ok 89 - got the right value from array with dim 5 at 2 0 1 1 0
            ok 90 - got the right value from array with dim 5 at 2 0 2 0 0
            ok 91 - got the right value from array with dim 5 at 2 0 2 1 0
            ok 92 - got the right value from array with dim 5 at 2 1 0 0 0
            ok 93 - got the right value from array with dim 5 at 2 1 0 1 0
            ok 94 - got the right value from array with dim 5 at 2 1 1 0 0
            ok 95 - got the right value from array with dim 5 at 2 1 1 1 0
            ok 96 - got the right value from array with dim 5 at 2 1 2 0 0
            ok 97 - got the right value from array with dim 5 at 2 1 2 1 0
            ok 98 - got the right value from array with dim 5 at 2 2 0 0 0
            ok 99 - got the right value from array with dim 5 at 2 2 0 1 0
            ok 100 - got the right value from array with dim 5 at 2 2 1 0 0
            ok 101 - got the right value from array with dim 5 at 2 2 1 1 0
            ok 102 - got the right value from array with dim 5 at 2 2 2 0 0
            ok 103 - got the right value from array with dim 5 at 2 2 2 1 0
            ok 104 - got the right value from array with dim 5 at 2 3 0 0 0
            ok 105 - got the right value from array with dim 5 at 2 3 0 1 0
            ok 106 - got the right value from array with dim 5 at 2 3 1 0 0
            ok 107 - got the right value from array with dim 5 at 2 3 1 1 0
            ok 108 - got the right value from array with dim 5 at 2 3 2 0 0
            ok 109 - got the right value from array with dim 5 at 2 3 2 1 0
            ok 110 - got the right value from array with dim 5 at 3 0 0 0 0
            ok 111 - got the right value from array with dim 5 at 3 0 0 1 0
            ok 112 - got the right value from array with dim 5 at 3 0 1 0 0
            ok 113 - got the right value from array with dim 5 at 3 0 1 1 0
            ok 114 - got the right value from array with dim 5 at 3 0 2 0 0
            ok 115 - got the right value from array with dim 5 at 3 0 2 1 0
            ok 116 - got the right value from array with dim 5 at 3 1 0 0 0
            ok 117 - got the right value from array with dim 5 at 3 1 0 1 0
            ok 118 - got the right value from array with dim 5 at 3 1 1 0 0
            ok 119 - got the right value from array with dim 5 at 3 1 1 1 0
            ok 120 - got the right value from array with dim 5 at 3 1 2 0 0
            ok 121 - got the right value from array with dim 5 at 3 1 2 1 0
            ok 122 - got the right value from array with dim 5 at 3 2 0 0 0
            ok 123 - got the right value from array with dim 5 at 3 2 0 1 0
            ok 124 - got the right value from array with dim 5 at 3 2 1 0 0
            ok 125 - got the right value from array with dim 5 at 3 2 1 1 0
            ok 126 - got the right value from array with dim 5 at 3 2 2 0 0
            ok 127 - got the right value from array with dim 5 at 3 2 2 1 0
            ok 128 - got the right value from array with dim 5 at 3 3 0 0 0
            ok 129 - got the right value from array with dim 5 at 3 3 0 1 0
            ok 130 - got the right value from array with dim 5 at 3 3 1 0 0
            ok 131 - got the right value from array with dim 5 at 3 3 1 1 0
            ok 132 - got the right value from array with dim 5 at 3 3 2 0 0
            ok 133 - got the right value from array with dim 5 at 3 3 2 1 0
            ok 134 - got the right value from array with dim 5 at 4 0 0 0 0
            ok 135 - got the right value from array with dim 5 at 4 0 0 1 0
            ok 136 - got the right value from array with dim 5 at 4 0 1 0 0
            ok 137 - got the right value from array with dim 5 at 4 0 1 1 0
            ok 138 - got the right value from array with dim 5 at 4 0 2 0 0
            ok 139 - got the right value from array with dim 5 at 4 0 2 1 0
            ok 140 - got the right value from array with dim 5 at 4 1 0 0 0
            ok 141 - got the right value from array with dim 5 at 4 1 0 1 0
            ok 142 - got the right value from array with dim 5 at 4 1 1 0 0
            ok 143 - got the right value from array with dim 5 at 4 1 1 1 0
            ok 144 - got the right value from array with dim 5 at 4 1 2 0 0
            ok 145 - got the right value from array with dim 5 at 4 1 2 1 0
            ok 146 - got the right value from array with dim 5 at 4 2 0 0 0
            ok 147 - got the right value from array with dim 5 at 4 2 0 1 0
            ok 148 - got the right value from array with dim 5 at 4 2 1 0 0
            ok 149 - got the right value from array with dim 5 at 4 2 1 1 0
            ok 150 - got the right value from array with dim 5 at 4 2 2 0 0
            ok 151 - got the right value from array with dim 5 at 4 2 2 1 0
            ok 152 - got the right value from array with dim 5 at 4 3 0 0 0
            ok 153 - got the right value from array with dim 5 at 4 3 0 1 0
            ok 154 - got the right value from array with dim 5 at 4 3 1 0 0
            ok 155 - got the right value from array with dim 5 at 4 3 1 1 0
            ok 156 - got the right value from array with dim 5 at 4 3 2 0 0
            ok 157 - got the right value from array with dim 5 at 4 3 2 1 0
            ok 158 - .elems for a shaped array (dim 5) returns the first dimension
        ok 2529 - Insertion and reading of shaped array elements
# FUDGED!
Potential difficulties:
    Smartmatch against True always matches; if you mean to test the topic for truthiness, use :so or *.so or ?* instead
    at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/nil.rakudo:67
    ------> [32m    subset MyInt of Int where [33m⏏[31mTrue;[0m
        1..67
        ok 2530 - empty sub returns Nil
        ok 2531 - do {} is Nil
        ok 2532 - if 1 {} is Nil
        ok 2533 - else {} is Nil
        ok 2534 - bare return returns Nil
        ok 2535 - EVAL of empty string is Nil
        ok 2536 - Nil is not defined
        ok 2537 - () is defined
        ok 2538 - assigning Nil to scalar leaves it undefined
        ok 2539 - assigning () to scalar results in a defined list
        ok 2540 - Nil.so is False
        not ok 2541 - Nil.ACCEPTS always returns Nil # TODO returns True/False
        # Failed test 'Nil.ACCEPTS always returns Nil'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/nil.rakudo line 30
        ok 2542 - Any method on Nil should return Nil (no args)
        ok 2543 - Any method on Nil should return Nil (with args)
        ok 2544 - return_nil() === Nil
        ok 2545 - return_nil().raku says Nil
        ok 2546 - return_nil() called twice
        ok 2547 - variable holding nil is not defined
        ok 2548 - $Statement for Nil; does one iteration
        ok 2549 - Nil is not any sort of Iter*
        ok 2550 - Nil assigned to scalar produces an Any
        ok 2551 - 
        ok 2552 - Nil.gist eq "Nil"
        ok 2553 - Nil.new is not defined
        ok 2554 - can assign Nil to subsets
        ok 2555 - assigns to subset type object
        ok 2556 - can bind to Nil
            1..2
            not ok 1 - code dies # TODO triage
            # Failed test 'code dies'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/nil.rakudo line 82
            ok 2 - # SKIP Code did not die, can not check exception
        not ok 2557 - param: dies for mandatory # TODO triage
        # Failed test 'param: dies for mandatory'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/nil.rakudo line 82
        ok 2558 - # SKIP triage
        not ok 2559 - ... set to type object # TODO triage
        # Failed test '... set to type object'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/nil.rakudo line 92
        not ok 2560 - param: lives for optional from var # TODO triage
        # Failed test 'param: lives for optional from var'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/nil.rakudo line 95
        # Type check failed in binding to parameter '$x'; expected Int but got Nil (Nil)
        not ok 2561 - ... set to type object # TODO triage
        # Failed test '... set to type object'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/nil.rakudo line 97
        ok 2562 - param: lives for with-default
        not ok 2563 - ... set to default # TODO triage
        # Failed test '... set to default'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/nil.rakudo line 102
        # expected: '123'
        #      got: (Any)
        ok 2564 - can use Nil as a default (natural)
        ok 2565 - can use Nil as a default (nil-triggered)
        ok 2566 - $/ is by default Nil
        not ok 2567 - $! is by default Nil
        # Failed test '$! is by default Nil'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/nil.rakudo line 111
        not ok 2568 - $_ is by default Any
        # Failed test '$_ is by default Any'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/nil.rakudo line 112
        ok 2569 - $/ has Nil as default
        ok 2570 - $! has Nil as default
No such method 'default' for invocant of type
'Rakudo::Internals::LoweredAwayLexical'
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/nil.rakudo line 116
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/nil.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

        1..108
        ok 2571 - EVAL 1.Num.raku is Num
        ok 2572 - EVAL 1.Num.raku is 1
        ok 2573 - EVAL 0.Num.raku is Num
        ok 2574 - EVAL 0.Num.raku is 0
        ok 2575 - EVAL -1.Num.raku is Num
        ok 2576 - EVAL -1.Num.raku is -1
        ok 2577 - EVAL 1.1.Num.raku is Num
        ok 2578 - EVAL 1.1.Num.raku is 1.1
        ok 2579 - EVAL -1.1.Num.raku is Num
        ok 2580 - EVAL -1.1.Num.raku is -1.1
        ok 2581 - EVAL 1e100.Num.raku is Num
        ok 2582 - EVAL 1e100.Num.raku is 1
        ok 2583 - The object is-a 'Int'
        ok 2584 - 1 stringification works
        ok 2585 - The object is-a 'Int'
        ok 2586 - -1 stringification works
        ok 2587 - The object is-a 'Rat'
        ok 2588 - 1/1 stringification works
        ok 2589 - The object is-a 'Rat'
        ok 2590 - -1 stringification works
        ok 2591 - The object is-a 'Rat'
        ok 2592 - 0.1 stringification works
        ok 2593 - The object is-a 'Rat'
        ok 2594 - -0.1 stringification works
        ok 2595 - The object is-a 'Rat'
        ok 2596 - 10.01 stringification works
        ok 2597 - The object is-a 'Num'
        ok 2598 - -1 stringification works
        ok 2599 - The object is-a 'Num'
        ok 2600 - 0.1 stringification works
        ok 2601 - The object is-a 'Num'
        ok 2602 - -0.1 stringification works
        ok 2603 - The object is-a 'Num'
        ok 2604 - 10.01 stringification works
        ok 2605 - 1e3 conforms to Num
        ok 2606 - 1e3 stringification works
        ok 2607 - The object is-a 'Num'
        ok 2608 - 10.01e3 stringification works
        ok 2609 - The object is-a 'Int'
        ok 2610 - 0b100 (binary) stringification works
        ok 2611 - The object is-a 'Int'
        ok 2612 - 0x100 (hex) stringification works
        ok 2613 - The object is-a 'Int'
        ok 2614 - 0o100 (octal) stringification works
        ok 2615 - basic addition works
        ok 2616 - basic addition with negative numbers works
        ok 2617 - The object is-a 'Rat'
        ok 2618 - The object is-a 'Rat'
        ok 2619 - trailing zeros compare correctly
        ok 2620 - The object is-a 'Num'
        ok 2621 - trailing zeros compare correctly
        ok 2622 - The object is-a 'Int'
        ok 2623 - 1.01 intifies to 1
        ok 2624 - The object is-a 'Int'
        ok 2625 - 0d0101 numifies to 101
        ok 2626 - we have bignums, not weeny floats
        ok 2627 - underscores allowed (and ignored) in numeric literals
        ok 2628 - multiple underscores ok
        ok 2629 - underscores in fraction ok
        ok 2630 - underscores in whole part ok
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Method::NotFound)
        ok 2631 - single underscores are not ok directly after the dot
        ok 2632 - single underscores are ok
        ok 2633 - 0_1 is parsed as 0d1
        ok 2634 - +^1 == -2 as promised
        ok 2635 - 0xFFFFFFFFFFFFFFFF is not -1
        ok 2636 - Num === Num should be truthy, and not die
        ok 2637 - 1e0.atanh returns ∞
        ok 2638 - Num:U.Range gives -Inf to Inf range
            1..6
            ok 1 - Num
            ok 2 - Rat
            ok 3 - Int
            ok 4 - Complex
            ok 5 - Str
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 6 - class that cannot .Num
        ok 2639 - Num.new coerces types that can .Num
            1..8
            ok 1 - return value (:D)
            ok 2 - new value (:D)
            ok 3 - return value (:U)
            ok 4 - new value (:U)
            ok 5 - return value (native)
            ok 6 - new value (native)
            ok 7 - return value (uninit. native)
            ok 8 - new value (uninit. native)
        ok 2640 - ++Num
            1..8
            ok 1 - return value (:D)
            ok 2 - new value (:D)
            ok 3 - return value (:U)
            ok 4 - new value (:U)
            ok 5 - return value (native)
            ok 6 - new value (native)
            ok 7 - return value (uninit. native)
            ok 8 - new value (uninit. native)
        ok 2641 - --Num
            1..4
            ok 1 - return value
            ok 2 - new value
            ok 3 - return value (uninit. native)
            ok 4 - new value (uninit. native)
        ok 2642 - Num++
            1..6
            ok 1 - return value (:U)
            ok 2 - new value (:U)
            ok 3 - return value (native)
            ok 4 - new value (native)
            ok 5 - return value (uninit. native)
            ok 6 - new value (uninit. native)
        ok 2643 - Num--
            1..8
            ok 1 - - uninitialized
            ok 2 - − (U+2212) uninitialized
            ok 3 - - zero
            ok 4 - − (U+2212) zero
            ok 5 - - positive
            ok 6 - − (U+2212) positive
            ok 7 - - negative
            ok 8 - − (U+2212) negative
        ok 2644 - prefix:<->(num) and U+2212 prefix op
            1..4
            ok 1 - uninitialized
            ok 2 - zero
            ok 3 - positive
            ok 4 - negative
        ok 2645 - abs(num)
            1..16
            ok 1 - uninit + zero
            ok 2 - uninit + positive
            ok 3 - uninit + negative
            ok 4 - uninit + uninit
            ok 5 - zero + uninit
            ok 6 - positive + uninit
            ok 7 - negative + uninit
            ok 8 - zero + positive
            ok 9 - zero + negative
            ok 10 - zero + zero
            ok 11 - positive + negative
            ok 12 - positive + zero
            ok 13 - positive + positive
            ok 14 - negative + zero
            ok 15 - negative + positive
            ok 16 - negative + negative
        ok 2646 - infix:<+>(num, num)
            1..16
            ok 1 - uninit * zero
            ok 2 - uninit * positive
            ok 3 - uninit * negative
            ok 4 - uninit * uninit
            ok 5 - zero * uninit
            ok 6 - positive * uninit
            ok 7 - negative * uninit
            ok 8 - zero * positive
            ok 9 - zero * negative
            ok 10 - zero * zero
            ok 11 - positive * negative
            ok 12 - positive * zero
            ok 13 - positive * positive
            ok 14 - negative * zero
            ok 15 - negative * positive
            ok 16 - negative * negative
        ok 2647 - infix:<*>(num, num)
            1..9
            ok 1 - uninit % defined
                1..2
                not ok 1 - expected code to fail but it threw X::AdHoc instead # TODO we die https://github.com/rakudo/rakudo/issues/2434
                # Failed test 'expected code to fail but it threw X::AdHoc instead'
                # at SETTING::src/core.c/Mu.pm6 line 983
                ok 2 - # SKIP expected code to fail but it threw X::AdHoc instead
            not ok 2 - defined % uninit # TODO we die https://github.com/rakudo/rakudo/issues/2434
            # Failed test 'defined % uninit'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/num.rakudo line 359
                1..2
                not ok 1 - expected code to fail but it threw X::AdHoc instead # TODO we die https://github.com/rakudo/rakudo/issues/2434
WARNING: unhandled Failure detected in DESTROY. If you meant to ignore it, you can mark it as handled by calling .Bool, .so, .not, or .defined methods. The Failure was:
Attempt to divide 5 by zero using %
  in sub  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 684
  in sub subtest at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 435
  in sub fails-like at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 675
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/num.rakudo line 359
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/num.rakudo line 182
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

                # Failed test 'expected code to fail but it threw X::AdHoc instead'
                # at SETTING::src/core.c/Mu.pm6 line 983
                ok 2 - # SKIP expected code to fail but it threw X::AdHoc instead
            not ok 3 - uninit % uninit # TODO we die https://github.com/rakudo/rakudo/issues/2434
            # Failed test 'uninit % uninit'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/num.rakudo line 361
            ok 4 - 0 % 4
            ok 5 - 4 % 5
            ok 6 - 5 % 4
            ok 7 - 0 % -4
            ok 8 - -4 % 5
            ok 9 - 5 % -4
        ok 2648 - infix:<%>(num, num)
            1..22
            ok 1 - uninit ** 1st power
            ok 2 - uninit ** positive
            ok 3 - uninit ** negative
            ok 4 - uninit ** uninit
            ok 5 - zero ** uninit
            ok 6 - positive ** uninit
            ok 7 - negative ** uninit
            ok 8 - 1 ** uninit
            ok 9 - uninit ** zero
            ok 10 - zero ** positive
            ok 11 - zero ** zero
            ok 12 - zero ** 1st power
            ok 13 - positive ** zero
            ok 14 - positive ** 1st power
            ok 15 - positive ** positive
            ok 16 - negative ** zero
            ok 17 - negative ** 1st power
            ok 18 - negative ** positive
            ok 19 - positive ** negative
            ok 20 - negative ** negative
            ok 21 - 1/3 power (third root)
            ok 22 - 4/6 power (6th root of 4th power)
        ok 2649 - infix:<**>(num, num)
            1..9
            ok 1 - uninitialized
            ok 2 - NaN
            ok 3 - negative
            ok 4 - -∞
            ok 5 - +∞
            ok 6 - zero
            ok 7 - neg zero
            ok 8 - one
            ok 9 - 42
        ok 2650 - log(num)
            1..10
            ok 1 - uninitialized
            ok 2 - NaN
            ok 3 - -∞
            ok 4 - +∞
            ok 5 - zero
            ok 6 - neg zero
            ok 7 - positive (1)
            ok 8 - positive (2)
            ok 9 - negative (1)
            ok 10 - negative (2)
        ok 2651 - ceiling(num)
            1..13
            ok 1 - uninitialized
            ok 2 - NaN
            ok 3 - -∞
            ok 4 - +∞
            ok 5 - 0e0
            ok 6 - τ
            ok 7 - -τ
            ok 8 - π
            ok 9 - -π
            ok 10 - π/2
            ok 11 - -π/2
            ok 12 - π/4
            ok 13 - -π/4
        ok 2652 - sin(num)
            1..11
            ok 1 - uninitialized
            ok 2 - NaN
            ok 3 - -∞
            ok 4 - +∞
            ok 5 - -1.1e0
            ok 6 - +1.1e0
            ok 7 - 0e0
            ok 8 - 1e0
            ok 9 - -1e0
            ok 10 - ½√2
            ok 11 - -½√2
        ok 2653 - asin(num)
            1..13
            ok 1 - uninitialized
            ok 2 - NaN
            ok 3 - -∞
            ok 4 - +∞
            ok 5 - 0e0
            ok 6 - π/4
            ok 7 - -π/4
            ok 8 - π
            ok 9 - -π
            ok 10 - π/2
            ok 11 - -π/2
            ok 12 - π/4
            ok 13 - -π/4
        ok 2654 - cos(num)
            1..11
            ok 1 - NaN
            ok 2 - -∞
            ok 3 - +∞
            ok 4 - -1.1e0
            ok 5 - +1.1e0
            ok 6 - 1e0
            ok 7 - 1e0
            ok 8 - -1e0
            ok 9 - 0e0
            ok 10 - ½√2
            ok 11 - -½√2
        ok 2655 - acos(num)
            1..13
            ok 1 - NaN
            ok 2 - -∞
            ok 3 - +∞
            ok 4 - uninitialized
            ok 5 - 0e0
            ok 6 - τ
            ok 7 - -τ
            ok 8 - π
            ok 9 - -π
            ok 10 - π/4
            ok 11 - -π/4
            ok 12 - π/2
            ok 13 - -π/2
        ok 2656 - tan(num)
            1..7
            ok 1 - NaN
            ok 2 - uninitialized
            ok 3 - 0e0
            ok 4 - 1e0
            ok 5 - -1e0
            ok 6 - π
            ok 7 - -π
        ok 2657 - atan(num)
            1..13
            ok 1 - NaN
            ok 2 - -∞
            ok 3 - +∞
            ok 4 - uninitialized
            ok 5 - 0e0
            ok 6 - τ
            ok 7 - -τ
            ok 8 - π
            ok 9 - -π
            ok 10 - π/4
            ok 11 - -π/4
            ok 12 - π/2
            ok 13 - -π/2
        ok 2658 - sec(num)
            1..10
            ok 1 - uninitialized
            ok 2 - NaN
            ok 3 - 0e0
            ok 4 - .9e0
            ok 5 - -.9e0
            ok 6 - 1e0
            ok 7 - ∞
            ok 8 - -∞
            ok 9 - 2/√2
            ok 10 - -2/√2
        ok 2659 - asec(num)
            1..38
            ok 1 - uninitialized
            ok 2 - NaN
            ok 3 - -∞
            ok 4 - +∞
            ok 5 - 0e0
            ok 6 - -0e0
            ok 7 - π/12
            ok 8 - π/10
            ok 9 - π/8
            ok 10 - π/6
            ok 11 - π/5
            ok 12 - π/4
            ok 13 - 3*π/10
            ok 14 - π/3
            ok 15 - 3*π/8
            ok 16 - 2*π/5
            ok 17 - 5*π/12
            ok 18 - -π/2
            ok 19 - 3*π/2
            ok 20 - 5*π/2
            ok 21 - -π/12
            ok 22 - -π/10
            ok 23 - -π/8
            ok 24 - -π/6
            ok 25 - -π/5
            ok 26 - -π/4
            ok 27 - -3*π/10
            ok 28 - -π/3
            ok 29 - -3*π/8
            ok 30 - -2*π/5
            ok 31 - -5*π/12
            ok 32 - -π/2
            ok 33 - -3*π/2
            ok 34 - -5*π/2
            ok 35 - π
            ok 36 - -π
            ok 37 - τ
            ok 38 - -τ
        ok 2660 - cotan(num)
            1..29
            ok 1 - NaN
            ok 2 - uninitialized
            ok 3 - -∞ is -0
            ok 4 - ∞
            ok 5 - -∞
            ok 6 - 0e0
            ok 7 - -0e0
            ok 8 - 2+√3
            ok 9 - √(5+2*√5)
            ok 10 - 1+√2
            ok 11 - √3
            ok 12 - √(1+2/√5)
            ok 13 - 1e0
            ok 14 - √(5-2*√5)
            ok 15 - √3/3
            ok 16 - √2-1
            ok 17 - √(1-2/√5)
            ok 18 - 2-√3
            ok 19 - -(2+√3)
            ok 20 - -√(5+2*√5)
            ok 21 - -(1+√2)
            ok 22 - -√3
            ok 23 - -√(1+2/√5)
            ok 24 - -1e0
            ok 25 - -√(5-2*√5)
            ok 26 - -√3/3
            ok 27 - -(√2-1)
            ok 28 - -√(1-2/√5)
            ok 29 - -(2-√3)
        ok 2661 - acotan(num)
            1..18
            ok 1 - uninitialized
            ok 2 - NaN
            ok 3 - ∞
            ok 4 - -∞
            ok 5 - 1e20
            ok 6 - -1e20
            ok 7 - 2.718281828459045
            ok 8 - -2.718281828459045
            ok 9 - 0
            ok 10 - -0
            ok 11 - 1
            ok 12 - -1
            ok 13 - 3.141592653589793
            ok 14 - -3.141592653589793
            ok 15 - 6.283185307179586
            ok 16 - -6.283185307179586
            ok 17 - 100
            ok 18 - -100
        ok 2662 - sinh(num)
            1..19
            ok 1 - uninitialized
            ok 2 - NaN
            ok 3 - ∞
            ok 4 - -∞
            ok 5 - 1e200
            ok 6 - -1e200 # TODO asinh does not comply with IEEE
            not ok 7 - -0e0 actually gives a minus 0 # TODO asinh does not comply with IEEE
            # Failed test '-0e0 actually gives a minus 0'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/num.rakudo line 706
            # expected: '-0'
            #      got: '0'
            ok 8 - 2.718281828459045
            ok 9 - -2.718281828459045
            ok 10 - 0
            ok 11 - -0
            ok 12 - 1
            ok 13 - -1
            ok 14 - 3.141592653589793
            ok 15 - -3.141592653589793
            ok 16 - 6.283185307179586
            ok 17 - -6.283185307179586
            ok 18 - 100
            ok 19 - -100
        ok 2663 - asinh(num)
            1..18
            ok 1 - uninitialized
            ok 2 - NaN
            ok 3 - ∞
            ok 4 - -∞
            ok 5 - 1e20
            ok 6 - -1e20
            ok 7 - 2.718281828459045
            ok 8 - -2.718281828459045
            ok 9 - 0
            ok 10 - -0
            ok 11 - 1
            ok 12 - -1
            ok 13 - 3.141592653589793
            ok 14 - -3.141592653589793
            ok 15 - 6.283185307179586
            ok 16 - -6.283185307179586
            ok 17 - 100
            ok 18 - -100
        ok 2664 - cosh(num)
            1..20
            ok 1 - uninitialized
            ok 2 - NaN
            ok 3 - 0e0
            ok 4 - .9e0
            ok 5 - -1e0
            ok 6 - -1e100
            ok 7 - -1e200
            ok 8 - -∞
            ok 9 - ∞
            ok 10 - 1e200
            ok 11 - 2.718281828459045
            ok 12 - -2.718281828459045
            ok 13 - 1
            ok 14 - -1
            ok 15 - 3.141592653589793
            ok 16 - -3.141592653589793
            ok 17 - 6.283185307179586
            ok 18 - -6.283185307179586
            ok 19 - 1e+20
            ok 20 - -1e+20
        ok 2665 - acosh(num)
            1..18
            ok 1 - uninitialized
            ok 2 - NaN
            ok 3 - ∞
            ok 4 - -∞
            ok 5 - 1e20
            ok 6 - -1e20
            ok 7 - 2.718281828459045
            ok 8 - -2.718281828459045
            ok 9 - 0
            ok 10 - -0
            ok 11 - 1
            ok 12 - -1
            ok 13 - 3.141592653589793
            ok 14 - -3.141592653589793
            ok 15 - 6.283185307179586
            ok 16 - -6.283185307179586
            ok 17 - 100
            ok 18 - -100
        ok 2666 - tanh(num)
            1..32
            ok 1 - 1e0
            ok 2 - -1e0
            ok 3 - 2.718281828459045
            ok 4 - -2.718281828459045
            ok 5 - 10
            ok 6 - -10
            ok 7 - 3.141592653589793
            ok 8 - -3.141592653589793
            ok 9 - 6.283185307179586
            ok 10 - -6.283185307179586
            ok 11 - 1e+20
            ok 12 - -1e+20
            ok 13 - 1e+100
            ok 14 - -1e+100
            ok 15 - 1e+200
            ok 16 - -1e+200
            ok 17 - Inf
            ok 18 - -Inf
            ok 19 - Inf
            ok 20 - -Inf
            ok 21 - 0
            ok 22 - -0
            ok 23 - 0.2
            ok 24 - -0.2
            ok 25 - 0.3
            ok 26 - -0.3
            ok 27 - 0.5
            ok 28 - -0.5
            ok 29 - 0.7
            ok 30 - -0.7
            ok 31 - 0.9
            ok 32 - -0.9
        ok 2667 - atanh(num)
        ok 2668 - Literal Nums close to the upper limit are not Inf
            1..5
            ok 1 - positive
            ok 2 - negative
            ok 3 - zero
            ok 4 - negative zero
            ok 5 - NaN
        ok 2669 - .Bool
            1..3
            ok 1 - (1)
            ok 2 - (2)
            ok 3 - (3)
        ok 2670 - no parsing glitches in the way Num is parsed
        ok 2671 - Nums that are close to each other parsed correctly as different
            1..2
            ok 1 - 9.999e-5
            ok 2 - 9.99899999999999995e-5
        ok 2672 - Num literals yield closest available Num to their nominal value
            1..13
            ok 1 - 
            ok 2 - 
            ok 3 - 
            ok 4 - 
            ok 5 - 
            ok 6 - 
            ok 7 - 
            ok 8 - 
            ok 9 - 
            ok 10 - 
            ok 11 - 
            ok 12 - 
            ok 13 - 
        ok 2673 - parsed nums choose closest available representation
        ok 2674 - Rat->Num conversion is monotonic
            1..5
            ok 1 - parsed number stringification
            ok 2 - Str.Num stringification
            ok 3 - val().Numeric.Str stringification
            ok 4 - parsed matches Str.Num
            ok 5 - parsed matches val()
        ok 2675 - parsed nums are the same as those produced from Str.Num
            1..3
            ok 1 - ==
            ok 2 - ===
            ok 3 - === of .WHICHes
        ok 2676 - distinct num literals do not compare the same
        ok 2677 - .raku roundtrips the Num correctly
            1..2
                1..7
                ok 1 - Num literal
                ok 2 - Num literal in EVAL
                ok 3 - +Str
                ok 4 - Str.Numeric
                ok 5 - Str.Num
                ok 6 - Num allomorph
                ok 7 - Num allomorph in EVAL
            ok 1 - huge-ish exponent
                1..7
                ok 1 - Num literal
                ok 2 - Num literal in EVAL
                ok 3 - +Str
                ok 4 - Str.Numeric
                ok 5 - Str.Num
                ok 6 - Num allomorph
                ok 7 - Num allomorph in EVAL
            ok 2 - huge-huge-huge exponent
        ok 2678 - no hangs/crashes when parsing nums with huge exponents
# FUDGED!
        1..182
        # checking fat-comma
        ok 2679 - The object is-a 'Pair'
        ok 2680 - got the right key($pair:)
        ok 2681 - got the right value($pair:)
        ok 2682 - got the right $pair.key()
        ok 2683 - got the right $pair.value()
        ok 2684 - got the right $pair.key
        ok 2685 - got the right $pair.value
        ok 2686 - got the right number of elements in the list
        ok 2687 - got the right key
        ok 2688 - got the right value
        ok 2689 - got the right number of elements in the list
        ok 2690 - got the right key
        ok 2691 - got the right value
        ok 2692 - got the right number of elements in the list
        ok 2693 - got the right key
        ok 2694 - got the right value
        ok 2695 - got the right number of elements in the list
        ok 2696 - got the right key
        ok 2697 - got the right value
        # checking Pair.new(:key,:value)
        ok 2698 - The object is-a 'Pair'
        ok 2699 - got the right key($pair:)
        ok 2700 - got the right value($pair:)
        ok 2701 - got the right $pair.key()
        ok 2702 - got the right $pair.value()
        ok 2703 - got the right $pair.key
        ok 2704 - got the right $pair.value
        ok 2705 - got the right number of elements in the list
        ok 2706 - got the right key
        ok 2707 - got the right value
        ok 2708 - got the right number of elements in the list
        ok 2709 - got the right key
        ok 2710 - got the right value
        ok 2711 - got the right number of elements in the list
        ok 2712 - got the right key
        ok 2713 - got the right value
        ok 2714 - got the right number of elements in the list
        ok 2715 - got the right key
        ok 2716 - got the right value
        # checking Pair.new(key,value)
        ok 2717 - The object is-a 'Pair'
        ok 2718 - got the right key($pair:)
        ok 2719 - got the right value($pair:)
        ok 2720 - got the right $pair.key()
        ok 2721 - got the right $pair.value()
        ok 2722 - got the right $pair.key
        ok 2723 - got the right $pair.value
        ok 2724 - got the right number of elements in the list
        ok 2725 - got the right key
        ok 2726 - got the right value
        ok 2727 - got the right number of elements in the list
        ok 2728 - got the right key
        ok 2729 - got the right value
        ok 2730 - got the right number of elements in the list
        ok 2731 - got the right key
        ok 2732 - got the right value
        ok 2733 - got the right number of elements in the list
        ok 2734 - got the right key
        ok 2735 - got the right value
        # checking pair()
        ok 2736 - The object is-a 'Pair'
        ok 2737 - got the right key($pair:)
        ok 2738 - got the right value($pair:)
        ok 2739 - got the right $pair.key()
        ok 2740 - got the right $pair.value()
        ok 2741 - got the right $pair.key
        ok 2742 - got the right $pair.value
        ok 2743 - got the right number of elements in the list
        ok 2744 - got the right key
        ok 2745 - got the right value
        ok 2746 - got the right number of elements in the list
        ok 2747 - got the right key
        ok 2748 - got the right value
        ok 2749 - got the right number of elements in the list
        ok 2750 - got the right key
        ok 2751 - got the right value
        ok 2752 - got the right number of elements in the list
        ok 2753 - got the right key
        ok 2754 - got the right value
        ok 2755 - The object is-a 'Pair'
        ok 2756 - got the right value
        ok 2757 - The object is-a 'Pair'
        ok 2758 - The object is-a 'Pair'
        ok 2759 - got right nested pair key
        ok 2760 - got right nested pair key
        ok 2761 - got right nested pair key (method chaining)
        ok 2762 - got right nested pair key (method chaining)
        ok 2763 - The object is-a 'Pair'
        ok 2764 - got the right value
        ok 2765 - The object is-a 'Pair'
        ok 2766 - got right nested key
        ok 2767 - got right nested value
        ok 2768 - lhs quotes
        not ok 2769 - hash stringification # TODO should it really have \n on the end?
        # Failed test 'hash stringification'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/pair.rakudo line 90
        # expected: "when\tnow\n"
        #      got: "when\tnow"
        ok 2770 - %() makes creates a real Hash
        ok 2771 - got the right key :foo.key
        ok 2772 - :foo.value isa Bool
        ok 2773 - :foo is True
        ok 2774 - :foo.value is True
        ok 2775 - got the right key :!foo.key
        ok 2776 - :!foo.value isa Bool
        ok 2777 - :!foo.value is False
        ok 2778 - The object is-a 'Pair'
        ok 2779 - The object is-a 'Pair'
        ok 2780 - The object is-a 'Pair'
        ok 2781 - in sub test1 got the right $pair.key
        ok 2782 - in sub test1 got the right $pair.value
        ok 2783 - The object is-a 'Pair'
        ok 2784 - The object is-a 'Pair'
        ok 2785 - The object is-a 'Pair'
        ok 2786 - in for loop got the right $pair.key
        ok 2787 - in for loop got the right $pair.value
        ok 2788 - The object is-a 'Pair'
        ok 2789 - in sub test2 got the right $pair.key
        ok 2790 - in sub test2 got the right $pair.value
        ok 2791 - The object is-a 'Pair'
        ok 2792 - sub test3: $pair[0] is $pair
        ok 2793 - sub test3: $pair[1] is failure
        ok 2794 - => has correct precedence
        ok 2795 - Zaphod is 2
        ok 2796 - Ford is 42
        ok 2797 - Zaphod is still 2
        ok 2798 - Ford is still 42
        ok 2799 - pairs stringify correctly (1)
        ok 2800 - pairs stringify correctly (2)
        ok 2801 - pairs with arrayitems as values stringify correctly (1)
        ok 2802 - pairs with arrayitems as values stringify correctly (2)
        ok 2803 - => should not stringify the key (1)
        ok 2804 - => should not stringify the key (2)
        ok 2805 - => should not stringify the key (3)
        ok 2806 - => should not stringify the key (4)
        ok 2807 - => should not stringify the key (5)
        ok 2808 - => should not stringify the key (6)
        ok 2809 - the keys of pairs should not get auto-stringified when passed to a sub (1)
        ok 2810 - the keys of pairs should not get auto-stringified when passed to a sub (2)
        ok 2811 - the keys of pairs should not get auto-stringified when passed to a sub (3)
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Assignment::RO)
        ok 2812 - setting .key dies
        ok 2813 - attempt to set .key doesn't change the key
        ok 2814 - attempt to set .key does not change the original var either
        ok 2815 - setting .value does not die
        ok 2816 - setting .value actually changes the value
        ok 2817 - setting .value does change the original var as it was itemized
        ok 2818 - :$foo syntax works
        ok 2819 - :@foo syntax works
        ok 2820 - :%foo syntax works
        ok 2821 - :&foo syntax works
        ok 2822 - can parse ":a()"
        ok 2823 - can execute ":a()"
        ok 2824 - can parse ":a[]"
        ok 2825 - can execute ":a[]"
        ok 2826 - can parse "(a => ())"
        ok 2827 - can execute "(a => ())"
        ok 2828 - can parse "(a => [])"
        ok 2829 - can execute "(a => [])"
        ok 2830 - Pair.antipair.key
        ok 2831 - Pair.antipair.key type
        ok 2832 - Pair.antipair.value
        ok 2833 - Pair.invert splits positional values
        ok 2834 - Pair.invert splits positional values and preserves order
        ok 2835 - Pair.invert.key type
        ok 2836 - Pair.invert splits positional values and dups keys
        ok 2837 - list of array pairs can be inverted
        ok 2838 - list of hash pairs can be inverted
        ok 2839 - chained colonpairs in parens build a list of pairs
        ok 2840 - chained colonpairs in curlies construct hashes with more than one element
        ok 2841 - both key and value can convey a raw Nil
        ok 2842 - both key and value can convey a Mu type
        ok 2843 - both key and value can convey an Any type
        ok 2844 - both key and value can convey a Junction type
        ok 2845 - both key and value can convey a Junction object
        ok 2846 - The object is-a 'Int'
        ok 2847 - can assign integer value and return that
        ok 2848 - the expected Int value was set
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 2849 - cannot assign a Str to an Int
        ok 2850 - pair binding
            1..4
            ok 1 - code dies
            ok 2 - right exception type (X::TypeCheck)
            ok 3 - .expected matches (Pair)
            ok 4 - .got matches (Int)
        ok 2851 - List.invert maps via a required Pair binding
        ok 2852 - accessing non-existent key on a Pair returns Nil
        ok 2853 - .Pair on Pair:D is identity
        ok 2854 - .Pair on Pair:U is identity
            1..24
            ok 1 - ("a"=>3,"z"=>1).Bag (True)
            ok 2 - ("z"=>1,"a"=>3).BagHash (True)
            ok 3 - ("a"=>3,"z"=>2).Mix (True)
            ok 4 - ("z"=>2,"a"=>3).MixHash (True)
            ok 5 - ${:a(3), :z(5)} (True)
            ok 6 - $(Map.new((:a(3),:z(5)))) (True)
            ok 7 - :a(3) (True)
            ok 8 - :z(3) (True)
            ok 9 - ("z"=>1,"a"=>1).Bag (False)
            ok 10 - ("z"=>1,"a"=>1).BagHash (False)
            ok 11 - Set.new("a","z") (False)
            ok 12 - SetHash.new("a","z") (False)
            ok 13 - ("z"=>1,"a"=>1).Mix (False)
            ok 14 - ("a"=>1,"z"=>1).MixHash (False)
            ok 15 - ${:a(Bool::True), :z(Bool::True)} (False)
            ok 16 - $(Map.new((:a,:z))) (False)
            ok 17 - :a (False)
            ok 18 - :z (False)
            ok 19 - Set (True)
            ok 20 - SetHash (True)
            ok 21 - custom class (True, 1)
            ok 22 - custom class (True, 2)
            ok 23 - custom class (True, 3)
            ok 24 - custom class (False)
        ok 2855 - Pair.ACCEPTS
            1..7
            ok 1 - :a(42)
            ok 2 - 42 => 70
            ok 3 - :foo(:bar(:meow(42)))
            ok 4 - ("a", "b", "c") => ("d", "e", "f")
            ok 5 - {:a("b"), :c("d")} => {:e("f"), :g("h")}
                1..4
                ok 1 - return's type
                ok 2 - return's number of elements
                ok 3 - .key
                ok 4 - .value
            ok 6 - (Any) => (Mu)
                1..4
                ok 1 - return's type
                ok 2 - return's number of elements
                ok 3 - .key
                ok 4 - .value
            ok 7 - (Mu) => (Any)
        ok 2856 - Pair.invert
            1..5
            ok 1 - roundtrip of Bool:U .value does not eqv :!foo
            ok 2 - (Str) => Str
            ok 3 - (Rat) => Num
            ok 4 - (Bool) => Bool
            ok 5 - (Numeric) => Numeric
        ok 2857 - Pair.raku with type objects
            1..2
            ok 1 - clone, same value
            ok 2 - clone, different value
        ok 2858 - Clone of Pair does not share .WHICH
        ok 2859 - fake-infix adverbs (named args) on a construct inside args to another routine
        ok 2860 - did we not do parens?
# FUDGED!
        1..240
        ok 2861 - &set produces a Set
        ok 2862 - ...with the right elements
        ok 2863 - Default value is false
        ok 2864 - Single-key subscript (existing element)
        ok 2865 - Single-key subscript has correct type (existing element)
        ok 2866 - Single-key subscript (nonexistent element)
        ok 2867 - Single-key subscript has correct type (nonexistent element)
        ok 2868 - exists with existing element
        ok 2869 - exists with nonexistent element
        ok 2870 - Bool returns True if there is something in the Set
        ok 2871 - Bool returns False if there is nothing in the Set
        ok 2872 - .hash doesn't die
        ok 2873 - ...and it returned a Hash
        ok 2874 - ...with the right elements
        ok 2875 - ...and values
        ok 2876 - Can't assign to an element (Sets are immutable)
        ok 2877 - Can't assign to .keys
        ok 2878 - Can't assign to .values
        ok 2879 - Can't :delete from Set
        ok 2880 - Multiple-element access
        ok 2881 - Multiple-element access (with nonexistent elements)
        ok 2882 - .elems gives number of keys
        ok 2883 - +$set gives number of keys
        ok 2884 - Identical sets smartmatch with each other
        ok 2885 - Subset does not smartmatch
        ok 2886 - Superset does not smartmatch
        ok 2887 - Smartmatch is not element of
        ok 2888 - Type-checking smartmatch works
        ok 2889 - Bag smartmatches with equivalent set
        ok 2890 - ... even if the Bag has greater quantities
        ok 2891 - Subset does not smartmatch
        ok 2892 - Superset does not smartmatch
        ok 2893 - Type-checking smartmatch works
        ok 2894 - Str.Set makes a Set
        ok 2895 - 'a'.Set is set a
        ok 2896 - Pair.Set makes a Set
        ok 2897 - (a => 1).Set is set a
        ok 2898 - (a => 0).Set is the empty set
        ok 2899 - <a b c>.Set makes a Set
        ok 2900 - <a b c a>.Set makes the set a b c
        ok 2901 - [a b c a].Set makes the set a b c
        ok 2902 - [a => 3, b => 0, 'c', 'a'].Set makes the set a c
        ok 2903 - {a => 2, b => 4, c => 0}.Set makes a Set
        ok 2904 - {a => 2, b => 4, c => 0}.Set makes the set a b
        ok 2905 - .Set on List of Pairs treats Pair.value as weight
        ok 2906 - .Set on Hash of Pairs treats Pair.value as weight
        ok 2907 - :exists with existing element
        ok 2908 - :exists with nonexistent element
        ok 2909 - :delete does not work on set
        ok 2910 - Int keys are left as Ints
        ok 2911 - Bool keys are left as Bools
        ok 2912 - And Str keys are permitted in the same set
        ok 2913 - Keys are counted correctly even when a key is False
        ok 2914 - A hash to which a Set has been bound becomes a set
        ok 2915 - ...with the right keys
        ok 2916 - ...and values all True
        ok 2917 - &set discards duplicates
        ok 2918 - &Set.new given an array of pairs produces a Set
        ok 2919 - ... with three elements under the single arg rule
        ok 2920 - &Set.new given an itemized array of pairs produces a Set
        ok 2921 - ... with one element
        ok 2922 - &Set.new given a Hash produces a Set
        ok 2923 - ... with three elements
        ok 2924 - ... all of which are Pairs
        ok 2925 - &Set.new given a Hash produces a Set
        ok 2926 - ... with three elements under the single arg rule
        ok 2927 - &Set.new given an itemized Hash produces a Set
        ok 2928 - ... with one element
        ok 2929 - &Set.new given a Set produces a Set
        ok 2930 - ... with one element
        ok 2931 - &Set.new given a SetHash produces a Set
        ok 2932 - ... with one element
        ok 2933 - &Set.new given a SetHash produces a Set
        ok 2934 - ... with one element
        ok 2935 - &set given a Bag produces a Set
        ok 2936 - ... with one element
        ok 2937 - .list returns 3 things
        ok 2938 - ... all of which are Pairs
        ok 2939 - .pairs returns 3 things
        ok 2940 - ... all of which are Pairs
        ok 2941 - ... the keys of which are Strs
        ok 2942 - ... and the values of which are Bool
        ok 2943 - .raku lives
        ok 2944 - ... and produces a string
        ok 2945 - .raku.EVAL lives
        ok 2946 - ... and produces a Set
        ok 2947 - ... and it has the correct values
        ok 2948 - .Str lives
        ok 2949 - ... and produces a string
        ok 2950 - ... which only contains bar baz and foo separated by spaces
        ok 2951 - .gist lives
        ok 2952 - ... and produces a string
        ok 2953 - ... which mentions foo
        ok 2954 - ... which mentions bar
        ok 2955 - ... which mentions baz
        ok 2956 - A Set bound to a %var is a Set
        ok 2957 - ...with the right elements
        ok 2958 - Single-key subscript (existing element)
        ok 2959 - Single-key subscript (nonexistent element)
        ok 2960 - Can't assign to an element (Sets are immutable)
        ok 2961 - Can't assign to a %var implemented by Set
        ok 2962 - Can't :delete a key from a Set
        ok 2963 - # SKIP Hypers not yet Set compatible
        ok 2964 - # SKIP Hypers not yet Set compatible
        ok 2965 - # SKIP Hypers not yet Set compatible
        ok 2966 - # SKIP Hypers not yet Set compatible
        ok 2967 - # SKIP Hypers not yet Set compatible
        ok 2968 - # SKIP Hypers not yet Set compatible
        ok 2969 - # SKIP Hypers not yet Set compatible
        ok 2970 - # SKIP Hypers not yet Set compatible
        ok 2971 - # SKIP Hypers not yet Set compatible
        ok 2972 - We got one of the three choices
        ok 2973 - .roll(2) returns the right number of items
        ok 2974 - .roll(2) returned "a"s, "b"s, and "c"s
        ok 2975 - .roll(100) returns 100 items
        ok 2976 - .roll(100) returned "a"s, "b"s, and "c"s
        ok 2977 - .roll should not change Set
        ok 2978 - empty set.roll -> Nil
        ok 2979 - empty set.roll(1) -> ().Seq
        ok 2980 - empty set.roll(*-1) -> ().Seq
        ok 2981 - empty set.roll(*) -> ().Seq
        ok 2982 - empty set.roll(Inf) -> ().Seq
        ok 2983 - empty set.roll(-1) -> ().Seq
        ok 2984 - empty set.roll(-Inf) -> ().Seq
        ok 2985 - empty set.roll(NaN) should die
        ok 2986 - Set.pick(*) gets all elements
        ok 2987 - Set.pick(*) returns elements in a random order
        ok 2988 - .pick should not change Set
        ok 2989 - We got one of the three choices
        ok 2990 - .pick(2) returns the right number of items
        ok 2991 - .pick(2) returned "a"s, "b"s, and "c"s
        ok 2992 - .pick(2) returned at most one "a"
        ok 2993 - .pick(2) returned at most one "b"
        ok 2994 - .pick(2) returned at most one "c"
        ok 2995 - .pick should not change Set
        ok 2996 - empty set.pick -> Nil
        ok 2997 - empty set.pick(1) -> ().Seq
        ok 2998 - empty set.pick(*-1) -> ().Seq
        ok 2999 - empty set.pick(*) -> ().Seq
        ok 3000 - empty set.pick(Inf) -> ().Seq
        ok 3001 - empty set.pick(-1) -> ().Seq
        ok 3002 - empty set.pick(-Inf) -> ().Seq
        ok 3003 - empty set.pick(NaN) should die
        ok 3004 - cannot call .grab on a Set
        ok 3005 - cannot call .grab(1) on a Set
        ok 3006 - cannot call .grab(*-1) on a Set
        ok 3007 - cannot call .grab(*) on a Set
        ok 3008 - cannot call .grab(Inf) on a Set
        ok 3009 - cannot call .grab(-1) on a Set
        ok 3010 - cannot call .grab(-Inf) on a Set
        ok 3011 - cannot call .grab(NaN) on a Set
        ok 3012 - cannot call .grabpairs on a Set
        ok 3013 - Two elements
        ok 3014 - One of the set's elements is indeed a Set!
        ok 3015 - With the proper elements
        ok 3016 - One of the set's elements is indeed a List!
        ok 3017 - With the proper elements
        ok 3018 - Two elements
        ok 3019 - One of the set's elements is indeed a set!
        ok 3020 - With the proper elements
        ok 3021 - One of the set's elements is indeed a List!
        ok 3022 - With the proper elements
        ok 3023 - Method .Set works on Int-1
        ok 3024 - Method .Set works on Int-2
        ok 3025 - Method .Set works on Str-1
        ok 3026 - Method .Set works on Str-2
        ok 3027 - Method .Set works on Array-1
        ok 3028 - Method .Set works on Array-2
        ok 3029 - Method .Set works on Hash-1
        ok 3030 - Method .Set works on Hash-2
        ok 3031 - Method .Set works on List-1
        ok 3032 - Method .Set works on List-2
        ok 3033 - .total gives sum of values (non-empty)
        ok 3034 - +$set gives sum of values (non-empty)
        ok 3035 - .minpairs works (non-empty)
        ok 3036 - .maxpairs works (non-empty)
        ok 3037 - .fmt(%s) works (non-empty)
        ok 3038 - .fmt(%s,sep) works (non-empty)
        ok 3039 - .fmt(%s%s) works (non-empty)
        ok 3040 - .fmt(%s%s,sep) works (non-empty)
        ok 3041 - .total gives sum of values (empty)
        ok 3042 - +$set gives sum of values (empty)
        ok 3043 - .minpairs works (empty)
        ok 3044 - .maxpairs works (empty)
        ok 3045 - .fmt(%s) works (empty)
        ok 3046 - .fmt(%s,sep) works (empty)
        ok 3047 - .fmt(%s%s) works (empty)
WARNING: unhandled Failure detected in DESTROY. If you meant to ignore it, you can mark it as handled by calling .Bool, .so, .not, or .defined methods. The Failure was:
Index out of range. Is: 1, should be in 0..0
  in sub test3 at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/pair.rakudo line 154
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/pair.rakudo line 157
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

WARNING: unhandled Failure detected in DESTROY. If you meant to ignore it, you can mark it as handled by calling .Bool, .so, .not, or .defined methods. The Failure was:
Attempt to divide by zero using %
  in sub  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 684
  in sub subtest at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 435
  in sub fails-like at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 675
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/num.rakudo line 361
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/num.rakudo line 182
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

        ok 3048 - .fmt(%s%s,sep) works (empty)
        ok 3049 - Cannot change key of Set.pairs
        ok 3050 - Cannot change value of Set.pairs
        ok 3051 - can metaop set assign like: (|)=
        ok 3052 - Faulty .WHICH creation
        ok 3053 - arrays not flattened out by Set.new (1)
        ok 3054 - arrays not flattened out by Set.new (2)
        ok 3055 - arrays not flattened out by Set.new (3)
        ok 3056 - Can subclass Set
            1..2
            ok 1 - 'my $rt125611 = RT125611.new.foo: "a"' died
            ok 2 - right exception type (X::Assignment::RO)
        ok 3057 - trying to assign throws X::Assignment::RO
        ok 3058 - Set.kv returns list of keys and values (1)
        ok 3059 - Set.kv returns list of keys and values (2)
        ok 3060 - smartmatch a Seq
        ok 3061 - make sure set.Hash returns objects
            1..3
            ok 1 - Set.new
            ok 2 - .Set
            ok 3 - set()
        ok 3062 - .hash does not cause keys to be stringified
            1..2
            ok 1 - code dies
            ok 2 - right exception type (Exception)
        ok 3063 - autovivification of of Set:U complains about immutability
        ok 3064 - .Mix on set gives correct Mix
        ok 3065 - .MixHash on set gives correct MixHash
        ok 3066 - ().Set returns the empty set
        ok 3067 - coercion of Map to Set 1
        ok 3068 - coercion of Map to Set 2
        ok 3069 - coercion of object Hash to Set 1
        ok 3070 - coercion of object Hash to Set 2
        ok 3071 - can we parameterize for strings?
        ok 3072 - does .keyof return the correct type
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::TypeCheck::Binding)
        ok 3073 - do wrong values make initialization croak
            1..3
            ok 1 - code dies
            ok 2 - right exception type (X::Cannot::Lazy)
            ok 3 - .what matches Set
        ok 3074 - did we throws-like X::Cannot::Lazy?
            1..3
            ok 1 - code dies
            ok 2 - right exception type (X::Cannot::Lazy)
            ok 3 - .what matches Set
        ok 3075 - did we throws-like X::Cannot::Lazy?
            1..3
            ok 1 - code dies
            ok 2 - right exception type (X::Cannot::Lazy)
            ok 3 - .what matches Set
        ok 3076 - did we throws-like X::Cannot::Lazy?
            1..3
            ok 1 - 'set;' died
            ok 2 - right exception type (Exception)
            ok 3 - .message matches /set/
        ok 3077 - set listop called without arguments and parentheses dies (1)
            1..3
            ok 1 - 'set<a b c>;' died
            ok 2 - right exception type (X::Syntax::Confused)
            ok 3 - .message matches /subscript/
        ok 3078 - set listop called without arguments dies (2)
            1..180
            ok 1 - Set ∈
            ok 2 - Set (elem)
            ok 3 - Set ∉
            ok 4 - Set ∋
            ok 5 - Set (cont)
            ok 6 - Set ∌
            ok 7 - Set ⊆
            ok 8 - Set (<=)
            ok 9 - Set ⊈
            ok 10 - Set ⊂
            ok 11 - Set (<)
            ok 12 - Set ⊄
            ok 13 - Set ⊇
            ok 14 - Set (>=)
            ok 15 - Set ⊉
            ok 16 - Set ⊃
            ok 17 - Set (>)
            ok 18 - Set ⊅
            ok 19 - Set ∪
            ok 20 - Set (|)
            ok 21 - Set ∩
            ok 22 - Set (&)
            ok 23 - Set ∖ 
            ok 24 - Set (-)
            ok 25 - Set ⊖
            ok 26 - Set (^)
            ok 27 - Set ⊍
            ok 28 - Set (.)
            ok 29 - Set ⊎
            ok 30 - Set (+)
            ok 31 - SetHash ∈
            ok 32 - SetHash (elem)
            ok 33 - SetHash ∉
            ok 34 - SetHash ∋
            ok 35 - SetHash (cont)
            ok 36 - SetHash ∌
            ok 37 - SetHash ⊆
            ok 38 - SetHash (<=)
            ok 39 - SetHash ⊈
            ok 40 - SetHash ⊂
            ok 41 - SetHash (<)
            ok 42 - SetHash ⊄
            ok 43 - SetHash ⊇
            ok 44 - SetHash (>=)
            ok 45 - SetHash ⊉
            ok 46 - SetHash ⊃
            ok 47 - SetHash (>)
            ok 48 - SetHash ⊅
            ok 49 - SetHash ∪
            ok 50 - SetHash (|)
            ok 51 - SetHash ∩
            ok 52 - SetHash (&)
            ok 53 - SetHash ∖ 
            ok 54 - SetHash (-)
            ok 55 - SetHash ⊖
            ok 56 - SetHash (^)
            ok 57 - SetHash ⊍
            ok 58 - SetHash (.)
            ok 59 - SetHash ⊎
            ok 60 - SetHash (+)
            ok 61 - Bag ∈
            ok 62 - Bag (elem)
            ok 63 - Bag ∉
            ok 64 - Bag ∋
            ok 65 - Bag (cont)
            ok 66 - Bag ∌
            ok 67 - Bag ⊆
            ok 68 - Bag (<=)
            ok 69 - Bag ⊈
            ok 70 - Bag ⊂
            ok 71 - Bag (<)
            ok 72 - Bag ⊄
            ok 73 - Bag ⊇
            ok 74 - Bag (>=)
            ok 75 - Bag ⊉
            ok 76 - Bag ⊃
            ok 77 - Bag (>)
            ok 78 - Bag ⊅
            ok 79 - Bag ∪
            ok 80 - Bag (|)
            ok 81 - Bag ∩
            ok 82 - Bag (&)
            ok 83 - Bag ∖ 
            ok 84 - Bag (-)
            ok 85 - Bag ⊖
            ok 86 - Bag (^)
            ok 87 - Bag ⊍
            ok 88 - Bag (.)
            ok 89 - Bag ⊎
            ok 90 - Bag (+)
            ok 91 - BagHash ∈
            ok 92 - BagHash (elem)
            ok 93 - BagHash ∉
            ok 94 - BagHash ∋
            ok 95 - BagHash (cont)
            ok 96 - BagHash ∌
            ok 97 - BagHash ⊆
            ok 98 - BagHash (<=)
            ok 99 - BagHash ⊈
            ok 100 - BagHash ⊂
            ok 101 - BagHash (<)
            ok 102 - BagHash ⊄
            ok 103 - BagHash ⊇
            ok 104 - BagHash (>=)
            ok 105 - BagHash ⊉
            ok 106 - BagHash ⊃
            ok 107 - BagHash (>)
            ok 108 - BagHash ⊅
            ok 109 - BagHash ∪
            ok 110 - BagHash (|)
            ok 111 - BagHash ∩
            ok 112 - BagHash (&)
            ok 113 - BagHash ∖ 
            ok 114 - BagHash (-)
            ok 115 - BagHash ⊖
            ok 116 - BagHash (^)
            ok 117 - BagHash ⊍
            ok 118 - BagHash (.)
            ok 119 - BagHash ⊎
            ok 120 - BagHash (+)
            ok 121 - Mix ∈
            ok 122 - Mix (elem)
            ok 123 - Mix ∉
            ok 124 - Mix ∋
            ok 125 - Mix (cont)
            ok 126 - Mix ∌
            ok 127 - Mix ⊆
            ok 128 - Mix (<=)
            ok 129 - Mix ⊈
            ok 130 - Mix ⊂
            ok 131 - Mix (<)
            ok 132 - Mix ⊄
            ok 133 - Mix ⊇
            ok 134 - Mix (>=)
            ok 135 - Mix ⊉
            ok 136 - Mix ⊃
            ok 137 - Mix (>)
            ok 138 - Mix ⊅
            ok 139 - Mix ∪
            ok 140 - Mix (|)
            ok 141 - Mix ∩
            ok 142 - Mix (&)
            ok 143 - Mix ∖ 
            ok 144 - Mix (-)
            ok 145 - Mix ⊖
            ok 146 - Mix (^)
            ok 147 - Mix ⊍
            ok 148 - Mix (.)
            ok 149 - Mix ⊎
            ok 150 - Mix (+)
            ok 151 - MixHash ∈
            ok 152 - MixHash (elem)
            ok 153 - MixHash ∉
            ok 154 - MixHash ∋
            ok 155 - MixHash (cont)
            ok 156 - MixHash ∌
            ok 157 - MixHash ⊆
            ok 158 - MixHash (<=)
            ok 159 - MixHash ⊈
            ok 160 - MixHash ⊂
            ok 161 - MixHash (<)
            ok 162 - MixHash ⊄
            ok 163 - MixHash ⊇
            ok 164 - MixHash (>=)
            ok 165 - MixHash ⊉
            ok 166 - MixHash ⊃
            ok 167 - MixHash (>)
            ok 168 - MixHash ⊅
            ok 169 - MixHash ∪
            ok 170 - MixHash (|)
            ok 171 - MixHash ∩
            ok 172 - MixHash (&)
            ok 173 - MixHash ∖ 
            ok 174 - MixHash (-)
            ok 175 - MixHash ⊖
            ok 176 - MixHash (^)
            ok 177 - MixHash ⊍
            ok 178 - MixHash (.)
            ok 179 - MixHash ⊎
            ok 180 - MixHash (+)
        ok 3079 - set ops do not hang with Setty/Baggy/Mixy type objects
        ok 3080 - did we get right number of elements
        ok 3081 - do we get a truthy value for a
        ok 3082 - do we get a falsy value for e
        ok 3083 - is the %h really a Set
        ok 3084 - cannot re-initialize Set
        ok 3085 - cannot :delete from Set
        ok 3086 - cannot delete from Set by assignment
        ok 3087 - Nums that are close to each other remain distinct when put in sets
        ok 3088 - have typechecking on a Hashifeid Set iterator
        ok 3089 - can we smartmatch empty
        ok 3090 - coerce Set -> SetHash
        ok 3091 - coerce Set -> Bag
        ok 3092 - coerce Set -> BagHash
        ok 3093 - coerce Set -> Mix
        ok 3094 - coerce Set -> MixHash
        ok 3095 - parameterized Set
        ok 3096 - did it parameterize ok
        ok 3097 - must have Ints
        ok 3098 - multi method Setty(Set:U:) returns a Set type object
        ok 3099 - the two Set:D.STORE candidates create equivalent objects
        ok 3100 - does .item work on Sets
# FUDGED!
        1..27
        ok 3101 - unitialized $var does Mu
        ok 3102 - value contained in a $var does Mu
        ok 3103 - unitialized @var does Positional
        ok 3104 - value contained in a @var does Positional
        ok 3105 - generic val in a @var is converted to Positional
        ok 3106 - List does Positional
        ok 3107 - Array does Positional
        ok 3108 - Range does Positional
        ok 3109 - Buf does Positional
        not ok 3110 - Capture does Positional # TODO Capture does Positional
        # Failed test 'Capture does Positional'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/sigils-and-types.rakudo line 32
        # Type: Capture doesn't do role Positional
        ok 3111 - uninitialized %var does Associative
        ok 3112 - value in %var does Associative
        ok 3113 - Pair does Associative
        ok 3114 - Set does Associative
        ok 3115 - Bag does Associative
        ok 3116 - QuantHash does Associative
        not ok 3117 - Capture does Associative # TODO Capture does Associative
        # Failed test 'Capture does Associative'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/sigils-and-types.rakudo line 44
        # Type: Capture doesn't do role Associative
        ok 3118 - a Sub does Callable
        ok 3119 - a Method does Callable
        ok 3120 - a multi does Callable
        ok 3121 - a proto does Callable
        ok 3122 - a token does Callable
        ok 3123 - a rule does Callable
        ok 3124 - a macro does Callable
        ok 3125 - cannot just assign &b to &a
        ok 3126 - and the correct function is still in place
        ok 3127 - can use &$x() for invoking
# FUDGED!
        1..80
        ok 3128 - compile my Int $foo
        ok 3129 - compile my Str $bar
        ok 3130 - Int $foo isa Int
        ok 3131 - Str $bar isa Str
            1..2
            ok 1 - '$foo = 'xyz'' died
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 3132 - Int restricts to integers
            1..2
            ok 1 - '$foo = Mu' died
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 3133 - Int does not accept Mu
        ok 3134 - Int is an integer
            1..2
            ok 1 - '$bar = 42' died
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 3135 - Str restricts to strings
            1..2
            ok 1 - '$bar = Mu' died
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 3136 - Str does not accept Mu
        ok 3137 - Str is a strings
            1..2
            ok 1 - '$baz = 'xyz'' died
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 3138 - of Int restricts to integers
        ok 3139 - of Int is an integer
        ok 3140 - Has native type int
            1..2
            ok 1 - 'my int $alpha = Nil' died
            ok 2 - right exception type (Exception)
        ok 3141 - native int type cannot be undefined
        ok 3142 - object Int type can be undefined
        ok 3143 - Has native type num
        not ok 3144 - native num type can be undefined # TODO assigning Nil to natives
        # Failed test 'native num type can be undefined'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/type.rakudo line 49
        # Error: Cannot unbox a type object (Nil) to a num.
        ok 3145 - object Num type can be undefined
        ok 3146 - object Str type can be undefined, list context
        ok 3147 - sub parameters with matching type
            1..2
            ok 1 - 'paramtype("foo")' died
            ok 2 - right exception type (X::TypeCheck::Argument)
        ok 3148 - sub parameters with non-matching type dies
        ok 3149 - recursive factorial with type contstraints work
            1..2
            ok 1 - 'my Num $n; $n = 42' died
            ok 2 - right exception type (X::Syntax::Number::LiteralType)
        ok 3150 - Num does not accept Int
            1..2
            ok 1 - 'my Num $n; $n = $*PID' died
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 3151 - Num does not accept Int
            1..2
            ok 1 - 'my Complex $n; $n = 42' died
            ok 2 - right exception type (X::Syntax::Number::LiteralType)
        ok 3152 - Complex does not accept Int
            1..2
            ok 1 - 'my Complex $n; $n = $*PID' died
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 3153 - Complex does not accept Int
            1..2
            ok 1 - 'my Rat $n; $n = 42' died
            ok 2 - right exception type (X::Syntax::Number::LiteralType)
        ok 3154 - Rat does not accept Int
            1..2
            ok 1 - 'my Rat $n; $n = $*PID' died
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 3155 - Rat does not accept Int
            1..2
            ok 1 - 'my Int $n; $n = 42e0' died
            ok 2 - right exception type (X::Syntax::Number::LiteralType)
        ok 3156 - Int does not accept Num
            1..2
            ok 1 - 'my Int $n; $n = $*PID.Num' died
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 3157 - Int does not accept Num
            1..2
            ok 1 - 'my Complex $n; $n = 42e0' died
            ok 2 - right exception type (X::Syntax::Number::LiteralType)
        ok 3158 - Complex does not accept Num
            1..2
            ok 1 - 'my Complex $n; $n = $*PID.Num' died
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 3159 - Complex does not accept Num
            1..2
            ok 1 - 'my Rat $n; $n = 42e0' died
            ok 2 - right exception type (X::Syntax::Number::LiteralType)
        ok 3160 - Rat does not accept Num
            1..2
            ok 1 - 'my Rat $n; $n = $*PID.Num' died
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 3161 - Rat does not accept Num
            1..2
            ok 1 - 'my Int $n; $n = 42.0' died
            ok 2 - right exception type (X::Syntax::Number::LiteralType)
        ok 3162 - Int does not accept Rat
            1..2
            ok 1 - 'my Int $n; $n = $*PID.Rat' died
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 3163 - Int does not accept Rat
            1..2
            ok 1 - 'my Complex $n; $n = 42.0' died
            ok 2 - right exception type (X::Syntax::Number::LiteralType)
        ok 3164 - Complex does not accept Rat
            1..2
            ok 1 - 'my Complex $n; $n = $*PID.Rat' died
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 3165 - Complex does not accept Rat
            1..2
            ok 1 - 'my Num $n; $n = 42.0' died
            ok 2 - right exception type (X::Syntax::Number::LiteralType)
        ok 3166 - Num does not accept Rat
            1..2
            ok 1 - 'my Num $n; $n = $*PID.Rat' died
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 3167 - Num does not accept Rat
            1..2
            ok 1 - 'my Int $n; $n = <42+0i>' died
            ok 2 - right exception type (X::Syntax::Number::LiteralType)
        ok 3168 - Int does not accept Complex
            1..2
            ok 1 - 'my Int $n; $n = $*PID\i' died
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 3169 - Int does not accept Complex
            1..2
            ok 1 - 'my Rat $n; $n = <42+0i>' died
            ok 2 - right exception type (X::Syntax::Number::LiteralType)
        ok 3170 - Rat does not accept Complex
            1..2
            ok 1 - 'my Rat $n; $n = $*PID\i' died
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 3171 - Rat does not accept Complex
            1..2
            ok 1 - 'my Num $n; $n = <42+0i>' died
            ok 2 - right exception type (X::Syntax::Number::LiteralType)
        ok 3172 - Num does not accept Complex
            1..2
            ok 1 - 'my Num $n; $n = $*PID\i' died
            ok 2 - right exception type (X::TypeCheck::Assignment)
        ok 3173 - Num does not accept Complex
            1..2
            ok 1 - 'my num $n; $n = 42' died
            ok 2 - right exception type (X::Syntax::Number::LiteralType)
        ok 3174 - num does not accept Int
            1..2
            ok 1 - 'my int $n; $n = 42e0' died
            ok 2 - right exception type (X::Syntax::Number::LiteralType)
        ok 3175 - int does not accept Num
            1..2
            ok 1 - 'my int $n; $n = 42.0' died
            ok 2 - right exception type (X::Syntax::Number::LiteralType)
        ok 3176 - int does not accept Rat
            1..2
            ok 1 - 'my num $n; $n = 42.0' died
            ok 2 - right exception type (X::Syntax::Number::LiteralType)
        ok 3177 - num does not accept Rat
            1..2
            ok 1 - 'my int $n; $n = <42+0i>' died
            ok 2 - right exception type (X::Syntax::Number::LiteralType)
        ok 3178 - int does not accept Complex
            1..2
            ok 1 - 'my num $n; $n = <42+0i>' died
            ok 2 - right exception type (X::Syntax::Number::LiteralType)
        ok 3179 - num does not accept Complex
        ok 3180 - good return value works (returns)
            1..2
            ok 1 - 'returntype1(Bool::False)' died
            ok 2 - right exception type (X::TypeCheck::Return)
        ok 3181 - bad return value dies (returns)
        ok 3182 - good return value works (of)
            1..2
            ok 1 - 'returntype2(Bool::False)' died
            ok 2 - right exception type (X::TypeCheck::Return)
        ok 3183 - bad return value dies (of)
        ok 3184 - good return value works (my Type sub)
            1..2
            ok 1 - 'returntype3(Bool::False)' died
            ok 2 - right exception type (X::TypeCheck::Return)
        ok 3185 - bad return value dies (my Type sub)
        ok 3186 - good return value works (-->)
            1..2
            ok 1 - 'returntype4(Bool::False)' died
            ok 2 - right exception type (X::TypeCheck::Return)
        ok 3187 - bad return value dies (-->)
        ok 3188 - good implicit return value works (returns)
            1..2
            ok 1 - 'returntype1(Bool::False)' died
            ok 2 - right exception type (X::TypeCheck::Return)
        ok 3189 - bad implicit return value dies (returns)
        ok 3190 - good implicit return value works (of)
            1..2
            ok 1 - 'returntype2(Bool::False)' died
            ok 2 - right exception type (X::TypeCheck::Return)
        ok 3191 - bad implicit return value dies (of)
        ok 3192 - good implicit return value works (my Type sub)
            1..2
            ok 1 - 'returntype3(Bool::False)' died
            ok 2 - right exception type (X::TypeCheck::Return)
        ok 3193 - bad implicit return value dies (my Type sub)
        ok 3194 - good implicit return value works (-->)
            1..2
            ok 1 - 'returntype4(Bool::False)' died
            ok 2 - right exception type (X::TypeCheck::Return)
        ok 3195 - bad implicit return value dies (-->)
            1..2
            ok 1 - 'my Int Str $x' died
            ok 2 - right exception type (X::Comp::NYI)
        ok 3196 - multiple prefix constraints not allowed
            1..2
            ok 1 - 'sub foo(Int Str $x) { }' died
            ok 2 - right exception type (X::Parameter::MultipleTypeConstraints)
        ok 3197 - multiple prefix constraints not allowed
            1..2
            ok 1 - 'sub foo(--> Int Str) { }' died
            ok 2 - right exception type (Exception)
        ok 3198 - multiple prefix constraints not allowed
            1..2
            ok 1 - 'our Int Str sub foo() { }' died
            ok 2 - right exception type (X::Comp::NYI)
        ok 3199 - multiple prefix constraints not allowed
        ok 3200 - Any ~~ Mu
        ok 3201 - Mu !~~ Any
        ok 3202 - Mu !~~ Int
        ok 3203 - Int ~~ Numeric
        ok 3204 - Numeric !~~ Int
        ok 3205 - Array is a kind of List
        ok 3206 - A List is not an Array
        ok 3207 - Array does Positional too
# FUDGED!
        1..49
        ok 3208 - () is defined
        ok 3209 - Nil as part of list is element
        ok 3210 - Empty as part of list, is empty list
        ok 3211 - Pushing Empty returns same array
        ok 3212 - Pushing Empty in list context is empty list
        ok 3213 - Unshifting Empty returns same array
        ok 3214 - Unshifting Empty in list context is empty list
        ok 3215 - Setting array to Empty returns empty string
        ok 3216 - Setting to Empty restores original state
        ok 3217 - assigning Nil to Int should work
        ok 3218 - Nil makes undefined here
        not ok 3219 - Check that we have an 'Int' array # TODO .clone doesn't copy typedness
        # Failed test 'Check that we have an 'Int' array'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/undefined-types.rakudo line 33
        # expected: '(Int)'
        #      got: (Int)
        ok 3220 - Empty as part of Int list, is empty list
        ok 3221 - assigning Empty returns same array
        ok 3222 - Pushing Empty in Int list context is empty list
        ok 3223 - assigning Empty returns same array
        ok 3224 - Unshifting Empty in Int list context is empty list
        ok 3225 - assigning Nil to Int should work
        ok 3226 - Nil makes undefined here
        ok 3227 - setting array to Empty returns empty string
        not ok 3228 - Check that we still have an 'Int' array # TODO .clone doesn't copy typedness
        # Failed test 'Check that we still have an 'Int' array'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/undefined-types.rakudo line 43
        # expected: '(Int)'
        #      got: (Int)
        ok 3229 - Setting to Empty restores original state
        not ok 3230 - Check that we have an 'Int' hash # TODO .clone doesn't copy typedness
        # Failed test 'Check that we have an 'Int' hash'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/undefined-types.rakudo line 51
        # expected: '(Int)'
        #      got: (Int)
        ok 3231 - Empty as part of Int list, is empty pair
        ok 3232 - assigning Nil to hash element should work
        ok 3233 - Nil makes undefined here
        ok 3234 - setting hash to Empty returns empty string
        not ok 3235 - Check that we still have an 'Int' hash # TODO .clone doesn't copy typedness
        # Failed test 'Check that we still have an 'Int' hash'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/undefined-types.rakudo line 57
        # expected: '(Int)'
        #      got: (Int)
        ok 3236 - Setting to Empty restores original state
        ok 3237 - sink statement prefix returns Nil (list context)
        ok 3238 - sink execucted the statement
        ok 3239 - sink block prefix returns Nil (list context)
        ok 3240 - the block was executed
        ok 3241 - sink in scalar context (statement)
        ok 3242 - ... statement executed
        ok 3243 - sink in scalar context (block)
        ok 3244 - ... block executed
Use of uninitialized value $obj of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/undefined-types.rakudo line 84
        ok 3245 - prefix:<~> on type object gives empty string (Any)
Use of uninitialized value $int of type Int in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/undefined-types.rakudo line 85
        ok 3246 - prefix:<~> on type object gives empty string (Int)
Use of uninitialized value $obj of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/undefined-types.rakudo line 86
        ok 3247 - .Stringy on type object gives empty string (Any)
Use of uninitialized value $int of type Int in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/undefined-types.rakudo line 87
        ok 3248 - .Stringy on type object gives empty string (Int)
Use of uninitialized value $obj of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/undefined-types.rakudo line 89
        ok 3249 - prefix:<~> returns a Stringy (Any)
Use of uninitialized value $int of type Int in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/undefined-types.rakudo line 90
        ok 3250 - prefix:<~> returns a Stringy (Int)
Use of uninitialized value $obj of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/undefined-types.rakudo line 92
        ok 3251 - .Stringy returns a Stringy (Any)
Use of uninitialized value $int of type Int in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/undefined-types.rakudo line 93
        ok 3252 - .Stringy returns a Stringy (Int)
        ok 3253 - .gist on type object gives (Any)
        ok 3254 - .gist on type object gives (Int)
Use of uninitialized value element of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/undefined-types.rakudo line 98
        ok 3255 - infix:<~> uses coercion to Stringy (Any)
Use of uninitialized value element of type Int in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/undefined-types.rakudo line 99
        ok 3256 - infix:<~> uses coercion to Stringy (Int)
# FUDGED!
        1..130
        ok 3257 - can assign * to a variable and isa works
        ok 3258 - can type variables with Whatever
        ok 3259 - *.WHAT does not autocurry
        ok 3260 - (*-1).WHAT lives
        ok 3261 - *-1 is some form of Code
        ok 3262 - *-1 is a WhateverCode object
        ok 3263 - and we can execute that Code
        ok 3264 - *.abs is of type Code
        ok 3265 - ... WhateverCode, more specifically
        ok 3266 - 1..* is a Range, not a Code
        ok 3267 - 1..*-1 is a WhateverCode
        ok 3268 - (1..*-1)(10) is a Range
        ok 3269 - *.meth created closure works
        ok 3270 - Enums and Whatever star interact OK
        ok 3271 - "*.uc eq $str" produces a Callable object
        ok 3272 - and it works (+)
        ok 3273 - and it works (-)
        ok 3274 - @a[1..*] skips first element, stops at last
        ok 3275 - array is unmodified after reference to [1..*]
        ok 3276 - *-1..* lives and clips to range of List
        ok 3277 - $_ % * works
        ok 3278 - +* is of type Code
        ok 3279 - -> $key {+$key} generates closure to numify
        ok 3280 - +* generates closure to numify
        ok 3281 - +* generates closure to numify
        ok 3282 - +* in hash slice
        ok 3283 - * * * generated a closure
        ok 3284 - ... that takes two arguments
        ok 3285 - * * * + * generated a closure
        ok 3286 - ... that works
        ok 3287 - ... that respects precedence
        ok 3288 - that can work with three different arguments
        ok 3289 - * + * * * generated a closure
        ok 3290 - ... that works
        ok 3291 - ... that respects precedence
        ok 3292 - that can work with three different arguments
        ok 3293 - xx * works
        ok 3294 - *.defined works in grep
        ok 3295 - *.defined generates a closure
        ok 3296 - *.defined works (true)
        ok 3297 - *.defined works (false)
        not ok 3298 - can dummy-asign to * # TODO * as dummy
        # Failed test 'can dummy-asign to *'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/whatever.rakudo line 133
        # Error: Cannot modify an immutable Whatever (*)
        ok 3299 - Can skip lvalues and replace them by Whatever
        ok 3300 - can use a declaration in Whatever-curried expression
        ok 3301 - and it did not get promoted into its own scope
        ok 3302 - * works on LHS of user-defined operator (type)
        ok 3303 - * works on RHS of user-defined operator (type)
        ok 3304 - * works on both sides of user-defined operator (type)
        ok 3305 - * works on LHS of user-defined operator (result)
        ok 3306 - * works on RHS of user-defined operator (result)
        ok 3307 - * works on both sides of user-defined operator (result)
        ok 3308 - also with three *
        ok 3309 - also if the last is not a *, but a normal value
        ok 3310 - '* + 2' curries
        ok 3311 - '* min 2' curries
        ok 3312 - '* max 2' curries
        ok 3313 - '* max *' curries
        ok 3314 - in *.foo(oh_noes()), oh_noes() not called when making closure
        ok 3315 - and we get a Callable as expected
        ok 3316 - does get called when invoked
        ok 3317 - does get called when invoked
        ok 3318 - we get a Callable from chained methods with *
        ok 3319 - we call both methods
        ok 3320 - prefix:<!> Whatever-curries correctly
        ok 3321 - Whatever-curried method calls have a signature
        ok 3322 - Whatever-curried operators have a signature
            1..2
            ok 1 - '{*.{}}()' died
            ok 2 - right exception type (X::Syntax::Malformed)
        ok 3323 - {*.{}}() dies
        ok 3324 - Whatever-currying !< (1)
        ok 3325 - Whatever-currying !< (2)
        ok 3326 - Whatever-currying !< (3)
        ok 3327 - Whatever-currying !< (4)
        ok 3328 - Whatever-currying with R- (1)
        ok 3329 - Whatever-currying with R- (2)
        ok 3330 - Whatever-currying with R- (3)
        ok 3331 - &infix:<+>(*, 42) doesn't make a closure
        ok 3332 - &infix:<+>(*, 42) doesn't make a closure
        ok 3333 - Whatever-currying single * with X+ (1)
        ok 3334 - Whatever-currying single * with X+ (2)
        ok 3335 - Whatever-currying single * with X+ (3)
        ok 3336 - Whatever-currying multi * with X+ (1)
        ok 3337 - Whatever-currying multi * with X+ (2)
        ok 3338 - Whatever-currying multi * with X+ (3)
        ok 3339 - Whatever-currying with X+ lists (1)
        ok 3340 - Whatever-currying with X+ lists (2)
        ok 3341 - Whatever-currying single * with Z+ (1)
        ok 3342 - Whatever-currying single * with Z+ (2)
        ok 3343 - Whatever-currying single * with Z+ (3)
        ok 3344 - Whatever-currying multi * with Z+ (1)
        ok 3345 - Whatever-currying multi * with Z+ (2)
        ok 3346 - Whatever-currying multi * with Z+ (3)
        ok 3347 - Whatever-currying with Z+ lists (1)
        ok 3348 - Whatever-currying with Z+ lists (2)
        ok 3349 - assignment of whatever still works
        ok 3350 - assignment to variable with whatever in it
        ok 3351 - *.&sub curries
        ok 3352 - *[0] curries
        ok 3353 - ... it works
        ok 3354 - Chained comparison (1)
        ok 3355 - Chained comparison (2)
        ok 3356 - Chained comparison (3)
        ok 3357 - *.[1] is some kind of code
        ok 3358 - *.<a> is some kind of code
        ok 3359 - *.{1} is some kind of code
        ok 3360 - Whatever type object does not autoprime
        ok 3361 - WhateverCode type object does not autoprime
        ok 3362 - *++ is some kind of code
        ok 3363 - ++* is some kind of code
        ok 3364 - Can call *++ WhateverCode
        ok 3365 - WhateverCode parameters are rw
            1..3
            ok 1 - '*(42)' died
            ok 2 - right exception type (X::Method::NotFound)
            ok 3 - .typename matches Whatever
        ok 3366 - did we throws-like X::Method::NotFound?
        ok 3367 - Code.ACCEPTS preserves container
        ok 3368 - Whatever-currying !~~ (1)
        ok 3369 - Whatever-currying !~~ (2)
        not ok 3370 - *+* does not warn from inside EVAL # TODO useless use corner case
        # Failed test '*+* does not warn from inside EVAL'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/whatever.rakudo line 353
        #      got err: "WARNINGS for /Users/tobiuo/class/seminar/Abyss-Server/EVAL_0:\nUseless use of \"+\" in expression \"*+*\" in sink context (line 1)\n"
        # expected err: ""
        ok 3371 - no warning when WhateverCode passed as arg and invoked
        ok 3372 - combinations(2..*)
        not ok 3373 - outer parameter in rx in WhateverCode in closure # TODO closure/scoping of outer parameter with rx
        # Failed test 'outer parameter in rx in WhateverCode in closure'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/whatever.rakudo line 366
        # expected: $[(), ("foo",), ("fie",), ()]
        #      got: $[(), ("foo",), ("fie",), ()]
        ok 3374 - topic refreshed in immediate invocation of WhateverCode
Too many positionals passed; expected 0 arguments but got 1
  in sub f2 at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-names/pseudo-6c.rakudo line 211
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/whatever.rakudo line 380
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S02-types/whatever.rakudo line 358
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

        1..16
        ok 3375 - attribute binding lives
        ok 3376 - binding $!x instance attribute (1)
        ok 3377 - binding $!x instance attribute (2)
        ok 3378 - binding $x instance attribute (1)
        ok 3379 - binding $x instance attribute (2)
        ok 3380 - binding $x instance attribute (3)
        ok 3381 - # SKIP class attributes
        ok 3382 - # SKIP class attributes
        ok 3383 - # SKIP class attributes
        ok 3384 - binding private class attribute (1)
        ok 3385 - binding private class attribute (2)
        ok 3386 - binding private class attribute (3)
        ok 3387 - is the scalar attribute mixed in?
        ok 3388 - is the array attribute mixed in?
        ok 3389 - is the hash attribute mixed in?
        ok 3390 - is the code attribute mixed in?
# FUDGED!
        1..8
        # Testing for calling block bindings...
        ok 3391 - Calling block binding without argument. (Runtime)
        ok 3392 - # SKIP ::= NYI
        ok 3393 - Calling block binding with argument. (Runtime, with parens)
        ok 3394 - Calling block binding with argument. (Runtime, no parens)
        ok 3395 - # SKIP ::= NYI
        ok 3396 - # SKIP ::= NYI
        ok 3397 - Testing the value for placeholder(Runtime binding)
        ok 3398 - # SKIP ::= NYI
# FUDGED!
        1..11
        ok 3399 - # SKIP ::= NYI
        ok 3400 - # SKIP ::= NYI
        ok 3401 - # SKIP ::= NYI
        ok 3402 - # SKIP ::= NYI
        ok 3403 - # SKIP ::= NYI
        ok 3404 - # SKIP ::= NYI
        ok 3405 - # SKIP ::= NYI
        ok 3406 - # SKIP ::= NYI
        ok 3407 - # SKIP ::= NYI
            1..2
            ok 1 - 'my $a is readonly = 5;' died
            ok 2 - right exception type (X::Comp::Trait::Unknown)
        ok 3408 - variable trait "is readonly" is no longer valid (1)
            1..2
            ok 1 - '(my $a is readonly) = 5;' died
            ok 2 - right exception type (X::Comp::Trait::Unknown)
        ok 3409 - variable trait "is readonly" is no longer valid (2)
# FUDGED!
        1..33
        ok 3410 - normal assignment works
        ok 3411 - y is now bound to x
        ok 3412 - y is bound to x (we checked with the =:= identity op)
        ok 3413 - z is not bound to x
        ok 3414 - z is not bound to x (we checked with the =:= identity op)
        ok 3415 - y has been changed to "Raku Hacker"
        ok 3416 - x has also been changed to "Raku Hacker"
        ok 3417 - z is still "Just Another" because it was not bound to x
            1..2
            ok 1 - '0 := 1' died
            ok 2 - right exception type (X::Bind)
        ok 3418 - cannot bind to a literal
        ok 3419 - CALLER resolves bindings in caller's dynamic scope
        ok 3420 - # SKIP list binding: RT  \#122369
        ok 3421 - # SKIP list binding: RT  \#122369
        ok 3422 - # SKIP list binding: RT  \#122369
        ok 3423 - # SKIP list binding: RT  \#122369
        ok 3424 - # SKIP list binding: RT  \#122369
        ok 3425 - # SKIP list binding: RT  \#122369
        ok 3426 - # SKIP list binding: RT  \#122369
        ok 3427 - bound readonly sub param was bound correctly (1)
        ok 3428 - bound readonly sub param was bound correctly (2) (no change)
        ok 3429 - bound readonly sub param remains readonly (1)
        ok 3430 - bound readonly sub param remains readonly (2)
        ok 3431 - bound readonly sub param remains readonly (3)
        ok 3432 - bound rw sub param was bound correctly (1)
        ok 3433 - bound rw sub param was bound correctly (2)
        ok 3434 - bound rw sub param remains rw (1)
        ok 3435 - bound rw sub param remains rw (2)
        ok 3436 - bound rw sub param remains rw (3)
        ok 3437 - # SKIP list binding: RT  \#122369
        ok 3438 - # SKIP list binding: RT  \#122369
        ok 3439 - binding has same precdence as list assignment
        ok 3440 - can bind variable to itself (no-oop)
        ok 3441 - interaction between signature binding and ordinary binding
        ok 3442 - rebinding
# FUDGED!
        1..23
        ok 3443 - ltr feed as simple assignment
        ok 3444 - rtl feed as simple assignment
        ok 3445 - array ==> grep ==> result
        ok 3446 - result <== grep <== array
        ok 3447 - result = do {array ==> grep}
        ok 3448 - result = (array ==> grep)
        ok 3449 - x was passed as explicit param
        not ok 3450 - optional param y was not bound to fed list # TODO feeds + signatures
        # Failed test 'optional param y was not bound to fed list'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-feeds/basic.rakudo line 59
        not ok 3451 - ...slurpy array *@z got it # TODO feeds + signatures
        # Failed test '...slurpy array *@z got it'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-feeds/basic.rakudo line 60
        # expected: '1 2 3 4 5'
        #      got: ''
        not ok 3452 - @arr <== grep <== eager @arr works # TODO feeds + eager
        # Failed test '@arr <== grep <== eager @arr works'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-feeds/basic.rakudo line 70
        # expected: '1 5 7'
        #      got: '1 2 4 5 7 8 1 5 7'
        not ok 3453 - @arr <== eager grep <== @arr works # TODO feeds + eager
        # Failed test '@arr <== eager grep <== @arr works'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-feeds/basic.rakudo line 74
        # expected: '1 5 7'
        #      got: '1 2 4 5 7 8 1 5 7'
        ok 3454 - @tap contained what was expected at the time
        not ok 3455 - final result was unaffected by the tap variable # TODO feeds + eager
        # Failed test 'final result was unaffected by the tap variable'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-feeds/basic.rakudo line 85
        # expected: '2 4 6 8 10'
        #      got: '0 1 2 3 4 5 6 7 8 9 2 4 6 8 10'
        ok 3456 - # SKIP double-ended feeds
        ok 3457 - # SKIP double-ended feeds
        ok 3458 - # SKIP double-ended feeds
        ok 3459 - # SKIP double-ended feeds
        ok 3460 - 
        not ok 3461 -  # TODO isn't lazy
        # Failed test at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-feeds/basic.rakudo line 125
        # expected: '1'
        #      got: '10'
        ok 3462 - # SKIP * feeds
        ok 3463 - # SKIP * feeds
        ok 3464 - # SKIP * feeds
        ok 3465 - # SKIP * feeds
# FUDGED!
        1..412
        ok 3466 - ascii hyper >> <<
        ok 3467 - unicode hyper >> <<
        ok 3468 - ascii hyper >> >>
        ok 3469 - unicode hyper >> >>
        ok 3470 - ascii hyper << >>
        ok 3471 - unicode hyper << >>
        ok 3472 - ascii hyper << <<
        ok 3473 - unicode hyper << <<
        ok 3474 - ascii hyper >>[ ]<<
        ok 3475 - unicode hyper >>[ ]<<
        ok 3476 - ascii hyper >>[ ]>>
        ok 3477 - unicode hyper >>[ ]>>
        ok 3478 - ascii hyper <<[ ]>>
        ok 3479 - unicode hyper <<[ ]>>
        ok 3480 - ascii hyper <<[ ]<<
        ok 3481 - unicode hyper <<[ ]<<
        ok 3482 - precedence - »+« vs »*«
        ok 3483 - hyper auto increment an array
        ok 3484 - hyper auto increment an array ASCII notation
        ok 3485 - hyper op on assignment/pipeline
        ok 3486 - hyper op on assignment/pipeline ASCII notation
        ok 3487 - auto dimension upgrade on rhs ASCII notation
        ok 3488 - auto dimension upgrade on lhs ASCII notation
        ok 3489 - both dwim short side lengthening on ASCII notation
            1..4
            ok 1 - code dies
            ok 2 - right exception type (X::HyperOp::NonDWIM)
            ok 3 - .left-elems matches 3
            ok 4 - .right-elems matches 5
        ok 3490 - both non-dwim dies correctly on ASCII notation
        ok 3491 - list-level element truncate on rhs ASCII notation
        ok 3492 - list-level element truncate on lhs ASCII notation
        ok 3493 - list-level element extension on rhs ASCII notation
        ok 3494 - list-level element extension on lhs ASCII notation
        ok 3495 - list-level element extension on rhs ASCII notation
        ok 3496 - list-level element extension on lhs ASCII notation
        ok 3497 - list-level element extension on rhs ASCII notation
        ok 3498 - list-level element extension on lhs ASCII notation
        ok 3499 - scalar element extension on rhs ASCII notation
        ok 3500 - scalar element extension on lhs ASCII notation
        ok 3501 - list-level element truncate on rhs unicode notation
        ok 3502 - list-level element truncate on lhs unicode notation
        ok 3503 - list-level element extension on rhs unicode notation
        ok 3504 - list-level element extension on lhs unicode notation
        ok 3505 - list-level element extension on rhs unicode notation
        ok 3506 - list-level element extension on lhs unicode notation
        ok 3507 - list-level element extension on rhs unicode notation
        ok 3508 - list-level element extension on lhs unicode notation
        ok 3509 - scalar element extension on rhs unicode notation
        ok 3510 - scalar element extension on lhs unicode notation
        ok 3511 - lazy list-level extension on lhs ascii notation
            1..3
            ok 1 - code dies
            ok 2 - right exception type (X::HyperOp::Infinite)
            ok 3 - .side matches left
        ok 3512 - lazy list on left side with both dwim dies correctly
            1..3
            ok 1 - code dies
            ok 2 - right exception type (X::HyperOp::Infinite)
            ok 3 - .side matches left
        ok 3513 - lazy list on left side with right dwim dies correctly
            1..3
            ok 1 - code dies
            ok 2 - right exception type (X::HyperOp::Infinite)
            ok 3 - .side matches left
        ok 3514 - lazy list on left side with both non-dwim dies correctly
        ok 3515 - lazy list-level extension on rhs ascii notation
            1..3
            ok 1 - code dies
            ok 2 - right exception type (X::HyperOp::Infinite)
            ok 3 - .side matches right
        ok 3516 - lazy list on right side with both dwim dies correctly
            1..3
            ok 1 - code dies
            ok 2 - right exception type (X::HyperOp::Infinite)
            ok 3 - .side matches right
        ok 3517 - lazy list on right side with left dwim dies correctly
            1..3
            ok 1 - code dies
            ok 2 - right exception type (X::HyperOp::Infinite)
            ok 3 - .side matches right
        ok 3518 - lazy list on right side with both non-dwim dies correctly
            1..3
            ok 1 - code dies
            ok 2 - right exception type (X::HyperOp::Infinite)
            ok 3 - .side matches both
        ok 3519 - lazy list on both sides with both non-dwim dies correctly
            1..3
            ok 1 - code dies
            ok 2 - right exception type (X::HyperOp::Infinite)
            ok 3 - .side matches both
        ok 3520 - lazy list on both sides with both dwim dies correctly
            1..3
            ok 1 - code dies
            ok 2 - right exception type (X::HyperOp::Infinite)
            ok 3 - .side matches both
        ok 3521 - lazy list on both sides with left dwim dies correctly
            1..3
            ok 1 - code dies
            ok 2 - right exception type (X::HyperOp::Infinite)
            ok 3 - .side matches both
        ok 3522 - lazy list on both sides with right dwim dies correctly
        ok 3523 - method call on integer list elements
        ok 3524 - method call on integer list elements (ASCII)
        ok 3525 - operator call on integer list elements
        ok 3526 - operator call on integer list elements (Same thing, dot form)
        ok 3527 - postfix operator (dotted form) on integer list elements after unary postfix hyper operator
        ok 3528 - postfix operator (dotted form) on integer list elements after unary postfix hyper operator (ASCII)
        ok 3529 - postfix operator (dotted form) on integer list elements after unary postfix hyper operator (unspace form)
        ok 3530 - non-wordy postfix operator
        ok 3531 - non-wordy postfix operator, ASCII
        ok 3532 - non-wordy postfix operator, dotted form
        ok 3533 - non-wordy postfix operator, ASCII, dotted form
        ok 3534 - wordy postfix operator
        ok 3535 - wordy postfix operator, ASCII
            1..3
            ok 1 - code dies
            ok 2 - right exception type (X::Method::NotFound)
            ok 3 - .message matches No such method 'foo' for invocant of type 'Int'
        ok 3536 - wordy postfix operator: dotted form not allowed
            1..3
            ok 1 - code dies
            ok 2 - right exception type (X::Method::NotFound)
            ok 3 - .message matches No such method 'foo' for invocant of type 'Int'
        ok 3537 - wordy postfix operator, ASCII: dotted form not allowed
        ok 3538 - manually defined method i is not confused with postfix:<i>
        ok 3539 - manually defined method i is not confused with postfix:<i>
        ok 3540 - postfix:<i> still works
        ok 3541 - postfix:<i> still works (2)
            1..3
            ok 1 - code dies
            ok 2 - right exception type (X::Method::NotFound)
            ok 3 - .message matches WhateverCode.new
        ok 3542 - dotted form of postfix:<i> fails
        ok 3543 - postfix:<i> works on list elements
        ok 3544 - postfix:<i> works on list elements (ASCII form)
        ok 3545 - calling .() on list elements works
        ok 3546 - calling .() on list elements works, ASCII
        ok 3547 - method call on list elements
        ok 3548 - method call on list elements (Same thing, dot form)
        ok 3549 - method call on list elements (ASCII)
        ok 3550 - method call on list elements (ASCII, Same thing, dot form)
        ok 3551 - method call on list elements (quoted method name)
        ok 3552 - method call on list elements (ASCII, quoted method name)
        ok 3553 - plain method call works OK
        ok 3554 - hyper-method-call on list of user-defined objects
        ok 3555 - distribution for unary prefix
        ok 3556 - distribution for unary prefix, deep comparison
        ok 3557 - distribution for unary postfix autoincr
        ok 3558 - distribution for unary postfix autoincr, deep comparison
        ok 3559 - nodal postcircumfixes do not distribute
        ok 3560 - nodal methods do not distribute (elems)
        ok 3561 - nodal methods do not distribute (reverse)
        ok 3562 - .all is nodal
        ok 3563 - .antipairs is nodal
        ok 3564 - .any is nodal
        ok 3565 - .Array is nodal
        ok 3566 - .BagHash is nodal
        ok 3567 - .Bag is nodal
        ok 3568 - .categorize is nodal
        ok 3569 - .classify is nodal
        ok 3570 - .combinations is nodal
        ok 3571 - .deepmap is nodal
        ok 3572 - .duckmap is nodal
        ok 3573 - .eager is nodal
        ok 3574 - .elems is nodal
        ok 3575 - .end is nodal
        ok 3576 - .first is nodal
        ok 3577 - .flat is nodal
        ok 3578 - .flatmap is nodal
        ok 3579 - .grep is nodal
        ok 3580 - .hash is nodal
        ok 3581 - .Hash is nodal
        ok 3582 - .join is nodal
        ok 3583 - .keys is nodal
        ok 3584 - .kv is nodal
        ok 3585 - .list is nodal
        ok 3586 - .List is nodal
        ok 3587 - .map is nodal
        ok 3588 - .max is nodal
        ok 3589 - .min is nodal
        ok 3590 - .minmax is nodal
        ok 3591 - .MixHash is nodal
        ok 3592 - .Mix is nodal
        ok 3593 - .nodemap is nodal
        ok 3594 - .none is nodal
        ok 3595 - .one is nodal
        ok 3596 - .pairs is nodal
        ok 3597 - .pairup is nodal
        ok 3598 - .permutations is nodal
        ok 3599 - .pick is nodal
        ok 3600 - .postcircumfix:<[ ]> is nodal
        ok 3601 - .postcircumfix:<[; ]> is nodal
        ok 3602 - .produce is nodal
        ok 3603 - .reduce is nodal
        ok 3604 - .repeated is nodal
        ok 3605 - .reverse is nodal
        ok 3606 - .roll is nodal
        ok 3607 - .rotate is nodal
        ok 3608 - .rotor is nodal
        ok 3609 - .Seq is nodal
        ok 3610 - .SetHash is nodal
        ok 3611 - .Set is nodal
        ok 3612 - .Slip is nodal
        ok 3613 - .sort is nodal
        ok 3614 - .squish is nodal
        ok 3615 - .Supply is nodal
        ok 3616 - .tree is nodal
        ok 3617 - .unique is nodal
        ok 3618 - .values is nodal
        ok 3619 - .push is nodal
        ok 3620 - .pop is nodal
        ok 3621 - .append is nodal
        ok 3622 - .unshift is nodal
        ok 3623 - .shift is nodal
        ok 3624 - .prepend is nodal
        not ok 3625 - .splice is nodal # TODO doesn't seem to see the nodal
        # Failed test '.splice is nodal'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-metaops/hyper.rakudo line 425
        # expected: ''
        #      got: '([2] [4])'
        ok 3626 - distribution for binary infix, same shape, ASCII
        ok 3627 - distribution for binary infix, same shape, ASCII, deep comparison
        ok 3628 - distribution for binary infix, dimension upgrade, ASCII
        ok 3629 - distribution for binary infix, dimension upgrade, ASCII, deep comparison
        ok 3630 - distribution for binary infix, S03 cross-upgrade, ASCII
        ok 3631 - distribution for binary infix, S03 cross-upgrade, ASCII, deep comparison
        ok 3632 - distribution for binary infix, same shape
        ok 3633 - distribution for binary infix, same shape, deep comparison
        ok 3634 - distribution for binary infix, dimension upgrade
        ok 3635 - distribution for binary infix, dimension upgrade, deep comparison
        ok 3636 - distribution for binary infix, S03 cross-upgrade
        ok 3637 - distribution for binary infix, S03 cross-upgrade, deep comparison
        ok 3638 - hyper op works on variables, too.
        ok 3639 - hyper op and correctly promotes scalars
        ok 3640 - hyper-dereference an array
        ok 3641 - hyper-dereference an array slice
        ok 3642 - »|« hyperjunction evals
        ok 3643 - >>|<< hyperjunction evals, ASCII
        ok 3644 - »&« hyperjunction evals
        ok 3645 - >>&<< hyperjunction evals, ASCII
        ok 3646 - hash - >>+<< result has right number of keys (same keys)
        ok 3647 - hash - correct result from >>+<< (same keys)
        ok 3648 - hash - correct result from >>+<< (same keys)
        ok 3649 - hash - correct result from >>+<< (same keys)
        ok 3650 - hash - »+« result has right number of keys (union test)
        ok 3651 - hash - correct result from »+« (union test)
        ok 3652 - hash - correct result from »+« (union test)
        ok 3653 - hash - correct result from »+« (union test)
        ok 3654 - hash - >>+<< result has right number of keys (union test)
        ok 3655 - hash - correct result from >>+<< (union test)
        ok 3656 - hash - correct result from >>+<< (union test)
        ok 3657 - hash - correct result from >>+<< (union test)
        ok 3658 - hash - <<+>> result has right number of keys (same keys)
        ok 3659 - hash - correct result from <<+>> (same keys)
        ok 3660 - hash - correct result from <<+>> (same keys)
        ok 3661 - hash - correct result from <<+>> (same keys)
        ok 3662 - hash - <<+>> result has right number of keys (intersection test)
        ok 3663 - hash - correct result from <<+>> (intersection test)
        ok 3664 - hash - correct result from <<+>> (intersection test)
        ok 3665 - hash - <<+>> result has right number of keys (intersection test)
        ok 3666 - hash - correct result from <<+>> (intersection test)
        ok 3667 - hash - correct result from <<+>> (intersection test)
        ok 3668 - hash - >>+>> result has right number of keys
        ok 3669 - hash - correct result from >>+>>
        ok 3670 - hash - correct result from >>+>>
        ok 3671 - hash - correct result from >>+>>
        ok 3672 - hash - >>+>> result has right number of keys
        ok 3673 - hash - correct result from >>+>>
        ok 3674 - hash - correct result from >>+>>
        ok 3675 - hash - <<+<< result has right number of keys
        ok 3676 - hash - correct result from <<+<<
        ok 3677 - hash - correct result from <<+<<
        ok 3678 - hash - correct result from <<+<<
        ok 3679 - hash - <<+<< result has right number of keys
        ok 3680 - hash - correct result from <<+<<
        ok 3681 - hash - correct result from <<+<<
        ok 3682 - hash - -<< result has right number of keys
        ok 3683 - hash - correct result from -<<
        ok 3684 - hash - correct result from -<<
        ok 3685 - hash - correct result from -<<
        ok 3686 - hash - --<< result has right number of keys
        ok 3687 - hash - correct result from --<<
        ok 3688 - hash - correct result from --<<
        ok 3689 - hash - correct result from --<<
        ok 3690 - hash - --<< result has right number of keys
        ok 3691 - hash - correct result from --<<
        ok 3692 - hash - correct result from --<<
        ok 3693 - hash - correct result from --<<
        ok 3694 - hash - >>++ result has right number of keys
        ok 3695 - hash - correct result from >>++
        ok 3696 - hash - correct result from >>++
        ok 3697 - hash - correct result from >>++
        ok 3698 - hash - >>++ result has right number of keys
        ok 3699 - hash - correct result from >>++
        ok 3700 - hash - correct result from >>++
        ok 3701 - hash - correct result from >>++
        ok 3702 - hash - >>! result has right number of keys
        ok 3703 - hash - correct result from >>!
        ok 3704 - hash - correct result from >>!
        ok 3705 - hash - correct result from >>!
        ok 3706 - hash - >>*>> result has right number of keys
        ok 3707 - hash - correct result from >>*>>
        ok 3708 - hash - correct result from >>*>>
        ok 3709 - hash - correct result from >>*>>
        ok 3710 - hash - <<**<< result has right number of keys
        ok 3711 - hash - correct result from <<**<<
        ok 3712 - hash - correct result from <<**<<
        ok 3713 - hash - correct result from <<**<<
        ok 3714 - hash - <<*>> result has right number of keys
        ok 3715 - hash - correct result from <<*>>
        ok 3716 - hash - correct result from <<*>>
        ok 3717 - hash - correct result from <<*>>
        ok 3718 - hash - <<**>> result has right number of keys
        ok 3719 - hash - correct result from <<**>>
        ok 3720 - hash - correct result from <<**>>
        ok 3721 - hash - correct result from <<**>>
        ok 3722 - hash - >>.abs result has right number of keys
        ok 3723 - hash - correct result from >>.abs
        ok 3724 - hash - correct result from >>.abs
        ok 3725 - hash - correct result from >>.abs
        ok 3726 - hash in array - result array is the correct length
        ok 3727 - hash in array - correct result from <<~>>
        ok 3728 - hash in array - correct result from <<~>>
        ok 3729 - hash in array - correct result from <<~>>
        ok 3730 - hash in array - correct result from <<~>>
        ok 3731 - hash in array - result array is the correct length
        ok 3732 - hash in array - correct result from >>~<<
        ok 3733 - hash in array - correct result from >>~<<
        ok 3734 - hash in array - correct result from >>~<<
        ok 3735 - hash in array - correct result from >>~<<
        ok 3736 - hash in array - result array is the correct length
        ok 3737 - hash in array - correct result from >>~>>
        ok 3738 - hash in array - correct result from >>~>>
        ok 3739 - hash in array - correct result from >>~>>
        ok 3740 - hash in array - correct result from >>~>>
        ok 3741 - hash in array - result array is the correct length
        ok 3742 - hash in array - correct result from <<R~<<
        ok 3743 - hash in array - correct result from <<R~<<
        ok 3744 - hash in array - correct result from <<R~<<
        ok 3745 - hash in array - correct result from <<R~<<
        ok 3746 - hash in array - result array is the correct length
        ok 3747 - hash in array - correct result from <<~>>
        ok 3748 - hash in array - correct result from <<~>>
        ok 3749 - hash in array - correct result from <<~>>
        ok 3750 - hash in array - correct result from <<~>>
        ok 3751 - hash in array - correct result from <<~>>
        ok 3752 - hash in array - correct result from <<~>>
        ok 3753 - hash in array - correct result from <<~>>
        ok 3754 - hash in array - correct result from <<~>>
        ok 3755 - hash in array - result array is the correct length
        ok 3756 - hash in array - correct result from «~»
        ok 3757 - hash in array - correct result from «~»
        ok 3758 - hash in array - correct result from «~»
        ok 3759 - hash in array - correct result from «~»
        ok 3760 - hash in array - result array is the correct length
        ok 3761 - hash in array - correct result from »~«
        ok 3762 - hash in array - correct result from »~«
        ok 3763 - hash in array - correct result from »~«
        ok 3764 - hash in array - correct result from »~«
        ok 3765 - hash in array - result array is the correct length
        ok 3766 - hash in array - correct result from »~»
        ok 3767 - hash in array - correct result from »~»
        ok 3768 - hash in array - correct result from »~»
        ok 3769 - hash in array - correct result from »~»
        ok 3770 - hash in array - result array is the correct length
        ok 3771 - hash in array - correct result from «R~«
        ok 3772 - hash in array - correct result from «R~«
        ok 3773 - hash in array - correct result from «R~«
        ok 3774 - hash in array - correct result from «R~«
        ok 3775 - hash in array - result array is the correct length
        ok 3776 - hash in array - correct result from «~»
        ok 3777 - hash in array - correct result from «~»
        ok 3778 - hash in array - correct result from «~»
        ok 3779 - hash in array - correct result from «~»
        ok 3780 - hash in array - correct result from «~»
        ok 3781 - hash in array - correct result from «~»
        ok 3782 - hash in array - correct result from «~»
        ok 3783 - hash in array - correct result from «~»
        ok 3784 - hash in array - result array is the correct length
        ok 3785 - hash in array - correct result from -<<
        ok 3786 - hash in array - correct result from -<<
        ok 3787 - hash in array - correct result from -<<
        ok 3788 - hash in array - correct result from -<<
        ok 3789 - hash in array - result array is the correct length
        ok 3790 - hash in array - correct result from ++<<
        ok 3791 - hash in array - correct result from ++<<
        ok 3792 - hash in array - correct result from ++<<
        ok 3793 - hash in array - correct result from ++<<
        ok 3794 - hash in array - result array is the correct length
        ok 3795 - hash in array - correct result from ++<<
        ok 3796 - hash in array - correct result from ++<<
        ok 3797 - hash in array - correct result from ++<<
        ok 3798 - hash in array - correct result from ++<<
        ok 3799 - hash in array - result array is the correct length
        ok 3800 - hash in array - correct result from ++<<
        ok 3801 - hash in array - correct result from ++<<
        ok 3802 - hash in array - correct result from ++<<
        ok 3803 - hash in array - correct result from ++<<
        ok 3804 - # SKIP EVAL(Buf) RT  \#122256
        ok 3805 - dwimmy hyper doesn't return an itemized list
        ok 3806 - dwimmy hyper extends lists ending with * by copying the last element
        ok 3807 - dwimmy hyper extends lists ending with * by copying the last element
        ok 3808 - dwimmy hyper extends lists ending with * by copying the last element
        ok 3809 - dwimmy hyper extends lists ending with * by copying the last element
        ok 3810 - dwimmy hyper omits * when both arguments of same length have one
        ok 3811 - dwimmy hyper takes longer length given two arguments ending with *
        ok 3812 - can use hypers with local scoped user-defined operators
        ok 3813 - ranges and hyper ops mix
        ok 3814 - <<-<<
        ok 3815 - >>->>
        ok 3816 - >>-<<
        ok 3817 - <<->>
        ok 3818 - »+=« returns the right value
        ok 3819 - »+=« changes its lvalue
        ok 3820 - »*=» returns the right value
        ok 3821 - »*=» changes its lvalue
        ok 3822 - »~=» with list of scalars on the left returns the right value
        ok 3823 - »~=» changes each scalar
        ok 3824 - >>[+]<< works
        ok 3825 - .>> works with .()
        ok 3826 - .>>.() means the same as >>.()
        ok 3827 - can call Callable objects in a list in parallel using >>.()
            1..2
            not ok 1 - 'my @a >>[=]>> (1,2,3)' died # TODO can_meta check for meta operators NYI
            # Failed test ''my @a >>[=]>> (1,2,3)' died'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-metaops/hyper.rakudo line 926
            ok 2 - # SKIP Code did not die, can not check exception
        not ok 3828 - hypering assignment dies correctly # TODO can_meta check for meta operators NYI
        # Failed test 'hypering assignment dies correctly'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-metaops/hyper.rakudo line 926
        ok 3829 - hyper against an undefined Iterable doesn't hang
        ok 3830 - hyper against an undefined Associative doesn't hang
        ok 3831 - no-dwim hyper between empty lists doesn't hang
        ok 3832 - left-dwim hyper between empty lists doesn't hang
        ok 3833 - right-dwim hyper between empty lists doesn't hang
        ok 3834 - both-dwim hyper between empty lists doesn't hang
        ok 3835 - left-dwim hyper against empty RHS doesn't hang
        ok 3836 - right-dwim hyper against empty RHS doesn't hang
        ok 3837 - both-dwim hyper against empty RHS doesn't hang
            1..4
            ok 1 - code dies
            ok 2 - right exception type (X::HyperOp::NonDWIM)
            ok 3 - .left-elems matches 1
            ok 4 - .right-elems matches 0
        ok 3838 - non-dwim hyper against empty RHS dies
        ok 3839 - left-dwim hyper against empty LHS doesn't hang
        ok 3840 - right-dwim hyper against empty LHS doesn't hang
        ok 3841 - both-dwim hyper against empty LHS doesn't hang
            1..4
            ok 1 - code dies
            ok 2 - right exception type (X::HyperOp::NonDWIM)
            ok 3 - .right-elems matches 1
            ok 4 - .left-elems matches 0
        ok 3842 - non-dwim hyper against empty RHS dies
        ok 3843 - left-dwim hyper against empty RHS doesn't hang
        ok 3844 - right-dwim hyper against empty RHS doesn't hang
        ok 3845 - both-dwim hyper against empty RHS doesn't hang
            1..4
            ok 1 - code dies
            ok 2 - right exception type (X::HyperOp::NonDWIM)
            ok 3 - .left-elems matches 5
            ok 4 - .right-elems matches 0
        ok 3846 - non-dwim hyper against empty RHS dies
        ok 3847 - left-dwim hyper against empty LHS doesn't hang
        ok 3848 - right-dwim hyper against empty LHS doesn't hang
        ok 3849 - both-dwim hyper against empty LHS doesn't hang
            1..4
            ok 1 - code dies
            ok 2 - right exception type (X::HyperOp::NonDWIM)
            ok 3 - .right-elems matches 5
            ok 4 - .left-elems matches 0
        ok 3850 - non-dwim hyper against empty RHS dies
            1..2
            ok 1 - '3 «.» foo' died
            ok 2 - right exception type (Exception)
        ok 3851 - «.» can't be hypered
        ok 3852 - hyper op works with range on non-magical side (1)
        ok 3853 - hyper op works with range on non-magical side (2)
        ok 3854 - hyper op works with (finite) range on non-magical side (3)
        ok 3855 - Hyper prefix can autogen with &
        ok 3856 - Hyper prefix can autogen without &
        ok 3857 - Hyper >><< can autogen with &
        ok 3858 - Hyper >>>> can autogen with &
        ok 3859 - Hyper <<<< can autogen with &
        ok 3860 - Hyper <<>> can autogen with &
        ok 3861 - Hyper >><< can autogen without &
        ok 3862 - Hyper >>>> can autogen without &
        ok 3863 - Hyper <<<< can autogen without &
        ok 3864 - Hyper <<>> can autogen without &
        ok 3865 - Hyper >><< can autogen with &[]
        ok 3866 - Hyper >>>> can autogen with &[]
        ok 3867 - Hyper <<<< can autogen with &[]
        ok 3868 - Hyper <<>> can autogen with &[]
        ok 3869 - Hyper postfix can autogen with &
        ok 3870 - Hyper postfix can autogen without &
        ok 3871 - union hyperoperator on a hash shouldn't warn about missing keys
            1..20
            ok 1 - ».
            ok 2 - ».""()
            ok 3 - ».&
            ok 4 - ».$
            ok 5 - ».::
            ok 6 - ».?
            ok 7 - ».?""()
            ok 8 - ».?&
            ok 9 - ».?$
            ok 10 - ».?::
            ok 11 - ».+
            ok 12 - ».+""()
            ok 13 - ».+&
            ok 14 - ».+$
            ok 15 - ».+::
            ok 16 - ».*
            ok 17 - ».*""()
            ok 18 - ».*&
            ok 19 - ».*$
            ok 20 - ».*::
        ok 3872 - method call variants respect nodality
            1..8
                1..2
                ok 1 - right result
                ok 2 - producing method name ran only once
            ok 1 - ».""() evaluates given value only once
                1..2
                ok 1 - right result
                ok 2 - producing method name ran only once
            ok 2 - ».?""() evaluates given value only once
                1..2
                ok 1 - right result
                ok 2 - producing method name ran only once
            ok 3 - ».+""() evaluates given value only once
                1..2
                ok 1 - right result
                ok 2 - producing method name ran only once
            ok 4 - ».*""() evaluates given value only once
                1..2
                ok 1 - right result
                ok 2 - sub ran expected number of times
            ok 5 - ».& sub calls
                1..2
                ok 1 - right result
                ok 2 - sub ran expected number of times
            ok 6 - ».?& sub calls
                1..2
                ok 1 - right result
                ok 2 - sub ran expected number of times
            ok 7 - ».+& sub calls
                1..2
                ok 1 - right result
                ok 2 - sub ran expected number of times
            ok 8 - ».*& sub calls
        ok 3873 - hyper method calls string/var method names
        ok 3874 - No crash when RHS to be expanded is an itemized list
        ok 3875 - An array built with a hyperoperator is mutable
        ok 3876 - Hyper on slip values is correct
        ok 3877 - Values created with a hyperoperator can be wrapped in a slip
# FUDGED!
        1..47
        ok 3878 - 4 !< 5
        ok 3879 - 4 !< 5 is Bool
        ok 3880 - 4 !> 5
        ok 3881 - 4 !> 5 is Bool
        ok 3882 - 4 !<= 5
        ok 3883 - 4 !<= 5 is Bool
        ok 3884 - 4 !>= 5
        ok 3885 - 4 !>= 5 is Bool
        ok 3886 - 4 !== 5
        ok 3887 - 4 !== 5 is Bool
        ok 3888 - 'bat' !lt 'ace'
        ok 3889 - 'bat' !lt 'ace' is Bool
        ok 3890 - 'bat' !gt 'ace'
        ok 3891 - 'bat' !gt 'ace' is Bool
        ok 3892 - 'bat' !le 'ace'
        ok 3893 - 'bat' !le 'ace' is Bool
        ok 3894 - 'bat' !ge 'ace'
        ok 3895 - 'bat' !ge 'ace' is Bool
        ok 3896 - 'bat' !eq 'ace'
        ok 3897 - 'bat' !eq 'ace' is Bool
        ok 3898 - 'bat' !before 'ace'
        ok 3899 - 'bat' !before 'ace' is Bool
        ok 3900 - 'bat' !after 'ace'
        ok 3901 - 'bat' !after 'ace' is Bool
        ok 3902 - 4 !=== 5
        ok 3903 - 4 !=== 5 is Bool
        ok 3904 - 4 !eqv 5
        ok 3905 - 4 !eqv 5 is Bool
        ok 3906 - 4 !=:= 5
        ok 3907 - 4 !=:= 5 is Bool
            1..2
            ok 1 - '"a" !!eq "a"' died
            ok 2 - right exception type (X::Syntax::Confused)
        ok 3908 - Doubled prefix:<!> is illegal
        ok 3909 - ![!eq] is legal and works (1)
        ok 3910 - ![!eq] is legal and works (2)
        ok 3911 - !&& is legal and works (1)
        ok 3912 - !&& is legal and works (2)
        ok 3913 - !|| is legal and works (1)
        ok 3914 - !|| is legal and works (2)
        ok 3915 - !^^ is legal and works (1)
        ok 3916 - !^^ is legal and works (2)
            1..2
            ok 1 - '3 !. foo' died
            ok 2 - right exception type (X::Syntax::CannotMeta)
        ok 3917 - !. is too fiddly
            1..2
            ok 1 - '3 !. "foo"' died
            ok 2 - right exception type (X::Obsolete)
        ok 3918 - !. can't do P5 concat
        ok 3919 - Meta not can autogen (!===)
        ok 3920 - Meta not can autogen (!%%)
        ok 3921 - Meta not can autogen (![!%%])
        ok 3922 - Meta not can autogen (!===) without &
        ok 3923 - Meta not can autogen (!===) with &[]
            1..12
            ok 1 - !after/!after (Str)
            ok 2 - !before/!before (Str)
            ok 3 - # SKIP Should this work? https://github.com/rakudo/rakudo/issues/1304
            ok 4 - # SKIP Should this work? https://github.com/rakudo/rakudo/issues/1304
            ok 5 - # SKIP Should this work? https://github.com/rakudo/rakudo/issues/1304
            ok 6 - # SKIP Should this work? https://github.com/rakudo/rakudo/issues/1304
            ok 7 - !after/!after (Int)
            ok 8 - !before/!before (Int)
            ok 9 - # SKIP Should this work? https://github.com/rakudo/rakudo/issues/1304
            ok 10 - # SKIP Should this work? https://github.com/rakudo/rakudo/issues/1304
            ok 11 - # SKIP Should this work? https://github.com/rakudo/rakudo/issues/1304
            ok 12 - # SKIP Should this work? https://github.com/rakudo/rakudo/issues/1304
        ok 3924 - chaining of !before/!after
# FUDGED!
        1..581
        ok 3925 - [+] works
        ok 3926 - [*] works
        ok 3927 - [-] works
        ok 3928 - [/] works
        ok 3929 - [div] works
        ok 3930 - [**] works
        ok 3931 - [%] works
        ok 3932 - [mod] works
        ok 3933 - [\+] works
        ok 3934 - [\-] works
        ok 3935 - [~] works
        ok 3936 - [\~] works
        ok 3937 - [<] works (1)
        ok 3938 - [<] works (2)
        ok 3939 - [>] works (1)
        ok 3940 - [>] works (2)
        ok 3941 - [==] works (1)
        ok 3942 - [==] works (2)
        ok 3943 - [!=] works (1)
        ok 3944 - [!=] works (2)
        ok 3945 - [eq] basic sanity (positive)
        ok 3946 - [eq] basic sanity (negative)
        ok 3947 - [ne] basic sanity (positive)
        ok 3948 - [ne] basic sanity (negative)
        ok 3949 - [lt] basic sanity (positive)
        ok 3950 - [lt] basic sanity (negative)
        ok 3951 - [=:=] basic sanity 1
        ok 3952 - [=:=] basic sanity 2
        ok 3953 - [!=:=] basic sanity (positive)
        ok 3954 - [!=:=] basic sanity (negative)
        ok 3955 - [=:=] after binding
        ok 3956 - [===] with literals
        ok 3957 - [===] with vars (positive)
        ok 3958 - [===] with vars (negative)
        ok 3959 - [!===] basic sanity (positive)
        ok 3960 - [!===] basic sanity (negative)
        ok 3961 - [\<] works (1)
        ok 3962 - [\<] works (2)
        ok 3963 - [\>] works (1)
        ok 3964 - [\>] works (2)
        ok 3965 - [\==] works (1)
        ok 3966 - [\==] works (2)
        ok 3967 - [\!=] works (1)
        ok 3968 - [\!=] works (2)
        ok 3969 - [\**] (right assoc) works (1)
        ok 3970 - [\**] (right assoc) works (2)
        ok 3971 - two nested [\+]
        ok 3972 - [+] does not flatten []-arrays
        ok 3973 - [//] works
        ok 3974 - [orelse] works
        ok 3975 - [||] works
        ok 3976 - [or] works
        ok 3977 - [\||] works
        ok 3978 - [&&] works with 1 false
        ok 3979 - [&&] works
        ok 3980 - [and] works with 1 false
        ok 3981 - [and] works
        ok 3982 - [=>] works (1)
        ok 3983 - [=>] works (2)
        ok 3984 - [=>] works (3)
        ok 3985 - [=>] works on Seq
        not ok 3986 - [,] returns a single Array # TODO item context
        # Failed test '[,] returns a single Array'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-metaops/reduce.rakudo line 161
        # expected: '1'
        #      got: '6'
        ok 3987 - [,] returns something Positional
        ok 3988 - Sanity Check
        ok 3989 - Parse [>>+<<]
        ok 3990 - reduce metaop of hyper metaop works with only one element
        not ok 3991 - reduce metaop of hyper metaop works with zero elements # TODO reduce metaop of hyper metaop works with zero elements
        # Failed test 'reduce metaop of hyper metaop works with zero elements'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-metaops/reduce.rakudo line 176
        # Error: Too few positionals passed; expected 2 arguments but got 0
        ok 3992 - [...] reduce metaop works on user defined ops
        ok 3993 - [*]() returns 1
        ok 3994 - [+]() returns 0
        ok 3995 - [*] 41 returns 41
        ok 3996 - [*] 42 returns 42
        ok 3997 - [*] 42 returns (42)
        ok 3998 - [~] 'towel' returns 'towel'
        ok 3999 - [~] 'washcloth' returns 'washcloth'
        ok 4000 - [~] 'towel' returns 'towel'
        ok 4001 - [~] 'towel' returns something Iterable
        ok 4002 - [<] 42 returns true
        ok 4003 - [<] 42 returns '1'
        ok 4004 - [<] 42 returns something Iterable
        ok 4005 - triangle reduce is lazy
        ok 4006 - triangle reduce knows if it's lazy
        ok 4007 - triangle reduce knows if it's lazy
        ok 4008 - [max]() returns -Inf
        ok 4009 - [min]() returns -Inf
        ok 4010 - [max] Any, Any, 2 returns 2
        ok 4011 - [min] Any, Any, 2 returns 2
        ok 4012 - [^^] works (one of two true)
        ok 4013 - [^^] works (one of two true)
        ok 4014 - [^^] works (two true)
        ok 4015 - [^^] works (two false)
        ok 4016 - [^^] works (three false)
        ok 4017 - [^^] works (three true)
        ok 4018 - [^^] mix 1
        ok 4019 - [^^] mix 2
        ok 4020 - [^^] mix 3
        ok 4021 - [^^] mix 4
        ok 4022 - [^^] mix 5
        ok 4023 - [^^] mix 6
        ok 4024 - reduce empty list ok
        ok 4025 - |0| reduce [^^] false variable test  \#1
        ok 4026 - |0| reduce [^^] false variable test  \#2
        ok 4027 - |0| reduce [^^] false variable test  \#3
        ok 4028 - |0| reduce [^^] false variable test  \#4
        ok 4029 - |0| reduce [^^] false variable test  \#5
        ok 4030 - |0| reduce [^^] false variable test  \#6
        ok 4031 - |0| reduce [^^] false variable test  \#7
        ok 4032 - |0| reduce [^^] false variable test  \#8
        ok 4033 - |0| reduce [^^] false variable test  \#9
        ok 4034 - |0| reduce [^^] false variable test  \#10
        ok 4035 - |0| infix ^^ false variable test  \#1
        ok 4036 - |0| infix ^^ false variable test  \#2
        ok 4037 - |0| infix ^^ false variable test  \#3
        ok 4038 - |0| infix ^^ false variable test  \#4
        ok 4039 - |0| infix ^^ false variable test  \#5
        ok 4040 - |0| infix ^^ false variable test  \#6
        ok 4041 - |0| infix ^^ false variable test  \#7
        ok 4042 - |0| infix ^^ false variable test  \#8
        ok 4043 - |0| infix ^^ false variable test  \#9
        ok 4044 - |""| reduce [^^] false variable test  \#1
        ok 4045 - |""| reduce [^^] false variable test  \#2
        ok 4046 - |""| reduce [^^] false variable test  \#3
        ok 4047 - |""| reduce [^^] false variable test  \#4
        ok 4048 - |""| reduce [^^] false variable test  \#5
        ok 4049 - |""| reduce [^^] false variable test  \#6
        ok 4050 - |""| reduce [^^] false variable test  \#7
        ok 4051 - |""| reduce [^^] false variable test  \#8
        ok 4052 - |""| reduce [^^] false variable test  \#9
        ok 4053 - |""| reduce [^^] false variable test  \#10
        ok 4054 - |""| infix ^^ false variable test  \#1
        ok 4055 - |""| infix ^^ false variable test  \#2
        ok 4056 - |""| infix ^^ false variable test  \#3
        ok 4057 - |""| infix ^^ false variable test  \#4
        ok 4058 - |""| infix ^^ false variable test  \#5
        ok 4059 - |""| infix ^^ false variable test  \#6
        ok 4060 - |""| infix ^^ false variable test  \#7
        ok 4061 - |""| infix ^^ false variable test  \#8
        ok 4062 - |""| infix ^^ false variable test  \#9
        ok 4063 - |Bool::False| reduce [^^] false variable test  \#1
        ok 4064 - |Bool::False| reduce [^^] false variable test  \#2
        ok 4065 - |Bool::False| reduce [^^] false variable test  \#3
        ok 4066 - |Bool::False| reduce [^^] false variable test  \#4
        ok 4067 - |Bool::False| reduce [^^] false variable test  \#5
        ok 4068 - |Bool::False| reduce [^^] false variable test  \#6
        ok 4069 - |Bool::False| reduce [^^] false variable test  \#7
        ok 4070 - |Bool::False| reduce [^^] false variable test  \#8
        ok 4071 - |Bool::False| reduce [^^] false variable test  \#9
        ok 4072 - |Bool::False| reduce [^^] false variable test  \#10
        ok 4073 - |Bool::False| infix ^^ false variable test  \#1
        ok 4074 - |Bool::False| infix ^^ false variable test  \#2
        ok 4075 - |Bool::False| infix ^^ false variable test  \#3
        ok 4076 - |Bool::False| infix ^^ false variable test  \#4
        ok 4077 - |Bool::False| infix ^^ false variable test  \#5
        ok 4078 - |Bool::False| infix ^^ false variable test  \#6
        ok 4079 - |Bool::False| infix ^^ false variable test  \#7
        ok 4080 - |Bool::False| infix ^^ false variable test  \#8
        ok 4081 - |Bool::False| infix ^^ false variable test  \#9
        ok 4082 - |Any| reduce [^^] false variable test  \#1
        ok 4083 - |Any| reduce [^^] false variable test  \#2
        ok 4084 - |Any| reduce [^^] false variable test  \#3
        ok 4085 - |Any| reduce [^^] false variable test  \#4
        ok 4086 - |Any| reduce [^^] false variable test  \#5
        ok 4087 - |Any| reduce [^^] false variable test  \#6
        ok 4088 - |Any| reduce [^^] false variable test  \#7
        ok 4089 - |Any| reduce [^^] false variable test  \#8
        ok 4090 - |Any| reduce [^^] false variable test  \#9
        ok 4091 - |Any| reduce [^^] false variable test  \#10
        ok 4092 - |Any| infix ^^ false variable test  \#1
        ok 4093 - |Any| infix ^^ false variable test  \#2
        ok 4094 - |Any| infix ^^ false variable test  \#3
        ok 4095 - |Any| infix ^^ false variable test  \#4
        ok 4096 - |Any| infix ^^ false variable test  \#5
        ok 4097 - |Any| infix ^^ false variable test  \#6
        ok 4098 - |Any| infix ^^ false variable test  \#7
        ok 4099 - |Any| infix ^^ false variable test  \#8
        ok 4100 - |Any| infix ^^ false variable test  \#9
        ok 4101 - |Mu| reduce [^^] false variable test  \#1
        ok 4102 - |Mu| reduce [^^] false variable test  \#2
        ok 4103 - |Mu| reduce [^^] false variable test  \#3
        ok 4104 - |Mu| reduce [^^] false variable test  \#4
        ok 4105 - |Mu| reduce [^^] false variable test  \#5
        ok 4106 - |Mu| reduce [^^] false variable test  \#6
        ok 4107 - |Mu| reduce [^^] false variable test  \#7
        ok 4108 - |Mu| reduce [^^] false variable test  \#8
        ok 4109 - |Mu| reduce [^^] false variable test  \#9
        ok 4110 - |Mu| reduce [^^] false variable test  \#10
        ok 4111 - |Mu| infix ^^ false variable test  \#1
        ok 4112 - |Mu| infix ^^ false variable test  \#2
        ok 4113 - |Mu| infix ^^ false variable test  \#3
        ok 4114 - |Mu| infix ^^ false variable test  \#4
        ok 4115 - |Mu| infix ^^ false variable test  \#5
        ok 4116 - |Mu| infix ^^ false variable test  \#6
        ok 4117 - |Mu| infix ^^ false variable test  \#7
        ok 4118 - |Mu| infix ^^ false variable test  \#8
        ok 4119 - |Mu| infix ^^ false variable test  \#9
        ok 4120 - |Nil| reduce [^^] false variable test  \#1
        ok 4121 - |Nil| reduce [^^] false variable test  \#2
        ok 4122 - |Nil| reduce [^^] false variable test  \#3
        ok 4123 - |Nil| reduce [^^] false variable test  \#4
        ok 4124 - |Nil| reduce [^^] false variable test  \#5
        ok 4125 - |Nil| reduce [^^] false variable test  \#6
        ok 4126 - |Nil| reduce [^^] false variable test  \#7
        ok 4127 - |Nil| reduce [^^] false variable test  \#8
        ok 4128 - |Nil| reduce [^^] false variable test  \#9
        ok 4129 - |Nil| reduce [^^] false variable test  \#10
        ok 4130 - |Nil| infix ^^ false variable test  \#1
        ok 4131 - |Nil| infix ^^ false variable test  \#2
        ok 4132 - |Nil| infix ^^ false variable test  \#3
        ok 4133 - |Nil| infix ^^ false variable test  \#4
        ok 4134 - |Nil| infix ^^ false variable test  \#5
        ok 4135 - |Nil| infix ^^ false variable test  \#6
        ok 4136 - |Nil| infix ^^ false variable test  \#7
        ok 4137 - |Nil| infix ^^ false variable test  \#8
        ok 4138 - |Nil| infix ^^ false variable test  \#9
        ok 4139 - |1| reduce [^^] true numbery variable test  \#1
        ok 4140 - |1| reduce [^^] true numbery variable test  \#2
        ok 4141 - |1| reduce [^^] true numbery variable test  \#3
        ok 4142 - |1| reduce [^^] true numbery variable test  \#4
        ok 4143 - |1| reduce [^^] true numbery variable test  \#5
        ok 4144 - |1| reduce [^^] true numbery variable test  \#6
        ok 4145 - |1| reduce [^^] true numbery variable test  \#7
        ok 4146 - |1| reduce [^^] true numbery variable test  \#8
        ok 4147 - |1| reduce [^^] true numbery variable test  \#9
        ok 4148 - |1| infix ^^ true numbery variable test  \#1
        ok 4149 - |1| infix ^^ true numbery variable test  \#2
        ok 4150 - |1| infix ^^ true numbery variable test  \#3
        ok 4151 - |1| infix ^^ true numbery variable test  \#4
        ok 4152 - |1| infix ^^ true numbery variable test  \#5
        ok 4153 - |1| infix ^^ true numbery variable test  \#6
        ok 4154 - |1| infix ^^ true numbery variable test  \#7
        ok 4155 - |1| infix ^^ true numbery variable test  \#8
        ok 4156 - |-147| reduce [^^] true numbery variable test  \#1
        ok 4157 - |-147| reduce [^^] true numbery variable test  \#2
        ok 4158 - |-147| reduce [^^] true numbery variable test  \#3
        ok 4159 - |-147| reduce [^^] true numbery variable test  \#4
        ok 4160 - |-147| reduce [^^] true numbery variable test  \#5
        ok 4161 - |-147| reduce [^^] true numbery variable test  \#6
        ok 4162 - |-147| reduce [^^] true numbery variable test  \#7
        ok 4163 - |-147| reduce [^^] true numbery variable test  \#8
        ok 4164 - |-147| reduce [^^] true numbery variable test  \#9
        ok 4165 - |-147| infix ^^ true numbery variable test  \#1
        ok 4166 - |-147| infix ^^ true numbery variable test  \#2
        ok 4167 - |-147| infix ^^ true numbery variable test  \#3
        ok 4168 - |-147| infix ^^ true numbery variable test  \#4
        ok 4169 - |-147| infix ^^ true numbery variable test  \#5
        ok 4170 - |-147| infix ^^ true numbery variable test  \#6
        ok 4171 - |-147| infix ^^ true numbery variable test  \#7
        ok 4172 - |-147| infix ^^ true numbery variable test  \#8
        ok 4173 - |3.141592653589793e0| reduce [^^] true numbery variable test  \#1
        ok 4174 - |3.141592653589793e0| reduce [^^] true numbery variable test  \#2
        ok 4175 - |3.141592653589793e0| reduce [^^] true numbery variable test  \#3
        ok 4176 - |3.141592653589793e0| reduce [^^] true numbery variable test  \#4
        ok 4177 - |3.141592653589793e0| reduce [^^] true numbery variable test  \#5
        ok 4178 - |3.141592653589793e0| reduce [^^] true numbery variable test  \#6
        ok 4179 - |3.141592653589793e0| reduce [^^] true numbery variable test  \#7
        ok 4180 - |3.141592653589793e0| reduce [^^] true numbery variable test  \#8
        ok 4181 - |3.141592653589793e0| reduce [^^] true numbery variable test  \#9
        ok 4182 - |3.141592653589793e0| infix ^^ true numbery variable test  \#1
        ok 4183 - |3.141592653589793e0| infix ^^ true numbery variable test  \#2
        ok 4184 - |3.141592653589793e0| infix ^^ true numbery variable test  \#3
        ok 4185 - |3.141592653589793e0| infix ^^ true numbery variable test  \#4
        ok 4186 - |3.141592653589793e0| infix ^^ true numbery variable test  \#5
        ok 4187 - |3.141592653589793e0| infix ^^ true numbery variable test  \#6
        ok 4188 - |3.141592653589793e0| infix ^^ true numbery variable test  \#7
        ok 4189 - |3.141592653589793e0| infix ^^ true numbery variable test  \#8
        ok 4190 - |Bool::True| reduce [^^] true numbery variable test  \#1
        ok 4191 - |Bool::True| reduce [^^] true numbery variable test  \#2
        ok 4192 - |Bool::True| reduce [^^] true numbery variable test  \#3
        ok 4193 - |Bool::True| reduce [^^] true numbery variable test  \#4
        ok 4194 - |Bool::True| reduce [^^] true numbery variable test  \#5
        ok 4195 - |Bool::True| reduce [^^] true numbery variable test  \#6
        ok 4196 - |Bool::True| reduce [^^] true numbery variable test  \#7
        ok 4197 - |Bool::True| reduce [^^] true numbery variable test  \#8
        ok 4198 - |Bool::True| reduce [^^] true numbery variable test  \#9
        ok 4199 - |Bool::True| infix ^^ true numbery variable test  \#1
        ok 4200 - |Bool::True| infix ^^ true numbery variable test  \#2
        ok 4201 - |Bool::True| infix ^^ true numbery variable test  \#3
        ok 4202 - |Bool::True| infix ^^ true numbery variable test  \#4
        ok 4203 - |Bool::True| infix ^^ true numbery variable test  \#5
        ok 4204 - |Bool::True| infix ^^ true numbery variable test  \#6
        ok 4205 - |Bool::True| infix ^^ true numbery variable test  \#7
        ok 4206 - |Bool::True| infix ^^ true numbery variable test  \#8
        ok 4207 - |"no"| reduce [^^] true string variable test  \#1
        ok 4208 - |"no"| reduce [^^] true string variable test  \#2
        ok 4209 - |"no"| reduce [^^] true string variable test  \#3
        ok 4210 - |"no"| reduce [^^] true string variable test  \#4
        ok 4211 - |"no"| reduce [^^] true string variable test  \#5
        ok 4212 - |"no"| reduce [^^] true string variable test  \#6
        ok 4213 - |"no"| reduce [^^] true string variable test  \#7
        ok 4214 - |"no"| reduce [^^] true string variable test  \#8
        ok 4215 - |"no"| reduce [^^] true string variable test  \#9
        ok 4216 - |"no"| reduce [^^] true string variable test  \#10
        ok 4217 - |"no"| infix ^^ true string variable test  \#1
        ok 4218 - |"no"| infix ^^ true string variable test  \#2
        ok 4219 - |"no"| infix ^^ true string variable test  \#3
        ok 4220 - |"no"| infix ^^ true string variable test  \#4
        ok 4221 - |"no"| infix ^^ true string variable test  \#5
        ok 4222 - |"no"| infix ^^ true string variable test  \#6
        ok 4223 - |"no"| infix ^^ true string variable test  \#7
        ok 4224 - |"no"| infix ^^ true string variable test  \#8
        ok 4225 - |"no"| infix ^^ true string variable test  \#9
        ok 4226 - |"Bob"| reduce [^^] true string variable test  \#1
        ok 4227 - |"Bob"| reduce [^^] true string variable test  \#2
        ok 4228 - |"Bob"| reduce [^^] true string variable test  \#3
        ok 4229 - |"Bob"| reduce [^^] true string variable test  \#4
        ok 4230 - |"Bob"| reduce [^^] true string variable test  \#5
        ok 4231 - |"Bob"| reduce [^^] true string variable test  \#6
        ok 4232 - |"Bob"| reduce [^^] true string variable test  \#7
        ok 4233 - |"Bob"| reduce [^^] true string variable test  \#8
        ok 4234 - |"Bob"| reduce [^^] true string variable test  \#9
        ok 4235 - |"Bob"| reduce [^^] true string variable test  \#10
        ok 4236 - |"Bob"| infix ^^ true string variable test  \#1
        ok 4237 - |"Bob"| infix ^^ true string variable test  \#2
        ok 4238 - |"Bob"| infix ^^ true string variable test  \#3
        ok 4239 - |"Bob"| infix ^^ true string variable test  \#4
        ok 4240 - |"Bob"| infix ^^ true string variable test  \#5
        ok 4241 - |"Bob"| infix ^^ true string variable test  \#6
        ok 4242 - |"Bob"| infix ^^ true string variable test  \#7
        ok 4243 - |"Bob"| infix ^^ true string variable test  \#8
        ok 4244 - |"Bob"| infix ^^ true string variable test  \#9
        ok 4245 - |"10"| reduce [^^] true string variable test  \#1
        ok 4246 - |"10"| reduce [^^] true string variable test  \#2
        ok 4247 - |"10"| reduce [^^] true string variable test  \#3
        ok 4248 - |"10"| reduce [^^] true string variable test  \#4
        ok 4249 - |"10"| reduce [^^] true string variable test  \#5
        ok 4250 - |"10"| reduce [^^] true string variable test  \#6
        ok 4251 - |"10"| reduce [^^] true string variable test  \#7
        ok 4252 - |"10"| reduce [^^] true string variable test  \#8
        ok 4253 - |"10"| reduce [^^] true string variable test  \#9
        ok 4254 - |"10"| reduce [^^] true string variable test  \#10
        ok 4255 - |"10"| infix ^^ true string variable test  \#1
        ok 4256 - |"10"| infix ^^ true string variable test  \#2
        ok 4257 - |"10"| infix ^^ true string variable test  \#3
        ok 4258 - |"10"| infix ^^ true string variable test  \#4
        ok 4259 - |"10"| infix ^^ true string variable test  \#5
        ok 4260 - |"10"| infix ^^ true string variable test  \#6
        ok 4261 - |"10"| infix ^^ true string variable test  \#7
        ok 4262 - |"10"| infix ^^ true string variable test  \#8
        ok 4263 - |"10"| infix ^^ true string variable test  \#9
        ok 4264 - |"False"| reduce [^^] true string variable test  \#1
        ok 4265 - |"False"| reduce [^^] true string variable test  \#2
        ok 4266 - |"False"| reduce [^^] true string variable test  \#3
        ok 4267 - |"False"| reduce [^^] true string variable test  \#4
        ok 4268 - |"False"| reduce [^^] true string variable test  \#5
        ok 4269 - |"False"| reduce [^^] true string variable test  \#6
        ok 4270 - |"False"| reduce [^^] true string variable test  \#7
        ok 4271 - |"False"| reduce [^^] true string variable test  \#8
        ok 4272 - |"False"| reduce [^^] true string variable test  \#9
        ok 4273 - |"False"| reduce [^^] true string variable test  \#10
        ok 4274 - |"False"| infix ^^ true string variable test  \#1
        ok 4275 - |"False"| infix ^^ true string variable test  \#2
        ok 4276 - |"False"| infix ^^ true string variable test  \#3
        ok 4277 - |"False"| infix ^^ true string variable test  \#4
        ok 4278 - |"False"| infix ^^ true string variable test  \#5
        ok 4279 - |"False"| infix ^^ true string variable test  \#6
        ok 4280 - |"False"| infix ^^ true string variable test  \#7
        ok 4281 - |"False"| infix ^^ true string variable test  \#8
        ok 4282 - |"False"| infix ^^ true string variable test  \#9
        ok 4283 - [\^^]
        ok 4284 - [\xor]
Use of uninitialized value element of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-metaops/reduce.rakudo line 332
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-metaops/reduce.rakudo line 332
        ok 4285 - [\orelse]
Use of uninitialized value element of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-metaops/reduce.rakudo line 335
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-metaops/reduce.rakudo line 335
        ok 4286 - [\orelse]
        ok 4287 - [~] works in first class
        ok 4288 - [~] works in second class
        ok 4289 - [~] works outside class
        ok 4290 - a listop with immediate () is a function call (RT  \#82210)
        ok 4291 - [+] is a normal listop
        ok 4292 - argumentless [+] parses
        ok 4293 - RT  \#99942
        ok 4294 - reduce with X
            1..2
            ok 1 - '[leg] <a b c>' died
            ok 2 - right exception type (X::Syntax::CannotMeta)
        ok 4295 - non-associative operator "[leg]" can not be used as reduction operator
        ok 4296 - does  [:a] parse ok and give the right value
        ok 4297 - does [:a,] parse ok and give the right value
        ok 4298 - does [:!a] parse ok and give the right value
assign requires a concrete object (got a Rakudo::Internals::LoweredAwayLexical type object instead)
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-metaops/reduce.rakudo line 391
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-metaops/reduce.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

        1..42
        ok 4299 - user-defined prefix operator, long name
        ok 4300 - user-defined prefix operator, long name, optional parameter
        ok 4301 - user-defined prefix operator, long name, :times adverb, leading
        ok 4302 - user-defined prefix operator, long name, :times adverb, trailing
        ok 4303 - user-defined prefix operator, basic call
        ok 4304 - user-defined prefix operator, :times adverb, space
        ok 4305 - user-defined prefix operator, :times adverb, no space
        ok 4306 - :foo($bar)
        ok 4307 - :foo[1,2,3,@many]
        ok 4308 - :foo«alice bob charles»
        ok 4309 - :foo«alice»
        ok 4310 - :foo{ a => 1, b => 2 }
Block object coerced to string (please use .gist or .raku to do that)
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/adverbial-modifiers.rakudo line 48
Block object coerced to string (please use .gist or .raku to do that)
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/adverbial-modifiers.rakudo line 48
        ok 4311 - :foo{ dostuff() }
        ok 4312 - :foo(0)
        ok 4313 - :foo
        ok 4314 - fiddle(:x("a"):y("b"))
        ok 4315 - fiddle(:y("b"):x("a"))
        ok 4316 - fiddle(:x:y("b"))
        ok 4317 - fiddle(:x("a"):y)
        ok 4318 - fiddle(:x("a")):y("b")
        ok 4319 - fiddle(:y("b")):x("a")
        ok 4320 - fiddle(:x("a")):y("b")
        ok 4321 - fiddle(:x("a")):y
        ok 4322 - fiddle(:x):y
        ok 4323 - fiddle():x("a"):y("b")
        ok 4324 - fiddle():y("b"):x("a")
        ok 4325 - fiddle():x:y("b")
        ok 4326 - fiddle():x("a"):y
        ok 4327 - fiddle():x:y
        ok 4328 - f(:x("a") "b")
        ok 4329 - f(:x("a")"b")
        ok 4330 - f("b" :x("a"))
        ok 4331 - f("b":x("a"))
        ok 4332 - f(:x "b")
        ok 4333 - f("b" :x)
        ok 4334 - f("b"):x("a")
Use of uninitialized value element of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in sub f1 at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/adverbial-modifiers.rakudo line 171
        not ok 4335 - f1(\:bar :x("b")) # TODO Multi colonpair syntax not yet understood
        # Failed test 'f1(\:bar :x("b"))'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/adverbial-modifiers.rakudo line 172
        # expected: '("bar" => Bool::True)b'
        #      got: '\(:bar, :x("b"))'
        ok 4336 - f2((:bar))
        ok 4337 - f3((:bar),(:hee(3)))
        ok 4338 - (zpre 4 :x(5))
        ok 4339 - (4 zpost :x(5))
        ok 4340 - (3 zin 4 :x(5))
# FUDGED!
        1..8
        ok 4341 - basic infix:<S&>
        ok 4342 - basic infix:<S&> (multiple S&'s)
        not ok 4343 - S& has and-semantics (first term 0) # TODO S metaop NYI
        # Failed test 'S& has and-semantics (first term 0)'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/also.rakudo line 11
        not ok 4344 - also has and-semantics (second term 0) # TODO S metaop NYI
        # Failed test 'also has and-semantics (second term 0)'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/also.rakudo line 14
        ok 4345 - S& with two blocks
        not ok 4346 - blocks called in the right order # TODO S metaop NYI
        # Failed test 'blocks called in the right order'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/also.rakudo line 21
        # expected: 'bc'
        #      got: ''
        not ok 4347 - and semantics # TODO S metaop NYI
        # Failed test 'and semantics'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/also.rakudo line 27
        ok 4348 - short-circuit
# FUDGED!
WARNINGS for /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/assign.rakudo:
Useless use of constant integer 4 in sink context (lines 555, 555)
Useless use of constant integer 2 in sink context (lines 875, 875)
Useless use of constant integer 3 in sink context (lines 555, 555, 875, 875)
        1..301
        ok 4349 - assigned correct value to first of two scalars
        ok 4350 - ... and second
        ok 4351 - swap assignment works for the first value
        ok 4352 - ... and second
        ok 4353 - assignment operator called as function
        ok 4354 - assignment as function with types (1)
        ok 4355 - assignment as function with types (2)
        ok 4356 - assignment operator called as function
        ok 4357 - slice assignment swapping two element in the same array
        ok 4358 - slice assignment swapping two element in the same array
        ok 4359 - slice assignment swapping with array dwim
        ok 4360 - slice assignment swapping with array dwim
        ok 4361 - slice assignment swapping with array dwim makes listop
        ok 4362 - list assignment my ($, $, $) = @ works
        ok 4363 - list assignment my ($, $, $) = @ works
        ok 4364 - list assignment my ($, $, $) = @ works
        ok 4365 - list assignment my ($a, $, $b) = @ works
        ok 4366 - list assignment my ($, $a) = @ works
        ok 4367 - list assignment my ($, $, $, $a) = @ works
        ok 4368 - list assignment my ($, @) = @ works
        ok 4369 - list assignment my ($, @, $c) = @ works
        ok 4370 - list assignment ($a, *, $b) = @ works
        ok 4371 - list assignment (*, $a, *) = @ works
        ok 4372 - list assignment (*, *, *, $a) = @ works
        ok 4373 - list assignment (*, @) = @ works
        ok 4374 - list assignment (*, @, $c) = @ works
        ok 4375 - list assignment ($a, $, $b) = @ works
        ok 4376 - signature binding my ($one, *@) = 1..4 works
        ok 4377 - signature binding my ($a, $b, *@) = 1..4 works
        ok 4378 - signature binding my ($c, $d, *@) = 1..2 works
        ok 4379 - '$a' is '1'?: ($,$,$) = 1 .. 3
        ok 4380 - '$b' is '2'?: ($,$,$) = 1 .. 3
        ok 4381 - '$c' is '3'?: ($,$,$) = 1 .. 3
        ok 4382 - '@a' is '1 2 3'?:        @a = 1 .. 3
        ok 4383 - $s is '1'?:    my ($s,@a) = 1 .. 3
        ok 4384 - '@b' is '2 3'?: my ($s,@a) = 1 .. 3
        ok 4385 - got scalar in (scalar,hash) = list
        ok 4386 - got hash in (scalar,hash) = list
        ok 4387 - assigned correct value from list to sliced array
        ok 4388 - ... and second
        ok 4389 - ... and third
        ok 4390 - won't modify unassigned one
        ok 4391 - assigned correct value from list to unsorted sliced array
        ok 4392 - ... and second
        ok 4393 - ... and third
        ok 4394 - assigned correct value from list to slice-in-list
        ok 4395 - ... and second
        ok 4396 - ... and third
        ok 4397 - ... and fourth
        ok 4398 - ... and fifth
        ok 4399 - won't modify unassigned one
        ok 4400 - chained @ = % = list assignment
        ok 4401 - chained @ = % = list assignment
        ok 4402 - chained $ = % = list assignment
        ok 4403 - chained $ = % = list assignment
        ok 4404 - (@b, @a) = (@a, @b) assignment \@a[0] == undefined
        ok 4405 - (@b, @a) = (@a, @b) assignment \@b[0]
        ok 4406 - (@b, @a) = (@a, @b) assignment \@b[1]
        ok 4407 - (@b, @a) = @a, @b assignment \@a[0] == undefined
        ok 4408 - (@b, @a) = @a, @b assignment \@b[0]
        ok 4409 - (@b, @a) = @a, @b assignment \@b[1]
        ok 4410 - ||= operator
        ok 4411 - ||= operator parses as item assignment 1
        ok 4412 - ||= operator parses as item assignment 2
        ok 4413 - ... and second
        ok 4414 - ||= operator parses as item assignment 3
        ok 4415 - ||= operator parses as item assignment 4
        ok 4416 - or= operator
        ok 4417 - or= operator parses as list assignment 1
        ok 4418 - or= operator parses as list assignment 2
        ok 4419 - ... and second
        ok 4420 - or= operator parses as list assignment 3
        ok 4421 - or= operator parses as list assignment 4
        ok 4422 - or= thunks RHS
        ok 4423 - //= operator
        ok 4424 - //= operator parses as item assignment 1
        ok 4425 - //= operator parses as item assignment 2
        ok 4426 - ... and second
        ok 4427 - //= operator parses as item assignment 3
        ok 4428 - //= operator parses as item assignment 4
        ok 4429 - Verify //= autovivifies correctly
        ok 4430 - Verify //= autovivifies correctly
        ok 4431 - //= also works in declaration
        ok 4432 - orelse= operator
        ok 4433 - orelse= operator parses as list assignment 1
        ok 4434 - orelse= operator parses as list assignment 2
        ok 4435 - ... and second
        ok 4436 - orelse= operator parses as list assignment 3
        ok 4437 - orelse= operator parses as list assignment 4
        ok 4438 - Verify orelse= autovivifies correctly
        ok 4439 - Verify orelse= autovivifies correctly
        ok 4440 - orelse= also works in declaration
        ok 4441 - &&= operator
        ok 4442 - &&= operator parses as item assignment 1
        ok 4443 - &&= operator parses as item assignment 2
        ok 4444 - ... and second
        ok 4445 - &&= operator parses as item assignment 3
        ok 4446 - &&= operator parses as item assignment 4
        ok 4447 - &&= operator with True and False
        ok 4448 - and= operator
        ok 4449 - and= operator parses as list assignment 1
        ok 4450 - and= operator parses as list assignment 2
        ok 4451 - ... and second
        ok 4452 - and= operator parses as list assignment 3
        ok 4453 - and= operator parses as list assignment 4
        ok 4454 - and= operator with True and False
        ok 4455 - and= thunks RHS
        ok 4456 - (($c = 3) = 4) return val should be good as an lval
        ok 4457 - += operator
        ok 4458 - += operator parses as item assignment 1
        ok 4459 - += operator parses as item assignment 2
        ok 4460 - -= operator
        ok 4461 - -= operator parses as item assignment 1
        ok 4462 - -= operator parses as item assignment 2
        ok 4463 - *= operator
        ok 4464 - *= operator parses as item assignment 1
        ok 4465 - *= operator parses as item assignment 2
        ok 4466 - div= operator
        ok 4467 - div= operator parses as item assignment 1
        ok 4468 - div= operator parses as item assignment 2
        ok 4469 - **= operator
        ok 4470 - **= operator parses as item assignment 1
        ok 4471 - **= operator parses as item assignment 2
        ok 4472 - ~= operator
        ok 4473 - ~= operator parses as item assignment 1
        ok 4474 - ~= operator parses as item assignment 2
            1..2
            ok 1 - 'my $foo = 'foo'; $foo R~= 'foo';' died
            ok 2 - right exception type (X::Assignment::RO)
        ok 4475 - use of R~= operator on a non-container dies
        ok 4476 - R~= operator works
        ok 4477 - use of += on a Failure will trigger the failure to be thrown
        ok 4478 - x= operator
        ok 4479 - x= operator parses as item assignment 1
        ok 4480 - x= operator parses as item assignment 2
        ok 4481 - +&= operator
        ok 4482 - +&= operator parses as item assignment 1
        ok 4483 - +&= operator parses as item assignment 2
        ok 4484 - +|= operator
        ok 4485 - +|= operator parses as item assignment 1
        ok 4486 - +|= operator parses as item assignment 2
        ok 4487 - ~&= operator
        ok 4488 - ~&= operator parses as item assignment 1
        ok 4489 - ~&= operator parses as item assignment 2
        ok 4490 - ~|= operator
        ok 4491 - ~|= operator parses as item assignment 1
        ok 4492 - ~|= operator parses as item assignment 2
        ok 4493 - %= operator
        ok 4494 - %= operator parses as item assignment 1
        ok 4495 - %= operator parses as item assignment 2
        ok 4496 - +^= operator
        ok 4497 - +^= operator parses as item assignment 1
        ok 4498 - +^= operator parses as item assignment 2
        ok 4499 - ~^= operator
        ok 4500 - ~^= operator parses as item assignment 1
        ok 4501 - ~^= operator parses as item assignment 2
        ok 4502 - ^^= operator
        ok 4503 - ^^= operator parses as item assignment 1
        ok 4504 - ^^= operator parses as item assignment 2
        ok 4505 - ^^= with two true arguments yields Nil -> Any
        ok 4506 - ^^= doesn't permanently falsify scalars
        ok 4507 - xor= operator
        ok 4508 - xor= operator parses as list assignment 1
        ok 4509 - xor= operator parses as list assignment 2
        ok 4510 - xor= with two true arguments yields Nil -> Any
        ok 4511 - xor= doesn't permanently falsify scalars
        ok 4512 - ?|= operator
        ok 4513 - ?|= operator parses as item assignment 1
        ok 4514 - ?|= operator parses as item assignment 2
        ok 4515 - ?&= operator
        ok 4516 - ?&= operator parses as item assignment 1
        ok 4517 - ?&= operator parses as item assignment 2
        ok 4518 - ?^= operator
        ok 4519 - ?^= operator parses as item assignment 1
        ok 4520 - ?^= operator parses as item assignment 2
        ok 4521 - +<= operator
        ok 4522 - +<= operator parses as item assignment 1
        ok 4523 - +<= operator parses as item assignment 2
        ok 4524 - +>= operator
        ok 4525 - +>= operator parses as item assignment 1
        ok 4526 - +>= operator parses as item assignment 2
        ok 4527 - # SKIP ~< and ~> NYI
        ok 4528 - # SKIP ~< and ~> NYI
        ok 4529 - # SKIP ~< and ~> NYI
        ok 4530 - # SKIP ~< and ~> NYI
        ok 4531 - # SKIP ~< and ~> NYI
        ok 4532 - # SKIP ~< and ~> NYI
        ok 4533 - [+]= operator (just like +=)
        ok 4534 - [+]= operator parses as item assignment 1
        ok 4535 - [+]= operator parses as item assignment 2
        ok 4536 - [[+]]= operator (just like +=)
        ok 4537 - [[+]]= operator parses as item assignment 1
        ok 4538 - [[+]]= operator parses as item assignment 2
        ok 4539 - item assignment infix:<=> is tighter than the comma
        ok 4540 - item assignment infix:<=> is tighter than the comma (2)
        ok 4541 - item assignment infix:<=> is tighter than the comma (3)
        ok 4542 - lhs treats $::('Foo::b') as scalar (1)
        ok 4543 - lhs treats $::('Foo::b') as scalar (2)
        ok 4544 - lhs treats $Foo::c as scalar (1)
        ok 4545 - lhs treats $Foo::c as scalar (2)
        ok 4546 - lhs treats $(@a[0]) as scalar (1)
        ok 4547 - lhs treats $(@a[0]) as scalar (2)
        ok 4548 - lhs treats ($a) as list
        not ok 4549 - lhs treats ($a) as list # TODO item/list assignment
        # Failed test 'lhs treats ($a) as list'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/assign.rakudo line 593
        # expected: '3'
        #      got: '1'
        ok 4550 - lhs treats ($a, *) as list (1)
        not ok 4551 - lhs treats ($a, *) as list (2) # TODO list assignment with ($var, *)
        # Failed test 'lhs treats ($a, *) as list (2)'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/assign.rakudo line 601
        # expected: '6'
        #      got: '2'
        ok 4552 - # SKIP cannot modify an immutable value
        ok 4553 - # SKIP cannot modify an immutable value
        ok 4554 - # SKIP cannot modify an immutable value
        ok 4555 - lhs treats ($a,$b) as list
        ok 4556 - lhs treats ($a,$b) as list
        ok 4557 - lhs treats ($a,$b) as list, and passes only two items on
        not ok 4558 - lhs treats @a[0] as one-item list # TODO list assignment to scalar
        # Failed test 'lhs treats @a[0] as one-item list'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/assign.rakudo line 632
        # expected: '1'
        #      got: '2'
        ok 4559 - lhs treats @a[0] as one-item list
        ok 4560 - lhs treats @a[0] as one-item list
        ok 4561 - lhs treats @a[0,] as one-item list
        ok 4562 - lhs treats @a[0,] as one-item list
        ok 4563 - lhs treats @a[0,] as one-item list
        not ok 4564 - lhs treats %a<x> as one-item list # TODO list assignment to scalar
        # Failed test 'lhs treats %a<x> as one-item list'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/assign.rakudo line 649
        # expected: '1'
        #      got: '2'
        not ok 4565 - lhs treats %a<x> as one-item list # TODO list assignment to scalar
        # Failed test 'lhs treats %a<x> as one-item list'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/assign.rakudo line 650
        # expected: '1'
        #      got: '2'
        ok 4566 - lhs treats %a<x> as one-item list
        ok 4567 - lhs treats %a<x y z> as list
        ok 4568 - lhs treats %a<x y z> as list
        ok 4569 - lhs treats %a<x y z> as list
        not ok 4570 - lhs treats %a{'x'} as list # TODO list assignment to scalar
        # Failed test 'lhs treats %a{'x'} as list'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/assign.rakudo line 666
        # expected: '1'
        #      got: '1 2 1 2'
        not ok 4571 - lhs treats %a{'x'} as list # TODO list assignment to scalar
        # Failed test 'lhs treats %a{'x'} as list'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/assign.rakudo line 667
        # expected: '1'
        #      got: '1 2 1 2'
        ok 4572 - lhs treats %a{'x'} as list
        ok 4573 - lhs treats %a{'x','y','z'} as list
        ok 4574 - lhs treats %a{'x','y','z'} as list
        ok 4575 - lhs treats %a{'x','y','z'} as list
        ok 4576 - lhs treats %a{'x','y','z'} as list
        ok 4577 - lhs treats %a{'x','y','z'} as list
        ok 4578 - lhs treats %a{'x','y','z'} as list
        ok 4579 - lhs treats %a{'x'..'z'} as list
        ok 4580 - lhs treats %a{'x'..'z'} as list
        ok 4581 - lhs treats %a{'x'..'z'} as list
        ok 4582 - lhs treats %a{'x'..'z'} as list
        ok 4583 - lhs treats %a{'x'..'z'} as list
        ok 4584 - lhs treats %a{'x'..'z'} as list
        not ok 4585 - lhs treats @a[@b[$c]] as list # TODO list assignment, autovivification (?)
        # Failed test 'lhs treats @a[@b[$c]] as list'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/assign.rakudo line 700
        # expected: '1'
        #      got: '1 2 1 2'
        not ok 4586 - lhs treats @a[@b[$c]] as list # TODO list assignment, autovivification (?)
        # Failed test 'lhs treats @a[@b[$c]] as list'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/assign.rakudo line 701
        # expected: '1'
        #      got: '1 2 1 2'
        not ok 4587 -  # TODO list assignment, autovivification (?)
        # Failed test at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/assign.rakudo line 702
        # expected: 'lhs treats @a[@b[$c]] as list'
        #      got: 'True'
        ok 4588 - lhs treats @a[@b[$c,]] as list
        not ok 4589 - lhs treats @a[@b[$c,]] as list # TODO list assignment
        # Failed test 'lhs treats @a[@b[$c,]] as list'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/assign.rakudo line 712
        # expected: '2'
        #      got: '1'
        ok 4590 - lhs treats @a[@b[$c,]] as list
        ok 4591 - lhs treats foo()[$b] as list
        not ok 4592 - lhs treats foo()[$b] as list # TODO list assignment
        # Failed test 'lhs treats foo()[$b] as list'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/assign.rakudo line 723
        # expected: '1'
        #      got: '2'
        ok 4593 - lhs treats foo()[$b] as list
        ok 4594 - lhs treats foo()[$b,] as list
        ok 4595 - lhs treats foo()[$b,] as list
        ok 4596 - lhs treats foo()[$b,] as list
        ok 4597 - lhs treats $(@a[$b]) as item (1)
        not ok 4598 - lhs treats $(@a[$b]) as item (2) # TODO item assignment
        # Failed test 'lhs treats $(@a[$b]) as item (2)'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/assign.rakudo line 743
        # expected: '1'
        #      got: '2'
        not ok 4599 - lhs treats $(@a[$b]) as item (3) # TODO item assignment
        # Failed test 'lhs treats $(@a[$b]) as item (3)'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/assign.rakudo line 744
        # expected: '3'
        #      got: '2'
        ok 4600 - # SKIP ,= needs to be special cased after GLR to compile to push(@a, 3, 4)
        ok 4601 - # SKIP ,= needs to be special cased after GLR to compile to push(@a, 3, 4)
        ok 4602 - ,= works for hashes (return value)
        ok 4603 - ,= works for hashes (hash modified)
        ok 4604 - .= on scalars works
        ok 4605 - .= on array indexed values
        ok 4606 - .= on hash keyed values
        ok 4607 - min= worked (positive)
        ok 4608 - min= worked (negative)
        ok 4609 - max= worked (positive)
        ok 4610 - max= worked (negative)
        ok 4611 - my $t; $t = (cond) ?? !! gets value from ?? !!, not conds bool
        ok 4612 - .. also for false
        ok 4613 - truth with "our"
        ok 4614 - ... and false
        ok 4615 - my $t = (cond) ?? !! gets value from ?? !!
        ok 4616 - .. also for false
        ok 4617 - Can grep lazily through a very long range
        ok 4618 - ... with correct result
        ok 4619 - assignment to scalar via array item from array item
        ok 4620 - assignment to array item from array item to scalar
        ok 4621 - chained assignment works
        ok 4622 - chained assignment works
        ok 4623 - $rt125407 and @rt125407[0] should be equal
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Assignment::RO)
        ok 4624 - correct precedence between sub call and assignment (1)
        ok 4625 - correct precedence between sub call and assignment (2)
        ok 4626 - Assign to hash with the same hash on rhs
        ok 4627 - Assign to array with the same array on rhs
        ok 4628 - same with List
        ok 4629 - Assign to array with the same array on rhs
        ok 4630 - 
        ok 4631 - 
        ok 4632 - Assignment into parentheses'd my works.
        ok 4633 - Routine call taking a parenthesised my as argument works.  \#1
        ok 4634 - Routine call taking a parenthesised my as argument works.  \#2
        ok 4635 - Routine call taking a parenthesised my as argument works.  \#3
        ok 4636 - infix:<,=> has list precedence in the cases where infix:<=> does
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Syntax::CannotMeta)
        ok 4637 - Can't use diffy >= with the = metaop 
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Syntax::CannotMeta)
        ok 4638 - Can't use fiddly ~~ with the = metaop 
        ok 4639 - default-assignment (//=) does mix with implicit-variable method call
        ok 4640 - declarator gets its own precedence analysis (1)
        ok 4641 - declarator gets its own precedence analysis (2)
        ok 4642 - Chained assignment respects right associativity when evaluating left sigil for $
        ok 4643 - Internal chained item assignment does not mess up outer list assignment
        ok 4644 - @a[^2] on empty array vivifies the slots and assignment works
        ok 4645 - andthen= thunks RHS
        ok 4646 - notandthen= thunks RHS
        ok 4647 - orelse= thunks RHS
        ok 4648 - -= with :U target gives right result
            1..2
            ok 1 - 'my $b; $b %= 2' died
            ok 2 - right exception type (Exception)
        ok 4649 - %= with :U target throws
# FUDGED!
Potential difficulties:
    To pass an array, hash or sub to a function in Raku, just pass it as is.
    For other uses of Perl's ref operator consider binding with ::= instead.
    Parenthesize as \(...) if you intended a capture of a single variable.
    at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/eqv.rakudo:40
    ------> [32m  ok  (\[33m⏏[31m@a eqv \@a), "eqv on array references (1[0m
    To pass an array, hash or sub to a function in Raku, just pass it as is.
    For other uses of Perl's ref operator consider binding with ::= instead.
    Parenthesize as \(...) if you intended a capture of a single variable.
    at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/eqv.rakudo:40
    ------> [32m  ok  (\@a eqv \[33m⏏[31m@a), "eqv on array references (1)";[0m
    To pass an array, hash or sub to a function in Raku, just pass it as is.
    For other uses of Perl's ref operator consider binding with ::= instead.
    Parenthesize as \(...) if you intended a capture of a single variable.
    at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/eqv.rakudo:41
    ------> [32m  ok  (\[33m⏏[31m@b eqv \@b), "eqv on array references (2[0m
    To pass an array, hash or sub to a function in Raku, just pass it as is.
    For other uses of Perl's ref operator consider binding with ::= instead.
    Parenthesize as \(...) if you intended a capture of a single variable.
    at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/eqv.rakudo:41
    ------> [32m  ok  (\@b eqv \[33m⏏[31m@b), "eqv on array references (2)";[0m
    To pass an array, hash or sub to a function in Raku, just pass it as is.
    For other uses of Perl's ref operator consider binding with ::= instead.
    Parenthesize as \(...) if you intended a capture of a single variable.
    at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/eqv.rakudo:43
    ------> [32m  todo('huh?'); ok !(\[33m⏏[31m@a eqv \@b), "eqv on array references (3[0m
    To pass an array, hash or sub to a function in Raku, just pass it as is.
    For other uses of Perl's ref operator consider binding with ::= instead.
    Parenthesize as \(...) if you intended a capture of a single variable.
    at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/eqv.rakudo:43
    ------> [32m  todo('huh?'); ok !(\@a eqv \[33m⏏[31m@b), "eqv on array references (3)";[0m
    To pass an array, hash or sub to a function in Raku, just pass it as is.
    For other uses of Perl's ref operator consider binding with ::= instead.
    Parenthesize as \(...) if you intended a capture of a single variable.
    at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/eqv.rakudo:45
    ------> [32m  ok \[33m⏏[31m@a eqv \@b, '\@array of two bound arrays[0m
    To pass an array, hash or sub to a function in Raku, just pass it as is.
    For other uses of Perl's ref operator consider binding with ::= instead.
    Parenthesize as \(...) if you intended a capture of a single variable.
    at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/eqv.rakudo:45
    ------> [32m  ok \@a eqv \[33m⏏[31m@b, '\@array of two bound arrays are eqv[0m
    To refer to a positional match capture, just use $0 (numbering starts at 0).
    Parenthesize as \(...) if you intended a capture of a single numeric value.
    at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/eqv.rakudo:49
    ------> [32m  my $a = \[33m⏏[31m3;[0m
    To refer to a positional match capture, just use $0 (numbering starts at 0).
    Parenthesize as \(...) if you intended a capture of a single numeric value.
    at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/eqv.rakudo:50
    ------> [32m  my $b = \[33m⏏[31m3;[0m
    To pass an array, hash or sub to a function in Raku, just pass it as is.
    For other uses of Perl's ref operator consider binding with ::= instead.
    Parenthesize as \(...) if you intended a capture of a single variable.
    at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/eqv.rakudo:56
    ------> [32m  todo('huh?'); ok (\[33m⏏[31m$a !eqv \$b), "eqv on scalar references [0m
    To pass an array, hash or sub to a function in Raku, just pass it as is.
    For other uses of Perl's ref operator consider binding with ::= instead.
    Parenthesize as \(...) if you intended a capture of a single variable.
    at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/eqv.rakudo:56
    ------> [32m  todo('huh?'); ok (\$a !eqv \[33m⏏[31m$b), "eqv on scalar references (1-4)";[0m
    To pass an array, hash or sub to a function in Raku, just pass it as is.
    For other uses of Perl's ref operator consider binding with ::= instead.
    Parenthesize as \(...) if you intended a capture of a single variable.
    at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/eqv.rakudo:79
    ------> [32m  my $num = 3; my $a   = \[33m⏏[31m$num;[0m
    To pass an array, hash or sub to a function in Raku, just pass it as is.
    For other uses of Perl's ref operator consider binding with ::= instead.
    Parenthesize as \(...) if you intended a capture of a single variable.
    at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/eqv.rakudo:80
    ------> [32m  my $b   = \[33m⏏[31m$num;[0m
    To refer to a positional match capture, just use $0 (numbering starts at 0).
    Parenthesize as \(...) if you intended a capture of a single numeric value.
    at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/eqv.rakudo:101
    ------> [32m  ok !(\[33m⏏[31m3 eqv \4),         "eqv on anonymous sca[0m
    To refer to a positional match capture, just use $0 (numbering starts at 0).
    Parenthesize as \(...) if you intended a capture of a single numeric value.
    at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/eqv.rakudo:101
    ------> [32m  ok !(\3 eqv \[33m⏏[31m4),         "eqv on anonymous scalar ref[0m
    To refer to a positional match capture, just use $0 (numbering starts at 0).
    Parenthesize as \(...) if you intended a capture of a single numeric value.
    at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/eqv.rakudo:104
    ------> [32m  todo('huh?'); ok !(\[33m⏏[31m3 eqv \3),         "eqv on anonymous sca[0m
    To refer to a positional match capture, just use $0 (numbering starts at 0).
    Parenthesize as \(...) if you intended a capture of a single numeric value.
    at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/eqv.rakudo:104
    ------> [32m  todo('huh?'); ok !(\3 eqv \[33m⏏[31m3),         "eqv on anonymous scalar ref[0m
        1..59
        ok 4650 - eqv on values (1)
        ok 4651 - eqv on values (2)
        ok 4652 - eqv on values (3)
        ok 4653 - eqv on value types (1-1)
        ok 4654 - eqv on value types (1-2)
        ok 4655 - eqv on value types (1-3)
        ok 4656 - eqv on value types (2-1)
        ok 4657 - eqv on value types (2-2)
        ok 4658 - eqv on value types (2-3)
        ok 4659 - eqv on array references (1)
        ok 4660 - eqv on array references (2)
        not ok 4661 - eqv on array references (3) # TODO huh?
        # Failed test 'eqv on array references (3)'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/eqv.rakudo line 43
        ok 4662 - \@array of two bound arrays are eqv
        ok 4663 - eqv on scalar references (1-1)
        ok 4664 - eqv on scalar references (1-2)
        ok 4665 - eqv on scalar references (1-3)
        not ok 4666 - eqv on scalar references (1-4) # TODO huh?
        # Failed test 'eqv on scalar references (1-4)'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/eqv.rakudo line 56
        ok 4667 - eqv on sub references (1-1)
        ok 4668 - eqv on sub references (1-2)
        ok 4669 - eqv on sub references (1-3)
        ok 4670 - eqv on sub references (1-4)
        ok 4671 - eqv on sub references (2-1)
        ok 4672 - eqv on sub references (2-2)
        ok 4673 - eqv on sub references (2-3)
        ok 4674 - eqv on scalar references (2-1)
        ok 4675 - eqv on scalar references (2-2)
        ok 4676 - eqv on scalar references (2-3)
        ok 4677 - eqv on anonymous array references (1)
        ok 4678 - eqv on anonymous array references (2)
        ok 4679 - eqv on anonymous array references (3)
        ok 4680 - eqv on anonymous hash references (-)
        ok 4681 - eqv on anonymous hash references (+)
        ok 4682 - order really does not matter
        ok 4683 - hashes: different number of pairs
        ok 4684 - eqv on anonymous scalar references (1)
        not ok 4685 - eqv on anonymous scalar references (2) # TODO huh?
        # Failed test 'eqv on anonymous scalar references (2)'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/eqv.rakudo line 104
        ok 4686 - # SKIP huh?
        ok 4687 - chained eqv (1)
        ok 4688 - chained eqv (2)
        ok 4689 - subparam binding doesn't affect eqv (1)
        ok 4690 - subparam binding doesn't affect eqv (2)
        ok 4691 - subparam binding doesn't affect eqv (3)
        ok 4692 - subparam binding doesn't affect eqv (4)
        ok 4693 - eqv returns Bool::True when true
        ok 4694 - eqv returns Bool::False when false
        ok 4695 - Any eqv Any
        ok 4696 - eqv autothreads correctly
        ok 4697 - list starting with () - 1
        ok 4698 - list starting with () - 1
        ok 4699 - list starting with () - 1
        ok 4700 - list starting with () - 1
        ok 4701 - ((), ())
        ok 4702 - Values should be eqv only if they are the same type
        ok 4703 - Str vs. Int
            1..8
            ok 1 - identical Sets eqv each other
            ok 2 - identical SetHashes eqv each other
            ok 3 - Set does not eqv SetHash
            ok 4 - IntStr does not eqv Int
            ok 5 - IntStr does not eqv Str
            ok 6 - Int    does not eqv IntStr
            ok 7 - Str    does not eqv IntStr
            ok 8 - IntStr does     eqv IntStr
        ok 4704 - Setty eqv Setty
            1..6
            ok 1 - Seq() not eqv List()
            ok 2 - Seq(1 2) not eqv List(1 2)
            ok 3 - Seq() not eqv List(1 2)
            ok 4 - Seq(1 2) not eqv List()
            ok 5 - Seq(...) not eqv List(...)
            ok 6 - List(...) not eqv Seq(...)
        ok 4705 - Seq eqv List
            1..7
            ok 1 - eqv between identical Seqs does not die
            ok 2 - eqv between identical Seqs returns True
            ok 3 - eqv between identical lazy Seqs does not die
            ok 4 - eqv between identical lazy Seqs returns True
            ok 5 - eqv between shorter and longer Seq
            ok 6 - eqv between longer and shorter Seq
            ok 7 - eqv between Seqs with different end values
        ok 4706 - Seq eqv Seq
        ok 4707 - HyperSeq eqv HyperSeq
            1..8
                1..3
                ok 1 - code dies
                ok 2 - right exception type (X::Cannot::Lazy)
                ok 3 - .action matches eqv
            ok 1 - both lazy, same types (Seqs)
                1..3
                ok 1 - code dies
                ok 2 - right exception type (X::Cannot::Lazy)
                ok 3 - .action matches eqv
            ok 2 - both lazy, same types (Lists)
                1..3
                ok 1 - code dies
                ok 2 - right exception type (X::Cannot::Lazy)
                ok 3 - .action matches eqv
            ok 3 - both lazy, same types (Arrays)
            ok 4 - both lazy, different types
            ok 5 - different types, only one lazy
            ok 6 - Seqs, only one lazy
            ok 7 - Lists, only one lazy
            ok 8 - Arrays, only one lazy
        ok 4708 - Throws/lives in lazy cases
# FUDGED!
        1..40
assign requires a concrete object (got a Rakudo::Internals::LoweredAwayLexical type object instead)
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/flip-flop.rakudo line 12
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/flip-flop.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

        1..46
        ok 4709 - $foo =:= $foo is true
        ok 4710 - $bar =:= $bar is true
        ok 4711 - $foo =:= $bar is false
        ok 4712 - success returns a Bool
        ok 4713 - failure returns a Bool
        ok 4714 - $subref =:= $subref is true
        ok 4715 - &sub =:= &sub is true
        ok 4716 - $subref1 =:= $subref2 is false
        ok 4717 - basic sanity
        ok 4718 - =:= is true after rebinding (1-1)
        ok 4719 - =:= is true after rebinding (1-2)
        ok 4720 - =:= is true after rebinding (1-3)
        ok 4721 - =:= is true after rebinding (2-1)
        ok 4722 - =:= is true after rebinding (2-2)
        ok 4723 - =:= is true after rebinding (2-3)
        ok 4724 - =:= is true after rebinding (3-1)
        ok 4725 - =:= is true after rebinding (3-2)
        ok 4726 - =:= is true after rebinding (3-3)
        ok 4727 - =:= is true after rebinding (3-4)
        ok 4728 - =:= is true after rebinding (3-5)
        ok 4729 - =:= is true after rebinding (3-6)
        ok 4730 - rebinding of array elements (1)
        ok 4731 - rebinding of array elements (2)
        ok 4732 - assignment destroyed the bindings (1)
        ok 4733 - assignment destroyed the bindings (2)
        ok 4734 - assignment destroyed the bindings (3)
        ok 4735 - binding of scalar subparam retains =:= (1)
        ok 4736 - binding of scalar subparam retains =:= (2)
        ok 4737 - binding of scalar subparam retains =:= (3)
        ok 4738 - binding of scalar subparam marked is rw retains =:= (1)
        ok 4739 - binding of scalar subparam marked is rw retains =:= (2)
        ok 4740 - binding of scalar subparam marked is rw retains =:= (3)
        not ok 4741 - binding of slurpy array subparam retains =:= (1) # TODO unspecced
        # Failed test 'binding of slurpy array subparam retains =:= (1)'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/identity.rakudo line 96
        ok 4742 - binding of slurpy array subparam retains =:= (2)
        not ok 4743 - binding of slurpy array subparam retains =:= (3) # TODO unspecced
        # Failed test 'binding of slurpy array subparam retains =:= (3)'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/identity.rakudo line 100
        not ok 4744 - binding of implicit @_ subparam retains =:= (1) # TODO unspecced
        # Failed test 'binding of implicit @_ subparam retains =:= (1)'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/identity.rakudo line 109
        ok 4745 - binding of implicit @_ subparam retains =:= (2)
        not ok 4746 - binding of implicit @_ subparam retains =:= (3) # TODO unspecced
        # Failed test 'binding of implicit @_ subparam retains =:= (3)'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/identity.rakudo line 113
        ok 4747 - two identical objects are not the same object
        ok 4748 - two references to one object are still not the same object
        ok 4749 - binding makes two objects the same object
        not ok 4750 - misuse of =:= is failure (Mu) # TODO misuse of =:=
        # Failed test 'misuse of =:= is failure (Mu)'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/identity.rakudo line 132
        not ok 4751 - misuse of =:= is failure (literals) # TODO misuse of =:=
        # Failed test 'misuse of =:= is failure (literals)'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/identity.rakudo line 133
        not ok 4752 - misuse of =:= is failure (!=) # TODO misuse of =:=
        # Failed test 'misuse of =:= is failure (!=)'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/identity.rakudo line 134
        not ok 4753 - misuse of =:= is failure (even when ==) # TODO misuse of =:=
        # Failed test 'misuse of =:= is failure (even when ==)'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/identity.rakudo line 135
        ok 4754 - $a =:= $a || $a.WHAT =:= $a.WHAT returns True not an Int
# FUDGED!
        1..38
        ok 4755 - .= runs with block
        ok 4756 - inplace map [0]
        ok 4757 - inplace map [1]
        ok 4758 - inplace map [2]
        ok 4759 - .= works without surrounding whitespace
        ok 4760 - inplace grep [0]
        ok 4761 - inplace grep [1]
        ok 4762 - inplace grep [2]
        ok 4763 - inplace int
        ok 4764 - # SKIP Method '' not found for invocant of class 'Str'
        ok 4765 - # SKIP Method '' not found for invocant of class 'Str'
        ok 4766 - # SKIP Method '' not found for invocant of class 'Str'
        ok 4767 - # SKIP Method '' not found for invocant of class 'Str'
        ok 4768 - inplace uc
        ok 4769 - inplace lc
        ok 4770 - inplace tc
        ok 4771 - inplace sort
assign requires a concrete object (got a Rakudo::Internals::LoweredAwayLexical type object instead)
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/inplace.rakudo line 57
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/inplace.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

        1..16
        ok 4772 - 6 %% 3
        ok 4773 - 6 %% 3 isa Bool
        ok 4774 - 6 %% 4
        ok 4775 - 6 %% 4 isa Bool
        ok 4776 - %% works with explicit closure
        ok 4777 - %% works with whatever *
        ok 4778 - 6 !%% 3
        ok 4779 - 6 !%% 3 isa Bool
        ok 4780 - 6 !%% 4
        ok 4781 - 6 !%% 4 isa Bool
        ok 4782 - %% works with explicit closure
        ok 4783 - %% works with whatever *
            1..2
            ok 1 - code dies
            ok 2 - right exception type (X::Syntax::CannotMeta)
        ok 4784 - infix<!%> is not iffy enough
            1..4
            ok 1 - code dies
            ok 2 - right exception type (X::Numeric::DivideByZero)
            ok 3 - .numerator matches 9
            ok 4 - .using matches infix:<%%>
        ok 4785 - cannot divide by zero using infix:<%%>
            1..4
            not ok 1 - code dies # TODO not sure why this doesn't fire
            # Failed test 'code dies'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/is-divisible-by.rakudo line 41
            ok 2 - # SKIP Code did not die, can not check exception
            ok 3 - # SKIP Code did not die, can not check exception
            ok 4 - # SKIP Code did not die, can not check exception
        not ok 4786 - cannot divide by zero using infix:<%%> # TODO not sure why this doesn't fire
        # Failed test 'cannot divide by zero using infix:<%%>'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/is-divisible-by.rakudo line 41
            1..2
            ok 1 - %% op
            ok 2 - % op
        ok 4787 - no crashes with bigint args
# FUDGED!
        1..39
        ok 4788 - can ye handle that?
        ok 4789 - how about this?
        ok 4790 - ooh! 3 numbers! More difficult
        ok 4791 - again! 3 numbers!
            1..2
            ok 1 - '1 min 2 max 3' died
            ok 2 - right exception type (X::Syntax::NonAssociative)
        ok 4792 - No! No left-associativeness!
            1..2
            ok 1 - '1 max 2 min 3' died
            ok 2 - right exception type (X::Syntax::NonAssociative)
        ok 4793 - This is also not OK
        ok 4794 - min works for strings, too
        ok 4795 - max works for strings, too
        ok 4796 - 
        ok 4797 - 
        ok 4798 - 
        ok 4799 - 
        ok 4800 - minmax does not flatten ranges
        ok 4801 - minmax works on two arrays
        ok 4802 - minmax works on two lists
        ok 4803 - minmax works when both are on left list
        ok 4804 - minmax works when both are on right list
        ok 4805 - minmax works when both are on left array
        ok 4806 - minmax works when both are on right array
        ok 4807 - minmax works for strings, too
        ok 4808 - minmax works on two disjoint ranges
        ok 4809 - minmax works on two overlapping ranges
        ok 4810 - minmax works when both are on left list
        ok 4811 - minmax works when both are on right list
        ok 4812 - # SKIP Annoying test that we haven't done the obvious yet unspecced, fails because we have indeed done the obvious
        ok 4813 - # SKIP Annoying test that we haven't done the obvious yet unspecced, fails because we have indeed done the obvious
        ok 4814 - 2 min Any
        ok 4815 - Any min 2
        ok 4816 - 2 max Any
        ok 4817 - Any max 2
            1..2
            ok 1 - 'no fatal; my $ = do { min +'a', +'a' }; Nil' died
            ok 2 - right exception type (X::Str::Numeric)
        ok 4818 - min with two Failures throws
            1..2
            ok 1 - 'no fatal; my $ = do { max +'a', +'a' }; Nil' died
            ok 2 - right exception type (X::Str::Numeric)
        ok 4819 - max with two Failures throws
            1..2
            ok 1 - code returned a Failure
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::Str::Numeric)
            ok 2 - Failure threw when sunk
        ok 4820 - min with one Failure throws
            1..2
            ok 1 - code returned a Failure
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::Str::Numeric)
            ok 2 - Failure threw when sunk
        ok 4821 - max with one Failure throws
            1..2
            ok 1 - 'Failure.new.min' died
            ok 2 - right exception type (Exception)
        ok 4822 - .min on Failure throws
            1..2
            ok 1 - 'Failure.new.max' died
            ok 2 - right exception type (Exception)
        ok 4823 - .max on Failure throws
            1..2
            ok 1 - 'Failure.new.min: &infix:<cmp>' died
            ok 2 - right exception type (Exception)
        ok 4824 - .min with :&by on Failure throws
            1..2
            ok 1 - 'Failure.new.max: &infix:<cmp>' died
            ok 2 - right exception type (Exception)
        ok 4825 - .max with :&by on Failure throws
            1..8
            ok 1 - .max()
            ok 2 - .min()
            ok 3 - .max(*.value)
            ok 4 - .min(*.value)
            ok 5 - &max()
            ok 6 - &min()
            ok 7 - &max(:by(*.value))
            ok 8 - &min(:by(*.value))
        ok 4826 - min/max operations on Hashes
# FUDGED!
        1..78
        ok 4827 - ~
        ok 4828 - ?? !!
        ok 4829 - == (false)
        ok 4830 - == (true)
        ok 4831 - == (false)
        ok 4832 - != (true)
        ok 4833 - == (const on rhs)
        ok 4834 - != (const on rhs)
        ok 4835 - == (const on lhs)
        ok 4836 - != (const on lhs)
        ok 4837 - == (sum on rhs)
        ok 4838 - == (sum on rhs)
        ok 4839 - == (sum on lhs)
        ok 4840 - == (sum on lhs)
        ok 4841 - == (sum on lhs)
        ok 4842 - concatenation with ~ operator
        ok 4843 - || returns first true value
        ok 4844 - || returns last false value of list?
        ok 4845 - (my @s)[0] //= something works
        ok 4846 - (state @t)[0] //= something works
        ok 4847 - boolean or (?|) returns True or False
        ok 4848 - boolean or (?|) returns True or False
        ok 4849 - all elements in junction are incremented
        ok 4850 - any elements will match via junction
        ok 4851 - any test against scalar
        ok 4852 - any test array against any array
        ok 4853 - any test array against all array
        ok 4854 - all test array against any array
        ok 4855 - all test array against all array
        ok 4856 - test the all infix operator
        ok 4857 - hyper-add
        ok 4858 - joining of single items
            1..3
            ok 1 - code dies
            ok 2 - right exception type (X::Syntax::Confused)
            ok 3 - .message matches -> ;; $_? is raw = OUTER::<$_> {  \#`(Block|140194726652256) ... }
        ok 4859 - Guillemet form of subscript does not parse as infix hyperop
        ok 4860 - operator can start with a bang (!) and have Unicode character in it
            1..3
            ok 1 - '1%^^1' died
            ok 2 - right exception type (X::Syntax::DuplicatedPrefix)
            ok 3 - .prefixes matches ^^
        ok 4861 - %^^ fails to parse (RT  \#73198)
WARNING: unhandled Failure detected in DESTROY. If you meant to ignore it, you can mark it as handled by calling .Bool, .so, .not, or .defined methods. The Failure was:
Cannot convert string to number: base-10 number must begin with valid digits or '.' in '[32m⏏[31ma[0m' (indicated by ⏏[0m)
  in block <unit> at EVAL_665 line 1
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 636
  in sub subtest at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 435
  in sub throws-like at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 628
  in sub no-fatal-throws-like at /Users/tobiuo/class/seminar/Abyss-Server/roast/packages/Test-Helpers/lib/Test/Util.pm6 (Test::Util) line 375
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/minmax.rakudo line 101
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/minmax.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

WARNING: unhandled Failure detected in DESTROY. If you meant to ignore it, you can mark it as handled by calling .Bool, .so, .not, or .defined methods. The Failure was:
Cannot convert string to number: base-10 number must begin with valid digits or '.' in '[32m⏏[31ma[0m' (indicated by ⏏[0m)
  in block <unit> at EVAL_664 line 1
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 636
  in sub subtest at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 435
  in sub throws-like at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 628
  in sub no-fatal-throws-like at /Users/tobiuo/class/seminar/Abyss-Server/roast/packages/Test-Helpers/lib/Test/Util.pm6 (Test::Util) line 375
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/minmax.rakudo line 99
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/minmax.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

            1..3
            ok 1 - '555 ~~!~~ 666' died
            ok 2 - right exception type (X::Syntax::DuplicatedPrefix)
            ok 3 - .prefixes matches ~~
        ok 4862 - ~~!~~ fails to parse (RT  \#76436)
            1..2
            ok 1 - code dies
            ok 2 - right exception type (Exception)
        ok 4863 - did we throws-like Exception?
            1..2
Use of uninitialized value of type Str in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/misc.rakudo line 134
            not ok 1 - code dies # TODO 
            # Failed test 'code dies'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/misc.rakudo line 134
            ok 2 - # SKIP Code did not die, can not check exception
        not ok 4864 - did we throws-like Exception? # TODO 
        # Failed test 'did we throws-like Exception?'
        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/misc.rakudo line 134
        ok 4865 - unary MINUS SIGN
        ok 4866 - infix MINUS SIGN
        ok 4867 - infix MINUS SIGN is not considered a hyphen
        ok 4868 - prefix MINUS SIGN works with infix
        ok 4869 - we have infix MULTIPLICATION SIGN
        ok 4870 - we have infix DIVISION SIGN
        ok 4871 - we have infix LESS-THAN OR EQUAL TO
        ok 4872 - we have infix GREATER-THAN OR EQUAL TO
        ok 4873 - we have infix NOT EQUAL TO
        ok 4874 - we have infix LESS-THAN OR EQUAL TO (not always True)
        ok 4875 - we have infix GREATER-THAN OR EQUAL TO (not always True)
        ok 4876 - we have infix NOT EQUAL TO (not always True)
        ok 4877 - unicode op chaining
        ok 4878 - unicode op chaining
        ok 4879 - unicode op chaining
        ok 4880 - unicode ops chain with ASCII ones
        ok 4881 - unicode ops chain with ASCII ones (not always True)
        ok 4882 - Date ≥ Date (true)
        ok 4883 - Date ≥ Date (false)
        ok 4884 - Date ≤ Date (true)
        ok 4885 - Date ≤ Date (false)
        ok 4886 - Date ≠ Date (true)
        ok 4887 - Date ≠ Date (false)
        ok 4888 - DateTime ≥ DateTime (true)
        ok 4889 - DateTime ≥ DateTime (false)
        ok 4890 - DateTime ≤ DateTime (true)
        ok 4891 - DateTime ≤ DateTime (false)
        ok 4892 - DateTime ≠ DateTime (true)
        ok 4893 - DateTime ≠ DateTime (false)
        ok 4894 - Version ≥ Version (true)
        ok 4895 - Version ≥ Version (false)
        ok 4896 - Version ≤ Version (true)
        ok 4897 - Version ≤ Version (false)
        ok 4898 - Version ≠ Version (true)
        ok 4899 - Version ≠ Version (false)
        ok 4900 - Junctions with ≠ works like for negated ops
            1..3
            ok 1 - original value
            ok 2 - `does` with Str overrode Str method
No such method 'Bars' for invocant of type
'Abyss::Server::Mod::Foo+{<anon|2>}+{<anon|3>}'.  Did you mean any of
these: 'Bag', 'pairs'?
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/misc.rakudo line 219
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/misc.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

WARNINGS for /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/precedence.rakudo:
Useless use of constant integer 2 in sink context (lines 147, 147)
Useless use of "X" in expression "my $a = (1, 3) X (2, 4)" in sink context (line 149)
Useless use of constant integer 3 in sink context (lines 147, 147)
            1..77
            ok 3 - bare postfix binds tighter than ++
            ok 4 - dotted postfix binds tighter than ++
            ok 5 - ++ bind tighter than **
            ok 6 - -- does too
            ok 7 - ** bind tighter than unary -
            ok 8 - ~2**4 is a string
            ok 9 - unary ! binds tighter than *
            ok 10 - beh
            ok 11 - binary -> numify causes reinterpretation as, binds tighter than *
            ok 12 - on left side . is looser than ** and left-to-right with unary -
            ok 13 - on right side . is tighter than addition
            ok 14 - on right side . is tighter than methodcall
            ok 15 - on left side . is tighter than *
            ok 16 - * binds tighter than binary +
            ok 17 - div binds tighter than binary -
            ok 18 - / binds tighter than binary -
            ok 19 - ~ binds looser than *
            ok 20 - but tighter than &
            ok 21 - and + binds tighter than |
            ok 22 - x binds looser than binary +
            ok 23 - doublecheck
            ok 24 - x binds tighter than binary ~
            ok 25 - and ~ binds tighter than |
            ok 26 - & binds tighter than |
            ok 27 - ditto
            ok 28 - and also ^
            ok 29 - blah blah blah
                1..2
                ok 1 - 'my Mu $a = (1 | 2 ^ 3)' died
                ok 2 - right exception type (X::Syntax::NonListAssociative)
            ok 30 - | and ^ may not associate
                1..2
                ok 1 - 'my Mu $a = (1 ^ 2 | 3)' died
                ok 2 - right exception type (X::Syntax::NonListAssociative)
            ok 31 - ^ and | may not associate
            ok 32 - this is true because only one is == 1
            ok 33 - 0 < 2 <=> 1 < 2 means 0 < 1 < 2
            ok 34 - <=> binds looser than |
            ok 35 - <=> binds tighter than ==
                1..2
                ok 1 - '1 .. 2 .. 3' died
                ok 2 - right exception type (X::Syntax::NonAssociative)
            ok 36 - identical .. is not associative
                1..2
                ok 1 - '1 <=> 2 leg 3' died
                ok 2 - right exception type (X::Syntax::NonAssociative)
            ok 37 - <=> and leg are not associative
            ok 38 - != binds tighter than &&
            ok 39 - == binds tighter than || also when chaning
            ok 40 - && binds tighter than ??
            ok 41 - ??!! binds tighter than =
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::Syntax::ConditionalOperator::PrecedenceTooLoose)
            ok 42 - Can't use assignop inside ??!!
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::Syntax::ConditionalOperator::PrecedenceTooLoose)
            ok 43 - Can't use meta-assignop inside ??!!
            ok 44 - $ = binds tighter than ,
            ok 45 - = binds tighter than X
            ok 46 - item assignment is tighter than true
            ok 47 - not is tighter than comma
            ok 48 - list infix tighter than list assignment, looser t than comma
            ok 49 - to complicate things further, it dwims
            ok 50 - parens work around this
                1..2
                ok 1 - '4 X+> 1...2' died
                ok 2 - right exception type (X::Syntax::NonListAssociative)
            ok 51 - X+> must not associate with ...
                1..2
                ok 1 - ''08:12:23'.split(':') Z* 60 X** reverse ^3' died
                ok 2 - right exception type (X::Syntax::NonListAssociative)
            ok 52 - Z* and X** are non associative
            ok 53 - any is less tight than comma and Z
            ok 54 - @ = binds looser than ,
            ok 55 - First arg is 5, run 1
            ok 56 - First arg is 5, run 2
            ok 57 - First arg is 5, run 3
            ok 58 - First arg is 5, run 4
            ok 59 - # SKIP superscript exponent associativity
            ok 60 - # SKIP superscript exponent associativity
            not ok 61 - mixed exponent does right associative # TODO superscript exponent associativity
            # Failed test 'mixed exponent does right associative'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/precedence.rakudo line 229
            # expected: '256'
            #      got: '64'
            ok 62 - superscript exponent binds tighter than unary -
            ok 63 - ~2⁴ is a string
            ok 64 - on left side . is looser than superscript exponent and left-to-right with unary -
            ok 65 - on right side . is tighter than addition
            ok 66 - on right side . is tighter than methodcall
            ok 67 - uc has the correct precedence in comparison to eq
                1..2
                ok 1 - 'int 4.5' died
                ok 2 - right exception type (X::Syntax::Confused)
            ok 68 - there is no more prefix:<int>
            ok 69 - => is right-assoc (1)
            ok 70 - => is right-assoc (2)
                1..2
                ok 1 - '1, 2 Z 3, 4 X 5, 6' died
                ok 2 - right exception type (X::Syntax::NonListAssociative)
            ok 71 - list associativity only works between identical operators
            ok 72 - sanity 3 != 3
            not ok 73 - 3 !=3 does not die # TODO Inequality (!=) misparsed as assignment
            # Failed test '3 !=3 does not die'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/precedence.rakudo line 272
            # Cannot modify an immutable Int (3)
            not ok 74 - ensure 3 !=3 gives same result as 3 != 3 # TODO Inequality (!=) misparsed as assignment
            # Failed test 'ensure 3 !=3 gives same result as 3 != 3'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/precedence.rakudo line 273
            # expected: 'False'
            #      got: 'True'
            ok 75 - and after say is not interpreted as infix:<and>
            ok 76 - (|) has correct precedence.
            ok 77 - "not(0) + 1" is parsed as "(not 0) + 1"
                1..2
                ok 1 - 'my $lizmat = 42; ++$lizmat++' died
                ok 2 - right exception type (X::Syntax::NonAssociative)
            ok 78 - prefix/postfix ++ are not associative
            not ok 79 - exported multi has correct precedence # TODO RT 128042
            # Failed test 'exported multi has correct precedence'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-operators/precedence.rakudo line 307
            # expected: '1'
            #      got: '0'
# FUDGED!
            1..54
            ok 80 - [**] () eq 1 (arguably nonsensical)
            ok 81 - [*] () eq 1
            ok 82 - [/] () should fail
            ok 83 - [%] () should fail
            ok 84 - [x] () should fail
            ok 85 - [xx] () should fail
            ok 86 - [+&] () eq +^0
            ok 87 - [+<] () should fail
            ok 88 - [+>] () should fail
            ok 89 - [~&] () should fail
            ok 90 - # SKIP ~< NYI
            ok 91 - # SKIP ~> NYI
            ok 92 - [+] () eq 0
            ok 93 - [-] () eq 0
            ok 94 - [~] () eq ''
            ok 95 - [+|] () eq 0
            ok 96 - [+^] () eq 0
            ok 97 - [~|] () eq ''
            ok 98 - [~^] () eq ''
            ok 99 - [&] () eq all()
            ok 100 - [|] () eq any()
            ok 101 - [^] () eq one()
            ok 102 - [!==] () eq True
            ok 103 - [==] () eq True
            ok 104 - [<] () eq True
            ok 105 - [<=] () eq True
            ok 106 - [>] () eq True
            ok 107 - [>=] () eq True
            ok 108 - [before] () eq True
            ok 109 - [after] () eq True
            ok 110 - [~~] () eq True
            ok 111 - [!~~] () eq True
            ok 112 - [eq] () eq True)
            ok 113 - [ne] () eq True)
            ok 114 - [!eq] () eq True
            ok 115 - [lt] () eq True
            ok 116 - [le] () eq True
            ok 117 - [gt] () eq True
            ok 118 - [ge] () eq True
            ok 119 - [=:=] () eq True
            ok 120 - [!=:=] () eq True
            ok 121 - [===] () eq True
            ok 122 - [!===] () eq True
            ok 123 - [eqv] () eq True
            ok 124 - [!eqv] () eq True
            ok 125 - [&&] () eq True
            ok 126 - [||] () eq False
            ok 127 - [^^] () eq False
            ok 128 - [//] () is Any
            ok 129 - [,] () eq ()
            ok 130 - [Z] () eq []
            ok 131 - unary [==]
            ok 132 - unary [!=]
            ok 133 - unary [!==]
# FUDGED!
            1..44
            ok 134 - # SKIP hangs
            ok 135 - # SKIP hangs
            ok 136 - # SKIP hangs
            ok 137 - # SKIP hangs
            ok 138 - # SKIP hangs
            ok 139 - # SKIP hangs
            ok 140 - # SKIP hangs
            ok 141 - # SKIP hangs
            ok 142 - # SKIP hangs
            ok 143 - # SKIP hangs
            ok 144 - # SKIP hangs
            ok 145 - finite sequence started with one letter
            ok 146 - sequence started with one letter
            ok 147 - sequence started with two different letters
            ok 148 - character sequence started from array
            ok 149 - descending sequence started with one letter
            ok 150 - descending sequence started with two different letters
            ok 151 - descending sequence started with three different letters
            ok 152 - characters xand arity-1
            ok 153 - sequence ending with 'z' don't cross to two-letter strings
            ok 154 - sequence from 'A' to 'z' is finite and of correct length
            ok 155 - sequence from 'α' to 'ω' is finite and of correct length
            ok 156 - sequence from '☀' to '☕'
            ok 157 - exclusive sequence from '☀' to '☕'
            ok 158 - 'A' ... 'ZZ' does not go on forever
            ok 159 - last element of 'ZZ' ... 'AA' is 'AA'
                1..3
                ok 1 - code dies
                ok 2 - right exception type (Exception)
                ok 3 - .message matches Decrement out of range
            ok 160 - Str decrement fails after 'AA': leftmost characters are never removed
            ok 161 - 'Y', 'Z' ... 'A' works
            ok 162 - A is before AA
            ok 163 - 'A' ...^ 'ZZ' omits last element
            ok 164 - # SKIP lifting comparison ops
            ok 165 - # SKIP lifting comparison ops
            ok 166 - # SKIP lifting comparison ops
            ok 167 - # SKIP lifting comparison ops
            ok 168 - # SKIP lifting comparison ops
            ok 169 - # SKIP lifting comparison ops
            ok 170 - sequence with strings that starts with a digit but cannot convert to numbers
            ok 171 - unicode blocks
            ok 172 - mixture
            ok 173 - intuition does not try to cmp a WhateverCode
            ok 174 - can generate octals
            ok 175 - can generate reverse octals
            ok 176 - can juggle unicode balls
            ok 177 - can juggle unicode balls upside down
# FUDGED!
            1..6
            ok 178 - # SKIP RT  \#124444
            ok 179 - # SKIP RT  \#124444
            ok 180 - # SKIP RT  \#124444
            ok 181 - # SKIP RT  \#124444
            ok 182 - # SKIP RT  \#124444
            ok 183 - # SKIP RT  \#124444
# FUDGED!
            1..23
            ok 184 - :(Int $) ~~ :(Int $)
            ok 185 - :(Int $) ~~ :(Int $, Str $)
            ok 186 - :(Int $) ~~ :(Int $, Str $?)
            ok 187 - :(Str $) ~~ :(Any $)
            ok 188 - :(Int $, Rat $, &) ~~ :(*@_)
            ok 189 - :(:a($x)) ~~ :(:a(:b(:c($x))))
            ok 190 - :(Int $x ($y, Str $z)) ~~ :(Any $x ($l, Int $r))
            ok 191 - :(:x($t) (Int $f, Any $k)) ~~ :(:x($r) (Str $g, Any $i))
            ok 192 - :(:x($t) (Str $f, Str $k)) ~~ :(:x($r) (Str $g, Any $i))
            ok 193 - :(Int @, Str $, Rat $, Str $) ~~ :(Int @x, Any $b, Rat $n?, *@_)
            ok 194 - :(Str $a, Str $b?) ~~ :(Str $a, Str $b)
            ok 195 - :(Any $, :$foo) ~~ :(Any $x, :$foo!)
            ok 196 - :(Int $, Any :$x!, Str :$y) ~~ :(Int $, *%_)
            ok 197 - :(@ (Complex $, Str $, Int $)) ~~ :(@ (Any $, Str $, Numeric $))
            ok 198 - :(Complex $, *%rest) ~~ :(Complex $z, :$x, :$y, :$q)
            ok 199 - :(*%_) ~~ :(:$x, Int :$y, Cool :$z, *%_)
            ok 200 - :(:$x, *%_) ~~ :(:$x, *%_)
            ok 201 - :($, *@_) ~~ :($, Any $, Numeric $)
            ok 202 - # SKIP Parametric types
            not ok 203 - Code params with signatures # TODO Parametric types
            # Failed test 'Code params with signatures'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S03-smartmatch/signature-signature.rakudo line 39
            ok 204 - Can smartmatch against empty signature (False)
            ok 205 - Can smartmatch an empty signature (False)
            ok 206 - Can smartmatch against empty signature (True)
# FUDGED!
            1..46
            ok 207 - temp() changed the variable (1)
            ok 208 - temp() restored the variable (1)
            ok 209 - changed the temp array
            ok 210 - temp() restored the array
            ok 211 - changed the temp hash
            ok 212 - temp() restored the hash
            ok 213 - temp() changed the variable (2-1)
            ok 214 - temp() changed the variable (2-2)
            ok 215 - temp() restored the variable (2)
            ok 216 - temp() shouldn't change the variable containers
            ok 217 - temp() changed the package variable (3-1)
            ok 218 - temp() restored the package variable (3-2)
            ok 219 - temp() changed the variable in a try block
            ok 220 - temp() restored the variable, the block was exited using an exception
            ok 221 - temp() changed our array element
            ok 222 - temp() restored our array element
            ok 223 - temp() changed our hash element
            ok 224 - temp() restored our array element
            not ok 225 - temp() removed previously non-existent key # TODO RT #126447
            # Failed test 'temp() removed previously non-existent key'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-blocks-and-statements/temp.rakudo line 94
            not ok 226 - temp() restored hash has correct .elems # TODO RT #126447
            # Failed test 'temp() restored hash has correct .elems'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-blocks-and-statements/temp.rakudo line 95
            # expected: '3'
            #      got: '4'
            ok 227 - temp() changed our nested arrayitem/hashitem element
            ok 228 - temp() restored our nested arrayitem/hashitem element
Use of Nil in string context
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-blocks-and-statements/temp.rakudo line 132
            ok 229 - TEMP block (1)
Use of Nil in string context
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-blocks-and-statements/temp.rakudo line 133
            ok 230 - TEMP block (2)
Use of Nil in string context
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-blocks-and-statements/temp.rakudo line 134
            ok 231 - TEMP block (3)
Use of Nil in string context
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-blocks-and-statements/temp.rakudo line 135
            ok 232 - TEMP block (4)
Use of Nil in string context
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-blocks-and-statements/temp.rakudo line 138
            not ok 233 - TEMP block (5) # TODO TEMP phasers NYI
            # Failed test 'TEMP block (5)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-blocks-and-statements/temp.rakudo line 138
Use of Nil in string context
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-blocks-and-statements/temp.rakudo line 139
            not ok 234 - TEMP block (6) # TODO TEMP phasers NYI
            # Failed test 'TEMP block (6)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-blocks-and-statements/temp.rakudo line 139
Use of Nil in string context
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-blocks-and-statements/temp.rakudo line 140
            not ok 235 - TEMP block (7) # TODO TEMP phasers NYI
            # Failed test 'TEMP block (7)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-blocks-and-statements/temp.rakudo line 140
Use of Nil in string context
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-blocks-and-statements/temp.rakudo line 141
            not ok 236 - TEMP block (8) # TODO TEMP phasers NYI
            # Failed test 'TEMP block (8)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-blocks-and-statements/temp.rakudo line 141
Use of Nil in string context
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-blocks-and-statements/temp.rakudo line 155
            ok 237 - TEMP block (9)
Use of Nil in string context
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-blocks-and-statements/temp.rakudo line 156
            ok 238 - TEMP block (10)
Use of Nil in string context
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-blocks-and-statements/temp.rakudo line 157
            ok 239 - TEMP block (11)
            ok 240 - instantiating a WierdTemp worked
            ok 241 - .TEMP method wasn't yet executed
            not ok 242 - .TEMP method was executed on temporization # TODO TEMP phasers NYI
            # Failed test '.TEMP method was executed on temporization'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-blocks-and-statements/temp.rakudo line 179
            # expected: '1'
            #      got: '0'
            not ok 243 - .TEMP method was executed on restoration # TODO TEMP phasers NYI
            # Failed test '.TEMP method was executed on restoration'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-blocks-and-statements/temp.rakudo line 182
            # expected: '2'
            #      got: '0'
            ok 244 - recursive nested temps are restored properly
            ok 245 - multiple temps in the same scope are restored properly
            ok 246 - sanity
            ok 247 - non-recursive function properly resets value
            ok 248 - recursive function properly resets value
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::Dynamic::NotFound)
            ok 249 - Useful error conveyed when trying to temp a non-existing dynamic
            ok 250 - temp works with parametarized Hashes
            ok 251 - `temp` keeps around Nils in Arrays when they exist
            ok 252 - `temp` keeps Nils around in Hashes when they exist
# FUDGED!
Potential difficulties:
    Redeclaration of symbol '%p'.
    at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-declarations/my-6c.rakudo:55
    ------> [32m        my %p[33m⏏[31m; #OK[0m
    Redeclaration of symbol '$f'.
    at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-declarations/my-6c.rakudo:159
    ------> [32m    my $f[33m⏏[31m; #OK[0m
WARNINGS for /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-declarations/my-6c.rakudo:
Useless use of constant integer 1 in sink context (line 46)
            1..110
                1..2
                ok 1 - '$foo; my $foo = 42' died
                ok 2 - right exception type (X::Undeclared)
            ok 253 - my() variable not yet visible prior to declaration
            ok 254 - my() variable is visible now (2)
                1..2
                ok 1 - '$ret = $foo ~ my $foo;' died
                ok 2 - right exception type (X::Undeclared)
            ok 255 - my() variable not yet visible (1)
            ok 256 - my() variable not yet visible (2)
Use of uninitialized value element of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-declarations/my-6c.rakudo line 24
Use of uninitialized value element of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-declarations/my-6c.rakudo line 24
            ok 257 - my() variable is visible (1)
            ok 258 - my() variable is visible (2)
            ok 259 - my variable with & sigil works (1)
            ok 260 - my variable with & sigil works (2)
            ok 261 - calling a lexically defined my()-code var worked
                1..2
                ok 1 - 'foo(42)' died
                ok 2 - right exception type (X::Undeclared::Symbols)
            ok 262 - my &foo is lexically scoped
            ok 263 - do{my $a = 3; $a} works
            ok 264 - do{1; my $a = 3; $a} works
            ok 265 - "my $x = my $y = 0" parses
            ok 266 - value should still be set for arg, even if there's a later my
            ok 267 - $a is available in this scope
            ok 268 - $a is available in this scope
            ok 269 - $b is available in this scope
                1..2
                ok 1 - '$b' died
                ok 2 - right exception type (X::Undeclared)
            ok 270 - $b is not available in this scope
            ok 271 - $c is still the same outer value
            ok 272 - $c is available, and the outer value has been changed
            ok 273 - $d is still the outer $d
            ok 274 - $d is now the lexical (inner) $d
            ok 275 - $d has not changed
            ok 276 - $d is available, and the outer value has not changed
                1..2
                ok 1 - '$e' died
                ok 2 - right exception type (X::Undeclared)
            ok 277 - $e is not available in this scope
            ok 278 - $func2() just returns the $e lexical which is held by the closure
            ok 279 - $func() increments the $e lexical which is held by the closure
            ok 280 - ... and one more time just to be sure
            ok 281 - can parse squinting my value
            ok 282 - can capture squinting my value
            ok 283 - can set squinting my variable
            ok 284 - precedence of my wrt = and ,
            ok 285 - Can use @a
            ok 286 - Can use @b
            ok 287 - push actually worked on @a
            ok 288 - push actually worked on @b
            ok 289 - my in while cond seen from body
            ok 290 - my in while cond seen after
            ok 291 - my in if cond seen from then
            ok 292 - my in if cond seen from else
            ok 293 - my in if cond seen after
            ok 294 - 1st my in loop cond seen from body
            ok 295 - 2nd my in loop cond seen from body
            ok 296 - 1st my in loop cond seen after
            ok 297 - 2nd my in loop cond seen after
            ok 298 - two lexicals declared in scope is noop
                1..3
                ok 1 - 'my %h is default(%h<foo>)' died
                ok 2 - right exception type (X::Syntax::Variable::Initializer)
                ok 3 - .name matches %h
            ok 299 - did we throws-like X::Syntax::Variable::Initializer?
                1..3
                ok 1 - 'my $z = $z' died
                ok 2 - right exception type (X::Syntax::Variable::Initializer)
                ok 3 - .name matches $z
            ok 300 - did we throws-like X::Syntax::Variable::Initializer?
            ok 301 - initializing a variable using a try block containing same name works
                1..3
                ok 1 - 'my @foo := 1..3, (@foo Z+ 100)' died
                ok 2 - right exception type (X::Syntax::Variable::Initializer)
                ok 3 - .name matches @foo
            ok 302 - did we throws-like X::Syntax::Variable::Initializer?
            ok 303 - EVAL() knows the pad where it is launched from
            ok 304 - ... but initialization of variables might still happen afterwards
WARNINGS for /Users/tobiuo/class/seminar/Abyss-Server/EVAL_712:
Useless use of constant integer 1 in sink context (line 1)
            ok 305 - &x does not need to be pre-declared
                1..2
                ok 1 - '&x()' died
                ok 2 - right exception type (X::Undeclared::Symbols)
            ok 306 - &x() dies when empty
            ok 307 - my $x if 0
            ok 308 - 
            ok 309 - OUTER::<$x>
            ok 310 - SETTING::<$x>
            ok 311 - 
            ok 312 - unreached declaration in effect at block start
            ok 313 - type error
            ok 314 - also a type error
            ok 315 - native in declarator sig
            ok 316 - natives in declarator sig
            ok 317 - Native types in declarator sig 1/2 constrains
            ok 318 - Native types in declarator sig 2/2 constrains
            ok 319 - Native types in declarator sig allow correct assignments
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::TypeCheck)
            ok 320 - Type in declarator sig 1/1 constrains
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::TypeCheck)
            ok 321 - Types in declarator sig 1/2 constrain
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::TypeCheck)
            ok 322 - Types in declarator sig 2/2 constrain
            ok 323 - Types in declarator sig allow correct assignments
            ok 324 - native outside declarator sig 1
            ok 325 - native outside declarator sig 2
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::TypeCheck)
            ok 326 - Type outside declarator sig 1/1 constrains
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::TypeCheck)
            ok 327 - Type outside declarator sig 1/2 constrains
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::TypeCheck)
            ok 328 - Type outside declarator sig 2/2 constrains
            ok 329 - Native type outside declarator sig 1/2 constrains
            ok 330 - Native type outside declarator sig 2/2 constrains
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::TypeCheck)
            ok 331 - another Type in declarator sig
            ok 332 - Can access variable returned from a named closure that is declared below the calling position
            ok 333 - can call our-sub that accesses a lexical before the block was run
            ok 334 - can call our-sub that accesses a lexical after the block was run
            ok 335 - my (%h?) lives
            ok 336 - global scoped variables are visible inside class definitions
            ok 337 - typing a my-declared variable as ::a works.
            ok 338 - declaration of anonymous Scalar
            ok 339 - declaration of anonymous Array
            ok 340 - declaration of anonymous Hash
            ok 341 - can declare a variable inside a sub call
            ok 342 - dies on undeclared routines
            ok 343 - ... and it does so before run time
            ok 344 - inner / outer
            ok 345 - anonymous @ doesn't overshare
            ok 346 - anonymous % doesn't overshare
            ok 347 - anonymous sub doesn't overshare
            ok 348 - can declare sigilless within parenthesis
            ok 349 - cannot assign to sigilless variable after declaration (one)
            ok 350 - declarator with multiple variables can contain sigilless
            ok 351 - cannot assign to sigilless variable after declaration (many)
                1..2
                ok 1 - 'my (\a)' died
                ok 2 - right exception type (X::Syntax::Term::MissingInitializer)
            ok 352 - did we throws-like X::Syntax::Term::MissingInitializer?
                1..2
                ok 1 - 'my (\a, \b)' died
                ok 2 - right exception type (X::Syntax::Term::MissingInitializer)
            ok 353 - did we throws-like X::Syntax::Term::MissingInitializer?
            ok 354 - can signature-bind to my (\a, \b) and get correct values (1)
            ok 355 - can signature-bind to my (\a, \b) and get correct values (2)
            ok 356 - can call postcircumfix () on subs inside my
            ok 357 - no NullPointerException (and no segfault either)
                1..2
                    1..2
                    ok 1 - 'my Any :D $a' died
                    ok 2 - right exception type (X::Syntax::Malformed)
                ok 1 - did we throws-like X::Syntax::Malformed?
                    1..2
                    ok 1 - 'my Any ^:D $a' died
                    ok 2 - right exception type (X::Syntax::Malformed)
                ok 2 - did we throws-like X::Syntax::Malformed?
            ok 358 - report Malformed my correctly
                1..2
                    1..2
                    ok 1 - 'my Int $a of Str' died
                    ok 2 - right exception type (X::Syntax::Variable::ConflictingTypes)
                ok 1 - Type + of Type
                    1..2
                    ok 1 - 'my Int $a of Str is default("z") of Rat' died
                    ok 2 - right exception type (X::Comp::Group)
                ok 2 - Type + of Type + is default
            ok 359 - dies on conflicting type constraints
                1..3
                ok 1 - simple
                ok 2 - complex
                ok 3 - # SKIP not implemented
            ok 360 - can assign to sigil-less variables
                1..3
                ok 1 - simple
                ok 2 - complex
                ok 3 - # SKIP not implemented
            ok 361 - can bind to sigil-less variables
                1..3
                ok 1 - # SKIP ::= NYI
                ok 2 - # SKIP ::= NYI
                ok 3 - # SKIP ::= NYI
            ok 362 - can compile-time bind to sigil-less variables
# FUDGED!
Potential difficulties:
    Redeclaration of symbol '%p'.
    at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-declarations/my-6e.rakudo:55
    ------> [32m        my %p[33m⏏[31m; #OK[0m
    Redeclaration of symbol '$f'.
    at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-declarations/my-6e.rakudo:159
    ------> [32m    my $f[33m⏏[31m; #OK[0m
WARNINGS for /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-declarations/my-6e.rakudo:
Useless use of constant integer 1 in sink context (line 46)
            1..110
                1..2
                ok 1 - '$foo; my $foo = 42' died
                ok 2 - right exception type (X::Undeclared)
            ok 363 - my() variable not yet visible prior to declaration
            ok 364 - my() variable is visible now (2)
                1..2
                ok 1 - '$ret = $foo ~ my $foo;' died
                ok 2 - right exception type (X::Undeclared)
            ok 365 - my() variable not yet visible (1)
            ok 366 - my() variable not yet visible (2)
Use of uninitialized value element of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-declarations/my-6e.rakudo line 24
Use of uninitialized value element of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-declarations/my-6e.rakudo line 24
            ok 367 - my() variable is visible (1)
            ok 368 - my() variable is visible (2)
            ok 369 - my variable with & sigil works (1)
            ok 370 - my variable with & sigil works (2)
            ok 371 - calling a lexically defined my()-code var worked
                1..2
                ok 1 - 'foo(42)' died
                ok 2 - right exception type (X::Undeclared::Symbols)
            ok 372 - my &foo is lexically scoped
            ok 373 - do{my $a = 3; $a} works
            ok 374 - do{1; my $a = 3; $a} works
            ok 375 - "my $x = my $y = 0" parses
            ok 376 - value should still be set for arg, even if there's a later my
            ok 377 - $a is available in this scope
            ok 378 - $a is available in this scope
            ok 379 - $b is available in this scope
                1..2
                ok 1 - '$b' died
                ok 2 - right exception type (X::Undeclared)
            ok 380 - $b is not available in this scope
            ok 381 - $c is still the same outer value
            ok 382 - $c is available, and the outer value has been changed
            ok 383 - $d is still the outer $d
            ok 384 - $d is now the lexical (inner) $d
            ok 385 - $d has not changed
            ok 386 - $d is available, and the outer value has not changed
                1..2
                ok 1 - '$e' died
                ok 2 - right exception type (X::Undeclared)
            ok 387 - $e is not available in this scope
            ok 388 - $func2() just returns the $e lexical which is held by the closure
            ok 389 - $func() increments the $e lexical which is held by the closure
            ok 390 - ... and one more time just to be sure
            ok 391 - can parse squinting my value
            ok 392 - can capture squinting my value
            ok 393 - can set squinting my variable
            ok 394 - precedence of my wrt = and ,
            ok 395 - Can use @a
            ok 396 - Can use @b
            ok 397 - push actually worked on @a
            ok 398 - push actually worked on @b
            ok 399 - my in while cond seen from body
            ok 400 - my in while cond seen after
            ok 401 - my in if cond seen from then
            ok 402 - my in if cond seen from else
            ok 403 - my in if cond seen after
            ok 404 - 1st my in loop cond seen from body
            ok 405 - 2nd my in loop cond seen from body
            ok 406 - 1st my in loop cond seen after
            ok 407 - 2nd my in loop cond seen after
            ok 408 - two lexicals declared in scope is noop
                1..3
                ok 1 - 'my %h is default(%h<foo>)' died
                ok 2 - right exception type (X::Syntax::Variable::Initializer)
                ok 3 - .name matches %h
            ok 409 - did we throws-like X::Syntax::Variable::Initializer?
                1..3
                ok 1 - 'my $z = $z' died
                ok 2 - right exception type (X::Syntax::Variable::Initializer)
                ok 3 - .name matches $z
            ok 410 - did we throws-like X::Syntax::Variable::Initializer?
            ok 411 - initializing a variable using a try block containing same name works
                1..3
                ok 1 - 'my @foo := 1..3, (@foo Z+ 100)' died
                ok 2 - right exception type (X::Syntax::Variable::Initializer)
                ok 3 - .name matches @foo
            ok 412 - did we throws-like X::Syntax::Variable::Initializer?
            ok 413 - EVAL() knows the pad where it is launched from
            ok 414 - ... but initialization of variables might still happen afterwards
WARNINGS for /Users/tobiuo/class/seminar/Abyss-Server/EVAL_760:
Useless use of constant integer 1 in sink context (line 1)
            ok 415 - &x does not need to be pre-declared
                1..2
                ok 1 - '&x()' died
                ok 2 - right exception type (X::Undeclared::Symbols)
            ok 416 - &x() dies when empty
            ok 417 - my $x if 0
            ok 418 - 
            ok 419 - OUTER::<$x>
            not ok 420 - SETTING::<$x>
            # Failed test 'SETTING::<$x>'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-declarations/my-6e.rakudo line 216
            ok 421 - 
            ok 422 - unreached declaration in effect at block start
            ok 423 - type error
            ok 424 - also a type error
            ok 425 - native in declarator sig
            ok 426 - natives in declarator sig
            ok 427 - Native types in declarator sig 1/2 constrains
            ok 428 - Native types in declarator sig 2/2 constrains
            ok 429 - Native types in declarator sig allow correct assignments
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::TypeCheck)
            ok 430 - Type in declarator sig 1/1 constrains
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::TypeCheck)
            ok 431 - Types in declarator sig 1/2 constrain
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::TypeCheck)
            ok 432 - Types in declarator sig 2/2 constrain
            ok 433 - Types in declarator sig allow correct assignments
            ok 434 - native outside declarator sig 1
            ok 435 - native outside declarator sig 2
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::TypeCheck)
            ok 436 - Type outside declarator sig 1/1 constrains
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::TypeCheck)
            ok 437 - Type outside declarator sig 1/2 constrains
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::TypeCheck)
            ok 438 - Type outside declarator sig 2/2 constrains
            ok 439 - Native type outside declarator sig 1/2 constrains
            ok 440 - Native type outside declarator sig 2/2 constrains
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::TypeCheck)
            ok 441 - another Type in declarator sig
            ok 442 - Can access variable returned from a named closure that is declared below the calling position
            ok 443 - can call our-sub that accesses a lexical before the block was run
            ok 444 - can call our-sub that accesses a lexical after the block was run
            ok 445 - my (%h?) lives
            not ok 446 - global scoped variables are visible inside class definitions
            # Failed test 'global scoped variables are visible inside class definitions'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-declarations/my-6e.rakudo line 286
            # Error: Redeclaration of symbol 'A'.
            ok 447 - typing a my-declared variable as ::a works.
            ok 448 - declaration of anonymous Scalar
            ok 449 - declaration of anonymous Array
            ok 450 - declaration of anonymous Hash
            ok 451 - can declare a variable inside a sub call
            ok 452 - dies on undeclared routines
            ok 453 - ... and it does so before run time
            ok 454 - inner/outer
            ok 455 - anonymous @ doesn't overshare
            ok 456 - anonymous % doesn't overshare
            ok 457 - anonymous sub doesn't overshare
            ok 458 - can declare sigilless within parenthesis
            ok 459 - cannot assign to sigilless variable after declaration (one)
            ok 460 - declarator with multiple variables can contain sigilless
            ok 461 - cannot assign to sigilless variable after declaration (many)
                1..2
                ok 1 - 'my (\a)' died
                ok 2 - right exception type (X::Syntax::Term::MissingInitializer)
            ok 462 - did we throws-like X::Syntax::Term::MissingInitializer?
                1..2
                ok 1 - 'my (\a, \b)' died
                ok 2 - right exception type (X::Syntax::Term::MissingInitializer)
            ok 463 - did we throws-like X::Syntax::Term::MissingInitializer?
            ok 464 - can signature-bind to my (\a, \b) and get correct values (1)
            ok 465 - can signature-bind to my (\a, \b) and get correct values (2)
            ok 466 - can call postcircumfix () on subs inside my
            ok 467 - no NullPointerException (and no segfault either)
                1..2
                    1..2
                    ok 1 - 'my Any :D $a' died
                    ok 2 - right exception type (X::Syntax::Malformed)
                ok 1 - did we throws-like X::Syntax::Malformed?
                    1..2
                    ok 1 - 'my Any ^:D $a' died
                    ok 2 - right exception type (X::Syntax::Malformed)
                ok 2 - did we throws-like X::Syntax::Malformed?
            ok 468 - report Malformed my correctly
                1..2
                    1..2
                    ok 1 - 'my Int $a of Str' died
                    ok 2 - right exception type (X::Syntax::Variable::ConflictingTypes)
                ok 1 - Type + of Type
                    1..2
                    ok 1 - 'my Int $a of Str is default("z") of Rat' died
                    ok 2 - right exception type (X::Comp::Group)
                ok 2 - Type + of Type + is default
            ok 469 - dies on conflicting type constraints
                1..3
                ok 1 - simple
                ok 2 - complex
                ok 3 - # SKIP not implemented
            ok 470 - can assign to sigil-less variables
                1..3
                ok 1 - simple
                ok 2 - complex
                ok 3 - # SKIP not implemented
            ok 471 - can bind to sigil-less variables
                1..3
                ok 1 - # SKIP ::= NYI
                ok 2 - # SKIP ::= NYI
                ok 3 - # SKIP ::= NYI
            ok 472 - can compile-time bind to sigil-less variables
# FUDGED!
WARNING: unhandled Failure detected in DESTROY. If you meant to ignore it, you can mark it as handled by calling .Bool, .so, .not, or .defined methods. The Failure was:
Dynamic variable $*foo not found
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-blocks-and-statements/temp.rakudo line 231
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-blocks-and-statements/temp.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

            1..44
            ok 473 - Assignment to state variable with //= works.
            ok 474 - Assignment to state variable with //= happens once.
            ok 475 - state() works inside subs (first)
            ok 476 - state() works inside subs (second)
            ok 477 - state() works inside subs ( \#3)
            ok 478 - state() works inside coderefs
            ok 479 - state() works inside for-loops
            ok 480 - array state initialized correctly
            ok 481 - array state retained between calls
            ok 482 - array state initialized from call correctly
            ok 483 - array state retained between calls
            ok 484 - (state @foo) = @bar is not state @foo = @bar
            ok 485 - (state @foo) = @bar is not state @foo = @bar
            ok 486 - RHS of state $x = ... only called once
            ok 487 - state() and parens
            ok 488 - state() variable referenced from regex replacement part works
            ok 489 - chained state (1)
            ok 490 - chained state (2)
            ok 491 - state was initialized properly (first time)
            ok 492 - state keeps its value across calls (first time)
            ok 493 - state was initialized properly (second time)
            ok 494 - state keeps its value across calls (second time)
            ok 495 - state was initialized correctly for clone 1
            ok 496 - state was initialized correctly for clone 2
            ok 497 - state between clones is independent
            ok 498 - fib 10 works
            ok 499 - list assignment state in fib memoizes
            ok 500 - fib 2 works
            ok 501 - [list] assignment state in fib memoizes
            ok 502 - growing subset types rejects too high values
            ok 503 - the state variable in subset types works (1)
            ok 504 - the state variable in subset types works (2)
            ok 505 - the state variable in subset types works (3)
            ok 506 - a state variable in parens works with a state variable with //= init
            ok 507 - can parse "state $i++"
            ok 508 - state var in anonymous closure in loop is not shared
            ok 509 - state outside control structure
            not ok 510 - initialization not reached on first run of the functions # TODO initialization happens only on first call(?)
            # Failed test 'initialization not reached on first run of the functions'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-declarations/state.rakudo line 258
            # expected: '5'
            #      got: (Any)
            ok 511 - state vars and list assignment mixes
            ok 512 - anonymous state variable (1)
            ok 513 - anonymous state variable (2)
            ok 514 - Intensive use of state variable in inline-friendly sub does not hit problems
            ok 515 - Statevars work in block following "do" statement prefix
            ok 516 - Statevar uses the correct scope
# FUDGED!
            1..20
            ok 517 - all begin/check blocks in order
            not ok 518 - all init blocks in order # TODO will init NYI
            # Failed test 'all init blocks in order'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-declarations/will.rakudo line 23
            # expected: 'abc'
            #      got: 'ab'
            ok 519 - # SKIP declared variable not visible in block yet
            ok 520 - entered block ok
            not ok 521 - all block blocks set variable # TODO will post NYI
            # Failed test 'all block blocks set variable'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-declarations/will.rakudo line 50
            # expected: 'abecd'
            #      got: 'abec'
            ok 522 - # SKIP declared variable not visible in block yet
            not ok 523 - all block blocks get $_ # TODO declared variable not visible in block yet
            # Failed test 'all block blocks get $_'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-declarations/will.rakudo line 65
            # expected: 'abecd'
            #      got: (Any)
            ok 524 - for iteration  \#1
            ok 525 - for iteration  \#2
            ok 526 - for iteration  \#3
            ok 527 - all for blocks set variable
            ok 528 - # SKIP declared variable not visible in block yet
            not ok 529 - all for blocks get $_ # TODO declared variable not visible in block yet
            # Failed test 'all for blocks get $_'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-declarations/will.rakudo line 97
            # expected: 'aebebebc'
            #      got: (Any)
            ok 530 - unknown will trait
            ok 531 - block should not have executed
            ok 532 - don't know how to test yet
            ok 533 - block should not have executed
            ok 534 - will leave trait on class-scoped my variable not run yet
            ok 535 - will leave trait on class-scoped my variable ran
            ok 536 - will begin block gets var as topic
# FUDGED!
            1..21
            ok 537 - $! has an exception
            ok 538 - # SKIP $!.pending
            ok 539 - # SKIP $!.pending
            ok 540 - $! has been cleared
            ok 541 - @fails is full of fail
            ok 542 - fails do not enter $!
            not ok 543 - $!.pending has three unhandled exceptions # TODO $!.pending
            # Failed test '$!.pending has three unhandled exceptions'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-exceptions/pending.rakudo line 36
            # expected: '4'
            #      got: '1'
            ok 544 - fail 0 is not handled
            ok 545 - fail 0 is not true
            ok 546 - fail 0 is now handled
            ok 547 - fail 1 is not handled
            ok 548 - fail 1 is not defined
            ok 549 - fail 1 is now handled
            ok 550 - fail 2 is not handled
            ok 551 - assign to .handled
            ok 552 - fail 2 is now handled
            ok 553 - $!.pending has one unhandled exception
            ok 554 - $! has been cleared
            not ok 555 - unhandled Failures in $! at block exit are thrown # TODO $object.handled
            # Failed test 'unhandled Failures in $! at block exit are thrown'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-exceptions/pending.rakudo line 74
            # expected: '2'
            #      got: '0'
            ok 556 - $! has been cleared
            ok 557 - # SKIP $object.handled
# FUDGED!
            1..13
            ok 558 - Can use BEGIN <block> as an expression
            ok 559 - Can use BEGIN <expr> as an expression
            ok 560 - can set outer lexical from a BEGIN block
            ok 561 - can set outer package var from a BEGIN block
            ok 562 - can call subs from an outer scope in BEGIN
            ok 563 - can call subs from the setting in BEGIN
            ok 564 - use a class at BEGIN time
            ok 565 - Can execute an anonymous sub return from BEGIN
            ok 566 - BEGIN block was executed before a parse error happened later in the file
            ok 567 - Can use try at BEGIN time
            ok 568 - no Null PMC access when looping over SomeEnum.enums in blockless BEGIN
            not ok 569 - Value bound to variable in BEGIN persists # TODO RT#123776
            # Failed test 'Value bound to variable in BEGIN persists'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-phasers/begin.rakudo line 82
            # expected: 'foo'
            #      got: (Any)
            ok 570 - Assigment in BEGIN to list declared outside BEGIN lives
# FUDGED!
WARNINGS for /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-phasers/enter-leave.rakudo:
Useless use of constant integer 1 in sink context (line 255)
            1..33
            ok 571 - 
            ok 572 - 
            ok 573 - 
            ok 574 - 
            ok 575 - multiple ENTER/LEAVE worked
            ok 576 - ENTER/LEAVE repeats on loop blocks
            ok 577 - basic sanity check (1)
            ok 578 - LEAVE executed at the 1st explicit return
            ok 579 - basic sanity check (2)
            ok 580 - LEAVE executed at the 2nd explicit return
            ok 581 - # SKIP leave NYI RT  \#124960
            ok 582 - die calls LEAVE blocks
            ok 583 - $! set in LEAVE if exception thrown
            not ok 584 - $! not set in LEAVE if exception not thrown # TODO is this spec? why would LEAVE not see outer $!? fossil?
            # Failed test '$! not set in LEAVE if exception not thrown'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-phasers/enter-leave.rakudo line 125
            # expected: 'ayeno'
            #      got: 'ayeyes'
            ok 585 - die in ENTER caught by try
            ok 586 - die in LEAVE caught by try
            ok 587 - die in ENTER calls LEAVE
            ok 588 - die aborts ENTER queue
            ok 589 - die doesn't abort LEAVE queue
            ok 590 - single exception from LEAVE is rethrown after running LEAVEs
            ok 591 - LEAVE fires in a multi sub
            ok 592 - next triggers LEAVE
            ok 593 - can run for loop in phaser in for loop
            ok 594 - LEAVE fires after die in sub
            ok 595 - "last" triggers LEAVE phaser in loop
            ok 596 - "next" triggers LEAVE phaser in "for" loop
            ok 597 - ENTER works as an r-value (mainline)
            ok 598 - ENTER works as an r-value (sub)
            ok 599 - return in nested block with LEAVE works
                1..3
                ok 1 - code dies
                ok 2 - right exception type (X::PhaserExceptions)
                ok 3 - .exceptions matches sub { }
            ok 600 - did we throws-like X::PhaserExceptions?
            ok 601 - using ENTER inside LEAVE does not crash
            ok 602 - decont in ENTER works without locals
            ok 603 - Did ENTER only run once
# FUDGED!
            1..35
            ok 604 - EVAL once {...} works
            ok 605 - once {...} has not run yet
            ok 606 - can run code with once block
            ok 607 - once {...} fired
            ok 608 - can run code with once block again
            ok 609 - once {...} fired only once
            ok 610 - cloning code does not run anything
            ok 611 - can run clone of code with once block
            ok 612 - once {...} fired again for the clone
            ok 613 - can run clone of once block code again
            ok 614 - cloned once {...} fired only once
            ok 615 - EVAL INIT {...} works
            not ok 616 - INIT did not run at compile time # TODO not sure
            # Failed test 'INIT did not run at compile time'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-phasers/in-eval.rakudo line 41
            ok 617 - can run code with INIT block
            ok 618 - INIT {...} fires at run-time
            ok 619 - can run code with INIT block again
            ok 620 - INIT runs only once
            ok 621 - cloning code does not run anything
            ok 622 - can run clone of code with INIT block
            ok 623 - INIT {...} did not fire again for the clone
            ok 624 - EVAL CHECK {...} (and BEGIN {...}) works
            ok 625 - CHECK and BEGIN blocks ran before run time
            ok 626 - can run code with CHECK and BEGIN blocks
            ok 627 - CHECK {...} runs at compile time after BEGIN
            ok 628 - can run code with CHECK and BEGIN again
            ok 629 - CHECK runs once
            ok 630 - EVAL BEGIN {...} works
            ok 631 - BEGIN ran before run time
            ok 632 - can run code with BEGIN block
            ok 633 - BEGIN does not run again at run time
            ok 634 - EVAL END {...} works
            ok 635 - END {} has not run yet
            ok 636 - can call code with END block
            ok 637 - END {} does not run at run time either
# FUDGED!
WARNINGS for /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-phasers/in-loop.rakudo:
Useless use of constant integer 42 in sink context (line 168)
            1..21
            not ok 638 - trait blocks work properly in for loop # TODO NEXT/LEAVE ordering
            # Failed test 'trait blocks work properly in for loop'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-phasers/in-loop.rakudo line 38
            # expected: '(1 F)(1 E)(1 a)(1 N)(1 Lv)(2 E)(2 a)(2 b)(2 N)(2 Lv)(3 E)(3 a)(3 N)(3 Lv)(4 E)(4 Lv)(4 Lst)'
            #      got: '(1 F)(1 E)(1 a)(1 N)(1 Lv)(2 E)(2 a)(2 b)(2 Lv)(2 N)(3 E)(3 a)(3 N)(3 Lv)(4 E)(4 Lv)(4 Lst)'
            not ok 639 - trait blocks work properly in for loop # TODO NEXT/LEAVE ordering
            # Failed test 'trait blocks work properly in for loop'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-phasers/in-loop.rakudo line 70
            # expected: '(1 F1)(1 F2)(1 E1)(1 E2)(1 a)(1 N2)(1 N1)(1 Lv2)(1 Lv1)(2 E1)(2 E2)(2 a)(2 b)(2 N2)(2 N1)(2 Lv2)(2 Lv1)(3 E1)(3 E2)(3 a)(3 N2)(3 N1)(3 Lv2)(3 Lv1)(4 E1)(4 E2)(4 Lv2)(4 Lv1)(4 Lst2)(4 Lst1)'
            #      got: '(1 F1)(1 F2)(1 E1)(1 E2)(1 a)(1 N2)(1 N1)(1 Lv2)(1 Lv1)(2 E1)(2 E2)(2 a)(2 b)(2 Lv2)(2 Lv1)(2 N2)(2 N1)(3 E1)(3 E2)(3 a)(3 N2)(3 N1)(3 Lv2)(3 Lv1)(4 E1)(4 E2)(4 Lv2)(4 Lv1)(4 Lst1)(4 Lst2)'
            ok 640 - LAST does not fire for empty loop
            ok 641 - "last" statement called by LEAVE breaks out of while loop
            ok 642 - LEAVE in while loop works as expected
            ok 643 - no UnwindException with "last" and "ENTER" in for loop
            ok 644 - LAST phaser without block does not put Mu in the iteration variable
            ok 645 - LAST phaser with    block does not put Mu in the iteration variable
            ok 646 - FIRST in loop works fine with recursion
            ok 647 - NEXT in loop works fine with recursion
            ok 648 - LAST in loop works fine with recursion
            ok 649 - NEXT can see outer $_
            ok 650 - LAST can see outer $_
            ok 651 - POST should not see outer $_
Use of uninitialized value of type Rakudo::Internals::LoweredAwayLexical in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-phasers/in-loop.rakudo line 176
            not ok 652 - KEEP should not see outer $_ # TODO KEEP should not see outer 
            # Failed test 'KEEP should not see outer $_'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-phasers/in-loop.rakudo line 176
            # expected: '42 42 42 42 42 42 42 42 42 42'
            #      got: '0 1 2 3 4 5 6 7 8 9'
            ok 653 - LAST can see outer $_
            ok 654 - LEAVE can see outer $_
            ok 655 - PRE can see outer $_
            ok 656 - UNDO can see outer $_
                1..2
                ok 1 - unwanted loop
                ok 2 - wanted loop
            ok 657 - FIRST+LAST loops as last statement in subs work and do not crash
            ok 658 - FIRST statement in loop does not warn
# FUDGED!
            1..16
            ok 659 - NEXT called by both next and normal falling out
            ok 660 - NEXT called by both next and normal falling out
            ok 661 - NEXT called by both next and normal falling out
            ok 662 - NEXT are LAST blocks may not be exclusive
            ok 663 - die didn't trigger NEXT {}
            ok 664 - leave didn't trigger NEXT {}
            ok 665 - return didn't trigger NEXT {}
            ok 666 - last bypass NEXT {}
            not ok 667 - NEXT {} ran before LEAVE {} (1) # TODO NEXT/LEAVE ordering RT #124952
            # Failed test 'NEXT {} ran before LEAVE {} (1)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-phasers/next.rakudo line 112
            # expected: 'nlnl'
            #      got: 'lnln'
            not ok 668 - NEXT {} ran before LEAVE {} (2) # TODO NEXT/LEAVE ordering RT #124952
            # Failed test 'NEXT {} ran before LEAVE {} (2)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-phasers/next.rakudo line 124
            # expected: 'nlnl'
            #      got: 'lnln'
            ok 669 - NEXT {} ran in reversed order
            ok 670 - NEXT {} works in loop (;;) {}
            ok 671 - NEXT {} works in for loop
            ok 672 - last in a NEXT in a for loop terminates the loop
            ok 673 - last in a NEXT in a for loop terminates the loop, when triggered by next
            ok 674 - last in a NEXT in a loop terminates the loop
# FUDGED!
WARNING: unhandled Failure detected in DESTROY. If you meant to ignore it, you can mark it as handled by calling .Bool, .so, .not, or .defined methods. The Failure was:
1
  in sub fail_it at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-exceptions/pending.rakudo line 26
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-exceptions/pending.rakudo line 65
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-exceptions/pending.rakudo line 3
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

            1..22
            ok 675 - sub with PRE  compiles and runs
            ok 676 - sub with POST compiles and runs
                1..3
                ok 1 - 'foo(10)' died
                ok 2 - right exception type (X::Phaser::PrePost)
                ok 3 - .phaser matches PRE
            ok 677 - Violated PRE  throws (catchable) exception
                1..3
                ok 1 - 'bar(10)' died
                ok 2 - right exception type (X::Phaser::PrePost)
                ok 3 - .phaser matches POST
            ok 678 - Violated POST throws (catchable) exception
            ok 679 - sub with two PREs compiles and runs
                1..3
                ok 1 - 'baz(-1)' died
                ok 2 - right exception type (X::Phaser::PrePost)
                ok 3 - .phaser matches PRE
            ok 680 - sub with two PREs fails when first is violated
                1..3
                ok 1 - 'baz(42)' died
                ok 2 - right exception type (X::Phaser::PrePost)
                ok 3 - .phaser matches PRE
            ok 681 - sub with two PREs fails when second is violated
            ok 682 - sub with two POSTs compiles and runs
                1..3
                ok 1 - 'qox(-1)' died
                ok 2 - right exception type (X::Phaser::PrePost)
                ok 3 - .phaser matches POST
            ok 683 - sub with two POSTs fails if first POST is violated
                1..3
                ok 1 - 'qox(123)' died
                ok 2 - right exception type (X::Phaser::PrePost)
                ok 3 - .phaser matches POST
            ok 684 - sub with two POSTs fails if second POST is violated
            ok 685 - POST receives return value as $_ (succeess)
                1..3
                ok 1 - '$pt.test(1)' died
                ok 2 - right exception type (X::Phaser::PrePost)
                ok 3 - .phaser matches POST
            ok 686 - POST receives return value as $_ (failure)
            ok 687 - PRE and POST run on ordinary blocks
            ok 688 - PRE/POST run outside ENTER/LEAVE
            ok 689 - failing PRE runs nothing else
            ok 690 - failing POST runs LEAVE but not more POSTs
            ok 691 - POST runs on exception, with correct $!
            not ok 692 - POST has undefined $! on no exception # TODO POST and exceptions RT #124961
            # Failed test 'POST has undefined $! on no exception'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-phasers/pre-post.rakudo line 164
            # expected: 'ayeno'
            #      got: 'ayeyes'
            not ok 693 - failing POST on exception doesn't replace $!
            # Failed test 'failing POST on exception doesn't replace $!'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-phasers/pre-post.rakudo line 176
            ok 694 - blockless PRE/POST (+)
            ok 695 - blockless PRE/POST (-, 1)
            ok 696 - blockless PRE/POST (-, 2)
# FUDGED!
WARNINGS for /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statement-modifiers/with.rakudo:
Useless use of constant integer 1 in sink context (line 74)
            1..35
            ok 697 - post with
            ok 698 - post with
            ok 699 - post with
            ok 700 - post with in a loop
assign requires a concrete object (got a Rakudo::Internals::LoweredAwayLexical type object instead)
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statement-modifiers/with.rakudo line 39
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statement-modifiers/with.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

WARNINGS for /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/for.rakudo:
Useless use of constant integer 41 in sink context (lines 468, 469, 474, 477, 482)
            1..111
                1..2
                ok 1 - 'foreach 1..10 { $times_run++ }; 1' died
                ok 2 - right exception type (X::Obsolete)
            ok 701 - foreach is gone
                1..2
                ok 1 - 'foreach (1..10) { $times_run++}; 1' died
                ok 2 - right exception type (X::Obsolete)
            ok 702 - foreach is gone, even with parens
            ok 703 - foreach doesn't work
            ok 704 - for 0..5 {} works
            ok 705 - for 0 .. 5 -> {} works
            ok 706 - for zip(@a; @b) -> $x, $y works
            ok 707 - for 0 .. 5 { .some_sub } works
            ok 708 - for () {} works
            ok 709 - for () -> {} works
assign requires a concrete object (got a Rakudo::Internals::LoweredAwayLexical type object instead)
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/for.rakudo line 78
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/for.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

            1..39
            ok 710 - not yet gathered
            ok 711 - 5 elements gathered
            ok 712 - gather code executed
            ok 713 - first elem taken
            ok 714 - last elem taken
            ok 715 - nested gather works (two levels)
            ok 716 - nested gather works (three levels)
            ok 717 - take on lists and multiple takes work
            ok 718 - gather scopes dynamically, not lexically
            ok 719 - gather array-refs
            ok 720 - gather as a statement_prefix
            ok 721 - gather is lazy
            ok 722 - gather with nested while
            ok 723 - gather with nested loop
            ok 724 - take with multiple arguments produces one item each
            ok 725 - take with multiple arguments .flat tens out
            ok 726 - Nested identical gathers
            ok 727 - Elements in gather/take stringify correctly
            ok 728 - decontainerization happens (1)
            ok 729 - decontainerization happens (2)
            ok 730 - method form of take works.
            ok 731 - return value of take
            ok 732 - first example in S04-control.pod works
            ok 733 - take in flat context flattens
            ok 734 - take in item context doesn't flatten
            ok 735 - .flat flattens fully into a list of Ints.
            ok 736 - gather/take does not flatten out sublists
            ok 737 - a list of Lists, as an item.
            ok 738 - # SKIP RT  \#66820, and hangs under GLR
            ok 739 - # SKIP RT  \#66820, and hangs under GLR
            ok 740 - Neighbor is same object as in grid
            ok 741 - There are eight neighbors
                1..4
                ok 1 - 'say (gather for 1..3 { INIT take "OH HAI"; take $_ })' died
                ok 2 - right exception type (X::ControlFlow)
                ok 3 - .enclosing matches gather
                ok 4 - .illegal matches take
            ok 742 - "INIT take" inside of a "gather for" fails with X::ControlFlow
            ok 743 - take on a listy expression takes each element of that list
            ok 744 - AT-POS on gather Seq with take-rw value lives
            ok 745 - AT-POS on gather Seq with take-rw value works
            ok 746 - Got the value equality expected from take-rw
            ok 747 - Got the reference equality expected from take-rw
            ok 748 - take inside m:g runs the expected number of times
# FUDGED!
            1..10
            not ok 749 - non-compiling test # TODO lazy in not there yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/lazy.rakudo line 26
            not ok 750 - non-compiling test # TODO lazy in not there yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/lazy.rakudo line 26
            not ok 751 - non-compiling test # TODO lazy in not there yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/lazy.rakudo line 26
            not ok 752 - non-compiling test # TODO lazy in not there yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/lazy.rakudo line 26
            not ok 753 - non-compiling test # TODO lazy in not there yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/lazy.rakudo line 26
            not ok 754 - non-compiling test # TODO lazy in not there yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/lazy.rakudo line 38
            not ok 755 - non-compiling test # TODO lazy in not there yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/lazy.rakudo line 38
            not ok 756 - non-compiling test # TODO lazy in not there yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/lazy.rakudo line 50
            not ok 757 - non-compiling test # TODO lazy in not there yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/lazy.rakudo line 50
                1..2
                ok 1 - '(lazy { 43 }) = 23 ' died
                not ok 2 - right exception type (X::Assignment::RO) # TODO lazy in not there yet
                # Failed test 'right exception type (X::Assignment::RO)'
                # at SETTING::src/core.c/Exception.pm6 line 62
                # Expected: X::Assignment::RO
                # Got:      X::Method::NotFound
                # Exception message: No such method 'lazy' for invocant of type 'Int'.  Did you mean any of
                # these: 'any', 'say'?
            not ok 758 - assigning to a lazily computed value does not work # TODO lazy in not there yet
            # Failed test 'assigning to a lazily computed value does not work'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/lazy.rakudo line 54
# FUDGED!
            1..23
            not ok 759 - non-compiling test # TODO leave is not implemented yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 21
            not ok 760 - non-compiling test # TODO leave is not implemented yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 213
            not ok 761 - non-compiling test # TODO leave is not implemented yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 213
            not ok 762 - non-compiling test # TODO leave is not implemented yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 213
            not ok 763 - non-compiling test # TODO leave is not implemented yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 213
            not ok 764 - non-compiling test # TODO leave is not implemented yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 213
            not ok 765 - non-compiling test # TODO leave is not implemented yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 213
            not ok 766 - non-compiling test # TODO leave is not implemented yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 213
            not ok 767 - non-compiling test # TODO leave is not implemented yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 213
            not ok 768 - non-compiling test # TODO leave is not implemented yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 213
            not ok 769 - non-compiling test # TODO leave is not implemented yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 213
            not ok 770 - non-compiling test # TODO leave is not implemented yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 213
            not ok 771 - non-compiling test # TODO leave is not implemented yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 213
            not ok 772 - non-compiling test # TODO leave is not implemented yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 213
            not ok 773 - non-compiling test # TODO leave is not implemented yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 213
            not ok 774 - non-compiling test # TODO leave is not implemented yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 213
            not ok 775 - non-compiling test # TODO leave is not implemented yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 213
            not ok 776 - non-compiling test # TODO leave is not implemented yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 213
            not ok 777 - non-compiling test # TODO leave is not implemented yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 213
            not ok 778 - non-compiling test # TODO leave is not implemented yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 213
            not ok 779 - non-compiling test # TODO leave is not implemented yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 213
            not ok 780 - non-compiling test # TODO leave is not implemented yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 213
            not ok 781 - non-compiling test # TODO leave is not implemented yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S04-statements/leave.rakudo line 213
# FUDGED!
            1..32
            ok 782 - Hypothetical variable capture
            ok 783 - Hypothetical variable captured
            ok 784 - # SKIP Package variable capture RT  \#125122
            ok 785 - # SKIP Package variable capture RT  \#125122
            ok 786 - Reverse capture
            ok 787 - $0 captured
            ok 788 - $1 captured
            ok 789 - Compound hypothetical capture
            ok 790 - Implicit hypothetical variable captured
            ok 791 - Explicit hypothetical variable captured
            not ok 792 - Mixed capture # TODO Package variable capture RT #125122
            # Failed test 'Mixed capture'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-capture/alias.rakudo line 46
Use of Nil in string context
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-capture/alias.rakudo line 47
            not ok 793 - Implicit hypothetical variable captured # TODO Package variable capture RT #125122
            # Failed test 'Implicit hypothetical variable captured'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-capture/alias.rakudo line 47
            # expected: 'bc'
            #      got: ''
            not ok 794 - Explicit package variable captured # TODO Package variable capture RT #125122
            # Failed test 'Explicit package variable captured'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-capture/alias.rakudo line 48
            # expected: 'bc'
            #      got: ''
            ok 795 - Standard captures
            ok 796 - Captured <?alpha>
            ok 797 - Captured <?ident>
            ok 798 - Repeated standard captures
            ok 799 - Captured $first
            ok 800 - Captured $family
            ok 801 - Captured <ident>
            ok 802 - Pair match
            ok 803 - Key match
            ok 804 - Value match
            ok 805 - Pair match
            ok 806 - Reverse key match
            ok 807 - Reverse value match
            ok 808 - Capture starting at non-zero
            ok 809 - Capture starting at non-zero, explicit
            ok 810 - Capture starting at non-zero, incremented once
            ok 811 - Capture starting at non-zero, incremented twice
            ok 812 - Correct match of $<cat>=@(...) construct
            ok 813 - Correct capture of $<cat>=@(...) construct
# FUDGED!
            1..50
            ok 814 - Named simple array capture
            ok 815 - Captured strings
            ok 816 - Sequential simple array capture
            ok 817 - First captured strings
            ok 818 - Last captured strings
            ok 819 - Repeated hypothetical array capture
            ok 820 - Hypothetical variable captured
            ok 821 - No extra captures
            ok 822 - Hypothetical array capture
            ok 823 - Hypothetical variable captured
            ok 824 - # SKIP capturing to lexical variable NYI RT  \#126243
            ok 825 - # SKIP capturing to lexical variable NYI RT  \#126243
            ok 826 - # SKIP capturing to lexical variable NYI RT  \#126243
            ok 827 - # SKIP capturing to lexical variable NYI RT  \#126243
            ok 828 - # SKIP capturing to lexical variable NYI RT  \#126243
            ok 829 - Compound hypothetical capture
            ok 830 - Implicit hypothetical variable captured -- lives-ok
            ok 831 - Implicit hypothetical variable captured -- retval is correct
            ok 832 - Explicit hypothetical variable captured
            ok 833 - Nested array capture
            ok 834 - Outer array capture
            ok 835 - Inner array capture
            ok 836 - Subrule array capture
            ok 837 - Outer rule array capture
            ok 838 - Final subrule array capture
            ok 839 - Nested subrule array capture
            ok 840 - Outer rule nested array capture
            ok 841 - Subrule array capture
            ok 842 - Nested multiple array capture
            ok 843 - Multiple capture to nested array
            ok 844 - Multiple capture count
            ok 845 - Multiple capture to nested AoA[0]
            ok 846 - Multiple capture to nested AoA[2]
            ok 847 - Multiple capture to nested AoA[3]
            ok 848 - Multiple capture value of nested AoA[0][0]
            ok 849 - Multiple capture value of nested AoA[0][1]
            ok 850 - Multiple capture value of nested AoA[1][0]
            ok 851 - Multiple capture value of nested AoA[1][1]
            ok 852 - Multiple capture value of nested AoA[2][0]
            ok 853 - Multiple capture value of nested AoA[2][1]
            ok 854 - # SKIP capturing to lexical variable NYI RT  \#126243
            ok 855 - # SKIP capturing to lexical variable NYI RT  \#126243
            ok 856 - # SKIP capturing to lexical variable NYI RT  \#126243
            ok 857 - # SKIP capturing to lexical variable NYI RT  \#126243
            ok 858 - # SKIP capturing to lexical variable NYI RT  \#126243
            ok 859 - no error with array alias and list-quantified subpattern (1)
            ok 860 - ... and correct result
            ok 861 - no error with array alias and list-quantified subpattern (2)
            ok 862 - ... and correct result
            ok 863 - array alias works with quantified non-capturing structure
# FUDGED!
            1..61
            ok 864 - Match
            ok 865 - Matched
            ok 866 - Captured
            ok 867 - $/[0]
            ok 868 - $0
            ok 869 - $/[1]
            ok 870 - $1
            ok 871 - no $/[2]
            ok 872 - no $2
            ok 873 - no $/<dotdot>
            ok 874 - Match
            ok 875 - Matched
            ok 876 - Captured
            ok 877 - $/[0]
            ok 878 - $0
            ok 879 - $/[1]
            ok 880 - $1
            ok 881 - $/[2]
            ok 882 - $2
            ok 883 - $/<dotdot>
            ok 884 - $/<dotdot>[0]
            ok 885 - $/<dotdot>[1]
            ok 886 - $/<dotdot>[2]
            ok 887 - Nested captured
            ok 888 - Nested $0
            ok 889 - Nested $1
            ok 890 - Nested $2
            ok 891 - Nested $3
            ok 892 - Backreference
            ok 893 - Captured
            ok 894 - Captured
            ok 895 - Correct semantics of contiguous captures in backref
            ok 896 - Backtracking and backref interaction resulted in correct capture
            not ok 897 - Named backref # TODO dubious test RT #125004
            # Failed test 'Named backref'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-capture/dot.rakudo line 72
Use of Nil in string context
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-capture/dot.rakudo line 73
            not ok 898 - Named capture # TODO dubious test RT #125004
            # Failed test 'Named capture'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-capture/dot.rakudo line 73
            # expected: 'o'
            #      got: ''
Use of Nil in string context
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-capture/dot.rakudo line 74
            not ok 899 - Backref capture # TODO dubious test RT #125004
            # Failed test 'Backref capture'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-capture/dot.rakudo line 74
            # expected: 'o'
            #      got: ''
            not ok 900 - Positional backref # TODO dubious test RT #125005
            # Failed test 'Positional backref'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-capture/dot.rakudo line 78
Use of Nil in string context
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-capture/dot.rakudo line 79
            not ok 901 - Named capture # TODO dubious test RT #125005
            # Failed test 'Named capture'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-capture/dot.rakudo line 79
            # expected: 'o'
            #      got: ''
Use of Nil in string context
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-capture/dot.rakudo line 80
            not ok 902 - Backref capture # TODO dubious test RT #125005
            # Failed test 'Backref capture'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-capture/dot.rakudo line 80
            # expected: 'o'
            #      got: ''
            ok 903 - Failed positional backref
            ok 904 - Failed named backref
            ok 905 - Non-translation of non-interpolated "\$0"
            ok 906 - Non-translation of non-interpolated '$0'
            ok 907 - Non-translation of non-interpolated q{$0}
            ok 908 - Non-translation of non-interpolated q[$0]
            ok 909 - Non-translation of non-interpolated q<$0>
            ok 910 - Non-translation of non-interpolated q/$0/
            ok 911 - Non-translation of non-interpolated q!$0!
            ok 912 - Non-translation of non-interpolated q|$0|
            ok 913 - English name
            ok 914 - Match is john
            ok 915 - Match isn't jean
            ok 916 - French name
            ok 917 - Match is jean
            ok 918 - Russian name
            ok 919 - Match is ivan
            ok 920 - English metaname
            ok 921 - Metaname match is john
            ok 922 - Metaname match isn't jean
            ok 923 - Metaname is john
            ok 924 - Can refer to very high numbered capture variable without exploding
# FUDGED!
            1..47
            ok 925 - match successful
            ok 926 - got right type
            ok 927 - .Bool
            ok 928 - .defined
            ok 929 - .Str
            ok 930 - .from
            ok 931 - .to
            ok 932 - .prematch
            ok 933 - .postmatch
            ok 934 - .list (empty)
            ok 935 - .hash (empty)
            ok 936 - .keys (empty)
            ok 937 - .values (empty)
            ok 938 - .pairs (empty)
            ok 939 - .kv (empty)
            ok 940 - .Int with small value
            ok 941 - .Int with big value
            ok 942 - sanity 1
            ok 943 - sanity 2
            ok 944 - .prematch for zero-width matches
            ok 945 - .postmatch for zero-width matches
            ok 946 - .prematch produces a Str
            ok 947 - .postmatch produces a Str
            ok 948 - no match
            ok 949 - failed match is False
Use of Nil in string context
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-capture/match-object.rakudo line 44
            ok 950 - false match stringifies to empty string
            ok 951 - === of different match objects
            ok 952 - === of different but similar match objects
            ok 953 - === of one and the same match object
            ok 954 - eqv of different match objects
            ok 955 - eqv of different but similar match objects
            ok 956 - :$<foo> returns a pair
            ok 957 - its key is "foo"
            ok 958 - the pairs value is a defined match object
            ok 959 - current match state
            ok 960 - got right type
            ok 961 - .pos
            ok 962 - $/.keys returns both positional and associative captures
                1..2
                ok 1 - return value is a Match object
                ok 2 - return value contains right result
            ok 963 - can smartmatch against regexes stored in variables
            ok 964 - sanity
            ok 965 - non-Str orig
            ok 966 - .prematch on non-Str
            ok 967 - .postmatch on non-Str
            ok 968 - sanity
            not ok 969 - .orig retains the type (NFD) # TODO $/.orig on NFD matches
            # Failed test '.orig retains the type (NFD)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-capture/match-object.rakudo line 99
            # Actual type: Str
            ok 970 - NFD: $/ is set in Regex.ACCEPTS
                1..8
                ok 1 - &infix:<~~>
                ok 2 - Str.match
                ok 3 - Cool.match
                ok 4 - Str.subst
                ok 5 - Cool.subst
                ok 6 - Grammar.parse
                ok 7 - Grammar.subparse
                ok 8 - Grammar.parse-file
            ok 971 - $/ is set when matching in a loop
# FUDGED!
            1..11
            ok 972 - named rule ordinal capture
            ok 973 - named rule ordinal capture with abbreviated variable
            ok 974 - $/.orig works
            ok 975 - named rule named capture
            ok 976 - named rule named capture with abbreviated variable
            ok 977 - # SKIP assigning to match object
            ok 978 - # SKIP assigning to match object
            ok 979 - grammar sanity
            ok 980 - right keys in top level match
            ok 981 - $<b> has no captures
            ok 982 - can capture inside a || alternation even if previous capture was quantified (RT  \#107746)
# FUDGED!
            1..8
            ok 983 - call rule with positional argument
            ok 984 - call rule with positional argument
            ok 985 - call rule with named argument
            ok 986 - call rule with named argument
            ok 987 - read token from grammar namespace
            ok 988 - # SKIP Method "speaker" not found for invocant of class "Cursor"
            ok 989 - # SKIP Method "speaker" not found for invocant of class "Cursor"
            ok 990 - lookbehind that should not match does not match
# FUDGED!
            1..35
            not ok 991 - don't let a Mu based action method fail the parse # TODO RT #77350
            # Failed test 'don't let a Mu based action method fail the parse'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-grammar/inheritance.rakudo line 18
            # expected: 'so'
            #      got: (Nil)
            ok 992 - got right match (foo)
            ok 993 - got the right match through .parse TOP
            ok 994 - got the right match through .parse foo
            ok 995 - grammar isa Grammar
            ok 996 - inherited grammar still isa Grammar
            ok 997 - child isa parent
            ok 998 - got right match (bar)
            ok 999 - got right match (foo)
            ok 1000 - got right match (any)
            ok 1001 - got right match (any)
            ok 1002 - can parse foo through .parsed and inherited subrule
            ok 1003 - got right match (bar)
            ok 1004 - got right match (foo)
            ok 1005 - got right match (any)
            ok 1006 - got right match (any)
            ok 1007 - No match for bad input (any)
            ok 1008 - got right match
            ok 1009 - got right match
            ok 1010 - got right match
            ok 1011 - got right match
            ok 1012 - got right match
            ok 1013 - got right match
            ok 1014 - got right match (baz)
            ok 1015 - got right match (foo)
            ok 1016 - got right match (bar)
            ok 1017 - got right match (any)
            ok 1018 - got right match (any)
            ok 1019 - got right match (any)
            ok 1020 - No match for bad input (any)
            not ok 1021 - A grammar isa Grammar, even if inherting from a class # TODO automatic Grammar superclass
            # Failed test 'A grammar isa Grammar, even if inherting from a class'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-grammar/inheritance.rakudo line 71
            # Actual type: Abyss::Server::Mod::B
            ok 1022 - Grammar.WHAT.gist = Grammar()
            ok 1023 - did the array initialize ok
            ok 1024 - does it have the right type
            ok 1025 - does it type check ok
# FUDGED!
            1..31
            ok 1026 - can parse with proto regexes (1)
            ok 1027 - and matched the full string
            ok 1028 - got the right name of the capture
            ok 1029 - also works with $/
            ok 1030 - can parse with second alternative
            ok 1031 - can parse third second alternative
            ok 1032 - does not match sym of third alternative
            ok 1033 - does not match completely unrelated string
            ok 1034 - does not match empty string
            ok 1035 - can parse symbol inside double-angles
            ok 1036 - can parse with action methods
            ok 1037 - action method got called, make() worked
            ok 1038 - LTM picks longest literal
            ok 1039 - LTM picks longest with char classes
            ok 1040 - ...and it not just luck with ordering
            ok 1041 - LTM works with things like \d
            ok 1042 - ...and negated ones like \W
            ok 1043 - LTM and ? quantifier
            ok 1044 - LTM, ? and + quantifiers
            ok 1045 - LTM and * quantifier
            ok 1046 - :my declarations do not terminate LTM
            ok 1047 - Positional captures do not terminate LTM
            ok 1048 - Named captures do not terminate LTM
            ok 1049 - <?{...}> does not terminate LTM
            ok 1050 - <!{...}> does not terminate LTM
            ok 1051 - However, code blocks do terminate LTM
            ok 1052 - num parse
            ok 1053 - id parse
            ok 1054 - term parse
            not ok 1055 - <ident> override # TODO RT #120146
            # Failed test '<ident> override'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-grammar/protoregex.rakudo line 147
            # expected: '-my_id'
            #      got: ''
            not ok 1056 - <ident> alias # TODO RT #120146
            # Failed test '<ident> alias'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-grammar/protoregex.rakudo line 148
            # expected: '-my_id'
            #      got: ''
# FUDGED!
            1..12
            ok 1057 - basic sanity with custom <ws> rules
            ok 1058 - correct text captured
            ok 1059 - implicit <.ws> is overridden
            ok 1060 - implicit <.ws> did not capture
            ok 1061 - explicit <.ws> is overridden
            ok 1062 - explicit <.ws> did not capture
            ok 1063 - explicit  <ws> is overridden
            ok 1064 - explicit  <ws> did capture
            ok 1065 - match <ws>  against empty string
            ok 1066 - match <ws>? against empty string
            ok 1067 - # SKIP infinite loop: RT  \#64094 (noauto)
            ok 1068 - # SKIP infinite loop: RT  \#64094 (noauto)
# FUDGED!
            1..65
            ok 1069 - Simple scalar match 1
            ok 1070 - Simple scalar match 2
            ok 1071 - Simple scalar match 3
            ok 1072 - Nested scalar match 1
            ok 1073 - Nested scalar match 2
            ok 1074 - Nested scalar match 3
            ok 1075 - Rulish scalar match 1
            ok 1076 - Rulish scalar match 2
            ok 1077 - Rulish scalar match 3
            ok 1078 - Rulish scalar match 4
            ok 1079 - Rulish scalar match 5
            ok 1080 - Rulish scalar match 6
            ok 1081 - Rulish scalar match 7
            ok 1082 - match with string as rx works
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::SecurityPolicy)
            ok 1083 - particular garbage-in recognized as being garbage (see RT)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::SecurityPolicy)
            ok 1084 - dynamic lookups are restricted regex syntax
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 1085 - dynamic longname lookups are restricted regex syntax
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 1086 - dynamic longname lookups are restricted regex syntax (::)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 1087 - dynamic longname lookups are restricted regex syntax (2)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 1088 - dynamic regex aliases fail somehow
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::Syntax::Regex::Alias::LongName)
            ok 1089 - dynamic regex longname aliases fail specifically
            ok 1090 - returns true
            ok 1091 - returns a valid Match
            ok 1092 - returns correct Match
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::SecurityPolicy)
            ok 1093 - should handle this too
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::SecurityPolicy)
            ok 1094 - should handle this too
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::SecurityPolicy)
            ok 1095 - should handle this too
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::SecurityPolicy)
            ok 1096 - should handle this too
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::SecurityPolicy)
            ok 1097 - should handle this too
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::SecurityPolicy)
            ok 1098 - should handle this too
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::SecurityPolicy)
            ok 1099 - should handle this too
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::SecurityPolicy)
            ok 1100 - should handle this too
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::SecurityPolicy)
            ok 1101 - should handle this too
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::SecurityPolicy)
            ok 1102 - should handle this too
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::SecurityPolicy)
            ok 1103 - should handle this too
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::SecurityPolicy)
            ok 1104 - should handle this too
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::SecurityPolicy)
            ok 1105 - should handle this too
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::SecurityPolicy)
            ok 1106 - should handle this too
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::Syntax::Regex::Alias::LongName)
            ok 1107 - longname aliases fail specifically (unrestricted ::)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::Syntax::Regex::Alias::LongName)
            ok 1108 - dynamic longname aliases fail specifically (unrestricted ::)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::Syntax::Regex::Alias::LongName)
            ok 1109 - longname aliases fail specifically (unrestricted)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::Syntax::Regex::Alias::LongName)
            ok 1110 - dynamic longname aliases fail specifically (unrestricted)
            ok 1111 - Simple array match (a)
            ok 1112 - Simple array match (b)
            ok 1113 - Simple array match (c)
            ok 1114 - Simple array match (d)
            ok 1115 - Simple array match (!)
            ok 1116 - Nested array match (a)
            ok 1117 - Nested array match (e)
            ok 1118 - Match from correct position
            ok 1119 - Multiple array matching
            ok 1120 - Multiple array non-matching
            ok 1121 - Multiple array non-compiling
            ok 1122 - Multiple array compiling
            ok 1123 - Multiple array non-compiling
            ok 1124 - Multiple array compiling
                1..2
                ok 1 - '/%var/' died
                ok 2 - right exception type (X::Syntax::Reserved)
            ok 1125 - cannot interpolate hashes into regexes
                1..2
                ok 1 - 'm/%var/' died
                ok 2 - right exception type (X::Syntax::Reserved)
            ok 1126 - cannot interpolate hashes into regexes
                1..2
                ok 1 - 'my $x = { a => 1 }; "a" ~~ m/$x/' died
                ok 2 - right exception type (X::Syntax::Reserved)
            ok 1127 - cannot interpolate hashes into regexes, runtime
                1..2
                ok 1 - 'my $x := { a => 1 }; "a" ~~ m/$x/' died
                ok 2 - right exception type (X::Syntax::Reserved)
            ok 1128 - cannot interpolate hashes into regexes, runtime (binding)
            ok 1129 - undefined variable does not match
            not ok 1130 - interpolating undefined into a regex warns # TODO warn on undef
            # Failed test 'interpolating undefined into a regex warns'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-interpolation/regex-in-variable.rakudo line 137
            #      got err: ""
                1..3
                ok 1 - code dies
                ok 2 - right exception type (X::Attribute::Regex)
                ok 3 - .symbol matches $!a
            ok 1131 - Cannot interpolate attribute in a regex
                1..3
                ok 1 - code dies
                ok 2 - right exception type (X::Attribute::Regex)
                ok 3 - .symbol matches $!b
            ok 1132 - Cannot interpolate attribute in a regex in angle construct
                1..3
                ok 1 - code dies
                ok 2 - right exception type (X::Attribute::Regex)
                ok 3 - .symbol matches $!c
            ok 1133 - Cannot interpolate attribute in a closure in a regex
# FUDGED!
            1..19
            ok 1134 - Can match in an if block
            ok 1135 - ... and can use the match var
            ok 1136 - $/ is a dynamic lexical, so it is set outside that block.
            ok 1137 - Can match in a while block
            ok 1138 - ... and can use the match var
            ok 1139 - Can match in a bare block
            ok 1140 - ... and can use the match var
            ok 1141 - Can match in a do block
            ok 1142 - ... and can use the match var
            ok 1143 - Can match in the condition of a while loop
            ok 1144 - ... and can use $/ in the block
Use of Nil in string context
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-match/blocks.rakudo line 55
            not ok 1145 - ... and can use $/ outside the block # TODO Assignment to matched string affects earlier match objects
            # Failed test '... and can use $/ outside the block'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-match/blocks.rakudo line 55
            # expected: 'b'
            #      got: ''
            ok 1146 - Can match in the condition of an if statement
            ok 1147 - ... and can use $/ outside the block
            ok 1148 - $/ is properly set with explicit $_ in a given { } block
            ok 1149 - $/ is properly set in a given { } block
            ok 1150 - /foo/ matched against $_ (successfully)
            ok 1151 - /not/ matched against $_ (no match)
            ok 1152 - match in /if/;
# FUDGED!
Potential difficulties:
    Space is not significant here; please use quotes or :s (:sigspace) modifier (or, to suppress this warning, omit the space, or otherwise change the spacing)
    at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-match/capturing-contexts.rakudo:11
    ------> [32m$match = 'abd' ~~ m/ (a) (b) c || (\w) b[33m⏏[31m d /;[0m
    Space is not significant here; please use quotes or :s (:sigspace) modifier (or, to suppress this warning, omit the space, or otherwise change the spacing)
    at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-match/capturing-contexts.rakudo:25
    ------> [32m  'abd' ~~ m/ (a) (b) c || (\w) b[33m⏏[31m d /;[0m
    Space is not significant here; please use quotes or :s (:sigspace) modifier (or, to suppress this warning, omit the space, or otherwise change the spacing)
    at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-match/capturing-contexts.rakudo:35
    ------> [32mbd' ~~ m/ <alpha> <alpha> c || <alpha> b[33m⏏[31m d /;[0m
            1..64
            ok 1153 - Match object returned
            ok 1154 - Match object assigned to $/
            ok 1155 - Same match objects
            ok 1156 - Failed match returns Nil
            ok 1157 - positional capture accessible
            ok 1158 - array context - correct number of positional captures
            ok 1159 - array context - correct number of positional captures
            ok 1160 - the .list methods returns a list object
            ok 1161 - named capture accessible
            ok 1162 - hash context - correct number of named captures
            ok 1163 - hash context - named capture accessible
            ok 1164 - the .hash method returns a hash object
            ok 1165 - get rule result
            ok 1166 - match copy should be same as match
            ok 1167 - match list stringifies like a normal list
            ok 1168 - ... and it is Positional
            ok 1169 - match list stringifies like a normal list AFTER "isa"
            ok 1170 - match element [0][0] from /(.)+/
            ok 1171 - match element [0][1] from /(.)+/
            ok 1172 - match element [0][0] from /(.)+/ coerced
            ok 1173 - match element [0][1] from /(.)+/ coerced
            ok 1174 - Match coerced to Hash says match exists
            ok 1175 - undefined capture does not match
            not ok 1176 - match with undefined capture emits a warning # TODO referring to non-existing capture
            # Failed test 'match with undefined capture emits a warning'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-match/capturing-contexts.rakudo line 95
            #      got err: ""
assign requires a concrete object (got a Rakudo::Internals::LoweredAwayLexical type object instead)
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-match/capturing-contexts.rakudo line 104
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-match/capturing-contexts.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

            1..10
            ok 1177 - Regex matches (1)
            ok 1178 - $/.raku lives (with named captures
            ok 1179 - ... and it reproduces the right thing (1)
            ok 1180 -  right result (2)
            ok 1181 - Regex matches (2)
            ok 1182 - lives on quantified named captures
            ok 1183 - # SKIP <foo::bar>
            ok 1184 - # SKIP <foo::bar>
            ok 1185 - # SKIP <foo::bar>
            ok 1186 - # SKIP <foo::bar>
# FUDGED!
            1..12
            ok 1187 - can match and execute a closure
            ok 1188 - could access and update outer lexicals
            ok 1189 - # SKIP assignment to match variables (dubious)
            ok 1190 - # SKIP assignment to match variables (dubious)
            ok 1191 - Outer match
            ok 1192 - Outer caught
            ok 1193 - # SKIP assignment to match variables (dubious)
            ok 1194 - # SKIP assignment to match variables (dubious)
            ok 1195 - # SKIP assignment to match variables (dubious)
            ok 1196 - Zero match
            not ok 1197 - Zero matched # TODO make() inside closure
            # Failed test 'Zero matched'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-metachars/closure.rakudo line 48
            # expected: 'BC'
            #      got: 'abc'
            ok 1198 - One matched
# FUDGED!
            1..95
            ok 1199 - leading whitespace quotes words (space)
            ok 1200 - leading whitespace quotes words (tab)
                1..2
                ok 1 - '"aaaa" ~~ /<a aa>/' died
                ok 2 - right exception type (X::Method::NotFound)
            ok 1201 - <...> without whitespace calls a method (not quote words)
            ok 1202 - degenerate case of quote list
            ok 1203 - capturing grammatical assertion (1)
            ok 1204 - capturing grammatical assertion (2)
            ok 1205 - can call regexes which dashes (positive)
            ok 1206 - can call regexes which dashes (negative)
            ok 1207 - can call regex with hypen (positive)
            ok 1208 - can call regex with hypen (negative)
            ok 1209 - # SKIP <test()> NYI
            ok 1210 - # SKIP <test()> NYI
            ok 1211 - basic <foo=bar> aliasing
            ok 1212 - alias works
            ok 1213 - alias does not throw away original name
            ok 1214 - basic <foo=.bar> aliasing
            ok 1215 - alias works
            ok 1216 - alias does throw away original name
            ok 1217 - <foo=.bar>
            ok 1218 - =. renaming worked
            ok 1219 - =. removed the old capture name
            ok 1220 - <foo=[bao]>
            ok 1221 - =[...] renaming worked
            ok 1222 - <bar=-[bao]>
            ok 1223 - =[...] renaming worked
            ok 1224 - <foo=:Letter>
            ok 1225 - =:UniProp renaming worked
            ok 1226 - <bar=:!Letter>
            ok 1227 - =:!UniProp renaming worked
            ok 1228 - <baz=-:Letter>
            ok 1229 - =-:UniProp renaming worked
            ok 1230 - # SKIP angle quotes in regexes
            ok 1231 - # SKIP angle quotes in regexes
            ok 1232 - # SKIP colon arguments NYI
                1..2
                ok 1 - '"foo" ~~ /<test*>/' died
                ok 2 - right exception type (Exception)
            ok 1233 - no other characters are allowed (*)
                1..2
                ok 1 - '"foo" ~~ /<test|>/' died
                ok 2 - right exception type (Exception)
            ok 1234 - no other characters are allowed (|)
                1..2
                ok 1 - '"foo" ~~ /<test&>/' died
                ok 2 - right exception type (Exception)
            ok 1235 - no other characters are allowed (&)
                1..2
                ok 1 - '"foo" ~~ /<test:>/' died
                ok 2 - right exception type (Exception)
            ok 1236 - no other characters are allowed (:)
            ok 1237 - leading . prevents capturing
            ok 1238 - <.$foo> syntax placeholder
            ok 1239 - <$whatever> subrule (Regex, 1)
            ok 1240 - <$whatever> subrule (String, 1)
            ok 1241 - <$whatever> subrule (Regex, 2)
            ok 1242 - <$whatever> subrule (String, 2)
            ok 1243 - <::($name)> symbolic indirect subrule
            ok 1244 - strings are treated as a subrule in <@foo>
            ok 1245 - Regexes are left alone in <@foo> subrule
            ok 1246 - # SKIP The use of a hash as an assertion is reserved.
            ok 1247 - # SKIP The use of a hash as an assertion is reserved.
            ok 1248 - code interpolation
            ok 1249 - # SKIP <&foo()> NYI
            ok 1250 - code inside string was executed
            not ok 1251 - string value was cached # TODO <$subrule> NYI
            # Failed test 'string value was cached'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-metasyntax/angle-brackets.rakudo line 216
            # expected: '1'
            #      got: '2'
            ok 1252 - <?{...}> works
            ok 1253 - <?{...}> works
            ok 1254 - <!{...}> works
            ok 1255 - <!{...}> works
            ok 1256 - Can use contextuals with <?{...}>
            ok 1257 - <!alpha> matches non-letter characters
            ok 1258 - <!alpha> does not match letter characters
            ok 1259 - <!before>
            ok 1260 - <!before 2> does not capture
            ok 1261 - positive zero-width assertion
                1..2
                ok 1 - '"foo" ~~ /<...>/' died
                ok 2 - right exception type (Exception)
            ok 1262 - <...> dies in regex match
            ok 1263 - <???> lives in regex match
                1..2
                not ok 1 - '"foo" ~~ /<!!!>/' died # TODO !!! in regexes
                # Failed test ''"foo" ~~ /<!!!>/' died'
                # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-metasyntax/angle-brackets.rakudo line 260
                ok 2 - # SKIP Code did not die, can not check exception
            not ok 1264 - <!!!> dies in regex match # TODO !!! in regexes
            # Failed test '<!!!> dies in regex match'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-metasyntax/angle-brackets.rakudo line 260
            ok 1265 - # SKIP <*literal>
            ok 1266 - # SKIP <*literal>
            ok 1267 - # SKIP <*literal>
            ok 1268 - # SKIP <*literal>
            ok 1269 - # SKIP <*literal>
            ok 1270 - # SKIP <*literal>
            ok 1271 - # SKIP <*literal>
            ok 1272 - # SKIP <*literal>
            ok 1273 - # SKIP <*literal>
            ok 1274 - # SKIP <*literal>
            ok 1275 - # SKIP <*literal>
            ok 1276 - recursive regex using whole pattern
            ok 1277 - # SKIP <~~ ... >
            ok 1278 - <(...)> pair
            ok 1279 - <( match
            ok 1280 - )> match
            ok 1281 - non-matching <(...)>
            ok 1282 - <( in backtracking
            ok 1283 - multiple <(
            ok 1284 - multiple <( backtracking
            ok 1285 - .comb works well with <( )> (1)
            ok 1286 - .comb works well with <( )> (2)
            ok 1287 - .match :as(Str) works with <( )>
            ok 1288 - left word boundary (string beginning)
            ok 1289 - left word boundary (\W character)
            ok 1290 - right word boundary (string end)
            ok 1291 - right word boundary (\W character)
            ok 1292 - both word boundaries (\W character)
            ok 1293 - Interaction of quantifier, <(, )>, and action method ok
# FUDGED!
Potential difficulties:
    Space is not significant here; please use quotes or :s (:sigspace) modifier (or, to suppress this warning, omit the space, or otherwise change the spacing)
    at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-metasyntax/interpolating-closure.rakudo:19
    ------> [32mmy regex abc { a[33m⏏[31m b c }[0m
    Space is not significant here; please use quotes or :s (:sigspace) modifier (or, to suppress this warning, omit the space, or otherwise change the spacing)
    at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-metasyntax/interpolating-closure.rakudo:19
    ------> [32mmy regex abc { a b[33m⏏[31m c }[0m
    Redeclaration of symbol '$a'.
    at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-metasyntax/interpolating-closure.rakudo:44
    ------> [32mis '123' ~~ / :my $a[33m⏏[31m=2; <{ '$' ~ 'a' }> /, '2', 'stage of va[0m
    Redeclaration of symbol '$a'.
    at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-metasyntax/interpolating-closure.rakudo:47
    ------> [32mis '123' ~~ / :my $a[33m⏏[31m=rx[2]; <{ '$a' }> /, '2', 'stage of var[0m
            1..10
            ok 1294 - Rule block second
            ok 1295 - Rule block first
            not ok 1296 - Rule block fail # TODO dunno rule block fail
            # Failed test 'Rule block fail'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-metasyntax/interpolating-closure.rakudo line 30
            ok 1297 - Rule block interp
            ok 1298 - interpolating string with meta characters
            ok 1299 - ... gives the right match
            ok 1300 - sequence in a closure interpolates ok
            ok 1301 - scoping of variable in regex generated from <{}> metasyntax
            ok 1302 - stage of variable in regex generated from <{}> metasyntax
            ok 1303 - stage of variable in regex generated from <{}> metasyntax (2)
# FUDGED!
            1..62
            ok 1304 - basic sanity with |
            ok 1305 - Longest alternative wins 1
            ok 1306 - Second match still works
            ok 1307 - Longest alternative wins 2
            ok 1308 - Third match still works
            ok 1309 - Only one alternative left
            ok 1310 - No fourth match
            ok 1311 - basic sanity with |, different order
            ok 1312 - Longest alternative wins 1, different order
            ok 1313 - Second match still works, different order
            ok 1314 - Longest alternative wins 2, different order
            ok 1315 - Third match still works, different order
            ok 1316 - Only one alternative left, different order
            ok 1317 - No fourth match, different order
            ok 1318 - basic sanity with interpolated arrays
            ok 1319 - Longest alternative wins 1
            ok 1320 - Second match still works
            ok 1321 - Longest alternative wins 2
            ok 1322 - Third match still works
            ok 1323 - Only one alternative left
            ok 1324 - No fourth match
            ok 1325 - LTM - literals in tokens
            ok 1326 - LTM - literals in nested torkens
            ok 1327 - LTM - longer quantified charclass wins against shorter literal
            ok 1328 - LTM - longer quantified atom wins against shorter literal (subrules)
            ok 1329 - LTM - literal wins tie against \w*
            ok 1330 - # SKIP :: LTM stopper
            ok 1331 - implicit <.ws> stops LTM
            ok 1332 - LTM grammar - matched
            ok 1333 - LTM grammar - matched full string
            ok 1334 - was in the appropriate action methods
            ok 1335 - longer non-matcher parses
            ok 1336 - longer non-matching literal doesn't falsify shorter
            ok 1337 - Galt parses
            ok 1338 - literal from non-matching alternating subrule doesn't interfere
            ok 1339 - Gproto parses
            ok 1340 - literal from non-matching proto subrule doesn't interfere
            ok 1341 - subrule alternation with recombo matches
            ok 1342 - subrule alternation recombination doesn't confuse fates
            ok 1343 - IETF::RFC_Grammar::URI matches
            ok 1344 - IETF::RFC_Grammar::URI gets ltm and longlit right
            ok 1345 - token with huge number of alternations does not explode when used many times
            ok 1346 - alternation with :i matches
            ok 1347 - got longest alternative with :i
            ok 1348 - alternation with :m matches
            ok 1349 - got longest alternative with :m
            ok 1350 - alternation with :i:m matches
            ok 1351 - got longest alternative with :i:m
            ok 1352 - got longest alternative with constant
            ok 1353 - non constants don't count toward LTM
            ok 1354 - sequential alternation first branch involved in longest alternative (1)
            ok 1355 - sequential alternation first branch involved in longest alternative (2)
            ok 1356 - sequential alternation first branch failure after LTM tries next best option
            ok 1357 - sequential alternation branches after first not involved in LTM
            ok 1358 - \r\n grapheme in an alternation matches correctly
            not ok 1359 - negative lookahead does LTM properly # TODO negative lookahead does not LTM properly
            # Failed test 'negative lookahead does LTM properly'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-metasyntax/longest-alternative.rakudo line 462
            # expected: 'abcde'
            #      got: 'abcd'
            ok 1360 - LTM with :i, <[0..9]>, and repetition works
            ok 1361 - LTM with quantifier ** 1..2 followed by something else matches correctly
            ok 1362 - backtrack into |
            ok 1363 - don't backtrack into [ | ]:
            ok 1364 - don't backtrack into | under :r
            ok 1365 - backtrack into [ | ]:! despite :r
# FUDGED!
            1..13
                1..2
                ok 1 - '"aa!" ~~ /!/' died
                ok 2 - right exception type (X::Syntax::Regex::UnrecognizedMetachar)
            ok 1366 - "!" is not valid metasyntax
            ok 1367 - escaped "!" is valid
            ok 1368 - quoted "!" is valid
                1..2
                ok 1 - '"aa!" ~~ /\a/' died
                ok 2 - right exception type (Exception)
            ok 1369 - escaped "a" is not valid metasyntax
            ok 1370 - "a" is valid
            ok 1371 - quoted "a" is valid
            ok 1372 - \{ in a rule (+)
            ok 1373 - \{ in a rule (-)
            ok 1374 - Cannot parse regex a+ +
Use of uninitialized value $! of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-metasyntax/unknown.rakudo line 29
            not ok 1375 - error message mentions quantif{y,ier} # TODO faulty regex error
            # Failed test 'error message mentions quantif{y,ier}'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-metasyntax/unknown.rakudo line 29
                1..3
                ok 1 - '$_ = "0"; s/-/1/' died
                ok 2 - right exception type (X::Syntax::Regex::UnrecognizedMetachar)
                ok 3 - .metachar matches -
            ok 1376 - did we throws-like X::Syntax::Regex::UnrecognizedMetachar?
            ok 1377 - can parse /$'x'/
                1..3
                ok 1 - '/00:11:22/' died
                ok 2 - right exception type (X::Syntax::Regex::UnrecognizedModifier)
                ok 3 - .modifier matches 11
            ok 1378 - did we throws-like X::Syntax::Regex::UnrecognizedModifier?
# FUDGED!
WARNINGS for /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_0.rakudo:
Useless use of constant string "false" in sink context (line 96)
Useless use of constant string "true" in sink context (line 96)
            1..24
            ok 1379 - substitute regexp works
            ok 1380 - substitute regexp works with :g modifier
            ok 1381 - substitute regexp works with :g modifier
            ok 1382 - substitute regexp with capturing variables works
            ok 1383 - substitute regexp with capturing variables works with :g
            ok 1384 - Zero width replace works with :g
Can only use 'temp' on a container
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_0.rakudo line 45
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_0.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

            1..102
            ok 1385 - re_tests 609/1 (793)
            ok 1386 - re_tests 611/1 (795)
            ok 1387 - re_tests 613/1 (797)
            ok 1388 - re_tests 615/1 (799)
            ok 1389 - re_tests 617/1 (801)
            ok 1390 - re_tests 619/1 (803)
            ok 1391 - re_tests 621/1 (805)
            ok 1392 - re_tests 623/1 (807)
            ok 1393 - re_tests 625/1 (809)
            ok 1394 - re_tests 627/1 (811)
            ok 1395 - re_tests 629/1 (813)
            ok 1396 - re_tests 631/0 (815)
            ok 1397 - re_tests 633/1 (817)
            ok 1398 - re_tests 635  (819)
            ok 1399 - re_tests 637  (821)
            not ok 1400 - re_tests 639/1 (823) # TODO unknown issue
            # Failed test 're_tests 639/1 (823)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_5.rakudo line 34
            # expected: 'aaaa'
            #      got: (Nil)
            ok 1401 - re_tests 641  (825)
            ok 1402 - re_tests 643  (827)
            ok 1403 - re_tests 645/1 (829)
            ok 1404 - re_tests 647/1 (831)
            ok 1405 - re_tests 649/1 (833)
            ok 1406 - re_tests 651/0 (835)
            ok 1407 - re_tests 653  (837)
            ok 1408 - re_tests 655  (839)
            ok 1409 - re_tests 657/0 (841)
            ok 1410 - re_tests 659  (843)
            ok 1411 - re_tests 661  (845)
            ok 1412 - re_tests 663/0 (847)
            ok 1413 - re_tests 665/0 (849)
            ok 1414 - re_tests 667/0 (851)
            not ok 1415 - re_tests 669/0 (853) # TODO unknown issue
            # Failed test 're_tests 669/0 (853)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_5.rakudo line 51
            # expected: 'ab'
            #      got: (Nil)
            ok 1416 - re_tests 671/1 (855)
            ok 1417 - re_tests 673/1 (857)
            ok 1418 - re_tests 675/1 (859)
            ok 1419 - re_tests 677/0 (861)
            ok 1420 - re_tests 679/0 (863)
            ok 1421 - re_tests 679/1 (864)
            ok 1422 - re_tests 681/0 (867)
            ok 1423 - re_tests 683/0 (869)
            ok 1424 - re_tests 683/1 (870)
            ok 1425 - re_tests 685  (873)
            ok 1426 - re_tests 687  (875)
            ok 1427 - re_tests 689/0 (877)
            ok 1428 - re_tests 691/0 (879)
            ok 1429 - re_tests 691/1 (880)
            ok 1430 - re_tests 693/0 (883)
            ok 1431 - re_tests 695/0 (885)
            ok 1432 - re_tests 695/1 (886)
            ok 1433 - re_tests 697  (889)
            ok 1434 - re_tests 699  (891)
            ok 1435 - re_tests 701/0 (893)
            ok 1436 - re_tests 702/0 (894)
            ok 1437 - re_tests 702/1 (895)
            ok 1438 - re_tests 703/0 (896)
            ok 1439 - re_tests 704/0 (897)
            ok 1440 - re_tests 704/1 (898)
            ok 1441 - re_tests 705  (899)
            ok 1442 - re_tests 706  (900)
            ok 1443 - re_tests 707/0 (901)
            ok 1444 - re_tests 708/1 (902)
            ok 1445 - re_tests 709  (903)
            ok 1446 - re_tests 710  (904)
            ok 1447 - re_tests 711/0 (905)
            ok 1448 - re_tests 712/0 (906)
            ok 1449 - re_tests 712/1 (907)
            ok 1450 - re_tests 713/0 (908)
            ok 1451 - re_tests 714/0 (909)
            ok 1452 - re_tests 714/1 (910)
            ok 1453 - re_tests 715  (911)
            ok 1454 - re_tests 716  (912)
            ok 1455 - re_tests 717/0 (913)
            ok 1456 - re_tests 718/1 (914)
            ok 1457 - re_tests 719  (915)
            ok 1458 - re_tests 720  (916)
            ok 1459 - re_tests 721  (917)
            ok 1460 - re_tests 722/1 (918)
            ok 1461 - re_tests 723  (919)
            ok 1462 - re_tests 724/0 (920)
            ok 1463 - re_tests 726/0 (922)
            not ok 1464 - re_tests 728/1 (924) # TODO (?i) and backreferences
            # Failed test 're_tests 728/1 (924)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_5.rakudo line 101
            # expected: 'Ab'
            #      got: (Nil)
            not ok 1465 - re_tests 730/1 (926) # TODO (?i) and backreferences
            # Failed test 're_tests 730/1 (926)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_5.rakudo line 102
            # expected: 'ab'
            #      got: (Nil)
            ok 1466 - re_tests 732/0 (928)
            ok 1467 - re_tests 734/0 (930)
            ok 1468 - re_tests 735/0 (931)
            ok 1469 - re_tests 736  (932)
            ok 1470 - re_tests 738/0 (934)
            ok 1471 - re_tests 739/0 (935)
            ok 1472 - re_tests 740  (936)
            ok 1473 - re_tests 742/0 (938)
            ok 1474 - re_tests 744  (940)
            ok 1475 - re_tests 746/0 (942)
            ok 1476 - re_tests 748/0 (944)
            ok 1477 - # SKIP hangs
            ok 1478 - re_tests 752/1 (948)
            ok 1479 - re_tests 753/0 (949)
            ok 1480 - re_tests 754/1 (950)
            ok 1481 - re_tests 755/1 (951)
            ok 1482 - re_tests 756/1 (952)
            ok 1483 - re_tests 757/1 (953)
            ok 1484 - re_tests 758/1 (954)
            ok 1485 - re_tests 759  (955)
            ok 1486 - re_tests 761  (957)
# FUDGED!
            1..104
            ok 1487 - re_tests 763/1 (959)
            ok 1488 - re_tests 764  (960)
            ok 1489 - re_tests 766/0 (962)
            ok 1490 - re_tests 768  (964)
            ok 1491 - re_tests 770/0 (966)
            ok 1492 - re_tests 772/0 (968)
            not ok 1493 - re_tests 774  (970) # TODO needs RT
            # Failed test 're_tests 774  (970)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_6.rakudo line 25
            not ok 1494 - re_tests 776/0 (972) # TODO needs RT
            # Failed test 're_tests 776/0 (972)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_6.rakudo line 26
            # expected: 'a'
            #      got: (Nil)
            not ok 1495 - re_tests 778/2 (974) # TODO needs RT
            # Failed test 're_tests 778/2 (974)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_6.rakudo line 27
            # expected: ')'
            #      got: (Nil)
            ok 1496 - re_tests 780  (976)
            ok 1497 - re_tests 782  (978)
            not ok 1498 - re_tests 784/2 (980) # TODO needs RT
            # Failed test 're_tests 784/2 (980)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_6.rakudo line 31
            # expected: ')'
            #      got: (Nil)
            ok 1499 - re_tests 786  (982)
            ok 1500 - re_tests 788  (984)
            ok 1501 - re_tests 790  (986)
            ok 1502 - re_tests 791/0 (987)
            not ok 1503 - re_tests 792  (988) # TODO needs RT
            # Failed test 're_tests 792  (988)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_6.rakudo line 37
            not ok 1504 - re_tests 793/0 (989) # TODO needs RT
            # Failed test 're_tests 793/0 (989)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_6.rakudo line 38
            # expected: 'a'
            #      got: (Nil)
            ok 1505 - re_tests 794  (990)
            ok 1506 - re_tests 795/0 (991)
            not ok 1507 - re_tests 796  (992) # TODO needs RT
            # Failed test 're_tests 796  (992)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_6.rakudo line 42
            not ok 1508 - re_tests 797/0 (993) # TODO needs RT
            # Failed test 're_tests 797/0 (993)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_6.rakudo line 43
            # expected: 'a'
            #      got: (Nil)
            not ok 1509 - re_tests 798/2 (994) # TODO needs RT
            # Failed test 're_tests 798/2 (994)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_6.rakudo line 44
            # expected: 'aab'
            #      got: (Nil)
            ok 1510 - re_tests 800  (996)
            ok 1511 - re_tests 802/1 (998)
            not ok 1512 - re_tests 804/1 (1000) # TODO needs RT
            # Failed test 're_tests 804/1 (1000)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_6.rakudo line 48
            # expected: 'a'
            #      got: (Nil)
            not ok 1513 - re_tests 806/2 (1002) # TODO needs RT
            # Failed test 're_tests 806/2 (1002)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_6.rakudo line 49
            # expected: 'aab'
            #      got: (Nil)
            ok 1514 - re_tests 808  (1004)
            ok 1515 - re_tests 810  (1006)
            ok 1516 - re_tests 812/1 (1008)
            ok 1517 - re_tests 812/2 (1009)
            ok 1518 - re_tests 814/1 (1012)
            ok 1519 - re_tests 814/2 (1013)
            ok 1520 - re_tests 816/1 (1016)
            ok 1521 - re_tests 818/1 (1018)
            ok 1522 - re_tests 820  (1020)
            ok 1523 - re_tests 822/1 (1022)
            ok 1524 - re_tests 822/2 (1023)
            ok 1525 - re_tests 824/1 (1026)
            ok 1526 - re_tests 824/2 (1027)
            ok 1527 - re_tests 826/1 (1030)
            ok 1528 - re_tests 828  (1032)
            not ok 1529 - re_tests 829  (1033) # TODO needs RT
            # Failed test 're_tests 829  (1033)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_6.rakudo line 66
            ok 1530 - re_tests 831/1 (1035)
            ok 1531 - re_tests 832/1 (1036)
            ok 1532 - re_tests 833/1 (1037)
            ok 1533 - re_tests 834/0 (1038)
            ok 1534 - re_tests 835/0 (1039)
            not ok 1535 - re_tests 836/1 (1040) # TODO needs RT
            # Failed test 're_tests 836/1 (1040)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_6.rakudo line 73
            # expected: 'aaab'
            #      got: (Nil)
            not ok 1536 - re_tests 838/1 (1042) # TODO needs RT
            # Failed test 're_tests 838/1 (1042)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_6.rakudo line 74
            # expected: 'aaa'
            #      got: (Nil)
            not ok 1537 - re_tests 840/0 (1044) # TODO needs RT
            # Failed test 're_tests 840/0 (1044)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_6.rakudo line 75
            # expected: 'abc(ade)ufh()()x'
            #      got: '(ade)'
            ok 1538 - re_tests 842/0 (1046)
            ok 1539 - re_tests 844/0 (1048)
            ok 1540 - re_tests 846/0 (1050)
            ok 1541 - re_tests 847/0 (1051)
            ok 1542 - re_tests 849/0 (1053)
            ok 1543 - re_tests 851/0 (1055)
            ok 1544 - re_tests 852/0 (1056)
            ok 1545 - re_tests 854/0 (1058)
            ok 1546 - re_tests 856/0 (1060)
            ok 1547 - re_tests 857/0 (1061)
            ok 1548 - re_tests 858/0 (1062)
            ok 1549 - re_tests 859/0 (1063)
            ok 1550 - re_tests 860/0 (1064)
            ok 1551 - re_tests 861/0 (1065)
            ok 1552 - re_tests 862/0 (1066)
            ok 1553 - re_tests 863/0 (1067)
            ok 1554 - re_tests 864/0 (1068)
            ok 1555 - re_tests 865/0 (1069)
            ok 1556 - re_tests 866  (1070)
            ok 1557 - re_tests 868  (1072)
            ok 1558 - re_tests 870  (1074)
            ok 1559 - re_tests 871/0 (1075)
            ok 1560 - re_tests 873  (1077)
            ok 1561 - re_tests 875/0 (1079)
            ok 1562 - re_tests 876/0 (1080)
            ok 1563 - re_tests 878/0 (1082)
            ok 1564 - re_tests 880/0 (1084)
            ok 1565 - re_tests 881  (1085)
            ok 1566 - re_tests 882  (1086)
            ok 1567 - re_tests 883/0 (1087)
            ok 1568 - re_tests 884/0 (1088)
            ok 1569 - re_tests 885  (1089)
            ok 1570 - re_tests 886/0 (1090)
            ok 1571 - re_tests 887/0 (1091)
            ok 1572 - re_tests 888/0 (1092)
            ok 1573 - re_tests 889/0 (1093)
            ok 1574 - re_tests 890  (1094)
            ok 1575 - re_tests 892  (1096)
            ok 1576 - re_tests 894  (1098)
            ok 1577 - re_tests 895/0 (1099)
            ok 1578 - re_tests 897  (1101)
            ok 1579 - re_tests 899/0 (1103)
            ok 1580 - re_tests 900/0 (1104)
            ok 1581 - re_tests 902/0 (1106)
            ok 1582 - re_tests 904/0 (1108)
            ok 1583 - re_tests 905  (1109)
            ok 1584 - re_tests 906  (1110)
            ok 1585 - re_tests 907/0 (1111)
            ok 1586 - re_tests 908/0 (1112)
            ok 1587 - re_tests 909  (1113)
            ok 1588 - re_tests 910/0 (1114)
            ok 1589 - re_tests 911/0 (1115)
            ok 1590 - re_tests 912/0 (1116)
# FUDGED!
            1..103
            ok 1591 - re_tests 1049  (1253)
            ok 1592 - re_tests 1050  (1254)
            ok 1593 - re_tests 1051/0 (1255)
            ok 1594 - re_tests 1052/0 (1256)
            ok 1595 - re_tests 1053  (1257)
            ok 1596 - re_tests 1054/0 (1258)
            ok 1597 - re_tests 1055/0 (1259)
            ok 1598 - re_tests 1056/0 (1260)
            ok 1599 - re_tests 1057/0 (1261)
            ok 1600 - re_tests 1058  (1262)
            ok 1601 - re_tests 1060  (1264)
            ok 1602 - re_tests 1062  (1266)
            ok 1603 - re_tests 1063  (1267)
            ok 1604 - re_tests 1065  (1269)
            ok 1605 - re_tests 1067  (1271)
            ok 1606 - re_tests 1068  (1272)
            ok 1607 - re_tests 1070  (1274)
            ok 1608 - re_tests 1072  (1276)
            ok 1609 - re_tests 1073  (1277)
            ok 1610 - re_tests 1074  (1278)
            ok 1611 - re_tests 1075  (1279)
            ok 1612 - re_tests 1076  (1280)
            ok 1613 - re_tests 1077  (1281)
            ok 1614 - re_tests 1078  (1282)
            ok 1615 - re_tests 1079  (1283)
            ok 1616 - re_tests 1080  (1284)
            ok 1617 - re_tests 1081  (1285)
            ok 1618 - re_tests 1082  (1286)
            ok 1619 - re_tests 1084  (1288)
            ok 1620 - re_tests 1086  (1290)
            ok 1621 - re_tests 1087  (1291)
            ok 1622 - re_tests 1089  (1293)
            ok 1623 - re_tests 1091  (1295)
            ok 1624 - re_tests 1092  (1296)
            ok 1625 - re_tests 1094  (1298)
            ok 1626 - re_tests 1096  (1300)
            ok 1627 - re_tests 1097  (1301)
            ok 1628 - re_tests 1098  (1302)
            ok 1629 - re_tests 1099  (1303)
            ok 1630 - re_tests 1100  (1304)
            ok 1631 - re_tests 1101  (1305)
            ok 1632 - re_tests 1102  (1306)
            ok 1633 - re_tests 1103  (1307)
            ok 1634 - re_tests 1104  (1308)
            ok 1635 - re_tests 1105  (1309)
            ok 1636 - re_tests 1106/2 (1310)
            ok 1637 - re_tests 1108  (1312)
            not ok 1638 - re_tests 1110/1 (1314) # TODO (?>...) NYI
            # Failed test 're_tests 1110/1 (1314)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_8.rakudo line 68
            # expected: 'xs * sz'
            #      got: (Nil)
            ok 1639 - re_tests 1112  (1316)
            ok 1640 - re_tests 1114  (1318)
            ok 1641 - # SKIP expensive quantifier
            ok 1642 - # SKIP expensive quantifier
            ok 1643 - # SKIP expensive quantifier
            ok 1644 - # SKIP expensive quantifier
            ok 1645 - # SKIP expensive quantifier
            ok 1646 - # SKIP expensive quantifier
            ok 1647 - # SKIP expensive quantifier
            ok 1648 - # SKIP expensive quantifier
            ok 1649 - # SKIP expensive quantifier
            ok 1650 - # SKIP expensive quantifier
            ok 1651 - # SKIP expensive quantifier
            ok 1652 - # SKIP expensive quantifier
            ok 1653 - # SKIP expensive quantifier
            ok 1654 - # SKIP expensive quantifier
            ok 1655 - # SKIP expensive quantifier
            ok 1656 - # SKIP expensive quantifier
            ok 1657 - # SKIP expensive quantifier
            ok 1658 - # SKIP expensive quantifier
            ok 1659 - re_tests 1151  (1355)
            ok 1660 - # SKIP character classes in enumerated range
            ok 1661 - # SKIP character classes in enumerated range
            ok 1662 - # SKIP character classes in enumerated range
            ok 1663 - # SKIP character classes in enumerated range
            ok 1664 - # SKIP character classes in enumerated range
            ok 1665 - # SKIP character classes in enumerated range
            ok 1666 - # SKIP \G
            ok 1667 - re_tests 1163/1 (1367)
            ok 1668 - re_tests 1165/1 (1369)
            ok 1669 - re_tests 1167  (1371)
            ok 1670 - re_tests 1169  (1373)
            ok 1671 - re_tests 1171/1 (1375)
            ok 1672 - re_tests 1173  (1377)
            ok 1673 - re_tests 1175  (1379)
            ok 1674 - re_tests 1176  (1380)
            ok 1675 - re_tests 1178  (1382)
            ok 1676 - re_tests 1180  (1384)
            ok 1677 - re_tests 1182/1 (1386)
            ok 1678 - re_tests 1184  (1388)
            ok 1679 - re_tests 1186/1 (1390)
            ok 1680 - re_tests 1188/1 (1392)
            ok 1681 - re_tests 1190/1 (1394)
            ok 1682 - re_tests 1192/1 (1396)
            ok 1683 - re_tests 1194/1 (1398)
            ok 1684 - re_tests 1196/1 (1400)
            ok 1685 - re_tests 1198/1 (1402)
            ok 1686 - re_tests 1200/1 (1404)
            ok 1687 - re_tests 1202/1 (1406)
            ok 1688 - re_tests 1204/1 (1408)
            ok 1689 - re_tests 1206/1 (1410)
            ok 1690 - re_tests 1208/1 (1412)
            ok 1691 - re_tests 1210/1 (1414)
            ok 1692 - re_tests 1212  (1416)
            ok 1693 - re_tests 1214  (1418)
# FUDGED!
            1..84
            ok 1694 - re_tests 1215  (1419)
            ok 1695 - re_tests 1216  (1420)
            ok 1696 - re_tests 1218/1 (1422)
            ok 1697 - re_tests 1220  (1424)
            ok 1698 - re_tests 1222  (1426)
            ok 1699 - re_tests 1224/1 (1428)
            ok 1700 - re_tests 1226/1 (1430)
            ok 1701 - re_tests 1228  (1432)
            ok 1702 - re_tests 1230  (1434)
            ok 1703 - re_tests 1232/1 (1436)
            ok 1704 - re_tests 1232/2 (1437)
            ok 1705 - re_tests 1234/1 (1440)
            ok 1706 - re_tests 1234/2 (1441)
            ok 1707 - re_tests 1236/1 (1444)
            ok 1708 - re_tests 1236/2 (1445)
            ok 1709 - re_tests 1238  (1448)
            ok 1710 - re_tests 1239  (1449)
            ok 1711 - re_tests 1241/2 (1451)
            ok 1712 - re_tests 1242  (1452)
            not ok 1713 - re_tests 1244  (1454) # TODO test file needs review
            # Failed test 're_tests 1244  (1454)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_9.rakudo line 39
            not ok 1714 - re_tests 1246/2 (1456) # TODO test file needs review
            # Failed test 're_tests 1246/2 (1456)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_9.rakudo line 40
            # expected: ''
            #      got: 'CD'
            not ok 1715 - re_tests 1246/3 (1457) # TODO test file needs review
            # Failed test 're_tests 1246/3 (1457)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_9.rakudo line 41
            # expected: 'CD'
            #      got: (Nil)
            ok 1716 - re_tests 1248/2 (1460)
            not ok 1717 - re_tests 1248/3 (1461) # TODO test file needs review
            # Failed test 're_tests 1248/3 (1461)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_9.rakudo line 45
            # expected: ''
            #      got: (Nil)
            not ok 1718 - re_tests 1250/2 (1464) # TODO test file needs review
            # Failed test 're_tests 1250/2 (1464)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_9.rakudo line 46
            # expected: ''
            #      got: 'CD'
            not ok 1719 - re_tests 1250/3 (1465) # TODO test file needs review
            # Failed test 're_tests 1250/3 (1465)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_9.rakudo line 47
            # expected: 'CD'
            #      got: (Nil)
            ok 1720 - re_tests 1252/2 (1468)
            not ok 1721 - re_tests 1252/3 (1469) # TODO test file needs review
            # Failed test 're_tests 1252/3 (1469)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_9.rakudo line 51
            # expected: ''
            #      got: (Nil)
            not ok 1722 - re_tests 1254  (1472) # TODO test file needs review
            # Failed test 're_tests 1254  (1472)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_9.rakudo line 52
            ok 1723 - re_tests 1256/1 (1474)
            ok 1724 - re_tests 1258/1 (1476)
            ok 1725 - re_tests 1259/1 (1477)
            ok 1726 - re_tests 1261/1 (1479)
            ok 1727 - re_tests 1263/1 (1481)
            ok 1728 - re_tests 1265/1 (1483)
            ok 1729 - re_tests 1267/1 (1485)
            ok 1730 - re_tests 1269/1 (1487)
            ok 1731 - re_tests 1271/1 (1489)
            ok 1732 - re_tests 1273/1 (1491)
            ok 1733 - re_tests 1275/1 (1493)
            ok 1734 - re_tests 1277/1 (1495)
            ok 1735 - re_tests 1279/1 (1497)
            ok 1736 - re_tests 1281/1 (1499)
            ok 1737 - re_tests 1283/1 (1501)
            ok 1738 - re_tests 1285/1 (1503)
            ok 1739 - re_tests 1287/1 (1505)
            ok 1740 - re_tests 1289/1 (1507)
            ok 1741 - re_tests 1291/1 (1509)
            ok 1742 - re_tests 1293/1 (1511)
            ok 1743 - re_tests 1295/1 (1513)
            ok 1744 - re_tests 1297/1 (1515)
            ok 1745 - re_tests 1299/1 (1517)
            ok 1746 - re_tests 1301/1 (1519)
            ok 1747 - re_tests 1303/1 (1521)
            ok 1748 - re_tests 1305/1 (1523)
            ok 1749 - re_tests 1307/1 (1525)
            ok 1750 - re_tests 1309/1 (1527)
            ok 1751 - re_tests 1311/1 (1529)
            ok 1752 - re_tests 1313/1 (1531)
            ok 1753 - re_tests 1315/1 (1533)
            ok 1754 - re_tests 1317/1 (1535)
            ok 1755 - re_tests 1319/1 (1537)
            ok 1756 - re_tests 1321/1 (1539)
            ok 1757 - re_tests 1323/1 (1541)
            ok 1758 - re_tests 1325/1 (1543)
            ok 1759 - re_tests 1327/0 (1545)
            not ok 1760 - re_tests 1329  (1547) # TODO test file needs review
            # Failed test 're_tests 1329  (1547)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/Perl_9.rakudo line 92
            ok 1761 - re_tests 1330/1 (1548)
            ok 1762 - re_tests 1332/1 (1550)
            ok 1763 - re_tests 1334/1 (1552)
            ok 1764 - re_tests 1336/1 (1554)
            ok 1765 - re_tests 1338/1 (1556)
            ok 1766 - re_tests 1340/1 (1558)
            ok 1767 - re_tests 1342/1 (1560)
            ok 1768 - re_tests 1344/1 (1562)
            ok 1769 - re_tests 1346/1 (1564)
            ok 1770 - re_tests 1348/1 (1566)
            ok 1771 - re_tests 1350/1 (1568)
            ok 1772 - re_tests 1352/1 (1570)
            ok 1773 - re_tests 1354/1 (1572)
            ok 1774 - re_tests 1356/1 (1574)
            ok 1775 - re_tests 1358/1 (1576)
            ok 1776 - re_tests 1360/1 (1578)
            ok 1777 - re_tests 1362  (1580)
# FUDGED!
            1..23
            ok 1778 - :ii modifier: Hello ~~ s:ii/.*/foo/ => Foo
            ok 1779 - :ii modifier: hEllo ~~ s:ii/.*/foo/ => fOo
            ok 1780 - :ii modifier: A ~~ s:ii/.*/foo/ => FOO
            ok 1781 - :ii modifier: AA ~~ s:ii/.*/foo/ => FOO
            ok 1782 - :ii modifier: a b ~~ s:ii/.*/FOO/ => fOo
            ok 1783 - :ii modifier: a b ~~ s:ii/.*/FOOB/ => fOob
            ok 1784 - :ii modifier: Ab  ~~ s:ii/.*/ABCDE/ => AbCDE
            ok 1785 - :ii modifier: aB  ~~ s:ii/.*/abcde/ => aBcde
            ok 1786 - :ii modifier: aB  ~~ s:ii/.*/ABCDE/ => aBCDE
            ok 1787 - :i:ii:sigspace modifier: HELLO ~~ s:ii:s/.*/foo/ => FOO
            ok 1788 - :i:ii:sigspace modifier: hello ~~ s:ii:s/.*/fOo/ => foo
            ok 1789 - :i:ii:sigspace modifier: he lo ~~ s:ii:s/.*/FOOOoO/ => fooooo
            ok 1790 - :i:ii:sigspace modifier: He lo ~~ s:ii:s/.*/FOOO/ => Fooo
            ok 1791 - :i:ii:sigspace modifier: hE LO ~~ s:ii:s/.*/fooo/ => fOOO
            ok 1792 - :i:ii:sigspace modifier: hE LO ~~ s:ii:s/.*/foobar/ => fOOBAR
            ok 1793 - :i:ii:sigspace modifier: HE LO ~~ s:ii:s/.*/foo/ => FOO
            ok 1794 - :i:ii:sigspace modifier: Ab Cd E ~~ s:ii:s/.*/abc de ghi j/ => Abc De GHI J
            ok 1795 - :i:ii:sigspace modifier: Ab CD ~~ s:ii:s/.*/abc de ghi j/ => Abc DE GHI J
            ok 1796 - :i:ii:sigspace modifier: Ab Cd ~~ s:ii:s/.*/abc de ghi j/ => Abc De Ghi J
assign requires a concrete object (got a Rakudo::Internals::LoweredAwayLexical type object instead)
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/ii.rakudo line 60
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/ii.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

            1..24
            ok 1797 - can declare :constant in regex
            ok 1798 - ... and it matched the constant
            ok 1799 - does not work with wrong text
            ok 1800 - can declare :my in regex
            ok 1801 - correct match with "my" variable
            ok 1802 - does not work with wrong text
            ok 1803 - :state in regex (match) (1)
            ok 1804 - :state in regex ($/) (1)
            ok 1805 - :state in regex (match) (2)
            ok 1806 - :state in regex ($/) (2)
            ok 1807 - :state in regex (no match)
            ok 1808 - :our in regex
            not ok 1809 - can access our variable from the outside # TODO :our variables in regexes
            # Failed test 'can access our variable from the outside'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/my.rakudo line 50
            # expected: 'zho'
            #      got: (Any)
            ok 1810 - can access variables in regex (not temp'ed)
            ok 1811 - (-) not temp'ed
            ok 1812 - temp'ed variable still 1
            ok 1813 - can access temp'ed variable in regex (+)
            ok 1814 - (-) temp'ed
            ok 1815 - temp'ed variable again 1
            ok 1816 - can detect a non-match with :let
            not ok 1817 - unsuccessful match did not affect :let variable # TODO unsuccessful match preserves :let value
            # Failed test 'unsuccessful match did not affect :let variable'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/my.rakudo line 72
            # expected: '1'
            #      got: '5'
            ok 1818 - can match changed :let variable
            ok 1819 - successful match preserves new :let value
            ok 1820 - :my terminates upon }\n
# FUDGED!
            1..40
Use of uninitialized value element of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/pos.rakudo line 16
            not ok 1821 - Matched 1: ''
            # Failed test 'Matched 1: '''
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/pos.rakudo line 16
            not ok 1822 - Interim position correct
            # Failed test 'Interim position correct'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/pos.rakudo line 17
            # expected: '3'
            #      got: (Nil)
Use of uninitialized value element of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/pos.rakudo line 18
            not ok 1823 - Matched 2: ''
            # Failed test 'Matched 2: '''
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/pos.rakudo line 18
            not ok 1824 - Final position correct
            # Failed test 'Final position correct'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/pos.rakudo line 19
            # expected: '6'
            #      got: (Nil)
assign requires a concrete object (got a Rakudo::Internals::LoweredAwayLexical type object instead)
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/pos.rakudo line 23
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/pos.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

            1..5
            ok 1825 - normal regexes backtrack into subrules
            ok 1826 -  ... but not with :ratchet
            not ok 1827 - if the failing atom is outside the :!ratchet group: no backtracking # TODO Dubios test. Does it have to be this way?
            # Failed test 'if the failing atom is outside the :!ratchet group: no backtracking'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/ratchet.rakudo line 20
            ok 1828 - if the failing atom is inside the :!ratchet group: backtracking
            ok 1829 - Same if not grouped
# FUDGED!
            1..5
            ok 1830 - Simple combination of :x(2) and :exhaustive
            not ok 1831 - First entry of prev. genenerated $/ # TODO exhaustive capture too greedy RT #125133
            # Failed test 'First entry of prev. genenerated $/'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-modifier/repetition-exhaustive.rakudo line 25
            # expected: 'ab'
            #      got: 'abbb'
            ok 1832 - Second entry of prev. genenerated $/
            ok 1833 - Simple combination of :x(3) and :exhaustive
            ok 1834 - Simple combination of :x(4) and :exhaustive
# FUDGED!
            1..190
            ok 1835 - We can use subst
            ok 1836 - .. withouth side effect
            ok 1837 - .. or using Str as pattern
            ok 1838 - .. with literal string matching
            ok 1839 - We can have a closure as replacement
            ok 1840 - .. and with the .= modifier
            ok 1841 - .. it changes the receiver
            ok 1842 - non-Str replacement works for string form too
            ok 1843 - .. bare strings cannot see $/ because they are evaluated first
            ok 1844 - .. you must wrap it in a closure to delay evaluation
            ok 1845 - .. and do nifty things in closures
            ok 1846 - "a".subst("a", "b") is "b"
            ok 1847 - $/ is left untouched
            ok 1848 - "a".subst(/a/, "b") is "b"
            ok 1849 - $/ matched "a"
            ok 1850 - "a".subst(/x/, "y") is "a"
            ok 1851 - $/ is a falsey
assign requires a concrete object (got a Rakudo::Internals::LoweredAwayLexical type object instead)
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-substitution/subst.rakudo line 43
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-substitution/subst.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

            1..8
            ok 1852 - # SKIP RT  \#126142 - NYI
            ok 1853 - # SKIP RT  \#126142 - NYI
            ok 1854 - # SKIP RT  \#126142 - NYI
            ok 1855 - # SKIP RT  \#126142 - NYI
            ok 1856 - # SKIP RT  \#126142 - NYI
            ok 1857 - # SKIP RT  \#126142 - NYI
            ok 1858 - # SKIP RT  \#126142 - NYI
            ok 1859 - # SKIP RT  \#126142 - NYI
# FUDGED!
            1..65
            ok 1860 - Each side can be individual characters
            ok 1861 - The two sides of the any pair can be strings interpreted as tr/// would multichar
            ok 1862 - The two sides of the any pair can be strings interpreted as tr/// would range
            ok 1863 - If the first character is a dash it isn't part of a range
            ok 1864 - If the last character is a dash it isn't part of a range
            ok 1865 - The two sides can consists of both chars and ranges
            ok 1866 - The two sides can consist of multiple ranges
            ok 1867 - The two sides of each pair may also be array references
            ok 1868 - Using string range on one side and array reference on the other
            ok 1869 - Using array reference on one side and string range on the other
            ok 1870 - The array version can map one characters to one-or-more characters
            ok 1871 - The array version can map one-or-more characters to one-or-more characters
            ok 1872 - The array version can map one characters to one-or-more characters, using leftmost longest match
            ok 1873 - Ranges can be grouped
            ok 1874 - Multiple ranges interpreted in string
            ok 1875 - Spaces in interpreted ranges are not skipped (all spaces are important)
            ok 1876 - Spaces in interpreted ranges are not skipped (all spaces are important)
            ok 1877 - 
            ok 1878 - 
            ok 1879 - 
            ok 1880 - 
            ok 1881 - 
            ok 1882 - ambiguous ranges combined
            ok 1883 - leading ranges interpreted as string
            ok 1884 - trailing ranges interpreted as string
            ok 1885 - leading, trailing ranges interpreted as string
            ok 1886 - can replace with empty string
            ok 1887 - :s flag (squash)
            ok 1888 - :d flag (delete)
            ok 1889 - no flags
            ok 1890 - ... with :c
            ok 1891 - ... with :s
            ok 1892 - ... with :s and :c
            ok 1893 - ... with :d and :c
            ok 1894 - no flags
            ok 1895 - squashing depends on replacement repeat, not searchlist repeat
            ok 1896 - squashing depends on replacement repeat, not searchlist repeat
            ok 1897 - array, many-to-many transliteration, complement
            ok 1898 - fence-post issue (make sure to replace end bits as well)
            ok 1899 - ... and now complement and squash
            ok 1900 - basic regex works
            ok 1901 - regexes pairs work
            ok 1902 - basic closure
            ok 1903 - closure pairs work
            ok 1904 - closure and regex
            ok 1905 - pairs of regexes and closures
            ok 1906 - # SKIP feed operator NYI
assign requires a concrete object (got a Rakudo::Internals::LoweredAwayLexical type object instead)
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-transliteration/trans.rakudo line 212
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-transliteration/trans.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

            1..18
            ok 1907 - Can use a closure on the RHS
            ok 1908 - Closure executed three times
            ok 1909 - Can use a closure on the RHS with :c
            ok 1910 - Closure executed three times with :c
            ok 1911 - Can use two closures in trans
            ok 1912 - Source string unchanged
            ok 1913 - can use closures in pairs of arrays
            ok 1914 - Source string unchanged
            ok 1915 - can use closures in pairs of arrays
            ok 1916 - Source string unchanged
            ok 1917 - Closure not invoked (only longest match used)
            ok 1918 - Closure invoked twice (once per replacement)
            ok 1919 - regex and closure mix
Use of uninitialized value of type Rakudo::Internals::LoweredAwayLexical in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-transliteration/with-closure.rakudo line 45
Use of uninitialized value of type Rakudo::Internals::LoweredAwayLexical in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-transliteration/with-closure.rakudo line 45
            not ok 1920 - regex and closure mix (with $/ as topic) # TODO nom regression
            # Failed test 'regex and closure mix (with $/ as topic)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-transliteration/with-closure.rakudo line 45
            # expected: 'hellllo'
            #      got: 'heo'
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-transliteration/with-closure.rakudo line 48
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-transliteration/with-closure.rakudo line 48
            not ok 1921 - regex and closure mix (with $/ as topic and capture) # TODO nom regression
            # Failed test 'regex and closure mix (with $/ as topic and capture)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S05-transliteration/with-closure.rakudo line 48
            # expected: 'hellllo'
            #      got: 'heo'
            ok 1922 - Original string not modified
            ok 1923 - # SKIP Unable to resolve method ord in class Any
            ok 1924 - original string unchanged
# FUDGED!
            1..21
            ok 1925 - callframe() returns a CallFrame
            ok 1926 - callframe().line
            ok 1927 - .file
            ok 1928 - # SKIP Unable to resolve method inline in type CallFrame
            ok 1929 - can access outer lexicals via .my
            ok 1930 - can access outer lexicals via .my
            ok 1931 - cannot mutate without is dynamic
            ok 1932 - callframe(0).code returns this Sub
            ok 1933 - callframe(1).code returns the calling Sub
            ok 1934 - 
            ok 1935 - 
            ok 1936 - $x successfully modified
            ok 1937 - $y not modified
            ok 1938 - CallFrame.raku works
            not ok 1939 - CallFrame.gist works
            # Failed test 'CallFrame.gist works'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-advanced/callframe.rakudo line 50
            ok 1940 - .raku on callframe in a sub does not crash
            ok 1941 - No crash when using callframe(1).file many times in a loop
            ok 1942 - No crash when using callframe.gist in a hot loop
            ok 1943 - .annotations does not crash
            ok 1944 - Exploring call frames until no code object does not crash
            ok 1945 - did we get the right callframe each time?
# FUDGED!
            1..6
            not ok 1946 - Int is dispatched # TODO This is canary test. If this TODO passes then it's probably the time to unfudge the main tests
            # Failed test 'Int is dispatched'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-advanced/dispatching.rakudo line 25
            # expected: '42'
            #      got: (Nil)
            not ok 1947 - Str is dispatched # TODO This is canary test. If this TODO passes then it's probably the time to unfudge the main tests
            # Failed test 'Str is dispatched'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-advanced/dispatching.rakudo line 26
            # expected: '22'
            #      got: (Nil)
            ok 1948 - # SKIP Until 2020 dispatcher proposal is implemented
            ok 1949 - # SKIP Until 2020 dispatcher proposal is implemented
            ok 1950 - # SKIP Until 2020 dispatcher proposal is implemented
            ok 1951 - # SKIP Until 2020 dispatcher proposal is implemented
            # You planned 6 tests, but ran 1951
            # You failed 8 tests of 1951
# FUDGED!
WARNINGS for /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-advanced/return.rakudo:
Useless use of constant integer 1 in sink context (line 352)
            1..101
            ok 1952 - A bare return is Nil
            ok 1953 - An implicit bare return is Nil
            ok 1954 - A bare return returns Nil --> Any in array/list context
            ok 1955 - An implicit bare return Nil --> Any in array/list context
            ok 1956 - An empty return is false
            ok 1957 - An empty return is 0
            ok 1958 - An empty return interpolates nothing in array/list context
            ok 1959 - A slip return is false
            ok 1960 - A slip return is 0
            ok 1961 - A slip return interpolates nothing in array/list context
            ok 1962 - A bare return is a false value
            ok 1963 - An implicit bare return is a false value
            ok 1964 - A returned empty list is an empty list in array/list context
            ok 1965 - An implicit returned empty list is an empty list in array/list context
            ok 1966 - A bare return is undefined in scalar context
            ok 1967 - got the right return value
            ok 1968 - got the right return value
            ok 1969 - got the right return value
            ok 1970 - got the right return value
            ok 1971 - The object is-a 'Array'
            ok 1972 - got the right number of return value
            ok 1973 - got the right return value
            ok 1974 - got the right return value
            ok 1975 - got the right return value
            ok 1976 - The object is-a 'Array'
            ok 1977 - got the right number of return value
            ok 1978 - got the right return value
            ok 1979 - got the right return value
            ok 1980 - got the right return value
            ok 1981 - The object is-a 'Array'
            ok 1982 - got the right number of return value
            ok 1983 - got the right return value
            ok 1984 - got the right return value
            ok 1985 - got the right return value
            ok 1986 - The object is-a 'Array'
            ok 1987 - got the right number of return value
            ok 1988 - got the right return value
            ok 1989 - got the right return value
            ok 1990 - got the right return value
            ok 1991 - The object is-a 'Array'
            ok 1992 - got the right number of return value
            ok 1993 - got the right return value
            ok 1994 - got the right return value
            ok 1995 - got the right return value
            ok 1996 - The object is-a 'Array'
            ok 1997 - got the right number of return value
            ok 1998 - got the right return value
            ok 1999 - got the right return value
            ok 2000 - got the right return value
            ok 2001 - The object is-a 'Array'
            ok 2002 - got the right number of return value
            ok 2003 - got the right return value
            ok 2004 - got the right return value
            ok 2005 - got the right return value
            ok 2006 - The object is-a 'Array'
            ok 2007 - got the right number of return value
            ok 2008 - got the right return value
            ok 2009 - got the right return value
            ok 2010 - got the right return value
            ok 2011 - 
            ok 2012 - got the right number of return value
            ok 2013 - got the right return value
            ok 2014 - got the right return value
            ok 2015 - got the right return value
            ok 2016 - can call method on return value (hashitem)
            ok 2017 - got right result
            ok 2018 - can hash de-ref return value (hashitem)
            ok 2019 - 
            ok 2020 - got the right number of return value
            ok 2021 - got the right return value
            ok 2022 - got the right return value
            ok 2023 - got the right return value
            ok 2024 - can call method on return value (hashitem)
            ok 2025 - got right result
            ok 2026 - can hash de-ref return value (hashitem)
            ok 2027 - bare blocks are invisible to return
            ok 2028 - nested bare blocks are invisible to return
            ok 2029 - pointy blocks are invisible to return
            ok 2030 - subcalls in user-defined control flow are invisible to return
            ok 2031 - return correctly from official method only
            ok 2032 - return correctly from official submethod only
            ok 2033 - return correctly from official sub only
            ok 2034 - return with named arguments
            ok 2035 -  ... correct key
            ok 2036 -  ... correct value
            not ok 2037 - sub with empty catch block returns value before block # TODO RT #61732
            # Failed test 'sub with empty catch block returns value before block'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-advanced/return.rakudo line 354
            # expected: '1'
            #      got: (Nil)
            ok 2038 - get right value from sub with double ;
            ok 2039 - can call sub that returns two things (no parens)
            ok 2040 - can use value returned from empty routine
            ok 2041 - 
            ok 2042 - 
                1..2
                ok 1 - 'my class A { has Str method foo(--> Int) { "hi" } }' died
                ok 2 - right exception type (X::Redeclaration)
            ok 2043 - did we throws-like X::Redeclaration?
                1..2
                ok 1 - 'my class A { has Int method foo() { return "hi" } }; A.foo' died
                ok 2 - right exception type (X::TypeCheck::Return)
            ok 2044 - did we throws-like X::TypeCheck::Return?
            ok 2045 - Can return 42 through Int typecheck
            ok 2046 - Can return Nil through Int typecheck
            ok 2047 - Can return Failure through Int typecheck
            ok 2048 - Can't return 42.0 through Int typecheck
            ok 2049 - Can't return Cool through Int typecheck
            ok 2050 - Sub doing 42.return works
            ok 2051 - can return from parameter defaults
            ok 2052 - Containerized Nil passes Callable:D constraint
# FUDGED!
            1..13
            ok 2053 - sub foo {...} works
                1..2
                ok 1 - 'sub foo;' died
                ok 2 - right exception type (X::UnitScope::Invalid)
            ok 2054 - old Perl "sub foo;" syntax is dead
                1..2
                ok 1 - 'lightning()' died
                ok 2 - right exception type (X::StubCode)
            ok 2055 - executing stub subroutine dies
            ok 2056 - redefining stub subroutine works without extra syntax
Stub code executed
  in sub hail at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-advanced/stub.rakudo line 20
            ok 2057 - executing stub subroutine lives (should warn here)
            ok 2058 - redefining stub subroutine works without extra syntax
                1..2
                ok 1 - 'wind()' died
                ok 2 - right exception type (X::StubCode)
            ok 2059 - executing stub subroutine dies
            ok 2060 - redefining stub subroutine works without extra syntax
                1..2
                ok 1 - 'sub hail {26}; sub hail {10}' died
                ok 2 - right exception type (X::Redeclaration)
            ok 2061 - redefining existing subroutine dies
            ok 2062 - # SKIP supersede NYI
            ok 2063 - not execued stub code is fine
            ok 2064 - execued stub code goes BOOM when used
            ok 2065 - exeucted stub code goes BOOM under fatal
# FUDGED!
            1..90
            ok 2066 - one event logged
            ok 2067 - it's foo
            ok 2068 - cannot upwrap a never-wrapped sub.
            ok 2069 - two events logged
            ok 2070 - wrapper before
            ok 2071 - wrapper after
            ok 2072 - logged the correct events
            ok 2073 - four events
            ok 2074 - additional wrapping takes effect
            ok 2075 - ... on top of initial wrapping
            ok 2076 - old wrapped sub was not destroyed
            ok 2077 - the original wrapper is still in effect
            ok 2078 - one events for unwrapped (should be back to original now)
            ok 2079 - got execpted value
            ok 2080 - out of order unwrapping gave right number of results
            ok 2081 - got execpted value from remaining wrapper
            ok 2082 - got execpted value from original sub
            ok 2083 - can't re-unwrap an already unwrapped sub
            ok 2084 - Basic sub.
            ok 2085 - Basic wrapping works 
            ok 2086 - Recieved handle for unwrapping.
            ok 2087 - Function produces expected output after wrapping
            ok 2088 - unwrap the function
            ok 2089 - Function is no longer wrapped.
            ok 2090 - Sanity test.
            ok 2091 - Sanity test.
            not ok 2092 - Check that functions have a 'callwith' that works.  # TODO callwith
            # Failed test 'Check that functions have a 'callwith' that works. '
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-advanced/wrap.rakudo line 118
            # No such method 'callwith' for invocant of type 'Sub+{SoftRoutine}'
            ok 2093 - wrapping 1
            ok 2094 - Checking 1 level wrapping
            ok 2095 - wrapping 2
            ok 2096 - Checking 2 level wrapping
            ok 2097 - wrapping 3
            ok 2098 - Checking 3 level wrapping
            ok 2099 - wrapping 4
            ok 2100 - Checking 4 level wrapping
            ok 2101 - wrapping 5
WARNING: unhandled Failure detected in DESTROY. If you meant to ignore it, you can mark it as handled by calling .Bool, .so, .not, or .defined methods. The Failure was:
Failed
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-advanced/return.rakudo line 337
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

            ok 2102 - Checking 5 level wrapping
            ok 2103 - wrapping 6
            ok 2104 - Checking 6 level wrapping
            ok 2105 - wrapping 7
            ok 2106 - Checking 7 level wrapping
            ok 2107 - wrapping 8
            ok 2108 - Checking 8 level wrapping
            ok 2109 - wrapping 9
            ok 2110 - Checking 9 level wrapping
            ok 2111 - wrapping 10
            ok 2112 - Checking 10 level wrapping
            ok 2113 - Sanity.
            ok 2114 - First wrapping lived
            ok 2115 - Middle wrapper sanity.
            ok 2116 - Second wraping lived
            ok 2117 - three wrappers sanity.
            ok 2118 - unwrap the middle wrapper.
            ok 2119 - First wrapper and final function only, middle removed.
            ok 2120 - Sanity
            ok 2121 - Check that function is wrapped.
            not ok 2122 - Wrap is now out of scope, should be back to normal. # TODO temp and wrap
            # Failed test 'Wrap is now out of scope, should be back to normal.'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-advanced/wrap.rakudo line 162
            # expected: 'xxx'
            #      got: 'yyy'
            not ok 2123 - Wrap is now out of scope, should be back to normal. # TODO temp and wrap
            # Failed test 'Wrap is now out of scope, should be back to normal.'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-advanced/wrap.rakudo line 165
            # expected: 'xxx'
            #      got: 'yyy'
            ok 2124 - {nextsame}() dies properly
            not ok 2125 - right exception type (X::NoDispatcher)
            # Failed test 'right exception type (X::NoDispatcher)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-advanced/wrap.rakudo line 179
            # Actual type: X::ControlFlow::Return
            ok 2126 - wrapper test variable is undefined
            ok 2127 - wrapped greet() works
            ok 2128 - wrapper sees lexical from time of wrap (greet)
            ok 2129 - wrapper test variable is undefined
            ok 2130 - wrapped meet() works
            ok 2131 - wrapper sees lexical from time of wrap (meet)
            ok 2132 - wrap worked (sanity)
            ok 2133 - could unwrap by calling .restore on the handle
            ok 2134 - multiple wrappings in a loop
            ok 2135 - can wrap a multi
            ok 2136 - Did foo, capture return
            ok 2137 - default works with wrapped accessor, capture return
            ok 2138 - BUILD binding works with wrapped accessor, capture return
            ok 2139 - assignment works with wrapped accessor, capture return
            ok 2140 - Did foo, return callsame
            ok 2141 - default works with wrapped accessor, return callsame
            ok 2142 - BUILD binding works with wrapped accessor, return callsame
            ok 2143 - assignment works with wrapped accessor, return callsame
            ok 2144 - Did foo, callsame
            ok 2145 - default works with wrapped accessor, callsame
            ok 2146 - BUILD binding works with wrapped accessor, callsame
            ok 2147 - assignment works with wrapped accessor, callsame
            ok 2148 - Did foo, nextsame
            ok 2149 - default works with wrapped accessor, nextsame
            ok 2150 - BUILD binding works with wrapped accessor, nextsame
            ok 2151 - assignment works with wrapped accessor, nextsame
Type check failed in binding to parameter '<anon>'; expected Abyss::Server but got Abyss::Server::Mod::C3 (Abyss::Server::Mod::...)
  in method foo at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-advanced/wrap.rakudo line 418
  in method foo at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-advanced/wrap.rakudo line 412
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-advanced/wrap.rakudo line 423
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-advanced/wrap.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

            1..13
            ok 2152 - Priming :(::T  $a, $b, :$c) with \(1) gave :($b, :$c)
            ok 2153 - Priming :(::T  $a, T $b, T :$c) with \(1) gave :($b, :$c)
            ok 2154 - Priming :(::T  $a, T @b, T :@c) with \(1) gave :(@b, :@c)
            ok 2155 - Priming :(::T  $a, T $b, T :$c) with \(1, 1) gave :(:$c)
            ok 2156 - Priming :(::T  $a, T @b, T :@c) with \(1, $[1]) gave :(:@c)
            ok 2157 - Priming :(::T  $a, Array[T] $b, Array[Int] :$c) with \(1) gave :($b, Array[Int] :$c)
            ok 2158 - Priming :(::T  $a, Array[T] $b, Array[Int] :$c) with \(1, Array[Int].new()) gave :(Array[Int] :$c)
            ok 2159 - Priming :(::T  $a, Array[Array[T]] $b, Array[Array[Int]] :$c) with \(1) gave :($b, Array[Array[Int]] :$c)
            ok 2160 - Priming :(::T  $a, Array[Positional[T]] $b, Array[Positional[Int]] :$c) with \(1) gave :($b, Array[Positional[Int]] :$c)
            ok 2161 - # SKIP We could do better here
            ok 2162 - Priming :() with \(*) gave :()
                1..3
                ok 1 - code dies
                ok 2 - right exception type (X::TypeCheck::Binding)
                ok 3 - .backtrace matches rx:i/.*in\s+\S+\s+\S*curr{fail}||prim/
            ok 2163 - Backtrace mentions priming and does not mention currying
            ok 2164 - &abc123.assuming(("a", "b", "c").Seq)((1, 2, 3).Seq) returned expected value ["a", "b", "c", 1, 2, 3]
# FUDGED!
            1..7
            ok 2165 - macro returning quasi
            ok 2166 - # SKIP :COMPILING flag
            ok 2167 - # SKIP :COMPILING flag
            ok 2168 - # SKIP :COMPILING flag
            ok 2169 - Macros can return noops
            ok 2170 - lexical vars in macros are not visible to the AST vars
            ok 2171 - # SKIP return from macro
# FUDGED!
WARNINGS for /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-macros/quasi-blocks.rakudo:
Useless use of constant string "grasshopper" in sink context (line 74)
Useless use of constant integer 2 in sink context (line 65)
Useless use of constant string "motor oil" in sink context (line 74)
Useless use of constant integer 1 in sink context (line 65)
            1..14
            ok 2172 - calls to macro are at parse time
            ok 2173 - macro call with arguments works
            ok 2174 - macro calls without parens work
            ok 2175 - macro call with arguments works
            ok 2176 - can define an entirely new operator
            ok 2177 - can shadow an existing operator
            ok 2178 - lexical lookup from quasi to macro works
            ok 2179 - # SKIP Cannot resolve caller prefix:<++>(Mu)
            ok 2180 - # SKIP Cannot resolve caller prefix:<++>(Mu)
            ok 2181 - lexical lookup from quasi to macro params works
            ok 2182 - macro can return its param
            ok 2183 - Nil from an empty block turns into no code
            ok 2184 - addition of two quasis with arithmetical expressions works (1)
            ok 2185 - addition of two quasis with arithmetical expressions works (2)
# FUDGED!
            1..15
            ok 2186 - can call lexically scoped multi
                1..2
                ok 1 - ' foo() ' died
                ok 2 - right exception type (X::Undeclared::Symbols)
            ok 2187 - lexical multi not callable outside of lexical scope
            ok 2188 - outer lexical multi callable
            ok 2189 - new inner lexical multi callable
            ok 2190 - in outer scope, can call the multi that is in scope
            ok 2191 - multi variant from inner scope not callable in outer
            ok 2192 - no multi variants callable outside of lexical scope
            ok 2193 - no multi variants callable outside of lexical scope
            not ok 2194 - inner multi conflicts with outer one # TODO lexical scope as tie breaker
            # Failed test 'inner multi conflicts with outer one'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-multi/lexical-multis.rakudo line 43
            # Ambiguous call to 'baz(...)'; these signatures all match:
            #   ()
            #   ()
            ok 2195 - in outer scope, no inner multi, so no conflict
            ok 2196 - got multi from package
            ok 2197 - lexical multi also callable
            ok 2198 - multi from package still callable outside the inner scope...
            ok 2199 - ...but lexical multi no longer callable
            ok 2200 - die in numification of proto
# FUDGED!
            1..27
            ok 2201 - dispatch on class worked
            ok 2202 - dispatch on class worked
            ok 2203 - dispatch with no possible candidates fell back to proto
            not ok 2204 - [+] overloaded by proto definition # TODO operator protos
            # Failed test '[+] overloaded by proto definition'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-multi/proto.rakudo line 25
            # expected: '12'
            #      got: '2 2 3'
            ok 2205 - proto definition of prefix:<moose> works
            ok 2206 - multi definition of prefix:<elk> works
            ok 2207 - dispatch on class worked (anon cap)
            ok 2208 - dispatch on class worked (anon cap)
            ok 2209 - dispatch with no possible candidates fell back to proto (anon cap)
                1..2
                ok 1 - 'bar(41)' died
                ok 2 - right exception type (Exception)
            ok 2210 - impossible dispatch failed (anon cap)
                1..2
                ok 1 - 'EVAL $rt65322' died
                ok 2 - right exception type (X::Redeclaration)
            ok 2211 - Can't define sub and multi sub without proto
                1..2
                ok 1 - '
                #         multi sub i1(Int $x) {}
                #         sub i1(Int $x, Str $y) {} 
                #     ' died
                ok 2 - right exception type (X::Redeclaration)
            ok 2212 - declaring a multi and a single routine dies
                1..2
                ok 1 - '
                #         sub i2(Int $x, Str $y) {1}
                #         sub i2(Int $x, Str $y) {2}
                #     ' died
                ok 2 - right exception type (X::Redeclaration)
            ok 2213 - declaring two only-subs with same name dies
                1..2
                ok 1 - 'proto rt68242($a){};proto rt68242($c,$d){};' died
                ok 2 - right exception type (X::Redeclaration)
            ok 2214 - attempt to define two proto subs with the same name dies
            ok 2215 - our proto can be accessed from the ouside
            ok 2216 - can use {*} in an expression in a proto (1)
            ok 2217 - can use {*} in an expression in a proto (2)
            ok 2218 - caching proto (1)
            ok 2219 - caching proto (2)
            ok 2220 - caching proto (3)
            ok 2221 - cached value did not cause extra call
            ok 2222 - sanity
            ok 2223 - It's ok not to dispatch to the multis
            ok 2224 - proto method after same-named attribute
            ok 2225 - proto method before same-named attribute
                1..2
                ok 1 - '
                #         proto f(Int $x) {*}; multi f($) { 'default' }; f 'foo'
                #     ' died
                ok 2 - right exception type (X::TypeCheck::Argument)
            ok 2226 - proto signature is checked, not just that of the candidates
                1..2
                ok 1 - 'my &x; sub x {}' died
                ok 2 - right exception type (X::Redeclaration)
            ok 2227 - my &x; sub x {} throws useful error
# FUDGED!
            1..95
            ok 2228 - multi works with constant
            ok 2229 - read-only multi was called
            ok 2230 - multi works with variable
            not ok 2231 - variable was modified # TODO Calls wrong candidate
            # Failed test 'variable was modified'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-multi/subsignature.rakudo line 24
            # expected: '100'
            #      got: '99'
            not ok 2232 - read-write multi was called # TODO Calls wrong candidate
            # Failed test 'read-write multi was called'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-multi/subsignature.rakudo line 26
            # expected: '1'
            #      got: '0'
            ok 2233 - got multi from package
            ok 2234 - lexical multi also callable
            ok 2235 - multi from package still callable outside the inner scope...
            ok 2236 - ...but lexical multi no longer callable
            ok 2237 - named me
            ok 2238 - named you
            ok 2239 - named me, named him
            ok 2240 - named him, named me
            ok 2241 - named me named him named her
            ok 2242 - named him named me named her
            ok 2243 - named her named me named him
            ok 2244 - named her named him named me
            ok 2245 - pos, named you
            ok 2246 - pos, named her
            ok 2247 - pos, pos
            ok 2248 - pos, pos, named
            ok 2249 - named me
            ok 2250 - named you
            ok 2251 - named me, named him
            ok 2252 - named him, named me
            ok 2253 - named me named him named her
            ok 2254 - named him named me named her
            ok 2255 - named her named me named him
            ok 2256 - named her named him named me
            ok 2257 - pos, named you
            ok 2258 - pos, named her
            ok 2259 - pos, pos
            ok 2260 - pos, pos, named
            ok 2261 - slurpy and named interact well (1)
            ok 2262 - slurpy and named interact well (2)
            ok 2263 - slurpy and named interact well (1)
            ok 2264 - slurpy and named interact well (2)
            ok 2265 - presence of mandatory named multi does not corrupt calling a nullary
            ok 2266 - presence of mandatory named multi does not corrupt calling a nullary
            ok 2267 - dispatch on class worked
            ok 2268 - dispatch on class worked
            ok 2269 - dispatch with no possible candidates fell back to proto
            not ok 2270 - [+] overloaded by proto definition # TODO operator protos
            # Failed test '[+] overloaded by proto definition'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-multi/subsignature.rakudo line 157
            # expected: '12'
            #      got: '2 2 3'
            ok 2271 - proto definition of prefix:<moose> works
            ok 2272 - multi definition of prefix:<elk> works
                1..2
                ok 1 - 'proto rt68242(|c($a)){};proto rt68242(|c($c,$d)){};' died
                ok 2 - right exception type (X::Redeclaration)
            ok 2273 - attempt to define two proto subs with the same name dies
                1..2
                ok 1 - 'EVAL $rt65322' died
                ok 2 - right exception type (X::Redeclaration)
            ok 2274 - Can't define sub and multi sub without proto
            ok 2275 - our proto can be accessed from the ouside
            ok 2276 - can use {*} in an expression in a proto (1)
            ok 2277 - can use {*} in an expression in a proto (2)
            ok 2278 - caching proto (1)
            ok 2279 - caching proto (2)
            ok 2280 - caching proto (3)
            ok 2281 - cached value did not cause extra call
            ok 2282 - sanity
            ok 2283 - It's ok not to dispatch to the multis
                1..2
                ok 1 - '
                #         proto f(|c(Int $x)) {*}; multi f(|c($)) { 'default' }; f 'foo'
                #     ' died
                ok 2 - right exception type (Exception)
            ok 2284 - proto signature is checked, not just that of the candidates
            ok 2285 - can call nextsame inside a multi sub
            not ok 2286 - called in the right order # TODO Multimethod sort does not descend into subsignatures
            # Failed test 'called in the right order'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-multi/subsignature.rakudo line 242
            # expected: 'IntAny'
            #      got: 'Any'
            ok 2287 - can call callsame inside a multi sub
            not ok 2288 - called in the right order # TODO Multimethod sort does not descend into subsignatures
            # Failed test 'called in the right order'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-multi/subsignature.rakudo line 253
            # expected: 'IntAnyInt'
            #      got: 'Any'
            ok 2289 - can call nextwith inside a multi sub
            not ok 2290 - called in the right order # TODO Multimethod sort does not descend into subsignatures
            # Failed test 'called in the right order'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-multi/subsignature.rakudo line 264
            # expected: 'IntAny4'
            #      got: 'Any3'
            ok 2291 - can call callwith inside a multi sub
            not ok 2292 - called in the right order # TODO Multimethod sort does not descend into subsignatures
            # Failed test 'called in the right order'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-multi/subsignature.rakudo line 275
            # expected: 'IntAny4Int'
            #      got: 'Any3'
            ok 2293 - It's ok to call nextsame in the last/only candidate
            ok 2294 - samewith $a stringified in sub
            ok 2295 - samewith $b stringified for Abyss::Server::Mod::C
            ok 2296 - samewith $b stringified for Abyss::Server::Mod::C.new
            ok 2297 - samewith works from inside a nested closure
            ok 2298 - multi sub with empty signature
            ok 2299 - multi sub with parameter list
            ok 2300 - multi with empty signature
            ok 2301 - multi with parameter list
            ok 2302 - dispatch tied as expected
            ok 2303 - not tied as only first type in the dispatch
            ok 2304 - use multi method to override builtin lives
            ok 2305 - use multi method to override builtin
            ok 2306 - interaction between named and slurpy (1)
            ok 2307 - interaction between named and slurpy (2)
            ok 2308 - interaction between named and slurpy (3)
            ok 2309 - interaction between named and slurpy (4)
            ok 2310 - can find multi method with key
            ok 2311 - can find multi method with slurpy
            ok 2312 - non-slurpy wins over slurpy
            ok 2313 - slurpy called when non-slurpy can not bind
            ok 2314 - optional parameter does not break type-based candidate sorting
            not ok 2315 - optional parameter does not break type-based candidate sorting # TODO Multimethod sort does not descend into subsignatures
            # Failed test 'optional parameter does not break type-based candidate sorting'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-multi/subsignature.rakudo line 380
            # expected: '2'
            #      got: '1'
            ok 2316 - multi can be passed as callable
            ok 2317 - multi sub declaration returns just the current candidate
            ok 2318 - and that candidate works
            ok 2319 - ... and does not contain the full multiness
            ok 2320 - captures in multi sigs work
            ok 2321 - ordered multi subs
            ok 2322 - first defined wins the tie
# FUDGED!
            1..65
            ok 2323 - dispatched to the constant sub
            ok 2324 - dispatched to the Int sub
            ok 2325 - dispatched to the Str sub
            ok 2326 - dispatched to the Num sub
            ok 2327 - dispatched to the Bool sub
            ok 2328 - dispatched to the Rule sub
            ok 2329 - dispatched to the Sub sub
            ok 2330 - dispatched to the Positional sub
            ok 2331 - dispatched to the Associative sub
            ok 2332 - dispatched to the Numeric sub
            ok 2333 - dispatched to the Inf sub
            ok 2334 - dispatched to the NaN sub
            ok 2335 - omitting 'sub' when declaring 'multi sub's works (1)
            ok 2336 - omitting 'sub' when declaring 'multi sub's works (2)
            ok 2337 - Slurpy MMD to nullary
            ok 2338 - Slurpy MMD to listop via args
            ok 2339 - Slurpy MMD to listop via list
            ok 2340 - Sigil-based dispatch (Any)
            ok 2341 - Sigil-based dispatch (Callable)
            ok 2342 - Sigil-based dispatch (Arrays)
            ok 2343 - Sigil-based dispatch (Associative)
            ok 2344 - Basic sanity
            ok 2345 - multi dispatch with ::T generics
            ok 2346 - fallback if there is a ::T variant
            ok 2347 - Type captures and containers mix
            ok 2348 - Basic sanity 2
            ok 2349 - multi dispatch with faked generics
            ok 2350 - fallback if there is a faked generic
            ok 2351 - MMD with anonymous parameters (1)
            ok 2352 - MMD with anonymous parameters (2)
            ok 2353 - MMD with anonymous parameters (3)
            ok 2354 - subset types involving multiple parameters (fallback)
            ok 2355 - subset types involving multiple parameters (success)
            ok 2356 - arity-based dispatch to ($)
            ok 2357 - arity-based dispatch to ($, $)
            ok 2358 - arity-based dispatch to ($, $, $)
            ok 2359 - arity-based dispatch to ($, $, @)
            ok 2360 - can dispatch to "$ where 0"
            ok 2361 - ... and the ordinary dispatch still works
            ok 2362 - can dispatch on typed Hash (Int)
            ok 2363 - can dispatch on typed Hash (Str)
            ok 2364 - can dispatch on typed Hash (Array)
            ok 2365 - can dispatch on typed Array (Int)
            ok 2366 - can dispatch on typed Array (Str)
            ok 2367 - can dispatch on typed Array (Array)
            ok 2368 - can dispatch on typed routine (Str)
            ok 2369 - can dispatch on typed routine (Int)
                1..2
                ok 1 - '
                #         class RT65674 {
                #             our multi sub a(Int $x) { 'Int ' ~ $x }
                #             our multi sub a(Str $x) { 'Str ' ~ $x }
                #         }
                #     ' died
                ok 2 - right exception type (X::Declaration::Scope::Multi)
            ok 2370 - no individual multi candidates in "our" scope
            ok 2371 - multis in classes (1)
            ok 2372 - multis in classes (2)
                1..2
                ok 1 - 'A::a([4, 5])' died
                ok 2 - right exception type (X::Multi::NoMatch)
            ok 2373 - multis in classes (3)
            ok 2374 - where-clause that uses multiple params (1)
            ok 2375 - where-clause that uses multiple params (1)
            ok 2376 - generics in multis (+)
            ok 2377 - generics in multis (-)
            ok 2378 - Int hits Int() candidate as if it were an Int candidate
            ok 2379 - Str hits Cool candidate
            ok 2380 - Set hits Int() candidate due to it accepting Any and coercing
            not ok 2381 - can distinguish Rat-like string in main # TODO coercions need to fail like constraints
            # Failed test 'can distinguish Rat-like string in main'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-multi/type-based.rakudo line 240
            not ok 2382 - can distinguish Num-like string in main # TODO coercions need to fail like constraints
            # Failed test 'can distinguish Num-like string in main'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-multi/type-based.rakudo line 241
            not ok 2383 - can distinguish Int-like string in main # TODO coercions need to fail like constraints
            # Failed test 'can distinguish Int-like string in main'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-multi/type-based.rakudo line 242
            not ok 2384 - can distinguish Complex-like string in main # TODO coercions need to fail like constraints
            # Failed test 'can distinguish Complex-like string in main'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-multi/type-based.rakudo line 243
            ok 2385 - Combination of where clause plus default parses correctly
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::Multi::Ambiguous)
            ok 2386 - arguments after ;; not considered by multi-dispatch
            ok 2387 - Can pass a Seq to an @-sigil arg in a multi
# FUDGED!
            1..16
            ok 2388 - # SKIP macros
            ok 2389 - # SKIP macros
            ok 2390 - slurpy circumfix:<<...>> works
            ok 2391 - slurpy circumfix:<<...>> works, allows spaces
            ok 2392 - lexically defined circumfix works inside EVAL
            ok 2393 - circumfix with non-Latin1 bracketing characters
            ok 2394 - circumfix with non-Latin1 bracketing characters, allows spaces
            ok 2395 - sub postcircumfix:<...> works
            ok 2396 - lexically defined postcircumfix works inside EVAL
            ok 2397 - can define circumfix using << >> and both delimiters from the same constant
            ok 2398 - can define and use circumfix using << >> and both delimiters from the same constant (1)
            ok 2399 - can define circumfix using << >> and both delimiters from the same constant
            ok 2400 - can define and use circumfix using << >> and both delimiters from the same constant (2)
            ok 2401 - can define circumfix using << {sym} >> and both delimiters from the same constant
            ok 2402 - can define and use circumfix using << >> and both delimiters from the same constant
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::Syntax::AddCategorical::TooManyParts)
            ok 2403 - constants containing too many parts throw correctly
# FUDGED!
WARNINGS for /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-operator-overloading/infix.rakudo:
Useless use of constant integer 3 in sink context (line 72)
            1..47
            ok 2404 - infix Unicode operator (actual overloading)
            ok 2405 - infix operator overloading for new operator
            ok 2406 - infix operator overloading for new operator (unicode)
            ok 2407 - infix operator overloading for new operator (nasty)
            ok 2408 - frenchquoted infix sub
            ok 2409 - # SKIP cannot bind with this LHS
            ok 2410 - operator overloading using symbolic dereferentiation
            ok 2411 - accessing a builtin operator using its subroutine name
            ok 2412 - accessing a userdefined operator using its subroutine name
            ok 2413 - accessing a hyperoperator using its subroutine name
            not ok 2414 -  # TODO infix:<;>
            # Failed test at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-operator-overloading/infix.rakudo line 72
            # expected: '5'
            #      got: '2'
            ok 2415 - instantiation of a prefix:<...> and infix:<as> overloading class worked
            ok 2416 - our object can be stringified
            ok 2417 - our object was stringified correctly
            ok 2418 - our object was coerced correctly
            ok 2419 - # SKIP infix Z will never work; no lexical Z RT  \#124983
            ok 2420 - # SKIP no lexical Z RT  \#124983
            ok 2421 - # SKIP no lexical Z RT  \#124983
            ok 2422 - # SKIP no lexical Z RT  \#124983
            ok 2423 - # SKIP no lexical Z RT  \#124983
            ok 2424 - Non-associative works for just tow operands.
            ok 2425 - Non-associative works when used with parens.
                1..2
                ok 1 - '2 our_non_assoc_infix 3 our_non_assoc_infix 4' died
                ok 2 - right exception type (X::Syntax::NonAssociative)
            ok 2426 - Non-associative should not parsed when used chainly.
            ok 2427 - old == still works on integers (+)
            ok 2428 - old == still works on integers (-)
            ok 2429 - infix:<==> on A objects works (+)
            ok 2430 - infix:<==> on A objects works (-)
            ok 2431 - infix redefinition of += works
            ok 2432 - can overload exiting operators (here: infix:<+>)
            ok 2433 - New multis don't disturb old ones
            ok 2434 - infix:<,>($a, $b)
            ok 2435 - very specific infix:<,>
            not ok 2436 - infix:<comment char>($a, $b) # TODO RT #65638
            # Failed test 'infix:<comment char>($a, $b)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-operator-overloading/infix.rakudo line 195
            # expected: '42'
            #      got: '5'
            ok 2437 - infix:<+>()
            ok 2438 - infix:<+>($a, $b)
            ok 2439 - foo= works for custom operators
            ok 2440 - foo= works for custom operators
            ok 2441 - bar= works for custom operators
            ok 2442 - overloading an operator does not hide other candidates
            ok 2443 - longest operator wins (RT  \#111418)
            ok 2444 - longest operator wins (RT  \#112870)
            ok 2445 - assignment to code variable works.
            ok 2446 - can call existing infix via compile-time string lookup
            ok 2447 - can call autogen infix via compile-time string lookup
            ok 2448 - &infix:<<$foo>> works
            ok 2449 - &infix:«$foo» works
            ok 2450 - &infix:[$foo] works
# FUDGED!
            1..3
            not ok 2451 - custom postcircumfix{ } is tied to the right class # TODO nom regression
            # Failed test 'custom postcircumfix{ } is tied to the right class'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-operator-overloading/methods.rakudo line 16
            # expected: 'bar'
            #      got: (Failure)
            ok 2452 - custom postcircumfix{ } does not lead to warnings
            ok 2453 - custom postcircumfix{ } with weird whitespacing does not require ;
# FUDGED!
            1..29
            ok 2454 - postfix operator overloading for new operator
            ok 2455 - postfix operator overloading for new operator (weird)
            ok 2456 - sum prefix operator
            ok 2457 - factorial postfix operator
            ok 2458 - correct overloaded method called
            ok 2459 - # SKIP missing block, apparently "if" not an op
                1..3
                ok 1 - code dies
                ok 2 - right exception type (X::Syntax::AddCategorical::TooFewParts)
                ok 3 - .message matches Not enough symbols provided for categorical of type circumfix; needs 2
            ok 2460 - circumfix definition without whitespace between starter and stopper fails with X::Syntax::AddCategorical::TooFewParts
                1..3
                ok 1 - code dies
                ok 2 - right exception type (X::Syntax::AddCategorical::TooManyParts)
                ok 3 - .message matches Too many symbols provided for categorical of type circumfix; needs only 2
            ok 2461 - circumfix definition with three parts fails with X::Syntax::AddCategorical::TooManyParts
                1..3
                ok 1 - code dies
                ok 2 - right exception type (X::Syntax::AddCategorical::TooManyParts)
                ok 3 - .message matches Too many symbols provided for categorical of type infix; needs only 1
            ok 2462 - infix definition with two parts fails with X::Syntax::AddCategorical::TooManyParts
                1..3
                ok 1 - code dies
                ok 2 - right exception type (X::Syntax::AddCategorical::TooManyParts)
                ok 3 - .message matches Too many symbols provided for categorical of type term; needs only 1
            ok 2463 - term definition with two parts fails with X::Syntax::AddCategorical::TooManyParts
            ok 2464 - ... basic prefix operator overloading worked
            ok 2465 - ... class methods work for class
            ok 2466 - ... basic infix operator overloading worked
            ok 2467 - stringification didn't die
            ok 2468 - stringification overloading worked in array stringification
            ok 2469 - can declare operator with a backslash (1)
            ok 2470 - can declare operator with a backslash (2)
            ok 2471 - can declare and use operator with a backslash
            ok 2472 - can define circumfix operator with a double quote (")
            ok 2473 - can define and use circumfix operator with a double quote (")
                1..3
                ok 1 - code dies
                ok 2 - right exception type (X::Syntax::Extension::TooComplex)
                ok 3 - .message matches Colon pair value '/./' too complex to use in name
            ok 2474 - infix definition for /./ fails with X::Syntax::Extension::TooComplex
            ok 2475 - can define infix with brackets as delimiter
            ok 2476 - can define and use infix with brackets as delimiter
            ok 2477 - can define circumfix with brackets as delimiter
            ok 2478 - can define and use circumfix with brackets as delimiter
            ok 2479 - can define and use operator with a sigilless constant as symbol
            ok 2480 - can define and use operator with a sigiled constant as symbol
                1..2
                ok 1 - 'sub meow:<bar> {}' died
                ok 2 - right exception type (X::Syntax::Extension::Category)
            ok 2481 - defining custom op in non-exitent category throws
            ok 2482 - can use colon-name extended sub name
# FUDGED!
            1..43
            ok 2483 - a user-defined USAGE sub is called if MAIN dispatch fails
            ok 2484 - a user-defined USAGE sub is not called if MAIN dispatch succeeds
            ok 2485 - if the MAIN dispatch results in an error, that error should be printed, not USAGE
            ok 2486 - auto-generated USAGE message goes to $*ERR and contains parameter name
            ok 2487 - auto-generated USAGE should handle sigilles parameters
            ok 2488 - --help option sends auto-generated USAGE message to $*OUT
            ok 2489 - boolean option +
            ok 2490 - boolean option -
            ok 2491 - option with value
            ok 2492 - named alias (inner name)
            ok 2493 - named alias (outer name)
            ok 2494 - Non Bool option last with no value
            ok 2495 - Bool option followed by positional value
                ok 1 - 
                ok 2 - 
                1..2
            ok 2496 - Valid arg with zero length value
                ok 1 - 
                ok 2 - 
                1..2
            ok 2497 - Valid arg with single space value
                ok 1 - 
                ok 2 - 
                1..2
            ok 2498 - Valid arg with two space value
                ok 1 - 
                ok 2 - 
                1..2
            ok 2499 - Valid arg with newline value
                ok 1 - 
                ok 2 - 
                1..2
            ok 2500 - Valid arg with tab value
                ok 1 - 
                ok 2 - 
                1..2
            ok 2501 - Valid arg with tab then space value
                ok 1 - 
                ok 2 - 
                1..2
            ok 2502 - Extra arg with zero length value
                ok 1 - 
                ok 2 - 
                1..2
            ok 2503 - Extra arg with single space value
                ok 1 - 
                ok 2 - 
                1..2
            ok 2504 - Extra arg with two space value
                ok 1 - 
                ok 2 - 
                1..2
            ok 2505 - Extra arg with newline value
                ok 1 - 
                ok 2 - 
                1..2
            ok 2506 - Extra arg with tab value
                ok 1 - 
                ok 2 - 
                1..2
            ok 2507 - Extra arg with newline value
            not ok 2508 - option with spacey value # TODO nom regression
            # Failed test 'option with spacey value'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-other/main-usage.rakudo line 137
            #      got status: 2
            #      got out: ""
            # expected out: IntStr.new(23, "23")
            not ok 2509 - long option with spacey value # TODO nom regression
            # Failed test 'long option with spacey value'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-other/main-usage.rakudo line 142
            #      got status: 2
            #      got out: ""
            # expected out: IntStr.new(23, "23")
            not ok 2510 - named alias (inner name) with spacey value # TODO nom regression
            # Failed test 'named alias (inner name) with spacey value'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-other/main-usage.rakudo line 147
            #      got status: 2
            #      got out: ""
            # expected out: IntStr.new(23, "23")
            not ok 2511 - named alias (outer name) with spacey value # TODO nom regression
            # Failed test 'named alias (outer name) with spacey value'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-other/main-usage.rakudo line 152
            #      got status: 2
            #      got out: ""
            # expected out: IntStr.new(23, "23")
            not ok 2512 - short option with spacey value # TODO nom regression
            # Failed test 'short option with spacey value'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-other/main-usage.rakudo line 157
            #      got status: 2
            #      got out: ""
            # expected out: IntStr.new(23, "23")
            ok 2513 - 
            ok 2514 - best multi matches (not just first one)
            ok 2515 - superfluous options trigger usage message
            ok 2516 - Stopping option processing
            ok 2517 - Boolean argument with --
            ok 2518 - single occurence for named array param
            ok 2519 - multiple occurence for named array param
            ok 2520 - correctly select Scalar candidate from Scalar and Array candidates.
            not ok 2521 - correct select Array candidate from Scalar and Array candidates. # TODO NYI
            # Failed test 'correct select Array candidate from Scalar and Array candidates.'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-other/main-usage.rakudo line 198
            #      got out: "Scalar"
            # expected out: "Array"
            ok 2522 - passing an integer matches MAIN(Str)
            ok 2523 - failed constraint check doesn't leak internal exception out to the user
            ok 2524 - use of anon slurpy hash does not cause a crash
                1..4
                ok 1 - default $*USAGE is available inside `sub USAGE`
                ok 2 - default $*USAGE is available inside `sub MAIN`
                ok 3 - trying to assign to $*USAGE inside sub MAIN throws
                ok 4 - trying to assign to $*USAGE inside sub MAIN throws
            ok 2525 - $*USAGE tests
# FUDGED!
            1..39
            ok 2526 - can Int   take an Int:U
            ok 2527 - can Int   take an Int:D
            ok 2528 - can Int:_ take an Int:U
            ok 2529 - can Int:_ take an Int:D
            ok 2530 - can Int:U take an Int:U
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 2531 - can Int:U take an Int:D
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 2532 - can Int:D take an Int:U
            ok 2533 - can Int:D take an Int:D
                1..2
                ok 1 - 'sub a(Int:foo $a) { $a }' died
                ok 2 - right exception type (X::InvalidTypeSmiley)
            ok 2534 - does Int:foo fail
            ok 2535 - can --> Int   return an Int:U
            ok 2536 - can --> Int   return an Int:D
            ok 2537 - can --> Int:_ return an Int:U
            ok 2538 - can --> Int:_ return an Int:D
            ok 2539 - can --> Int:U return an Int:U
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::TypeCheck::Return)
            ok 2540 - can --> Int:U return an Int:D
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::TypeCheck::Return)
            ok 2541 - can --> Int:D return an Int:U
            ok 2542 - can --> Int:D return an Int:D
                1..2
                ok 1 - 'sub a(--> Int:foo) { }' died
                ok 2 - right exception type (X::InvalidTypeSmiley)
            ok 2543 - does --> Int:foo fail
            ok 2544 - # SKIP use parameters is NYI until further notice
            ok 2545 - # SKIP use parameters is NYI until further notice
            ok 2546 - # SKIP use parameters is NYI until further notice
            ok 2547 - # SKIP use parameters is NYI until further notice
            ok 2548 - # SKIP use parameters is NYI until further notice
            ok 2549 - # SKIP use parameters is NYI until further notice
            ok 2550 - # SKIP use parameters is NYI until further notice
            ok 2551 - # SKIP use parameters is NYI until further notice
            ok 2552 - # SKIP use parameters is NYI until further notice
            ok 2553 - # SKIP use parameters is NYI until further notice
            ok 2554 - # SKIP use parameters is NYI until further notice
            ok 2555 - # SKIP use parameters is NYI until further notice
            ok 2556 - # SKIP use parameters is NYI until further notice
            ok 2557 - # SKIP use parameters is NYI until further notice
            ok 2558 - # SKIP use parameters is NYI until further notice
            ok 2559 - # SKIP use parameters is NYI until further notice
            ok 2560 - # SKIP use parameters is NYI until further notice
            ok 2561 - .gist on :U smileys
            ok 2562 - .gist on :U smileys uses shortname
            ok 2563 - .gist on :D smileys
            ok 2564 - .gist on :D smileys uses shortname
# FUDGED!
            1..21
            ok 2565 - code executes as testsub({...})
            ok 2566 - code executes as testsub($closure)
            ok 2567 - code executes as testsub(&subroutine)
            ok 2568 - code runs with proper signature (1)
                1..2
                ok 1 - 'testit(&teststr)' died
                ok 2 - right exception type (Exception)
            ok 2569 - code dies with invalid signature (1)
            ok 2570 - code runs with proper signature (1)
                1..2
                ok 1 - 'test-but-dont-call(&teststr)' died
                ok 2 - right exception type (Exception)
            ok 2571 - code dies with invalid signature (1)
            ok 2572 - code runs with proper signature (2)
                1..2
                ok 1 - 'testit(&testintint)' died
                ok 2 - right exception type (Exception)
            ok 2573 - code dies with invalid signature (2)
                1..2
                ok 1 - 'testit(&teststrbool)' died
                ok 2 - right exception type (Exception)
            ok 2574 - code dies with invalid signature (3)
                1..2
                ok 1 - 'testit(&teststrint)' died
                ok 2 - right exception type (Exception)
            ok 2575 - code dies with invalid signature (4)
            ok 2576 - # SKIP subsignatures dont factor into multi candidates yet
            ok 2577 - Multi dispatch based on closure parameter syntax (2)
            ok 2578 - Multi dispatch based on closure parameter syntax (3)
            ok 2579 - Multi dispatch based on closure parameter syntax (4)
            ok 2580 - Multi dispatch based on closure parameter syntax (5)
            ok 2581 - can use &a as a named parameter
                1..2
                ok 1 - 'sub f (Int &b:(--> Bool)) { }' died
                ok 2 - right exception type (X::Redeclaration)
            ok 2582 - only one way of specifying sub-signature return type allowed
            ok 2583 - called sub in unpacking Callable signature with colon
            ok 2584 - unpacking Callable signature with colon
                1..2
                ok 1 - can call with right signature
                    1..2
                    ok 1 - '-> &:(Int) {}({;})' died
                    ok 2 - right exception type (X::TypeCheck::Binding::Parameter)
                ok 2 - typcheck correctly fails with wrong arg
            ok 2585 - can use signature unpacking with anonymous parameters
# FUDGED!
            1..8
            ok 2586 - Can call my_sub() if &my_sub was a parameter
            ok 2587 - same with anonymous sub
            ok 2588 - can't pass thing that doesn't do Callable
            ok 2589 - can't pass thing that doesn't do Callable
            ok 2590 - Can pass a block to a &parameter
            ok 2591 - Can't pass something that isn't typed as returning Callable
            not ok 2592 - can call a sub with a code object defaulting to something of its own name # TODO RT #67932
            # Failed test 'can call a sub with a code object defaulting to something of its own name'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-signature/code.rakudo line 47
            # Type check failed in binding to parameter '&foo'; expected Callable but got Nil (Nil)
            ok 2593 - the inner &foo is undefined (scoping)
# FUDGED!
Potential difficulties:
    Useless use of ... in sink context
    at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-signature/definite-return.rakudo:99
    ------> [32mmpty) { 1, { ++$got-here; last } ... * }[33m⏏[31m<EOL>[0m
WARNINGS for /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-signature/definite-return.rakudo:
Useless use of constant integer False in sink context (line 104)
Useless use of constant integer True in sink context (lines 109, 114, 121)
Useless use of constant integer 42 in sink context (line 85)
Useless use of constant integer 1 in sink context (line 12)
Useless use of "sin(1)" in expression "sin(1)" in sink context (line 131)
Useless use of constant integer 3 in sink context (line 20)
            1..19
            ok 2594 - A function with a definite return value should ignore the result of its last statement
            ok 2595 - A function with a non-Nil definite return value should ignore the result of its last statement
                1..2
                ok 1 - '
                #         my sub return-nil(--> Nil) {
                #             return 1
                #         }
                #     ' died
                ok 2 - right exception type (Exception)
            ok 2596 - A function with a definite return value may not use return with a value
                1..2
                ok 1 - '
                #         my sub return-failure(--> Nil) {
                #             return Failure.new(X::AdHoc.new(4))
                #         }
                #     ' died
                ok 2 - right exception type (X::AdHoc)
            ok 2597 - A function with a definite return value may not use return with a value, even a Failure
            ok 2598 - Failures bypass the return value of function with a definite return value in the signature
            ok 2599 - Failures bypass the return value of function with a definite return value in the signature
            ok 2600 - Value-less returns are allowed in functions with definite return value in their signatures
            ok 2601 - # SKIP variables as return specifications dont parse yet
            ok 2602 - # SKIP variables as return specifications dont parse yet
            ok 2603 - We can return strings
            ok 2604 - We can return from statement-less blocks
            ok 2605 - We can return Empty
            ok 2606 - and the last statement of the function was sunk
            ok 2607 - can return True
            ok 2608 - can return False
            ok 2609 - can return pi
            ok 2610 - can return indiana-pi
            ok 2611 - pointy can have definite return type that is an integer
            ok 2612 - pointy can have definite return type of Nil
# FUDGED!
            1..151
            ok 2613 - .params does Positional
            ok 2614 - And all items are Parameters
            ok 2615 - we have three of them
            ok 2616 - can get the names with sigils
            ok 2617 - Could get first type
            ok 2618 - Could get second type
            ok 2619 - they are all read-only
            ok 2620 - ... none rw
            ok 2621 - ... none copy
            ok 2622 - ... none raw
            ok 2623 - ... none slurpy
            ok 2624 - ... some optional
            ok 2625 - ... none invocant
            ok 2626 - ... one named
            ok 2627 - (second sig) none are all read-only
            ok 2628 - ... one rw
            ok 2629 - ... one raw
            ok 2630 - ... one copy
            ok 2631 - ... none slurpy
            ok 2632 - ... some optional
            ok 2633 - ... none invocant
            ok 2634 - ... all named
            ok 2635 - named_names work
            ok 2636 - .name works for renamed params
            ok 2637 - .named for slurpies
            ok 2638 - .slurpy
            ok 2639 - .name for slurpies
            ok 2640 - multi named_names
            ok 2641 - ... and .name still works
            not ok 2642 - ... and .raku abbreviates separated name/named_name # TODO needs/find RT: Logic to make :a($a) into :$a makes :a(:b($a) into ::b(:$a)
            # Failed test '... and .raku abbreviates separated name/named_name'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-signature/introspection.rakudo line 64
            # expected: ':(:b($a))'
            #      got: ':(:b(:$a))'
            ok 2643 - .default returns closure
            ok 2644 - first closure works
            ok 2645 - # SKIP expected Any but got Mu instead
            ok 2646 - .constraints (+)
            ok 2647 - .constraints (-)
            ok 2648 - .constraints on unconstraint param should still smartmatch truely
            ok 2649 - smartmach against non-closure constraint (+)
            ok 2650 - smartmach against non-closure constraint (-)
            ok 2651 - :(3) contains the 3
            ok 2652 - :(3) has a parameter of type Int
            ok 2653 - .type_captures
            ok 2654 - can access a type_capture'd type
            ok 2655 - .raku on a nested signature contains variables of the subsignature (1)
            ok 2656 - .raku on a nested signature contains variables of the subsignature (2)
            ok 2657 - prefix | makes .capture true
            ok 2658 - prefix | appears in .raku output
            ok 2659 - prefix \ makes .raw true
            ok 2660 - prefix \ appears in .raku output
            ok 2661 - .raku of a signature with anonymous named parameter
            ok 2662 - .name of |c is "c"
            ok 2663 - .positional on Capture param is False
            ok 2664 - .capture on Capture param is True
            ok 2665 - .named on Capture param is True
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2666 - .raku of ($a, :$b) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2667 - .raku of (@a, :@b) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2668 - .raku of (%a, :%b) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2669 - .raku of (:a(:b($c))) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2670 - .raku of (|a) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2671 - .raku of (&a, :&b) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2672 - .raku of (\a) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2673 - .raku of (\a, $b, &c, %d, |e) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2674 - .raku of ($a = 2, :$b = 2) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2675 - .raku of (@a = Code.new, :@b = Code.new) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2676 - .raku of (%a = Code.new, :%b = Code.new) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2677 - .raku of (&a = Code.new, :&b = Code.new) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2678 - .raku of ($a is raw = 2) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2679 - .raku of (@a is raw = Code.new) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2680 - .raku of (%a is raw = Code.new) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2681 - .raku of (&a is raw = Code.new) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2682 - .raku of (\a = 2) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2683 - .raku of (Int $a, Int :$b) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2684 - .raku of (Int @a, Int :@b) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2685 - .raku of (Int %a, Int :%b) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2686 - .raku of (Int :a(:b($c))) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2687 - .raku of (|a ($a)) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2688 - .raku of (Sub &a, Sub :&b) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2689 - .raku of (Int \a) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2690 - .raku of (Int \a, Int $b, Sub &c, Int :$d, |e) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2691 - .raku of (Int $a = 2, Int :$b = 2) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2692 - .raku of (Int @a = Code.new, Int :@b = Code.new) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2693 - .raku of (Int %a = Code.new, Int :%b = Code.new) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2694 - .raku of (Sub &a = Code.new, Sub :&b = Code.new) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2695 - .raku of (@a ($a) = Code.new) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2696 - .raku of (%a (:a($b)) = Code.new, %b (:c(:d($e))) = Code.new) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2697 - .raku of ($, :a($)) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2698 - .raku of (@, :a(@)) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2699 - .raku of (%, :a(%)) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2700 - .raku of (:a(:b($))) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2701 - .raku of (|) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2702 - .raku of (&, :a(&)) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2703 - .raku of ($ is raw) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2704 - .raku of ($ is raw, $, &, %, |) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2705 - .raku of ($ = 2, :a($) = 2) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2706 - .raku of (@ = Code.new, :a(@) = Code.new) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2707 - .raku of (% = Code.new, :a(%) = Code.new) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2708 - .raku of (& = Code.new, :a(&) = Code.new) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2709 - .raku of ($ is raw = 2) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2710 - .raku of (@ is raw = Code.new) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2711 - .raku of (% is raw = Code.new) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2712 - .raku of (& is raw = Code.new) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2713 - .raku of (Int, Int :a($)) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2714 - .raku of (Int @, Int :a(@)) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2715 - .raku of (Int %, Int :a(%)) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2716 - .raku of (Int :a(:b($))) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2717 - .raku of (|a ($)) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2718 - .raku of (Sub &, Sub :a(&)) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2719 - .raku of (Int $ is raw) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2720 - .raku of (Int $ is raw, Int, Sub &, Int %, |) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2721 - .raku of (Int $ = 2, Int :a($) = 2) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2722 - .raku of (Int @ = Code.new, Int :a(@) = Code.new) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2723 - .raku of (Int % = Code.new, Int :a(%) = Code.new) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2724 - .raku of (Sub & = Code.new, Sub :a(&) = Code.new) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2725 - .raku of (@ ($a) = Code.new) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2726 - .raku of (% (:a($)) = Code.new, % (:c(:d($))) = Code.new) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2727 - .raku of ($ is raw, & is raw, % is raw, |) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2728 - .raku of (::T  $a, T $b) is idempotent
                1..3
                ok 1 - Result is same as original
                ok 2 - Same .raku output
                ok 3 - ...and no failures.
            ok 2729 - .raku of (::T T $a, T $b) is idempotent
                1..2
                ok 1 - Same .raku output
                ok 2 - ...and no failures.
            ok 2730 - .raku of -> $a {  \#`(Block|140193524119120) ... } is idempotent
                1..2
                ok 1 - Same .raku output
                ok 2 - ...and no failures.
            ok 2731 - .raku of ->  {  \#`(Block|140193524120200) ... } is idempotent
                1..2
                ok 1 - Same .raku output
                ok 2 - ...and no failures.
            ok 2732 - .raku of -> $ ($a) {  \#`(Block|140193506603536) ... } is idempotent
                1..2
                ok 1 - Same .raku output
                ok 2 - ...and no failures.
            ok 2733 - .raku of -> $ {  \#`(Block|140193506604328) ... } is idempotent
                1..2
                ok 1 - Same .raku output
                ok 2 - ...and no failures.
            ok 2734 - .raku of -> $a ($b) {  \#`(Block|140193502783040) ... } is idempotent
            ok 2735 - .raku of a sigature that has ::?CLASS
            ok 2736 - .raku on unnamed | parameters doesn't err
            ok 2737 - .raku on unnamed \ parameters doesn't err
            ok 2738 - ";;" in signature stringifies correctly using .gist
            ok 2739 - ";;" in signature stringifies correctly using .raku
            ok 2740 - Callable in signature stringifies correctly using .raku
            ok 2741 - Callable in signature stringifies correctly using .gist
            ok 2742 - perl on :(Callable)
            ok 2743 - .raku on :(Array of Callable)
            ok 2744 - .raku on :(Hash of Callable)
            ok 2745 - .gist does not strip typeless anon sigils
            ok 2746 - does a dynamic Parameter have a * twigil
            ok 2747 - does a private attribute Parameter have a ! twigil
            ok 2748 - does a public attribute Parameter have a . twigil
            ok 2749 - parameters do not give any prefix by default
            ok 2750 - slurpy positional parameters give a * prefix
            ok 2751 - slurpy LoL parameters give a ** prefix
            ok 2752 - slurpy named parameters give a * prefix
            ok 2753 - slurpy onearg parameters give a + prefix
            ok 2754 - positional parameters do not give any suffix by default
            ok 2755 - named parameters do not give any suffix by default
            ok 2756 - optional positional parameters give a ? suffix
            ok 2757 - required named parameters give a ! suffix
            ok 2758 - default values for positional parameters do not give a ? suffix
            ok 2759 - default values for named parameters do not give a ! suffix
            ok 2760 - an unnamed raw parameter should have the '$' sigil
            ok 2761 - private attribute parameters have the correct name
            ok 2762 - public attribute parameters have the correct name
            ok 2763 - OUTER defaults have the correct .raku
# FUDGED!
            1..100
            ok 2764 - Can pass positional arguments
            ok 2765 - Dies on passing superfluous arguments
            ok 2766 - Named argument passes an integer, not a Pair
            ok 2767 - can use :$x colonpair syntax to call named arg
            ok 2768 - colonpair with wrong variable name dies
            ok 2769 - colonpair with a private variable
            ok 2770 - colonpair with a public variable
            ok 2771 - colonpair with a positional variable
            ok 2772 - simple named param
            ok 2773 - not specifying named params that aren't mandatory works
            ok 2774 - using a named as a positional fails
            ok 2775 - naming named param also works
            ok 2776 - naming named param adverb-style also works
            ok 2777 - not specifying named params that aren't mandatory works (foo2)
            ok 2778 - using a named as a positional fails (foo2)
            ok 2779 - using a named as a positional fails (foo2)
            ok 2780 - naming named param x also works (foo2)
            ok 2781 - naming named param y also works (foo2)
            ok 2782 - naming named param x & y also works (foo2)
            ok 2783 - naming named param x adverb-style also works (foo2)
            ok 2784 - naming named param y adverb-style also works (foo2)
            ok 2785 - naming named params x & y adverb-style also works (foo2)
            ok 2786 - mixing fat-comma and adverb naming styles also works for named params (foo2)
            ok 2787 - mixing adverb and fat-comma naming styles also works for named params (foo2)
            ok 2788 - When we don't explicitly specify, we get the original value
            ok 2789 - When we explicitly specify, we get our value
            ok 2790 - When we explicitly specify, we get our value
            ok 2791 - When we explicitly specify, we get our value
            ok 2792 - # SKIP multiple same-named arguments NYI
            ok 2793 - # SKIP multiple same-named arguments NYI
            ok 2794 - # SKIP multiple same-named arguments NYI
            ok 2795 - # SKIP multiple same-named arguments NYI
            ok 2796 - # SKIP multiple same-named arguments NYI
            ok 2797 - # SKIP multiple same-named arguments NYI
            ok 2798 - # SKIP multiple same-named arguments NYI
            ok 2799 - # SKIP multiple same-named arguments NYI
            ok 2800 - # SKIP multiple same-named arguments NYI
            ok 2801 - # SKIP multiple same-named arguments NYI
            ok 2802 - # SKIP multiple same-named arguments NYI
            ok 2803 - # SKIP multiple same-named arguments NYI
            ok 2804 - # SKIP multiple same-named arguments NYI
            ok 2805 - # SKIP multiple same-named arguments NYI
            ok 2806 - # SKIP multiple same-named arguments NYI
            ok 2807 - # SKIP multiple same-named arguments NYI
            ok 2808 - named mandatory parameter is returned
            ok 2809 - not specifying a mandatory parameter fails
            ok 2810 - named mandatory parameter is returned
            ok 2811 - not specifying a mandatory parameter fails
            ok 2812 - text param was positional
            ok 2813 - justification param was not given
            ok 2814 - case param was named, and in justification param's position
            ok 2815 - text param was positional
            ok 2816 - justify param was named
            ok 2817 - case was not given at all
            ok 2818 - title param was positional
            ok 2819 - justify param was named with funny syntax
            ok 2820 - case param was named with funny syntax
            ok 2821 - parameters don't bind incorrectly
            ok 2822 - hobbit arg was slurped
            ok 2823 - wizard arg was slurped
            ok 2824 - exactly 2 arguments were slurped
            ok 2825 - dwarf arg was not given
            ok 2826 - explicit named arg received despite slurpy hash
            ok 2827 - exactly 2 arguments were slurped
            ok 2828 - sky argument was slurped
            ok 2829 - fire argument was slurped
            ok 2830 - grass argument was NOT slurped
            ok 2831 - aref actually implemented
            ok 2832 - ref is the same as aref
            ok 2833 - typed named parameters work...
            ok 2834 - ...when value not supplied also...
            ok 2835 - and the type check is enforced
            ok 2836 - renaming of parameters works
            ok 2837 - renaming of parameters works
            ok 2838 - old name is not available
                1..2
                ok 1 - 'sub rt68086( $a, $a ) { }' died
                ok 2 - right exception type (X::Redeclaration)
            ok 2839 - two sub params with the same name
                1..2
                ok 1 - 'sub svn28865( :$a, :@a ) {}' died
                ok 2 - right exception type (X::Signature::NameClash)
            ok 2840 - sub params with the same name and different types
            ok 2841 - call to sub with position params of same name and different type
            ok 2842 - .signature.raku with required parameter includes requirement
            ok 2843 - parameter rename appears in .signature.raku
            ok 2844 - passing in three named arguments
            ok 2845 - $a was bound before $b
            ok 2846 - $a was bound before $c
            ok 2847 - $b was bound before $c
                1..2
                ok 1 - 'sub a(:$x, :foo($x) = $x) { $x }' died
                ok 2 - right exception type (X::Redeclaration)
            ok 2848 - Cannot rename a parameter to an already existing positional
            ok 2849 - Can fill named parameter with default from other named
            ok 2850 - Can fill in directly even it has a default value
            ok 2851 - direct fill takes precedence
            ok 2852 - :a(1, 2, 3) can be passed to a :@a parameter
            ok 2853 - :a[1, 2, 3] can be passed to a :@a parameter
            ok 2854 - :a<1 2 3> can be passed to a :@a parameter
            ok 2855 - quoted pair key => positional parameter
            ok 2856 - can call function with empty named argument
            ok 2857 - can pass in several same-named arguments to sub, sigils other than "@" bind to last argument (1)
            ok 2858 - can pass in several same-named arguments to sub, sigils other than "@" bind to last argument (2)
            ok 2859 - rightmost named argument wins (1)
            ok 2860 - rightmost named argument wins (2)
            ok 2861 - rightmost named argument wins (3)
            ok 2862 - rightmost named argument wins (4)
            ok 2863 - Hot looping making call with aliased named parameter works
# FUDGED!
            1..4
                1..2
                ok 1 - f eq 2 after binding
                ok 2 - o eq 3 after binding
            ok 2864 - signature binding outside of routine calls
                1..5
                    1..5
                    ok 1 - :D ~~ :D (false)
                    ok 2 - :D ~~ :D (true)
                    ok 3 - :U ~~ :D
                    ok 4 - :D x 2 ~~ :D x2 (false)
                    ok 5 - :D x 2 ~~ :D x2 (true)
                ok 1 - strings
                    1..5
                    ok 1 - :D ~~ :D (false)
                    ok 2 - :D ~~ :D (true)
                    ok 3 - :U ~~ :D
                    ok 4 - :D x 2 ~~ :D x2 (false)
                    ok 5 - :D x 2 ~~ :D x2 (true)
                ok 2 - Complex
                    1..5
                    ok 1 - # SKIP crashes
                    ok 2 - # SKIP crashes
                    ok 3 - # SKIP crashes
                    ok 4 - # SKIP crashes
                    ok 5 - # SKIP crashes
                ok 3 - Rat
                    1..5
                    ok 1 - :D ~~ :D (false)
                    ok 2 - :D ~~ :D (true)
                    ok 3 - :U ~~ :D
                    ok 4 - :D x 2 ~~ :D x2 (false)
                    ok 5 - :D x 2 ~~ :D x2 (true)
                ok 4 - Num
                    1..5
                    ok 1 - :D ~~ :D (false)
                    ok 2 - :D ~~ :D (true)
                    ok 3 - :U ~~ :D
                    ok 4 - :D x 2 ~~ :D x2 (false)
                    ok 5 - :D x 2 ~~ :D x2 (true)
                ok 5 - Int
            ok 2865 - smartmatch on signatures with literals
            ok 2866 - invocant marker is allowed in bare signature
            ok 2867 - smartmatch with no slurpy on right side
# FUDGED!
            1..34
            ok 2868 - The object is-a 'Code'
            ok 2869 - The object is-a 'Routine'
            ok 2870 - The object is-a 'Sub'
            ok 2871 - basic invocation of an anonymous sub
            ok 2872 - invocation of a parameterless anonymous sub with a parameter dies
            ok 2873 - The object is-a 'Code'
            ok 2874 - The object is-a 'Block'
            ok 2875 - basic invocation of a pointy block
            ok 2876 - invocation of a parameterless pointy block with a parameter dies
            ok 2877 - The object is-a 'Code'
            ok 2878 - The object is-a 'Block'
            ok 2879 - basic invocation of a pointy block with a param
            ok 2880 - invocation of a parameterized block expecting a param without a param dies
            not ok 2881 - $_ got right value for code ref # TODO RT #63974
            # Failed test '$_ got right value for code ref'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-signature/sub-ref.rakudo line 60
            # expected: '2'
            #      got: (Rakudo::Internals::LoweredAwayLexical)
            not ok 2882 - @_ got right value in code ref # TODO RT #63974
            # Failed test '@_ got right value in code ref'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-signature/sub-ref.rakudo line 61
            # expected: '3 4 5'
            #      got: '2 3 4 5'
            ok 2883 - The object is-a 'Code'
            ok 2884 - The object is-a 'Routine'
            ok 2885 - The object is-a 'Sub'
            ok 2886 - basic invocation of a Perl-like anonymous sub (1)
            ok 2887 - basic invocation of a Perl-like anonymous sub (2)
            ok 2888 - The object is-a 'Code'
            ok 2889 - The object is-a 'Routine'
            ok 2890 - The object is-a 'Sub'
            ok 2891 - calling an anonymous sub with a positional param
            ok 2892 - calling an anonymous sub expecting a param without a param dies
            ok 2893 - calling an anonymous sub expecting one param with two params dies
            ok 2894 - # SKIP macros, compile time binding
            ok 2895 - # SKIP macros, compile time binding
            ok 2896 - # SKIP macros, compile time binding
            ok 2897 - # SKIP macros, compile time binding
            ok 2898 - closures: inc1 == 0
            ok 2899 - closures: inc1 == 1
            ok 2900 - closures: inc2 == 0
            ok 2901 - closures: inc2 == 1
# FUDGED!
            1..20
            ok 2902 - left value is correct: basic hash
            ok 2903 - right value is correct: basic hash
            ok 2904 - left value is correct: hash with extra values
            ok 2905 - right value is correct: hash with extra values
            ok 2906 - left value is correct: hash with values that are hashes
            ok 2907 - right value is correct: hash with values that are hashes
            ok 2908 - east value is correct: custom hash values work
            ok 2909 - west value is correct: custom hash values work
            ok 2910 - east value is correct: custom hash, extra values
            ok 2911 - west value is correct: custom hash, extra values
            ok 2912 - east value is correct: custom hash with values that are hashes
            ok 2913 - west value is correct: custom hash with values that are hashes
            ok 2914 - left object value is correct: simple object
            ok 2915 - right object value is correct: simple object
            ok 2916 - left object value is correct: nested object tree
            ok 2917 - right object value is correct: nested object tree
            ok 2918 - # SKIP signature binding of return values NYI
            ok 2919 - # SKIP signature binding of return values NYI
            ok 2920 - # SKIP signature binding of return values NYI
            ok 2921 - # SKIP signature binding of return values NYI
# FUDGED!
            1..7
            ok 2922 - assoc<left>
            ok 2923 - assoc<right>
            ok 2924 - assoc<list>
            ok 2925 - assoc<non>
            ok 2926 - # SKIP RT  \#116244
            ok 2927 - # SKIP RT  \#116244
            ok 2928 - User-defined chaining operators with assoc<chain> work
# FUDGED!
            1..23
                1..2
                ok 1 - '
                #     my $tmp = 1;
                #     sub mods_param ($x) { $x++; }
                #     mods_param($tmp)
                #     ' died
                ok 2 - right exception type (X::Multi::NoMatch)
            ok 2929 - can't modify parameter, constant by default
                1..2
                ok 1 - '
                #     my $tmp = 1;
                #     sub mods_param ($x) { $x = 1; }
                #     mods_param($tmp)
                #     ' died
                ok 2 - right exception type (Exception)
            ok 2930 - can't modify parameter, constant by default
                1..2
                ok 1 - 'sub mods_param_constant ($x is readonly) { $x++; };
                #              mods_param_constant($foo);' died
                ok 2 - right exception type (X::Multi::NoMatch)
            ok 2931 - can't modify constant parameter, constant by default
            ok 2932 - can't modify constant even if we claim it's rw
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::Parameter::RW)
            ok 2933 - is rw dies in signature binding if passed a literal Int
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::Parameter::RW)
            ok 2934 - is rw dies in signature binding if passed an itemized array
            ok 2935 - pass by "is rw" doesn't die
            ok 2936 - pass by reference works
            ok 2937 - trait "is rw" used to narrow multi-dispatch
            ok 2938 - trait "is rw" used to narrow multi-dispatch (converse)
            ok 2939 - is copy
            ok 2940 - pass by value works
            ok 2941 - can modify a copy
            ok 2942 - is raw with non-lvalue
            ok 2943 - is raw with non-lvalue
            ok 2944 - is raw works
            ok 2945 - <-> does not override explicit traints (sanity)
            not ok 2946 - <-> does not override explicit traints # TODO is readonly does not override
            # Failed test '<-> does not override explicit traints'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-traits/misc.rakudo line 92
            not ok 2947 - <-> does not override explicit traints (sanity) # TODO is readonly does not override
            # Failed test '<-> does not override explicit traints (sanity)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-traits/misc.rakudo line 93
            # expected: '2'
            #      got: '3'
            ok 2948 - Can't use an unknown trait
            ok 2949 - error message mentions trait
            ok 2950 - error message mentions the name of the trait
            ok 2951 - duplicate traits warn
# FUDGED!
            1..15
            not ok 2952 - 'is tighter' on prefix works # TODO changing precedence of already declared op
            # Failed test ''is tighter' on prefix works'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S06-traits/precedence.rakudo line 20
            # expected: '9'
            #      got: '3'
            ok 2953 - 'is looser' on prefix works
            ok 2954 - 'is tighter' on postfix works
            ok 2955 - 'is looser(&infix:<+>' works 1
            ok 2956 - 'is looser(&infix:<+>' works 2
            ok 2957 - 'is looser<+>' infix works 1
            ok 2958 - 'is looser<+>' infix works 2
            ok 2959 - 'is tighter<*>' infix works 1
            ok 2960 - 'is tighter<*>' infix works 2
            ok 2961 - 'is equiv(&infix:<*>)' works
            ok 2962 - 'is equiv<*>' works
            ok 2963 - Postifix declared looser than prefix
            ok 2964 - Postfix declared tighter than prefix
            ok 2965 - Should be parsed as '-(1!)'
            ok 2966 - Whitespace not allowed before user-defined postfix
# FUDGED!
            1..87
            ok 2967 - can hyper-map a simple code block
            ok 2968 - hyper over a big-ish list of Ints
            ok 2969 - two-stage hyper map over big-ish Int list
            ok 2970 - two-stage hyper map over some strings
            ok 2971 - hyper + grep
            ok 2972 - hyper + grep + map
                1..2
                ok 1 - hyper + map
                ok 2 - hyper + grep
            ok 2973 - hyper + map/grep in reverse
                1..5
                ok 1 - code dies
                ok 2 - right exception type (X::Invalid::Value)
                ok 3 - .method matches hyper
                ok 4 - .name matches batch
                ok 5 - .value matches -1
            ok 2974 - cannot have a batch of -1 for hyper
                1..5
                ok 1 - code dies
                ok 2 - right exception type (X::Invalid::Value)
                ok 3 - .value matches 0
                ok 4 - .name matches batch
                ok 5 - .method matches hyper
            ok 2975 - cannot have a batch of 0 for hyper
                1..5
                ok 1 - code dies
                ok 2 - right exception type (X::Invalid::Value)
                ok 3 - .method matches hyper
                ok 4 - .name matches degree
                ok 5 - .value matches -1
            ok 2976 - cannot have a degree of -1 for hyper
                1..5
                ok 1 - code dies
                ok 2 - right exception type (X::Invalid::Value)
                ok 3 - .value matches 0
                ok 4 - .method matches hyper
                ok 5 - .name matches degree
            ok 2977 - cannot have a degree of 0 for hyper
            ok 2978 - Exception thrown in hyper for is not lost (1..1)
            ok 2979 - Exception thrown in hyper for is not lost (1..1000)
            ok 2980 - Exception thrown in hyper map is not lost (1..1)
            ok 2981 - Exception thrown in hyper map is not lost (1..1000)
            ok 2982 - Exception thrown in hyper grep is not lost (1..1)
            ok 2983 - Exception thrown in hyper grep is not lost (1..1000)
                1..10
                ok 1 - .hyper(:3batch, :5degree) [0]
                ok 2 - .hyper(:3batch, :5degree) [1]
                ok 3 - .hyper(:3batch, :5degree) [2]
                ok 4 - .hyper(:3batch, :5degree) [3]
                ok 5 - .hyper(:3batch, :5degree) [4]
                ok 6 - .hyper(:1batch) [0]
                ok 7 - .hyper(:1batch) [1]
                ok 8 - .hyper(:1batch) [2]
                ok 9 - .hyper(:1batch) [3]
                ok 10 - .hyper(:1batch) [4]
            ok 2984 - .hyper with .map that sleep()s
            ok 2985 - hyper map with a multi sub works
            ok 2986 - for <a b c>.hyper { } actually iterates
            ok 2987 - Correct result for [+] (1..100).hyper
            ok 2988 - Correct result for [+] (1..100).hyper.grep(* != 22)
            ok 2989 - Correct result for [+] (1..100).grep(* != 22).hyper
            ok 2990 - .hyper.elems works
            ok 2991 - hyper map in sink context iterates
            ok 2992 - .is-lazy on HyperSeq returns False
            ok 2993 - .Numeric on HyperSeq
            ok 2994 - Correct result of .hyper.map(*+1) (try 0)
            ok 2995 - Correct result of .hyper.map(*+1) (try 1)
            ok 2996 - Correct result of .hyper.map(*+1) (try 2)
            ok 2997 - Correct result of .hyper.map(*+1) (try 3)
            ok 2998 - Correct result of .hyper.map(*+1) (try 4)
            ok 2999 - .hyper.map({.fmt(...)}) on a Buf slice works
            ok 3000 - .hyper.map({.fmt(...)}) on a Buf slice works
            ok 3001 - .hyper.map({.fmt(...)}) on a Buf slice works
            ok 3002 - .hyper.map({.fmt(...)}) on a Buf slice works
            ok 3003 - .hyper.map({.fmt(...)}) on a Buf slice works
            ok 3004 - can race-map a simple code block
            ok 3005 - race over a big-ish list of Ints
            ok 3006 - two-stage race map over big-ish Int list
            ok 3007 - two-stage race map over some strings
            ok 3008 - race + grep
            ok 3009 - race + grep + map
                1..2
                ok 1 - race + map
                ok 2 - race + grep
            ok 3010 - race + map/grep in reverse
                1..5
                ok 1 - code dies
                ok 2 - right exception type (X::Invalid::Value)
                ok 3 - .value matches -1
                ok 4 - .name matches batch
                ok 5 - .method matches race
            ok 3011 - cannot have a batch of -1 for race
                1..5
                ok 1 - code dies
                ok 2 - right exception type (X::Invalid::Value)
                ok 3 - .method matches race
                ok 4 - .name matches batch
                ok 5 - .value matches 0
            ok 3012 - cannot have a batch of 0 for race
                1..5
                ok 1 - code dies
                ok 2 - right exception type (X::Invalid::Value)
                ok 3 - .method matches race
                ok 4 - .value matches -1
                ok 5 - .name matches degree
            ok 3013 - cannot have a degree of -1 for race
                1..5
                ok 1 - code dies
                ok 2 - right exception type (X::Invalid::Value)
                ok 3 - .value matches 0
                ok 4 - .name matches degree
                ok 5 - .method matches race
            ok 3014 - cannot have a degree of 0 for race
            ok 3015 - Exception thrown in race for is not lost (1..1)
            ok 3016 - Exception thrown in race for is not lost (1..1000)
            ok 3017 - Exception thrown in race map is not lost (1..1)
            ok 3018 - Exception thrown in race map is not lost (1..1000)
            ok 3019 - Exception thrown in race grep is not lost (1..1)
            ok 3020 - Exception thrown in race grep is not lost (1..1000)
                1..10
                ok 1 - .race(:3batch, :5degree) [0]
                ok 2 - .race(:3batch, :5degree) [1]
                ok 3 - .race(:3batch, :5degree) [2]
                ok 4 - .race(:3batch, :5degree) [3]
                ok 5 - .race(:3batch, :5degree) [4]
                ok 6 - .race(:1batch) [0]
                ok 7 - .race(:1batch) [1]
                ok 8 - .race(:1batch) [2]
                ok 9 - .race(:1batch) [3]
                ok 10 - .race(:1batch) [4]
            ok 3021 - .race with .map that sleep()s
            ok 3022 - race map with a multi sub works
            ok 3023 - for <a b c>.race { } actually iterates
            ok 3024 - Correct result for [+] (1..100).race
            ok 3025 - Correct result for [+] (1..100).race.grep(* != 22)
            ok 3026 - Correct result for [+] (1..100).grep(* != 22).race
            ok 3027 - .race.elems works
            ok 3028 - race map in sink context iterates
            ok 3029 - .is-lazy on RaceSeq returns False
            ok 3030 - .Numeric on RaceSeq
            ok 3031 - Correct result of .race.map(*+1) (try 0)
            ok 3032 - Correct result of .race.map(*+1) (try 1)
            ok 3033 - Correct result of .race.map(*+1) (try 2)
            ok 3034 - Correct result of .race.map(*+1) (try 3)
            ok 3035 - Correct result of .race.map(*+1) (try 4)
            ok 3036 - .race.map({.fmt(...)}) on a Buf slice works
            ok 3037 - .race.map({.fmt(...)}) on a Buf slice works
            ok 3038 - .race.map({.fmt(...)}) on a Buf slice works
            ok 3039 - .race.map({.fmt(...)}) on a Buf slice works
            ok 3040 - .race.map({.fmt(...)}) on a Buf slice works
            ok 3041 - Can switch from race to hyper mode
            ok 3042 - Switching from race to hyper mode does not break results
            ok 3043 - Can switch from race to sequential Seq
            ok 3044 - Switching from race to sequential Seq does not break results
            ok 3045 - Can switch from hyper to race mode
            ok 3046 - Switching from hyper to race mode does not break results
            ok 3047 - Can switch from hyper to sequential Seq
            ok 3048 - hyper to sequential Seq switch does not break results or disorder
            ok 3049 - .hyper preserves order
            ok 3050 - hyperized s/…/…/;
            ok 3051 - # SKIP reliably hangs / segfaults on at least MacOS
            ok 3052 - die in a race nested in a race propagates exception
            ok 3053 - die in a hyper nested in a hyper propagates exception
# FUDGED!
            1..103
            ok 3054 - $r is an Iterator
            ok 3055 - $r.count-only works
            ok 3056 - $r.pull-one == 1 and Range Iterator kept place
            ok 3057 - $r.pull-one == 2
            ok 3058 - $r.pull-one == 3
            ok 3059 - $r.pull-one == 4
            ok 3060 - $r.pull-one == 5
            ok 3061 - $r.pull-one is done
            ok 3062 - $r is an Iterator
            ok 3063 - # SKIP Method 'count-only' not found for invocant of class
            ok 3064 - $r.pull-one == -1.5 and Range Iterator kept place
            ok 3065 - $r.pull-one == -0.5
            ok 3066 - $r.pull-one == .5
            ok 3067 - $r.pull-one == 1.5
            ok 3068 - $r.pull-one == 2.5
            ok 3069 - $r.pull-one is done
            ok 3070 - $r is an Iterator
            ok 3071 - # SKIP Method 'count-only' not found for invocant of class
            ok 3072 - $r.pull-one == -1.5 and Range Iterator kept place
            ok 3073 - $r.pull-one == -0.5
            ok 3074 - $r.pull-one == .5
            ok 3075 - $r.pull-one == 1.5
            ok 3076 - $r.pull-one == 2.5
            ok 3077 - $r.pull-one is done
            ok 3078 - $r is an Iterator
            ok 3079 - # SKIP Method 'count-only' not found for invocant of class
            ok 3080 - $r.pull-one == -0.5 and Range Iterator kept place
            ok 3081 - $r.pull-one == .5
            ok 3082 - $r.pull-one == 1.5
            ok 3083 - $r.pull-one == 2.5
            ok 3084 - $r.pull-one is done
            ok 3085 - $r is an Iterator
            ok 3086 - $r.is-lazy works
            ok 3087 - $r.pull-one == -1 and Range Iterator kept place
            ok 3088 - $r.pull-one == 0
            ok 3089 - $r.pull-one == 1
            ok 3090 - $r.pull-one == 2
            ok 3091 - $r.pull-one == 3
            ok 3092 - $r.pull-one == 4
            ok 3093 - $r.pull-one == 5
            ok 3094 - $r.pull-one == 106
            ok 3095 - $r is an Iterator
            ok 3096 - $r.is-lazy works
            ok 3097 - $r.pull-one == -1.5 and Range Iterator kept place
            ok 3098 - $r.pull-one == -0.5
            ok 3099 - $r.pull-one == .5
            ok 3100 - $r.pull-one == 1.5
            ok 3101 - $r.pull-one == 2.5
            ok 3102 - $r.pull-one == 3.5
            ok 3103 - $r.pull-one == 4.5
            ok 3104 - $r is an Iterator
            ok 3105 - $r.is-lazy works
            ok 3106 - $r.pull-one == -1.5 and Range Iterator kept place
            ok 3107 - $r.pull-one == -0.5
            ok 3108 - $r.pull-one == .5
            ok 3109 - $r.pull-one == 1.5
            ok 3110 - $r.pull-one == 2.5
            ok 3111 - $r.pull-one == 3.5
            ok 3112 - $r.pull-one == 4.5
            ok 3113 - $r1 is an Iterator
            ok 3114 - $r2 is an Iterator
            ok 3115 - $r1.pull-one == -1
            ok 3116 - $r2.pull-one == 42
            ok 3117 - $r1.pull-one == 0
            ok 3118 - $r2.pull-one == 43
            ok 3119 - $r1.pull-one == 1
            ok 3120 - $r2.pull-one == 44
            ok 3121 - $r1.pull-one == 2
            ok 3122 - $r2.pull-one == 45
            ok 3123 - $r1.pull-one == 3
            ok 3124 - $r2.pull-one == 46
            ok 3125 - $r1.pull-one == 4
            ok 3126 - $r2.pull-one == 47
            ok 3127 - $r1.pull-one == 5
            ok 3128 - $r2.pull-one == 48
            ok 3129 - $r is an Iterator
            ok 3130 - # SKIP Method 'count-only' not found for invocant of class
            ok 3131 - $r.pull-one == d and Range Iterator kept place
            ok 3132 - $r.pull-one == e
            ok 3133 - $r.pull-one == f
            ok 3134 - $r.pull-one == g
            ok 3135 - $r.pull-one is done
            ok 3136 - $r is an Iterator
            ok 3137 - $r.is-lazy works
            ok 3138 - $r.pull-one == d and Range Iterator kept place
            ok 3139 - $r.pull-one == e
            ok 3140 - $r.pull-one == f
            ok 3141 - $r.pull-one == g
            ok 3142 - $r.pull-one == h
            ok 3143 - $r.pull-one == i
            ok 3144 - $r is an Iterator
            ok 3145 - $r.pull-one == 0
            ok 3146 - $r.pull-one == 1
            ok 3147 - $r.pull-one == 2
            ok 3148 - $r.pull-one == 3
            ok 3149 - # SKIP Method 'count-only' not found for invocant of class
            ok 3150 - $r.pull-one == 4 and Range Iterator kept place
            ok 3151 - $r.pull-one == 5
            ok 3152 - $r.pull-one == 6
            ok 3153 - $r.pull-one == 7
                1..6
                ok 1 - .skip-one returns truthy value on successfull skip
                ok 2 - .pull-one after .skip-one gives correct value
                ok 3 - .skip-one (1)
                ok 4 - .skip-one (2)
                ok 5 - .pull-one after 2 .skip-one gives correct value
                ok 6 - .skip-one returns falsy value when there is nothing to skip
            ok 3154 - Iterator.skip-one
                1..3
                ok 1 - skipping 3 values succeeds
                ok 2 - next value after skip is correct
                ok 3 - skipping more values than we have is falsy
            ok 3155 - Iterator.skip-at-least
                1..3
                ok 1 - method returns correct value
                ok 2 - value after skip is correct
                ok 3 - when not enough values to skip, returns IterationEnd
            ok 3156 - Iterator.skip-at-least-pull-one
# FUDGED!
            1..44
            ok 3157 - just mentioning a hash value should not autovivify it
            ok 3158 - autovivification of a hash element to an arrayitem worked
            ok 3159 - Created one hash item
            ok 3160 - autovivification of a hash element to a hashitem worked
            ok 3161 - Inner hash item is really a Hash
            ok 3162 - autovivification to an array by &push
            ok 3163 - autovivified to Array
            ok 3164 - autovivification to an array by &unshift
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-autovivification/autovivification.rakudo line 55
            ok 3165 - autovivification of an array element to an array by &push
            ok 3166 - autovivification of an hash element to an array by &push
            ok 3167 - uninitialized variable is not a Hash (1)
            ok 3168 - hash element assignment worked
            ok 3169 - # SKIP isa multi variant
            ok 3170 - uninitialized variable is not a Hash (2)
            ok 3171 - accessing a not existing hash element of an uninitialized variable works
            ok 3172 - uninitialized variable is not autovivified to a hash (2)
            ok 3173 - accessing a not existing hash element of an uninitialized variable works (2)
            ok 3174 - uninitialized variable is not autovivified to a hash (3)
            ok 3175 - uninitialized variable is not autovivified to a hash (4)
            ok 3176 - uninitialized variable is not a Hash (3)
            ok 3177 - binding a not existing hash element of an uninitialized variable works
            not ok 3178 - uninitialized variable is autovivified to a hash (4) # TODO autoviv, binding
            # Failed test 'uninitialized variable is autovivified to a hash (4)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-autovivification/autovivification.rakudo line 103
            ok 3179 - binding a not existing hash element of an uninitialized variable works (2)
            not ok 3180 - uninitialized variable is autovivified to a hash (5) # TODO autoviv, binding
            # Failed test 'uninitialized variable is autovivified to a hash (5)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-autovivification/autovivification.rakudo line 108
            ok 3181 - uninitialized variable is not an Array (1)
            ok 3182 - uninitialized variable was autovivified to an array (1)
            ok 3183 - array element assignment worked
            ok 3184 - uninitialized variable is not an Array (2)
            ok 3185 - accessing a not existing array element of an uninitialized variable works
            ok 3186 - uninitialized variable was not autovivified to an array (2)
            ok 3187 - accessing a not existing array element of an uninitialized variable works
            ok 3188 - uninitialized variable was not autovivified to an array (3)
            ok 3189 - uninitialized variable was not autovivified to an array (4)
            ok 3190 - uninitialized variable is not an Array (3)
            ok 3191 - binding a not existing array element of an uninitialized variable works (1)
            not ok 3192 - uninitialized variable is autovivified to an array (1) # TODO unknown
            # Failed test 'uninitialized variable is autovivified to an array (1)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-autovivification/autovivification.rakudo line 146
            ok 3193 - binding a not existing array element of an uninitialized variable works (2)
            not ok 3194 - uninitialized variable is autovivified to an array (2) # TODO unknown
            # Failed test 'uninitialized variable is autovivified to an array (2)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-autovivification/autovivification.rakudo line 151
            ok 3195 - autovivification of an array element to an arrayitem worked
            ok 3196 - autovivification of an array element to a hashitem worked
            ok 3197 - using an undeclared globaly qualified code variable in void context is ok
            ok 3198 - ...but invoking undeclared globally qualifed code variable should die
            ok 3199 - autovivificaion of arrays works via multidim syntax
            ok 3200 - autovivification of hashes works via multidim syntax
# FUDGED!
            1..55
            ok 3201 - Any-typed hash access (+)
            ok 3202 - and the hash really uses ===-semantics
            ok 3203 - Any-typed hash does not like Mu keys
            ok 3204 - returned key is correct
            ok 3205 - value-type semantics
            ok 3206 - non-conformant type dies
            ok 3207 - key type mismatch
            ok 3208 - value type mismatch
            ok 3209 - key and value type mismatch
            ok 3210 - .keys
            ok 3211 - .values
            ok 3212 - .kv types (1)
            ok 3213 - .kv types (2)
            ok 3214 - .pairs.key type
            ok 3215 - .pairs.value type
            ok 3216 - .elems
            ok 3217 - binding to typed objecthash elements
            ok 3218 - updated .elems
            ok 3219 - binding key type check failure
            ok 3220 - binding value type check failure
            ok 3221 - Hash.push fails when the resulting array conflicts with the type check
            ok 3222 - Hash.push without array creation is OK
            ok 3223 - Hash.push key type check failure
            ok 3224 - Hash.push value type check failure
            ok 3225 - list assignment + object hashes
            not ok 3226 - using Mu as a key (1) # TODO oh noes, it dies
            # Failed test 'using Mu as a key (1)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-hashes/objecthash.rakudo line 60
            # Type check failed in binding to parameter '<anon>'; expected Any but got Mu (Mu)
            ok 3227 - # SKIP oh noes, it dies
            ok 3228 - using Any as a key
            ok 3229 - # SKIP oh noes, it dies
            not ok 3230 - check whatever access with Mu as key # TODO oh noes, it dies
            # Failed test 'check whatever access with Mu as key'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-hashes/objecthash.rakudo line 70
            # expected: '2,3'
            #      got: '3'
            ok 3231 - .exists returns True on a %h{Any} in a TypedHash
            ok 3232 - declaring empty object hash on rhs of assignment to hash does not die with "Cannot look up attributes in a type object"
            ok 3233 - empty hash listifies to empty list
            ok 3234 - empty object hash listifies to empty list
            ok 3235 - New on an object hash instance produces an object hash
            ok 3236 - Clone of an object hash instance is an object hash
            ok 3237 - Can use mixin objects as keys
            ok 3238 - 
            ok 3239 - 
            ok 3240 - 
            ok 3241 - 
            ok 3242 - 
            ok 3243 - 
            ok 3244 - 
            ok 3245 - 
            ok 3246 - 
            ok 3247 - 
            ok 3248 - 
            ok 3249 - 
            ok 3250 - 
            ok 3251 - 
            ok 3252 - 
            ok 3253 - 
            ok 3254 - 
            ok 3255 - Accept dynamic object hash
# FUDGED!
            1..35
            ok 3256 - basic slice
            ok 3257 - basic slice, explicit list
            ok 3258 - basic slice, duplicate indices
            ok 3259 - slice from array, part 2
            ok 3260 - slice from array slice, part 1
            ok 3261 - slice from array slice, part 2
            ok 3262 - range from array
            ok 3263 - nested slice
            ok 3264 - slice plus range from array
            ok 3265 - range plus slice from array
            ok 3266 - finite sequence slice
            ok 3267 - infinite sequence slice
            ok 3268 - infinite even sequence slice
            ok 3269 - infinite even sequence slice
            ok 3270 - assigning a slice too many items yields a correct return value
            ok 3271 - slice on array literal
            ok 3272 - slice on arrayitem literal
            ok 3273 - values from hash keys, part 1
            ok 3274 - values from hash keys, part 2
            ok 3275 - calculated slice: hyperop
            ok 3276 - @array[2..1] is an empty slice
            ok 3277 - # SKIP *..* does not slice
            ok 3278 - # SKIP *..* does not slice
            ok 3279 - The object is-a 'Array'
            ok 3280 - 
            ok 3281 - slice with one element is a list
            ok 3282 - slice with one element specified by variables
            ok 3283 - can use 1..^@a for subscripting
            ok 3284 - # SKIP .= with non-identifier postfixes
            ok 3285 - # SKIP .= with non-identifier postfixes
            ok 3286 - can assign to a Buf slice
            ok 3287 - [*] slice returns all elements of a list of hash value
                1..3
                ok 1 - more indexes than els
                ok 2 - fewer indexes than els
                ok 3 - lazy iterable with iterator starting non-lazy
            ok 3288 - no "drift" when re-using lazy iterable for indexing
                1..6
                ok 1 - Inf range inclusive
                ok 2 - Inf range exclusive
                ok 3 - Whatever range inclusive
                ok 4 - Whatever range exclusive
                ok 5 - Whatever callable
                ok 6 - Callable
            ok 3289 - infinite ranges and whatever stars
                1..62
                ok 1 - Nested slice, no adverbs
                ok 2 - Nested slice, p adverb
                ok 3 - Nested slice, negated p adverb
                ok 4 - Nested slice, k adverb
                ok 5 - Nested slice, negated k adverb
                ok 6 - Nested slice, v adverb
                ok 7 - Nested slice, negated v adverb
                ok 8 - Nested slice, kv adverb
                ok 9 - Nested slice, negated kv adverb
                ok 10 - Nested slice, exists adverb 1
                ok 11 - Nested slice, exists adverb 2
                ok 12 - Nested slice, exists adverb 3
                ok 13 - Nested slice, delete adverb 1-1
                ok 14 - Nested slice, delete adverb 1-2
                ok 15 - Nested slice, delete adverb 2-1
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 179
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 179
                ok 16 - Nested slice, delete adverb 2-2
                ok 17 - Nested slice, negated delete adverb 3-1
                ok 18 - Nested slice, negated delete adverb 3-2
                ok 19 - Nested slice, delete + kv adverbs
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 179
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 179
                ok 20 - Nested slice, delete + kv adverbs 2
                ok 21 - Nested slice, delete + !kv adverbs
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 179
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 179
                ok 22 - Nested slice, delete + !kv adverbs 2
                ok 23 - Nested slice, delete + p adverbs
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 179
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 179
                ok 24 - Nested slice, delete + p adverbs 2
                ok 25 - Nested slice, delete + !p adverbs
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 179
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 179
                ok 26 - Nested slice, delete + !p adverbs 2
                ok 27 - Nested slice, delete + k adverbs
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 179
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 179
                ok 28 - Nested slice, delete + k adverbs 2
                ok 29 - Nested slice, delete + !k adverbs
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 179
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 179
                ok 30 - Nested slice, delete + !k adverbs 2
                ok 31 - Nested slice, delete + v adverbs
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 179
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 179
                ok 32 - Nested slice, delete + v adverbs 2
                ok 33 - Nested slice, delete + !v adverbs
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 179
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 179
                ok 34 - Nested slice, delete + !v adverbs 2
                ok 35 - Nested slice, delete + exists adverbs
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 179
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 179
                ok 36 - Nested slice, delete + exists adverbs 2
                ok 37 - Nested slice, delete + !exists adverbs
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 179
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 179
                ok 38 - Nested slice, delete + !exists adverbs 2
                ok 39 - Nested slice, delete + exists + kv adverbs
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 179
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 179
                ok 40 - Nested slice, delete + exists + kv adverbs 2
                ok 41 - Nested slice, delete + !exists + kv adverbs
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 179
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 179
                ok 42 - Nested slice, delete + !exists + kv adverbs 2
                ok 43 - Nested slice, delete + exists + !kv adverbs
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 179
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 179
                ok 44 - Nested slice, delete + exists + !kv adverbs 2
                ok 45 - Nested slice, delete + !exists + !kv adverbs
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 179
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 179
                ok 46 - Nested slice, delete + !exists + !kv adverbs 2
                ok 47 - Nested slice, delete + exists + p adverbs
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 179
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 179
                ok 48 - Nested slice, delete + exists + p adverbs 2
                ok 49 - Nested slice, delete + !exists + p adverbs
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 179
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 179
                ok 50 - Nested slice, delete + !exists + p adverbs 2
                ok 51 - Nested slice, delete + exists + !p adverbs
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 179
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 179
                ok 52 - Nested slice, delete + exists + !p adverbs 2
                ok 53 - Nested slice, delete + !exists + !p adverbs
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 179
Use of uninitialized value of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 179
                ok 54 - Nested slice, delete + !exists + !p adverbs 2
                ok 55 - Nested slice, exists + kv adverbs
                ok 56 - Nested slice, !exists + kv adverbs
                ok 57 - Nested slice, exists + !kv adverbs
                ok 58 - Nested slice, !exists + !kv adverbs
                ok 59 - Nested slice, exists + p adverbs
                ok 60 - Nested slice, !exists + p adverbs
                ok 61 - Nested slice, exists + !p adverbs
                ok 62 - Nested slice, !exists + !p adverbs
            ok 3290 - nested slices
# FUDGED!
            1..84
            ok 3291 - @x.VAR.of of typed array (my Int @x)
            ok 3292 - .WHAT.gist of the type object makes sense
            ok 3293 - can assign values of the right type
            ok 3294 - can assign range of the right type
            ok 3295 - can push values of the right type
            ok 3296 - can unshift values of the right type
            ok 3297 - can assign values to a slice
            ok 3298 - can pop from typed array
            ok 3299 - can unshift from typed array
            ok 3300 - @x.VAR.of of typed array (my Int @x)
            ok 3301 - can assign values of the right type (Int @x)
            ok 3302 - can assign range of the right type (Int @x)
            ok 3303 - can push values of the right type (Int @x)
            ok 3304 - can unshift values of the right type (Int @x)
            ok 3305 - can assign values to a slice (Int @x)
            ok 3306 - can pop from typed array (Int @x)
            ok 3307 - can unshift from typed array (Int @x)
            ok 3308 - initialization of typed array
            ok 3309 - initialization of typed array from range
            ok 3310 - @x.VAR.of of typed array (my @x of Int)
            ok 3311 - can assign values of the right type (@x of Int)
            ok 3312 - can assign range of the right type (@x of Int)
            ok 3313 - can push values of the right type (@x of Int)
            ok 3314 - can unshift values of the right type (@x of Int)
            ok 3315 - can assign values to a slice (@x of Int)
            ok 3316 - can pop from typed array (@x of Int)
            ok 3317 - can unshift from typed array (@x of Int)
            ok 3318 - @x.VAR.of of typed array (my Array @x)
            ok 3319 - can not assign values of the wrong type
            ok 3320 - can not assign range of the wrong type
            ok 3321 - can not push values of the wrong type
            ok 3322 - can not unshift values of the wrong type
            ok 3323 - can not assign values of wrong type to a slice
            ok 3324 - ... but assigning values of the right type is OK
            ok 3325 - @x.VAR.of of typed array (my @x of Array)
            ok 3326 - can not assign values of the wrong type
            ok 3327 - can not assign range of the wrong type
            ok 3328 - can not push values of the wrong type
            ok 3329 - can not unshift values of the wrong type
            ok 3330 - can not assign values of wrong type to a slice
            ok 3331 - ... but assigning values of the right type is OK
            ok 3332 - my Array of Int @x declares a nested array
            not ok 3333 - assignment works # TODO nested typechecks are borked
            # Failed test 'assignment works'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/arrays.rakudo line 86
            # Type check failed in assignment to @x; expected Array[Int] but got Array ([2, 3])
            not ok 3334 - pushing works # TODO nested typechecks are borked
            # Failed test 'pushing works'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/arrays.rakudo line 88
            # Type check failed in assignment to @x; expected Array[Int] but got Array ([8, 9])
            ok 3335 - type constraint is enforced
            ok 3336 - pushing to the inner array is OK
            ok 3337 - inner array enforces the type constraint
            ok 3338 - can assign typed array to typed array
            ok 3339 - # SKIP need parameterized Lists
            ok 3340 - @a.values is typed (2)
            ok 3341 - # SKIP initialization
            ok 3342 - type check Positional of Int allows correctly typed array to be returned explicitly
            ok 3343 - type check Positional of Int allows correctly typed array to be returned implicitly
            ok 3344 - type check Positional of Int prevents untyped array to be returned explicitly
            ok 3345 - type check Positional of Int prevents untyped array to be returned implicitly
            ok 3346 - type check Positional of Int prevents incorrectly typed array to be returned explicitly
            ok 3347 - type check Positional of Int prevents incorrectly typed array to be returned implicitly
            ok 3348 - type check Positional of Num allows subtyped Int array to be returned explicitly
            ok 3349 - type check Positional of Num allows subtyped Int array to be returned implicitly
            ok 3350 - # SKIP type on our-variables
            ok 3351 - can assign to untyped array in presence of typed array
                1..2
                ok 1 - 'my Int @a = "ab", "cd"' died
                ok 2 - right exception type (X::TypeCheck::Assignment)
            ok 3352 - typed arrays do check type during list assignment
                1..2
                ok 1 - 'my Int @a = "ab", "cd"; 42.Str;' died
                ok 2 - right exception type (X::TypeCheck::Assignment)
            ok 3353 - typed arrays do check type during list assignment in sink
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::TypeCheck::Assignment)
            ok 3354 - assignment checks for types
                1..2
                ok 1 - '@x[0]++' died
                ok 2 - right exception type (X::TypeCheck)
            ok 3355 - pushed value to typed array (using "subset") is type checked
            ok 3356 - does the roundtrip preserve typedness
Use of uninitialized value of type Int in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 179
Use of uninitialized value of type Int in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 179
Use of uninitialized value of type Int in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 179
            ok 3357 - do typed arrays with empty elements roundtrip
            ok 3358 - Array of Str works as return constraint
            ok 3359 - Get back the typed array correctly (1)
            ok 3360 - Get back the typed array correctly (2)
            ok 3361 - Can feed Arrays of Type to .new of Array[Array[Type]] (binding)
            ok 3362 - Type is maintained (binding)
            ok 3363 - Can feed Arrays of Type to .new of Array[Array[Type]] (assignment)
            ok 3364 - Type is maintained (assignment)
            ok 3365 - Can assign to and return Array[Hash] from type-constrained sub
            ok 3366 - can bind element of typed array to scalar container of same type
            ok 3367 - can bind element of typed array to scalar container of same type (but not explicitly typed)
            ok 3368 - Binding literal to typed array checks types
            ok 3369 - Binding variablle to typed array checks type
            ok 3370 - deleted element of typed arrays does not lose type info inside .map
            ok 3371 - .gist on typed array shows real type objects
            ok 3372 - @a of Foo accepted by sub (Foo @a)
            ok 3373 - using `of` does not affect arrays defined later
            ok 3374 - using `of` does not affect arrays with `of` defined later
# FUDGED!
            1..1833
            # Testing int array
            ok 3375 - int array type is Positional
            ok 3376 - int array type is Positional[int]
            ok 3377 - int array type .of is int
            ok 3378 - int array is Positional
            ok 3379 - int array is Positional[int]
            ok 3380 - int array .of is int
            ok 3381 - int array is Positional
            ok 3382 - int array is Positional[int]
            ok 3383 - int array .of is int
            ok 3384 - .new from int array is Positional
            ok 3385 - .new from int array Positional[int]
            ok 3386 - .new from int array .of is int
            ok 3387 - New int array has no elems
            ok 3388 - New int array has end of -1
            ok 3389 - New int array Int-ifies to 0
            ok 3390 - New int array numifies to 0
            ok 3391 - New int array is falsey
            ok 3392 - Empty int array is not lazy
            ok 3393 - Accessing non-existing on int array gives 0
            ok 3394 - Elems do not grow just from an access on int array
            ok 3395 - Can store integer in an int array
            ok 3396 - Can get value from int array
            ok 3397 - The elems grew as expected on int array
            ok 3398 - int array becomes truthy when it has an element
            ok 3399 - Can slice-assign to an int array
            ok 3400 - Can get slice-assigned value from int array (1)
            ok 3401 - Can get slice-assigned value from int array (2)
            ok 3402 - The elems grew as expected on int array
            ok 3403 - The end value matches grown elems on int array
            ok 3404 - Int-ifies to grown number of elems on int array
            ok 3405 - Numifies to grown number of elems on int array
            ok 3406 - int array with values is not lazy
            ok 3407 - Can assign non-contiguously to int array
            ok 3408 - Elems behind non-contiguous assign are 0 on int array
            ok 3409 - Non-contiguous assignment works on int array
            ok 3410 - Can also get last element on int array
            ok 3411 - Can clear int array by assigning empty list
            ok 3412 - Cleared int array has no elems
            ok 3413 - Cleared int array has end of -1
            ok 3414 - Cleared int array Int-ifies to 0
            ok 3415 - Cleared int array numifies to 0
            ok 3416 - Cleared int array is falsey
            ok 3417 - Can assign integer range to int array
            ok 3418 - Got correct elems from range assign on int array
            ok 3419 - Got correct element from range assign on int array (1)
            ok 3420 - Got correct element from range assign on int array (2)
            ok 3421 - :exists works on int array (1)
            ok 3422 - :exists works on int array (2)
            ok 3423 - :exists works on int array (3)
            ok 3424 - Can call int array constructor with a single value
            ok 3425 - Correct number of elems set in constructor of int array
            ok 3426 - Correct element value set by constructor of int array
            ok 3427 - Can call int array constructor with values
            ok 3428 - Correct number of elems set in constructor of int array
            ok 3429 - Correct elem value set by constructor of int array (1)
            ok 3430 - Correct elem value set by constructor of int array (2)
            ok 3431 - Correct elem value set by constructor of int array (3)
            ok 3432 - Correct elem value set by constructor of int array (4)
            ok 3433 - Can also get last 2 elements on int array
            ok 3434 - int array .flat returns a Seq
            ok 3435 - int array .eager returns identity
            ok 3436 - Can iterate over int array
            ok 3437 - Mutating for loop on int array works (1)
            ok 3438 - Mutating for loop on int array works (2)
            ok 3439 - Mutating for loop on int array works (3)
            ok 3440 - Mutating for loop on int array works (4)
            ok 3441 - Can map over int array
            ok 3442 - Mutating map on int array works (1)
            ok 3443 - Mutating map on int array works (2)
            ok 3444 - Mutating map on int array works (3)
            ok 3445 - Mutating map on int array works (4)
            ok 3446 - grep a int array
            ok 3447 - int array.grep(Int)
            ok 3448 - int array.grep(Int, :k)
            ok 3449 - int array.grep(Int, :kv)
            ok 3450 - int array.grep(Int, :p)
            ok 3451 - int array.grep(Int, :v)
            ok 3452 - int array.grep(Int)
            ok 3453 - int array.grep(Int, :k)
            ok 3454 - int array.grep(Int, :kv)
            ok 3455 - int array.grep(Int, :p)
            ok 3456 - int array.grep(Int, :v)
            ok 3457 - Can use reduce meta-op on a int array
            ok 3458 - .values from a int array
            ok 3459 - .pairup from a int array
            ok 3460 - .keys from a int array
            ok 3461 - .pairs from a int array
            ok 3462 - .antipairs from a int array
            ok 3463 - .kv from a int array
            ok 3464 - .pick from a int array
            ok 3465 - .roll from a int array
            ok 3466 - int array.unique
            ok 3467 - int array.repeated
            ok 3468 - int array.squish
                1..4
                ok 1 - code dies
                ok 2 - right exception type (X::Cannot::Empty)
                ok 3 - .action matches pop
                ok 4 - .what matches array[int]
            ok 3469 - Trying to pop an empty int array dies
                1..4
                ok 1 - code dies
                ok 2 - right exception type (X::Cannot::Empty)
                ok 3 - .action matches shift
                ok 4 - .what matches array[int]
            ok 3470 - Trying to shift an empty int array dies
            ok 3471 - can push to int array
            ok 3472 - push to int array works (1)
            ok 3473 - push to int array works (2)
                1..3
                ok 1 - code dies
                ok 2 - right exception type (X::TypeCheck)
                ok 3 - .got matches (Str)
            ok 3474 - Cannot push non-int/Int to int array
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 3475 - Cannot bind to int array
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 3476 - Cannot delete from int array
            ok 3477 - can push multiple to int array
            ok 3478 - push multiple to int array works (1)
            ok 3479 - push multiple to int array works (2)
            ok 3480 - push multiple to int array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 3481 - Cannot push non-int/Int to int array (multiple push)
            ok 3482 - can append to int array
            ok 3483 - append to int array works (1)
            ok 3484 - append to int array works (2)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 3485 - Cannot append non-int/Int to int array
            ok 3486 - can append multiple to int array
            ok 3487 - append multiple to int array works (1)
            ok 3488 - append multiple to int array works (2)
            ok 3489 - append multiple to int array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 3490 - Cannot append non-int/Int to int array (multiple append)
            ok 3491 - pop from int array works (1)
            ok 3492 - pop from int array works (2)
            ok 3493 - can unshift to int array
            ok 3494 - unshift to int array works (1)
            ok 3495 - unshift to int array works (2)
            ok 3496 - unshift to int array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 3497 - Cannot unshift non-int/Int to int array
            ok 3498 - can unshift multiple to int array
            ok 3499 - unshift multiple to int array works (1)
            ok 3500 - unshift multiple to int array works (2)
            ok 3501 - unshift multiple to int array works (3)
            ok 3502 - unshift multiple to int array works (4)
            ok 3503 - unshift multiple to int array works (5)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 3504 - Cannot unshift non-int/Int to int array (multiple unshift)
            ok 3505 - can prepend to int array
            ok 3506 - prepend to int array works (1)
            ok 3507 - prepend to int array works (2)
            ok 3508 - prepend to int array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 3509 - Cannot prepend non-int/Int to int array
            ok 3510 - can prepend multiple to int array
            ok 3511 - unshift multiple to int array works (1)
            ok 3512 - prepend multiple to int array works (2)
            ok 3513 - prepend multiple to int array works (3)
            ok 3514 - prepend multiple to int array works (4)
            ok 3515 - prepend multiple to int array works (5)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 3516 - Cannot prepend non-int/Int to int array (multiple unshift)
            ok 3517 - shift from int array works (1)
            ok 3518 - shift from int array works (2)
            ok 3519 - can initialize int from Range
            ok 3520 - Number of elems after splice int array
            ok 3521 - Splice on int array did the right thing (1)
            ok 3522 - Splice on int array did the right thing (2)
            ok 3523 - Splice on int array did the right thing (3)
            ok 3524 - Splice on int array did the right thing (4)
            ok 3525 - Splice on int array did the right thing (5)
            ok 3526 - Number of returned spliced values from int array
            ok 3527 - Correct value in splice returned from int array (1)
            ok 3528 - Correct value in splice returned from int array (2)
            ok 3529 - .Str space-separates on int array
            ok 3530 - .gist space-separates on int array
            ok 3531 - .raku includes type and int values on int array
            ok 3532 - does slice return same type
            ok 3533 - does slice handle containerized range
            ok 3534 - Flattening int array in call works
            ok 3535 - does join a int array
            ok 3536 - does emptying a int array really empty
            ok 3537 - does join handle holes in a int array
            ok 3538 - List-assigning int array to untyped works (1)
            ok 3539 - List-assigning int array to untyped works (2)
            ok 3540 - List-assigning int array to untyped works (3)
            ok 3541 - List-assign int array surrounded by literals (1)
            ok 3542 - List-assign int array surrounded by literals (2)
            ok 3543 - List-assign int array surrounded by literals (3)
            ok 3544 - List-assign int array surrounded by literals (4)
            ok 3545 - List-assign int array surrounded by literals (5)
            ok 3546 - List-assign untyped array of Int to int array (1)
            ok 3547 - List-assign untyped array of Int to int array (2)
            ok 3548 - List-assign untyped array of Int to int array (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 3549 - List-assigning incompatible untyped array to int array dies
            ok 3550 - Smartmatching same int arrays works
            ok 3551 - Smartmatching different int arrays works
            ok 3552 - Can we sort int array
            ok 3553 - Can we sort 2-element sorted int array
            ok 3554 - Can we sort 2-element unsorted int array
            ok 3555 - Can we sort 1-element int array
            ok 3556 - Can we sort 0-element int array
            # Testing int8 array
            ok 3557 - int8 array type is Positional
            ok 3558 - int8 array type is Positional[int8]
            ok 3559 - int8 array type .of is int8
            ok 3560 - int8 array is Positional
            ok 3561 - int8 array is Positional[int8]
            ok 3562 - int8 array .of is int8
            ok 3563 - int8 array is Positional
            ok 3564 - int8 array is Positional[int8]
            ok 3565 - int8 array .of is int8
            ok 3566 - .new from int8 array is Positional
            ok 3567 - .new from int8 array Positional[int8]
            ok 3568 - .new from int8 array .of is int8
            ok 3569 - New int8 array has no elems
            ok 3570 - New int8 array has end of -1
            ok 3571 - New int8 array Int-ifies to 0
            ok 3572 - New int8 array numifies to 0
            ok 3573 - New int8 array is falsey
            ok 3574 - Empty int8 array is not lazy
            ok 3575 - Accessing non-existing on int8 array gives 0
            ok 3576 - Elems do not grow just from an access on int8 array
            ok 3577 - Can store integer in an int8 array
            ok 3578 - Can get value from int8 array
            ok 3579 - The elems grew as expected on int8 array
            ok 3580 - int8 array becomes truthy when it has an element
            ok 3581 - Can slice-assign to an int8 array
            ok 3582 - Can get slice-assigned value from int8 array (1)
            ok 3583 - Can get slice-assigned value from int8 array (2)
            ok 3584 - The elems grew as expected on int8 array
            ok 3585 - The end value matches grown elems on int8 array
            ok 3586 - Int-ifies to grown number of elems on int8 array
            ok 3587 - Numifies to grown number of elems on int8 array
            ok 3588 - int8 array with values is not lazy
            ok 3589 - Can assign non-contiguously to int8 array
            ok 3590 - Elems behind non-contiguous assign are 0 on int8 array
            ok 3591 - Non-contiguous assignment works on int8 array
            ok 3592 - Can also get last element on int8 array
            ok 3593 - Can clear int8 array by assigning empty list
            ok 3594 - Cleared int8 array has no elems
            ok 3595 - Cleared int8 array has end of -1
            ok 3596 - Cleared int8 array Int-ifies to 0
            ok 3597 - Cleared int8 array numifies to 0
            ok 3598 - Cleared int8 array is falsey
            ok 3599 - Can assign integer range to int8 array
            ok 3600 - Got correct elems from range assign on int8 array
            ok 3601 - Got correct element from range assign on int8 array (1)
            ok 3602 - Got correct element from range assign on int8 array (2)
            ok 3603 - :exists works on int8 array (1)
            ok 3604 - :exists works on int8 array (2)
            ok 3605 - :exists works on int8 array (3)
            ok 3606 - Can call int8 array constructor with a single value
            ok 3607 - Correct number of elems set in constructor of int8 array
            ok 3608 - Correct element value set by constructor of int8 array
            ok 3609 - Can call int8 array constructor with values
            ok 3610 - Correct number of elems set in constructor of int8 array
            ok 3611 - Correct elem value set by constructor of int8 array (1)
            ok 3612 - Correct elem value set by constructor of int8 array (2)
            ok 3613 - Correct elem value set by constructor of int8 array (3)
            ok 3614 - Correct elem value set by constructor of int8 array (4)
            ok 3615 - Can also get last 2 elements on int8 array
            ok 3616 - int8 array .flat returns a Seq
            ok 3617 - int8 array .eager returns identity
            ok 3618 - Can iterate over int8 array
            ok 3619 - Mutating for loop on int8 array works (1)
            ok 3620 - Mutating for loop on int8 array works (2)
            ok 3621 - Mutating for loop on int8 array works (3)
            ok 3622 - Mutating for loop on int8 array works (4)
            ok 3623 - Can map over int8 array
            ok 3624 - Mutating map on int8 array works (1)
            ok 3625 - Mutating map on int8 array works (2)
            ok 3626 - Mutating map on int8 array works (3)
            ok 3627 - Mutating map on int8 array works (4)
            ok 3628 - grep a int8 array
            ok 3629 - int8 array.grep(Int)
            ok 3630 - int8 array.grep(Int, :k)
            ok 3631 - int8 array.grep(Int, :kv)
            ok 3632 - int8 array.grep(Int, :p)
            ok 3633 - int8 array.grep(Int, :v)
            ok 3634 - int8 array.grep(Int)
            ok 3635 - int8 array.grep(Int, :k)
            ok 3636 - int8 array.grep(Int, :kv)
            ok 3637 - int8 array.grep(Int, :p)
            ok 3638 - int8 array.grep(Int, :v)
            ok 3639 - Can use reduce meta-op on a int8 array
            ok 3640 - .values from a int8 array
            ok 3641 - .pairup from a int8 array
            ok 3642 - .keys from a int8 array
            ok 3643 - .pairs from a int8 array
            ok 3644 - .antipairs from a int8 array
            ok 3645 - .kv from a int8 array
            ok 3646 - .pick from a int8 array
            ok 3647 - .roll from a int8 array
            ok 3648 - int8 array.unique
            ok 3649 - int8 array.repeated
            ok 3650 - int8 array.squish
                1..4
                ok 1 - code dies
                ok 2 - right exception type (X::Cannot::Empty)
                ok 3 - .what matches array[int8]
                ok 4 - .action matches pop
            ok 3651 - Trying to pop an empty int8 array dies
                1..4
                ok 1 - code dies
                ok 2 - right exception type (X::Cannot::Empty)
                ok 3 - .what matches array[int8]
                ok 4 - .action matches shift
            ok 3652 - Trying to shift an empty int8 array dies
            ok 3653 - can push to int8 array
            ok 3654 - push to int8 array works (1)
            ok 3655 - push to int8 array works (2)
                1..3
                ok 1 - code dies
                ok 2 - right exception type (X::TypeCheck)
                ok 3 - .got matches (Str)
            ok 3656 - Cannot push non-int/Int to int8 array
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 3657 - Cannot bind to int8 array
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 3658 - Cannot delete from int8 array
            ok 3659 - can push multiple to int8 array
            ok 3660 - push multiple to int8 array works (1)
            ok 3661 - push multiple to int8 array works (2)
            ok 3662 - push multiple to int8 array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 3663 - Cannot push non-int/Int to int8 array (multiple push)
            ok 3664 - can append to int8 array
            ok 3665 - append to int8 array works (1)
            ok 3666 - append to int8 array works (2)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 3667 - Cannot append non-int/Int to int8 array
            ok 3668 - can append multiple to int8 array
            ok 3669 - append multiple to int8 array works (1)
            ok 3670 - append multiple to int8 array works (2)
            ok 3671 - append multiple to int8 array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 3672 - Cannot append non-int/Int to int8 array (multiple append)
            ok 3673 - pop from int8 array works (1)
            ok 3674 - pop from int8 array works (2)
            ok 3675 - can unshift to int8 array
            ok 3676 - unshift to int8 array works (1)
            ok 3677 - unshift to int8 array works (2)
            ok 3678 - unshift to int8 array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 3679 - Cannot unshift non-int/Int to int8 array
            ok 3680 - can unshift multiple to int8 array
            ok 3681 - unshift multiple to int8 array works (1)
            ok 3682 - unshift multiple to int8 array works (2)
            ok 3683 - unshift multiple to int8 array works (3)
            ok 3684 - unshift multiple to int8 array works (4)
            ok 3685 - unshift multiple to int8 array works (5)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 3686 - Cannot unshift non-int/Int to int8 array (multiple unshift)
            ok 3687 - can prepend to int8 array
            ok 3688 - prepend to int8 array works (1)
            ok 3689 - prepend to int8 array works (2)
            ok 3690 - prepend to int8 array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 3691 - Cannot prepend non-int/Int to int8 array
            ok 3692 - can prepend multiple to int8 array
            ok 3693 - unshift multiple to int8 array works (1)
            ok 3694 - prepend multiple to int8 array works (2)
            ok 3695 - prepend multiple to int8 array works (3)
            ok 3696 - prepend multiple to int8 array works (4)
            ok 3697 - prepend multiple to int8 array works (5)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 3698 - Cannot prepend non-int/Int to int8 array (multiple unshift)
            ok 3699 - shift from int8 array works (1)
            ok 3700 - shift from int8 array works (2)
            ok 3701 - can initialize int8 from Range
            ok 3702 - Number of elems after splice int8 array
            ok 3703 - Splice on int8 array did the right thing (1)
            ok 3704 - Splice on int8 array did the right thing (2)
            ok 3705 - Splice on int8 array did the right thing (3)
            ok 3706 - Splice on int8 array did the right thing (4)
            ok 3707 - Splice on int8 array did the right thing (5)
            ok 3708 - Number of returned spliced values from int8 array
            ok 3709 - Correct value in splice returned from int8 array (1)
            ok 3710 - Correct value in splice returned from int8 array (2)
            ok 3711 - .Str space-separates on int8 array
            ok 3712 - .gist space-separates on int8 array
            ok 3713 - .raku includes type and int values on int8 array
            ok 3714 - does slice return same type
            ok 3715 - does slice handle containerized range
            ok 3716 - Flattening int8 array in call works
            ok 3717 - does join a int8 array
            ok 3718 - does emptying a int8 array really empty
            ok 3719 - does join handle holes in a int8 array
            ok 3720 - List-assigning int8 array to untyped works (1)
            ok 3721 - List-assigning int8 array to untyped works (2)
            ok 3722 - List-assigning int8 array to untyped works (3)
            ok 3723 - List-assign int8 array surrounded by literals (1)
            ok 3724 - List-assign int8 array surrounded by literals (2)
            ok 3725 - List-assign int8 array surrounded by literals (3)
            ok 3726 - List-assign int8 array surrounded by literals (4)
            ok 3727 - List-assign int8 array surrounded by literals (5)
            ok 3728 - List-assign untyped array of Int to int8 array (1)
            ok 3729 - List-assign untyped array of Int to int8 array (2)
            ok 3730 - List-assign untyped array of Int to int8 array (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 3731 - List-assigning incompatible untyped array to int8 array dies
            ok 3732 - Smartmatching same int8 arrays works
            ok 3733 - Smartmatching different int8 arrays works
            ok 3734 - Can we sort int8 array
            ok 3735 - Can we sort 2-element sorted int8 array
            ok 3736 - Can we sort 2-element unsorted int8 array
            ok 3737 - Can we sort 1-element int8 array
            ok 3738 - Can we sort 0-element int8 array
            # Testing int16 array
            ok 3739 - int16 array type is Positional
            ok 3740 - int16 array type is Positional[int16]
            ok 3741 - int16 array type .of is int16
            ok 3742 - int16 array is Positional
            ok 3743 - int16 array is Positional[int16]
            ok 3744 - int16 array .of is int16
            ok 3745 - int16 array is Positional
            ok 3746 - int16 array is Positional[int16]
            ok 3747 - int16 array .of is int16
            ok 3748 - .new from int16 array is Positional
            ok 3749 - .new from int16 array Positional[int16]
            ok 3750 - .new from int16 array .of is int16
            ok 3751 - New int16 array has no elems
            ok 3752 - New int16 array has end of -1
            ok 3753 - New int16 array Int-ifies to 0
            ok 3754 - New int16 array numifies to 0
            ok 3755 - New int16 array is falsey
            ok 3756 - Empty int16 array is not lazy
            ok 3757 - Accessing non-existing on int16 array gives 0
            ok 3758 - Elems do not grow just from an access on int16 array
            ok 3759 - Can store integer in an int16 array
            ok 3760 - Can get value from int16 array
            ok 3761 - The elems grew as expected on int16 array
            ok 3762 - int16 array becomes truthy when it has an element
            ok 3763 - Can slice-assign to an int16 array
            ok 3764 - Can get slice-assigned value from int16 array (1)
            ok 3765 - Can get slice-assigned value from int16 array (2)
            ok 3766 - The elems grew as expected on int16 array
            ok 3767 - The end value matches grown elems on int16 array
            ok 3768 - Int-ifies to grown number of elems on int16 array
            ok 3769 - Numifies to grown number of elems on int16 array
            ok 3770 - int16 array with values is not lazy
            ok 3771 - Can assign non-contiguously to int16 array
            ok 3772 - Elems behind non-contiguous assign are 0 on int16 array
            ok 3773 - Non-contiguous assignment works on int16 array
            ok 3774 - Can also get last element on int16 array
            ok 3775 - Can clear int16 array by assigning empty list
            ok 3776 - Cleared int16 array has no elems
            ok 3777 - Cleared int16 array has end of -1
            ok 3778 - Cleared int16 array Int-ifies to 0
            ok 3779 - Cleared int16 array numifies to 0
            ok 3780 - Cleared int16 array is falsey
            ok 3781 - Can assign integer range to int16 array
            ok 3782 - Got correct elems from range assign on int16 array
            ok 3783 - Got correct element from range assign on int16 array (1)
            ok 3784 - Got correct element from range assign on int16 array (2)
            ok 3785 - :exists works on int16 array (1)
            ok 3786 - :exists works on int16 array (2)
            ok 3787 - :exists works on int16 array (3)
            ok 3788 - Can call int16 array constructor with a single value
            ok 3789 - Correct number of elems set in constructor of int16 array
            ok 3790 - Correct element value set by constructor of int16 array
            ok 3791 - Can call int16 array constructor with values
            ok 3792 - Correct number of elems set in constructor of int16 array
            ok 3793 - Correct elem value set by constructor of int16 array (1)
            ok 3794 - Correct elem value set by constructor of int16 array (2)
            ok 3795 - Correct elem value set by constructor of int16 array (3)
            ok 3796 - Correct elem value set by constructor of int16 array (4)
            ok 3797 - Can also get last 2 elements on int16 array
            ok 3798 - int16 array .flat returns a Seq
            ok 3799 - int16 array .eager returns identity
            ok 3800 - Can iterate over int16 array
            ok 3801 - Mutating for loop on int16 array works (1)
            ok 3802 - Mutating for loop on int16 array works (2)
            ok 3803 - Mutating for loop on int16 array works (3)
            ok 3804 - Mutating for loop on int16 array works (4)
            ok 3805 - Can map over int16 array
            ok 3806 - Mutating map on int16 array works (1)
            ok 3807 - Mutating map on int16 array works (2)
            ok 3808 - Mutating map on int16 array works (3)
            ok 3809 - Mutating map on int16 array works (4)
            ok 3810 - grep a int16 array
            ok 3811 - int16 array.grep(Int)
            ok 3812 - int16 array.grep(Int, :k)
            ok 3813 - int16 array.grep(Int, :kv)
            ok 3814 - int16 array.grep(Int, :p)
            ok 3815 - int16 array.grep(Int, :v)
            ok 3816 - int16 array.grep(Int)
            ok 3817 - int16 array.grep(Int, :k)
            ok 3818 - int16 array.grep(Int, :kv)
            ok 3819 - int16 array.grep(Int, :p)
            ok 3820 - int16 array.grep(Int, :v)
            ok 3821 - Can use reduce meta-op on a int16 array
            ok 3822 - .values from a int16 array
            ok 3823 - .pairup from a int16 array
            ok 3824 - .keys from a int16 array
            ok 3825 - .pairs from a int16 array
            ok 3826 - .antipairs from a int16 array
            ok 3827 - .kv from a int16 array
            ok 3828 - .pick from a int16 array
            ok 3829 - .roll from a int16 array
            ok 3830 - int16 array.unique
            ok 3831 - int16 array.repeated
            ok 3832 - int16 array.squish
                1..4
                ok 1 - code dies
                ok 2 - right exception type (X::Cannot::Empty)
                ok 3 - .action matches pop
                ok 4 - .what matches array[int16]
            ok 3833 - Trying to pop an empty int16 array dies
                1..4
                ok 1 - code dies
                ok 2 - right exception type (X::Cannot::Empty)
                ok 3 - .what matches array[int16]
                ok 4 - .action matches shift
            ok 3834 - Trying to shift an empty int16 array dies
            ok 3835 - can push to int16 array
            ok 3836 - push to int16 array works (1)
            ok 3837 - push to int16 array works (2)
                1..3
                ok 1 - code dies
                ok 2 - right exception type (X::TypeCheck)
                ok 3 - .got matches (Str)
            ok 3838 - Cannot push non-int/Int to int16 array
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 3839 - Cannot bind to int16 array
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 3840 - Cannot delete from int16 array
            ok 3841 - can push multiple to int16 array
            ok 3842 - push multiple to int16 array works (1)
            ok 3843 - push multiple to int16 array works (2)
            ok 3844 - push multiple to int16 array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 3845 - Cannot push non-int/Int to int16 array (multiple push)
            ok 3846 - can append to int16 array
            ok 3847 - append to int16 array works (1)
            ok 3848 - append to int16 array works (2)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 3849 - Cannot append non-int/Int to int16 array
            ok 3850 - can append multiple to int16 array
            ok 3851 - append multiple to int16 array works (1)
            ok 3852 - append multiple to int16 array works (2)
            ok 3853 - append multiple to int16 array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 3854 - Cannot append non-int/Int to int16 array (multiple append)
            ok 3855 - pop from int16 array works (1)
            ok 3856 - pop from int16 array works (2)
            ok 3857 - can unshift to int16 array
            ok 3858 - unshift to int16 array works (1)
            ok 3859 - unshift to int16 array works (2)
            ok 3860 - unshift to int16 array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 3861 - Cannot unshift non-int/Int to int16 array
            ok 3862 - can unshift multiple to int16 array
            ok 3863 - unshift multiple to int16 array works (1)
            ok 3864 - unshift multiple to int16 array works (2)
            ok 3865 - unshift multiple to int16 array works (3)
            ok 3866 - unshift multiple to int16 array works (4)
            ok 3867 - unshift multiple to int16 array works (5)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 3868 - Cannot unshift non-int/Int to int16 array (multiple unshift)
            ok 3869 - can prepend to int16 array
            ok 3870 - prepend to int16 array works (1)
            ok 3871 - prepend to int16 array works (2)
            ok 3872 - prepend to int16 array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 3873 - Cannot prepend non-int/Int to int16 array
            ok 3874 - can prepend multiple to int16 array
            ok 3875 - unshift multiple to int16 array works (1)
            ok 3876 - prepend multiple to int16 array works (2)
            ok 3877 - prepend multiple to int16 array works (3)
            ok 3878 - prepend multiple to int16 array works (4)
            ok 3879 - prepend multiple to int16 array works (5)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 3880 - Cannot prepend non-int/Int to int16 array (multiple unshift)
            ok 3881 - shift from int16 array works (1)
            ok 3882 - shift from int16 array works (2)
            ok 3883 - can initialize int16 from Range
            ok 3884 - Number of elems after splice int16 array
            ok 3885 - Splice on int16 array did the right thing (1)
            ok 3886 - Splice on int16 array did the right thing (2)
            ok 3887 - Splice on int16 array did the right thing (3)
            ok 3888 - Splice on int16 array did the right thing (4)
            ok 3889 - Splice on int16 array did the right thing (5)
            ok 3890 - Number of returned spliced values from int16 array
            ok 3891 - Correct value in splice returned from int16 array (1)
            ok 3892 - Correct value in splice returned from int16 array (2)
            ok 3893 - .Str space-separates on int16 array
            ok 3894 - .gist space-separates on int16 array
            ok 3895 - .raku includes type and int values on int16 array
            ok 3896 - does slice return same type
            ok 3897 - does slice handle containerized range
            ok 3898 - Flattening int16 array in call works
            ok 3899 - does join a int16 array
            ok 3900 - does emptying a int16 array really empty
            ok 3901 - does join handle holes in a int16 array
            ok 3902 - List-assigning int16 array to untyped works (1)
            ok 3903 - List-assigning int16 array to untyped works (2)
            ok 3904 - List-assigning int16 array to untyped works (3)
            ok 3905 - List-assign int16 array surrounded by literals (1)
            ok 3906 - List-assign int16 array surrounded by literals (2)
            ok 3907 - List-assign int16 array surrounded by literals (3)
            ok 3908 - List-assign int16 array surrounded by literals (4)
            ok 3909 - List-assign int16 array surrounded by literals (5)
            ok 3910 - List-assign untyped array of Int to int16 array (1)
            ok 3911 - List-assign untyped array of Int to int16 array (2)
            ok 3912 - List-assign untyped array of Int to int16 array (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 3913 - List-assigning incompatible untyped array to int16 array dies
            ok 3914 - Smartmatching same int16 arrays works
            ok 3915 - Smartmatching different int16 arrays works
            ok 3916 - Can we sort int16 array
            ok 3917 - Can we sort 2-element sorted int16 array
            ok 3918 - Can we sort 2-element unsorted int16 array
            ok 3919 - Can we sort 1-element int16 array
            ok 3920 - Can we sort 0-element int16 array
            # Testing int32 array
            ok 3921 - int32 array type is Positional
            ok 3922 - int32 array type is Positional[int32]
            ok 3923 - int32 array type .of is int32
            ok 3924 - int32 array is Positional
            ok 3925 - int32 array is Positional[int32]
            ok 3926 - int32 array .of is int32
            ok 3927 - int32 array is Positional
            ok 3928 - int32 array is Positional[int32]
            ok 3929 - int32 array .of is int32
            ok 3930 - .new from int32 array is Positional
            ok 3931 - .new from int32 array Positional[int32]
            ok 3932 - .new from int32 array .of is int32
            ok 3933 - New int32 array has no elems
            ok 3934 - New int32 array has end of -1
            ok 3935 - New int32 array Int-ifies to 0
            ok 3936 - New int32 array numifies to 0
            ok 3937 - New int32 array is falsey
            ok 3938 - Empty int32 array is not lazy
            ok 3939 - Accessing non-existing on int32 array gives 0
            ok 3940 - Elems do not grow just from an access on int32 array
            ok 3941 - Can store integer in an int32 array
            ok 3942 - Can get value from int32 array
            ok 3943 - The elems grew as expected on int32 array
            ok 3944 - int32 array becomes truthy when it has an element
            ok 3945 - Can slice-assign to an int32 array
            ok 3946 - Can get slice-assigned value from int32 array (1)
            ok 3947 - Can get slice-assigned value from int32 array (2)
            ok 3948 - The elems grew as expected on int32 array
            ok 3949 - The end value matches grown elems on int32 array
            ok 3950 - Int-ifies to grown number of elems on int32 array
            ok 3951 - Numifies to grown number of elems on int32 array
            ok 3952 - int32 array with values is not lazy
            ok 3953 - Can assign non-contiguously to int32 array
            ok 3954 - Elems behind non-contiguous assign are 0 on int32 array
            ok 3955 - Non-contiguous assignment works on int32 array
            ok 3956 - Can also get last element on int32 array
            ok 3957 - Can clear int32 array by assigning empty list
            ok 3958 - Cleared int32 array has no elems
            ok 3959 - Cleared int32 array has end of -1
            ok 3960 - Cleared int32 array Int-ifies to 0
            ok 3961 - Cleared int32 array numifies to 0
            ok 3962 - Cleared int32 array is falsey
            ok 3963 - Can assign integer range to int32 array
            ok 3964 - Got correct elems from range assign on int32 array
            ok 3965 - Got correct element from range assign on int32 array (1)
            ok 3966 - Got correct element from range assign on int32 array (2)
            ok 3967 - :exists works on int32 array (1)
            ok 3968 - :exists works on int32 array (2)
            ok 3969 - :exists works on int32 array (3)
            ok 3970 - Can call int32 array constructor with a single value
            ok 3971 - Correct number of elems set in constructor of int32 array
            ok 3972 - Correct element value set by constructor of int32 array
            ok 3973 - Can call int32 array constructor with values
            ok 3974 - Correct number of elems set in constructor of int32 array
            ok 3975 - Correct elem value set by constructor of int32 array (1)
            ok 3976 - Correct elem value set by constructor of int32 array (2)
            ok 3977 - Correct elem value set by constructor of int32 array (3)
            ok 3978 - Correct elem value set by constructor of int32 array (4)
            ok 3979 - Can also get last 2 elements on int32 array
            ok 3980 - int32 array .flat returns a Seq
            ok 3981 - int32 array .eager returns identity
            ok 3982 - Can iterate over int32 array
            ok 3983 - Mutating for loop on int32 array works (1)
            ok 3984 - Mutating for loop on int32 array works (2)
            ok 3985 - Mutating for loop on int32 array works (3)
            ok 3986 - Mutating for loop on int32 array works (4)
            ok 3987 - Can map over int32 array
            ok 3988 - Mutating map on int32 array works (1)
            ok 3989 - Mutating map on int32 array works (2)
            ok 3990 - Mutating map on int32 array works (3)
            ok 3991 - Mutating map on int32 array works (4)
            ok 3992 - grep a int32 array
            ok 3993 - int32 array.grep(Int)
            ok 3994 - int32 array.grep(Int, :k)
            ok 3995 - int32 array.grep(Int, :kv)
            ok 3996 - int32 array.grep(Int, :p)
            ok 3997 - int32 array.grep(Int, :v)
            ok 3998 - int32 array.grep(Int)
            ok 3999 - int32 array.grep(Int, :k)
            ok 4000 - int32 array.grep(Int, :kv)
            ok 4001 - int32 array.grep(Int, :p)
            ok 4002 - int32 array.grep(Int, :v)
            ok 4003 - Can use reduce meta-op on a int32 array
            ok 4004 - .values from a int32 array
            ok 4005 - .pairup from a int32 array
            ok 4006 - .keys from a int32 array
            ok 4007 - .pairs from a int32 array
            ok 4008 - .antipairs from a int32 array
            ok 4009 - .kv from a int32 array
            ok 4010 - .pick from a int32 array
            ok 4011 - .roll from a int32 array
            ok 4012 - int32 array.unique
            ok 4013 - int32 array.repeated
            ok 4014 - int32 array.squish
                1..4
                ok 1 - code dies
                ok 2 - right exception type (X::Cannot::Empty)
                ok 3 - .action matches pop
                ok 4 - .what matches array[int32]
            ok 4015 - Trying to pop an empty int32 array dies
                1..4
                ok 1 - code dies
                ok 2 - right exception type (X::Cannot::Empty)
                ok 3 - .what matches array[int32]
                ok 4 - .action matches shift
            ok 4016 - Trying to shift an empty int32 array dies
            ok 4017 - can push to int32 array
            ok 4018 - push to int32 array works (1)
            ok 4019 - push to int32 array works (2)
                1..3
                ok 1 - code dies
                ok 2 - right exception type (X::TypeCheck)
                ok 3 - .got matches (Str)
            ok 4020 - Cannot push non-int/Int to int32 array
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4021 - Cannot bind to int32 array
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4022 - Cannot delete from int32 array
            ok 4023 - can push multiple to int32 array
            ok 4024 - push multiple to int32 array works (1)
            ok 4025 - push multiple to int32 array works (2)
            ok 4026 - push multiple to int32 array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4027 - Cannot push non-int/Int to int32 array (multiple push)
            ok 4028 - can append to int32 array
            ok 4029 - append to int32 array works (1)
            ok 4030 - append to int32 array works (2)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4031 - Cannot append non-int/Int to int32 array
            ok 4032 - can append multiple to int32 array
            ok 4033 - append multiple to int32 array works (1)
            ok 4034 - append multiple to int32 array works (2)
            ok 4035 - append multiple to int32 array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4036 - Cannot append non-int/Int to int32 array (multiple append)
            ok 4037 - pop from int32 array works (1)
            ok 4038 - pop from int32 array works (2)
            ok 4039 - can unshift to int32 array
            ok 4040 - unshift to int32 array works (1)
            ok 4041 - unshift to int32 array works (2)
            ok 4042 - unshift to int32 array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4043 - Cannot unshift non-int/Int to int32 array
            ok 4044 - can unshift multiple to int32 array
            ok 4045 - unshift multiple to int32 array works (1)
            ok 4046 - unshift multiple to int32 array works (2)
            ok 4047 - unshift multiple to int32 array works (3)
            ok 4048 - unshift multiple to int32 array works (4)
            ok 4049 - unshift multiple to int32 array works (5)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4050 - Cannot unshift non-int/Int to int32 array (multiple unshift)
            ok 4051 - can prepend to int32 array
            ok 4052 - prepend to int32 array works (1)
            ok 4053 - prepend to int32 array works (2)
            ok 4054 - prepend to int32 array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4055 - Cannot prepend non-int/Int to int32 array
            ok 4056 - can prepend multiple to int32 array
            ok 4057 - unshift multiple to int32 array works (1)
            ok 4058 - prepend multiple to int32 array works (2)
            ok 4059 - prepend multiple to int32 array works (3)
            ok 4060 - prepend multiple to int32 array works (4)
            ok 4061 - prepend multiple to int32 array works (5)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4062 - Cannot prepend non-int/Int to int32 array (multiple unshift)
            ok 4063 - shift from int32 array works (1)
            ok 4064 - shift from int32 array works (2)
            ok 4065 - can initialize int32 from Range
            ok 4066 - Number of elems after splice int32 array
            ok 4067 - Splice on int32 array did the right thing (1)
            ok 4068 - Splice on int32 array did the right thing (2)
            ok 4069 - Splice on int32 array did the right thing (3)
            ok 4070 - Splice on int32 array did the right thing (4)
            ok 4071 - Splice on int32 array did the right thing (5)
            ok 4072 - Number of returned spliced values from int32 array
            ok 4073 - Correct value in splice returned from int32 array (1)
            ok 4074 - Correct value in splice returned from int32 array (2)
            ok 4075 - .Str space-separates on int32 array
            ok 4076 - .gist space-separates on int32 array
            ok 4077 - .raku includes type and int values on int32 array
            ok 4078 - does slice return same type
            ok 4079 - does slice handle containerized range
            ok 4080 - Flattening int32 array in call works
            ok 4081 - does join a int32 array
            ok 4082 - does emptying a int32 array really empty
            ok 4083 - does join handle holes in a int32 array
            ok 4084 - List-assigning int32 array to untyped works (1)
            ok 4085 - List-assigning int32 array to untyped works (2)
            ok 4086 - List-assigning int32 array to untyped works (3)
            ok 4087 - List-assign int32 array surrounded by literals (1)
            ok 4088 - List-assign int32 array surrounded by literals (2)
            ok 4089 - List-assign int32 array surrounded by literals (3)
            ok 4090 - List-assign int32 array surrounded by literals (4)
            ok 4091 - List-assign int32 array surrounded by literals (5)
            ok 4092 - List-assign untyped array of Int to int32 array (1)
            ok 4093 - List-assign untyped array of Int to int32 array (2)
            ok 4094 - List-assign untyped array of Int to int32 array (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4095 - List-assigning incompatible untyped array to int32 array dies
            ok 4096 - Smartmatching same int32 arrays works
            ok 4097 - Smartmatching different int32 arrays works
            ok 4098 - Can we sort int32 array
            ok 4099 - Can we sort 2-element sorted int32 array
            ok 4100 - Can we sort 2-element unsorted int32 array
            ok 4101 - Can we sort 1-element int32 array
            ok 4102 - Can we sort 0-element int32 array
            # Testing int64 array
            ok 4103 - int64 array type is Positional
            ok 4104 - int64 array type is Positional[int64]
            ok 4105 - int64 array type .of is int64
            ok 4106 - int64 array is Positional
            ok 4107 - int64 array is Positional[int64]
            ok 4108 - int64 array .of is int64
            ok 4109 - int64 array is Positional
            ok 4110 - int64 array is Positional[int64]
            ok 4111 - int64 array .of is int64
            ok 4112 - .new from int64 array is Positional
            ok 4113 - .new from int64 array Positional[int64]
            ok 4114 - .new from int64 array .of is int64
            ok 4115 - New int64 array has no elems
            ok 4116 - New int64 array has end of -1
            ok 4117 - New int64 array Int-ifies to 0
            ok 4118 - New int64 array numifies to 0
            ok 4119 - New int64 array is falsey
            ok 4120 - Empty int64 array is not lazy
            ok 4121 - Accessing non-existing on int64 array gives 0
            ok 4122 - Elems do not grow just from an access on int64 array
            ok 4123 - Can store integer in an int64 array
            ok 4124 - Can get value from int64 array
            ok 4125 - The elems grew as expected on int64 array
            ok 4126 - int64 array becomes truthy when it has an element
            ok 4127 - Can slice-assign to an int64 array
            ok 4128 - Can get slice-assigned value from int64 array (1)
            ok 4129 - Can get slice-assigned value from int64 array (2)
            ok 4130 - The elems grew as expected on int64 array
            ok 4131 - The end value matches grown elems on int64 array
            ok 4132 - Int-ifies to grown number of elems on int64 array
            ok 4133 - Numifies to grown number of elems on int64 array
            ok 4134 - int64 array with values is not lazy
            ok 4135 - Can assign non-contiguously to int64 array
            ok 4136 - Elems behind non-contiguous assign are 0 on int64 array
            ok 4137 - Non-contiguous assignment works on int64 array
            ok 4138 - Can also get last element on int64 array
            ok 4139 - Can clear int64 array by assigning empty list
            ok 4140 - Cleared int64 array has no elems
            ok 4141 - Cleared int64 array has end of -1
            ok 4142 - Cleared int64 array Int-ifies to 0
            ok 4143 - Cleared int64 array numifies to 0
            ok 4144 - Cleared int64 array is falsey
            ok 4145 - Can assign integer range to int64 array
            ok 4146 - Got correct elems from range assign on int64 array
            ok 4147 - Got correct element from range assign on int64 array (1)
            ok 4148 - Got correct element from range assign on int64 array (2)
            ok 4149 - :exists works on int64 array (1)
            ok 4150 - :exists works on int64 array (2)
            ok 4151 - :exists works on int64 array (3)
            ok 4152 - Can call int64 array constructor with a single value
            ok 4153 - Correct number of elems set in constructor of int64 array
            ok 4154 - Correct element value set by constructor of int64 array
            ok 4155 - Can call int64 array constructor with values
            ok 4156 - Correct number of elems set in constructor of int64 array
            ok 4157 - Correct elem value set by constructor of int64 array (1)
            ok 4158 - Correct elem value set by constructor of int64 array (2)
            ok 4159 - Correct elem value set by constructor of int64 array (3)
            ok 4160 - Correct elem value set by constructor of int64 array (4)
            ok 4161 - Can also get last 2 elements on int64 array
            ok 4162 - int64 array .flat returns a Seq
            ok 4163 - int64 array .eager returns identity
            ok 4164 - Can iterate over int64 array
            ok 4165 - Mutating for loop on int64 array works (1)
            ok 4166 - Mutating for loop on int64 array works (2)
            ok 4167 - Mutating for loop on int64 array works (3)
            ok 4168 - Mutating for loop on int64 array works (4)
            ok 4169 - Can map over int64 array
            ok 4170 - Mutating map on int64 array works (1)
            ok 4171 - Mutating map on int64 array works (2)
            ok 4172 - Mutating map on int64 array works (3)
            ok 4173 - Mutating map on int64 array works (4)
            ok 4174 - grep a int64 array
            ok 4175 - int64 array.grep(Int)
            ok 4176 - int64 array.grep(Int, :k)
            ok 4177 - int64 array.grep(Int, :kv)
            ok 4178 - int64 array.grep(Int, :p)
            ok 4179 - int64 array.grep(Int, :v)
            ok 4180 - int64 array.grep(Int)
            ok 4181 - int64 array.grep(Int, :k)
            ok 4182 - int64 array.grep(Int, :kv)
            ok 4183 - int64 array.grep(Int, :p)
            ok 4184 - int64 array.grep(Int, :v)
            ok 4185 - Can use reduce meta-op on a int64 array
            ok 4186 - .values from a int64 array
            ok 4187 - .pairup from a int64 array
            ok 4188 - .keys from a int64 array
            ok 4189 - .pairs from a int64 array
            ok 4190 - .antipairs from a int64 array
            ok 4191 - .kv from a int64 array
            ok 4192 - .pick from a int64 array
            ok 4193 - .roll from a int64 array
            ok 4194 - int64 array.unique
            ok 4195 - int64 array.repeated
            ok 4196 - int64 array.squish
                1..4
                ok 1 - code dies
                ok 2 - right exception type (X::Cannot::Empty)
                ok 3 - .action matches pop
                ok 4 - .what matches array[int64]
            ok 4197 - Trying to pop an empty int64 array dies
                1..4
                ok 1 - code dies
                ok 2 - right exception type (X::Cannot::Empty)
                ok 3 - .what matches array[int64]
                ok 4 - .action matches shift
            ok 4198 - Trying to shift an empty int64 array dies
            ok 4199 - can push to int64 array
            ok 4200 - push to int64 array works (1)
            ok 4201 - push to int64 array works (2)
                1..3
                ok 1 - code dies
                ok 2 - right exception type (X::TypeCheck)
                ok 3 - .got matches (Str)
            ok 4202 - Cannot push non-int/Int to int64 array
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4203 - Cannot bind to int64 array
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4204 - Cannot delete from int64 array
            ok 4205 - can push multiple to int64 array
            ok 4206 - push multiple to int64 array works (1)
            ok 4207 - push multiple to int64 array works (2)
            ok 4208 - push multiple to int64 array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4209 - Cannot push non-int/Int to int64 array (multiple push)
            ok 4210 - can append to int64 array
            ok 4211 - append to int64 array works (1)
            ok 4212 - append to int64 array works (2)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4213 - Cannot append non-int/Int to int64 array
            ok 4214 - can append multiple to int64 array
            ok 4215 - append multiple to int64 array works (1)
            ok 4216 - append multiple to int64 array works (2)
            ok 4217 - append multiple to int64 array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4218 - Cannot append non-int/Int to int64 array (multiple append)
            ok 4219 - pop from int64 array works (1)
            ok 4220 - pop from int64 array works (2)
            ok 4221 - can unshift to int64 array
            ok 4222 - unshift to int64 array works (1)
            ok 4223 - unshift to int64 array works (2)
            ok 4224 - unshift to int64 array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4225 - Cannot unshift non-int/Int to int64 array
            ok 4226 - can unshift multiple to int64 array
            ok 4227 - unshift multiple to int64 array works (1)
            ok 4228 - unshift multiple to int64 array works (2)
            ok 4229 - unshift multiple to int64 array works (3)
            ok 4230 - unshift multiple to int64 array works (4)
            ok 4231 - unshift multiple to int64 array works (5)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4232 - Cannot unshift non-int/Int to int64 array (multiple unshift)
            ok 4233 - can prepend to int64 array
            ok 4234 - prepend to int64 array works (1)
            ok 4235 - prepend to int64 array works (2)
            ok 4236 - prepend to int64 array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4237 - Cannot prepend non-int/Int to int64 array
            ok 4238 - can prepend multiple to int64 array
            ok 4239 - unshift multiple to int64 array works (1)
            ok 4240 - prepend multiple to int64 array works (2)
            ok 4241 - prepend multiple to int64 array works (3)
            ok 4242 - prepend multiple to int64 array works (4)
            ok 4243 - prepend multiple to int64 array works (5)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4244 - Cannot prepend non-int/Int to int64 array (multiple unshift)
            ok 4245 - shift from int64 array works (1)
            ok 4246 - shift from int64 array works (2)
            ok 4247 - can initialize int64 from Range
            ok 4248 - Number of elems after splice int64 array
            ok 4249 - Splice on int64 array did the right thing (1)
            ok 4250 - Splice on int64 array did the right thing (2)
            ok 4251 - Splice on int64 array did the right thing (3)
            ok 4252 - Splice on int64 array did the right thing (4)
            ok 4253 - Splice on int64 array did the right thing (5)
            ok 4254 - Number of returned spliced values from int64 array
            ok 4255 - Correct value in splice returned from int64 array (1)
            ok 4256 - Correct value in splice returned from int64 array (2)
            ok 4257 - .Str space-separates on int64 array
            ok 4258 - .gist space-separates on int64 array
            ok 4259 - .raku includes type and int values on int64 array
            ok 4260 - does slice return same type
            ok 4261 - does slice handle containerized range
            ok 4262 - Flattening int64 array in call works
            ok 4263 - does join a int64 array
            ok 4264 - does emptying a int64 array really empty
            ok 4265 - does join handle holes in a int64 array
            ok 4266 - List-assigning int64 array to untyped works (1)
            ok 4267 - List-assigning int64 array to untyped works (2)
            ok 4268 - List-assigning int64 array to untyped works (3)
            ok 4269 - List-assign int64 array surrounded by literals (1)
            ok 4270 - List-assign int64 array surrounded by literals (2)
            ok 4271 - List-assign int64 array surrounded by literals (3)
            ok 4272 - List-assign int64 array surrounded by literals (4)
            ok 4273 - List-assign int64 array surrounded by literals (5)
            ok 4274 - List-assign untyped array of Int to int64 array (1)
            ok 4275 - List-assign untyped array of Int to int64 array (2)
            ok 4276 - List-assign untyped array of Int to int64 array (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4277 - List-assigning incompatible untyped array to int64 array dies
            ok 4278 - Smartmatching same int64 arrays works
            ok 4279 - Smartmatching different int64 arrays works
            ok 4280 - Can we sort int64 array
            ok 4281 - Can we sort 2-element sorted int64 array
            ok 4282 - Can we sort 2-element unsorted int64 array
            ok 4283 - Can we sort 1-element int64 array
            ok 4284 - Can we sort 0-element int64 array
            # Testing uint array
            ok 4285 - uint array type is Positional
            ok 4286 - uint array type is Positional[uint]
            ok 4287 - uint array type .of is uint
            ok 4288 - uint array is Positional
            ok 4289 - uint array is Positional[uint]
            ok 4290 - uint array .of is uint
            ok 4291 - uint array is Positional
            ok 4292 - uint array is Positional[uint]
            ok 4293 - uint array .of is uint
            ok 4294 - .new from uint array is Positional
            ok 4295 - .new from uint array Positional[uint]
            ok 4296 - .new from uint array .of is uint
            ok 4297 - New uint array has no elems
            ok 4298 - New uint array has end of -1
            ok 4299 - New uint array Int-ifies to 0
            ok 4300 - New uint array numifies to 0
            ok 4301 - New uint array is falsey
            ok 4302 - Empty uint array is not lazy
            ok 4303 - Accessing non-existing on uint array gives 0
            ok 4304 - Elems do not grow just from an access on uint array
            ok 4305 - Can store integer in an uint array
            ok 4306 - Can get value from uint array
            ok 4307 - The elems grew as expected on uint array
            ok 4308 - uint array becomes truthy when it has an element
            ok 4309 - Can slice-assign to an uint array
            ok 4310 - Can get slice-assigned value from uint array (1)
            ok 4311 - Can get slice-assigned value from uint array (2)
            ok 4312 - The elems grew as expected on uint array
            ok 4313 - The end value matches grown elems on uint array
            ok 4314 - Int-ifies to grown number of elems on uint array
            ok 4315 - Numifies to grown number of elems on uint array
            ok 4316 - uint array with values is not lazy
            ok 4317 - Can assign non-contiguously to uint array
            ok 4318 - Elems behind non-contiguous assign are 0 on uint array
            ok 4319 - Non-contiguous assignment works on uint array
            ok 4320 - Can also get last element on uint array
            ok 4321 - Can clear uint array by assigning empty list
            ok 4322 - Cleared uint array has no elems
            ok 4323 - Cleared uint array has end of -1
            ok 4324 - Cleared uint array Int-ifies to 0
            ok 4325 - Cleared uint array numifies to 0
            ok 4326 - Cleared uint array is falsey
            ok 4327 - Can assign integer range to uint array
            ok 4328 - Got correct elems from range assign on uint array
            ok 4329 - Got correct element from range assign on uint array (1)
            ok 4330 - Got correct element from range assign on uint array (2)
            ok 4331 - :exists works on uint array (1)
            ok 4332 - :exists works on uint array (2)
            ok 4333 - :exists works on uint array (3)
            ok 4334 - Can call uint array constructor with a single value
            ok 4335 - Correct number of elems set in constructor of uint array
            ok 4336 - Correct element value set by constructor of uint array
            ok 4337 - Can call uint array constructor with values
            ok 4338 - Correct number of elems set in constructor of uint array
            ok 4339 - Correct elem value set by constructor of uint array (1)
            ok 4340 - Correct elem value set by constructor of uint array (2)
            ok 4341 - Correct elem value set by constructor of uint array (3)
            ok 4342 - Correct elem value set by constructor of uint array (4)
            ok 4343 - Can also get last 2 elements on uint array
            ok 4344 - uint array .flat returns a Seq
            ok 4345 - uint array .eager returns identity
            ok 4346 - Can iterate over uint array
            ok 4347 - Mutating for loop on uint array works (1)
            ok 4348 - Mutating for loop on uint array works (2)
            ok 4349 - Mutating for loop on uint array works (3)
            ok 4350 - Mutating for loop on uint array works (4)
            ok 4351 - Can map over uint array
            ok 4352 - Mutating map on uint array works (1)
            ok 4353 - Mutating map on uint array works (2)
            ok 4354 - Mutating map on uint array works (3)
            ok 4355 - Mutating map on uint array works (4)
            ok 4356 - grep a uint array
            ok 4357 - uint array.grep(Int)
            ok 4358 - uint array.grep(Int, :k)
            ok 4359 - uint array.grep(Int, :kv)
            ok 4360 - uint array.grep(Int, :p)
            ok 4361 - uint array.grep(Int, :v)
            ok 4362 - uint array.grep(Int)
            ok 4363 - uint array.grep(Int, :k)
            ok 4364 - uint array.grep(Int, :kv)
            ok 4365 - uint array.grep(Int, :p)
            ok 4366 - uint array.grep(Int, :v)
            ok 4367 - Can use reduce meta-op on a uint array
            ok 4368 - .values from a uint array
            ok 4369 - .pairup from a uint array
            ok 4370 - .keys from a uint array
            ok 4371 - .pairs from a uint array
            ok 4372 - .antipairs from a uint array
            ok 4373 - .kv from a uint array
            ok 4374 - .pick from a uint array
            ok 4375 - .roll from a uint array
            ok 4376 - uint array.unique
            ok 4377 - uint array.repeated
            ok 4378 - uint array.squish
                1..4
                ok 1 - code dies
                ok 2 - right exception type (X::Cannot::Empty)
                ok 3 - .what matches array[uint]
                ok 4 - .action matches pop
            ok 4379 - Trying to pop an empty uint array dies
                1..4
                ok 1 - code dies
                ok 2 - right exception type (X::Cannot::Empty)
                ok 3 - .action matches shift
                ok 4 - .what matches array[uint]
            ok 4380 - Trying to shift an empty uint array dies
            ok 4381 - can push to uint array
            ok 4382 - push to uint array works (1)
            ok 4383 - push to uint array works (2)
                1..3
                ok 1 - code dies
                ok 2 - right exception type (X::TypeCheck)
                ok 3 - .got matches (Str)
            ok 4384 - Cannot push non-int/Int to uint array
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4385 - Cannot bind to uint array
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4386 - Cannot delete from uint array
            ok 4387 - can push multiple to uint array
            ok 4388 - push multiple to uint array works (1)
            ok 4389 - push multiple to uint array works (2)
            ok 4390 - push multiple to uint array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4391 - Cannot push non-int/Int to uint array (multiple push)
            ok 4392 - can append to uint array
            ok 4393 - append to uint array works (1)
            ok 4394 - append to uint array works (2)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4395 - Cannot append non-int/Int to uint array
            ok 4396 - can append multiple to uint array
            ok 4397 - append multiple to uint array works (1)
            ok 4398 - append multiple to uint array works (2)
            ok 4399 - append multiple to uint array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4400 - Cannot append non-int/Int to uint array (multiple append)
            ok 4401 - pop from uint array works (1)
            ok 4402 - pop from uint array works (2)
            ok 4403 - can unshift to uint array
            ok 4404 - unshift to uint array works (1)
            ok 4405 - unshift to uint array works (2)
            ok 4406 - unshift to uint array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4407 - Cannot unshift non-int/Int to uint array
            ok 4408 - can unshift multiple to uint array
            ok 4409 - unshift multiple to uint array works (1)
            ok 4410 - unshift multiple to uint array works (2)
            ok 4411 - unshift multiple to uint array works (3)
            ok 4412 - unshift multiple to uint array works (4)
            ok 4413 - unshift multiple to uint array works (5)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4414 - Cannot unshift non-int/Int to uint array (multiple unshift)
            ok 4415 - can prepend to uint array
            ok 4416 - prepend to uint array works (1)
            ok 4417 - prepend to uint array works (2)
            ok 4418 - prepend to uint array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4419 - Cannot prepend non-int/Int to uint array
            ok 4420 - can prepend multiple to uint array
            ok 4421 - unshift multiple to uint array works (1)
            ok 4422 - prepend multiple to uint array works (2)
            ok 4423 - prepend multiple to uint array works (3)
            ok 4424 - prepend multiple to uint array works (4)
            ok 4425 - prepend multiple to uint array works (5)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4426 - Cannot prepend non-int/Int to uint array (multiple unshift)
            ok 4427 - shift from uint array works (1)
            ok 4428 - shift from uint array works (2)
            ok 4429 - can initialize uint from Range
            ok 4430 - Number of elems after splice uint array
            ok 4431 - Splice on uint array did the right thing (1)
            ok 4432 - Splice on uint array did the right thing (2)
            ok 4433 - Splice on uint array did the right thing (3)
            ok 4434 - Splice on uint array did the right thing (4)
            ok 4435 - Splice on uint array did the right thing (5)
            ok 4436 - Number of returned spliced values from uint array
            ok 4437 - Correct value in splice returned from uint array (1)
            ok 4438 - Correct value in splice returned from uint array (2)
            ok 4439 - .Str space-separates on uint array
            ok 4440 - .gist space-separates on uint array
            ok 4441 - .raku includes type and int values on uint array
            ok 4442 - does slice return same type
            ok 4443 - does slice handle containerized range
            ok 4444 - Flattening uint array in call works
            ok 4445 - does join a uint array
            ok 4446 - does emptying a uint array really empty
            ok 4447 - does join handle holes in a uint array
            ok 4448 - List-assigning uint array to untyped works (1)
            ok 4449 - List-assigning uint array to untyped works (2)
            ok 4450 - List-assigning uint array to untyped works (3)
            ok 4451 - List-assign uint array surrounded by literals (1)
            ok 4452 - List-assign uint array surrounded by literals (2)
            ok 4453 - List-assign uint array surrounded by literals (3)
            ok 4454 - List-assign uint array surrounded by literals (4)
            ok 4455 - List-assign uint array surrounded by literals (5)
            ok 4456 - List-assign untyped array of Int to uint array (1)
            ok 4457 - List-assign untyped array of Int to uint array (2)
            ok 4458 - List-assign untyped array of Int to uint array (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4459 - List-assigning incompatible untyped array to uint array dies
            ok 4460 - Smartmatching same uint arrays works
            ok 4461 - Smartmatching different uint arrays works
            ok 4462 - Can we sort uint array
            ok 4463 - Can we sort 2-element sorted uint array
            ok 4464 - Can we sort 2-element unsorted uint array
            ok 4465 - Can we sort 1-element uint array
            ok 4466 - Can we sort 0-element uint array
            # Testing uint8 array
            ok 4467 - uint8 array type is Positional
            ok 4468 - uint8 array type is Positional[uint8]
            ok 4469 - uint8 array type .of is uint8
            ok 4470 - uint8 array is Positional
            ok 4471 - uint8 array is Positional[uint8]
            ok 4472 - uint8 array .of is uint8
            ok 4473 - uint8 array is Positional
            ok 4474 - uint8 array is Positional[uint8]
            ok 4475 - uint8 array .of is uint8
            ok 4476 - .new from uint8 array is Positional
            ok 4477 - .new from uint8 array Positional[uint8]
            ok 4478 - .new from uint8 array .of is uint8
            ok 4479 - New uint8 array has no elems
            ok 4480 - New uint8 array has end of -1
            ok 4481 - New uint8 array Int-ifies to 0
            ok 4482 - New uint8 array numifies to 0
            ok 4483 - New uint8 array is falsey
            ok 4484 - Empty uint8 array is not lazy
            ok 4485 - Accessing non-existing on uint8 array gives 0
            ok 4486 - Elems do not grow just from an access on uint8 array
            ok 4487 - Can store integer in an uint8 array
            ok 4488 - Can get value from uint8 array
            ok 4489 - The elems grew as expected on uint8 array
            ok 4490 - uint8 array becomes truthy when it has an element
            ok 4491 - Can slice-assign to an uint8 array
            ok 4492 - Can get slice-assigned value from uint8 array (1)
            ok 4493 - Can get slice-assigned value from uint8 array (2)
            ok 4494 - The elems grew as expected on uint8 array
            ok 4495 - The end value matches grown elems on uint8 array
            ok 4496 - Int-ifies to grown number of elems on uint8 array
            ok 4497 - Numifies to grown number of elems on uint8 array
            ok 4498 - uint8 array with values is not lazy
            ok 4499 - Can assign non-contiguously to uint8 array
            ok 4500 - Elems behind non-contiguous assign are 0 on uint8 array
            ok 4501 - Non-contiguous assignment works on uint8 array
            ok 4502 - Can also get last element on uint8 array
            ok 4503 - Can clear uint8 array by assigning empty list
            ok 4504 - Cleared uint8 array has no elems
            ok 4505 - Cleared uint8 array has end of -1
            ok 4506 - Cleared uint8 array Int-ifies to 0
            ok 4507 - Cleared uint8 array numifies to 0
            ok 4508 - Cleared uint8 array is falsey
            ok 4509 - Can assign integer range to uint8 array
            ok 4510 - Got correct elems from range assign on uint8 array
            ok 4511 - Got correct element from range assign on uint8 array (1)
            ok 4512 - Got correct element from range assign on uint8 array (2)
            ok 4513 - :exists works on uint8 array (1)
            ok 4514 - :exists works on uint8 array (2)
            ok 4515 - :exists works on uint8 array (3)
            ok 4516 - Can call uint8 array constructor with a single value
            ok 4517 - Correct number of elems set in constructor of uint8 array
            ok 4518 - Correct element value set by constructor of uint8 array
            ok 4519 - Can call uint8 array constructor with values
            ok 4520 - Correct number of elems set in constructor of uint8 array
            ok 4521 - Correct elem value set by constructor of uint8 array (1)
            ok 4522 - Correct elem value set by constructor of uint8 array (2)
            ok 4523 - Correct elem value set by constructor of uint8 array (3)
            ok 4524 - Correct elem value set by constructor of uint8 array (4)
            ok 4525 - Can also get last 2 elements on uint8 array
            ok 4526 - uint8 array .flat returns a Seq
            ok 4527 - uint8 array .eager returns identity
            ok 4528 - Can iterate over uint8 array
            ok 4529 - Mutating for loop on uint8 array works (1)
            ok 4530 - Mutating for loop on uint8 array works (2)
            ok 4531 - Mutating for loop on uint8 array works (3)
            ok 4532 - Mutating for loop on uint8 array works (4)
            ok 4533 - Can map over uint8 array
            ok 4534 - Mutating map on uint8 array works (1)
            ok 4535 - Mutating map on uint8 array works (2)
            ok 4536 - Mutating map on uint8 array works (3)
            ok 4537 - Mutating map on uint8 array works (4)
            ok 4538 - grep a uint8 array
            ok 4539 - uint8 array.grep(Int)
            ok 4540 - uint8 array.grep(Int, :k)
            ok 4541 - uint8 array.grep(Int, :kv)
            ok 4542 - uint8 array.grep(Int, :p)
            ok 4543 - uint8 array.grep(Int, :v)
            ok 4544 - uint8 array.grep(Int)
            ok 4545 - uint8 array.grep(Int, :k)
            ok 4546 - uint8 array.grep(Int, :kv)
            ok 4547 - uint8 array.grep(Int, :p)
            ok 4548 - uint8 array.grep(Int, :v)
            ok 4549 - Can use reduce meta-op on a uint8 array
            ok 4550 - .values from a uint8 array
            ok 4551 - .pairup from a uint8 array
            ok 4552 - .keys from a uint8 array
            ok 4553 - .pairs from a uint8 array
            ok 4554 - .antipairs from a uint8 array
            ok 4555 - .kv from a uint8 array
            ok 4556 - .pick from a uint8 array
            ok 4557 - .roll from a uint8 array
            ok 4558 - uint8 array.unique
            ok 4559 - uint8 array.repeated
            ok 4560 - uint8 array.squish
                1..4
                ok 1 - code dies
                ok 2 - right exception type (X::Cannot::Empty)
                ok 3 - .what matches array[uint8]
                ok 4 - .action matches pop
            ok 4561 - Trying to pop an empty uint8 array dies
                1..4
                ok 1 - code dies
                ok 2 - right exception type (X::Cannot::Empty)
                ok 3 - .what matches array[uint8]
                ok 4 - .action matches shift
            ok 4562 - Trying to shift an empty uint8 array dies
            ok 4563 - can push to uint8 array
            ok 4564 - push to uint8 array works (1)
            ok 4565 - push to uint8 array works (2)
                1..3
                ok 1 - code dies
                ok 2 - right exception type (X::TypeCheck)
                ok 3 - .got matches (Str)
            ok 4566 - Cannot push non-int/Int to uint8 array
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4567 - Cannot bind to uint8 array
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4568 - Cannot delete from uint8 array
            ok 4569 - can push multiple to uint8 array
            ok 4570 - push multiple to uint8 array works (1)
            ok 4571 - push multiple to uint8 array works (2)
            ok 4572 - push multiple to uint8 array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4573 - Cannot push non-int/Int to uint8 array (multiple push)
            ok 4574 - can append to uint8 array
            ok 4575 - append to uint8 array works (1)
            ok 4576 - append to uint8 array works (2)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4577 - Cannot append non-int/Int to uint8 array
            ok 4578 - can append multiple to uint8 array
            ok 4579 - append multiple to uint8 array works (1)
            ok 4580 - append multiple to uint8 array works (2)
            ok 4581 - append multiple to uint8 array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4582 - Cannot append non-int/Int to uint8 array (multiple append)
            ok 4583 - pop from uint8 array works (1)
            ok 4584 - pop from uint8 array works (2)
            ok 4585 - can unshift to uint8 array
            ok 4586 - unshift to uint8 array works (1)
            ok 4587 - unshift to uint8 array works (2)
            ok 4588 - unshift to uint8 array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4589 - Cannot unshift non-int/Int to uint8 array
            ok 4590 - can unshift multiple to uint8 array
            ok 4591 - unshift multiple to uint8 array works (1)
            ok 4592 - unshift multiple to uint8 array works (2)
            ok 4593 - unshift multiple to uint8 array works (3)
            ok 4594 - unshift multiple to uint8 array works (4)
            ok 4595 - unshift multiple to uint8 array works (5)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4596 - Cannot unshift non-int/Int to uint8 array (multiple unshift)
            ok 4597 - can prepend to uint8 array
            ok 4598 - prepend to uint8 array works (1)
            ok 4599 - prepend to uint8 array works (2)
            ok 4600 - prepend to uint8 array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4601 - Cannot prepend non-int/Int to uint8 array
            ok 4602 - can prepend multiple to uint8 array
            ok 4603 - unshift multiple to uint8 array works (1)
            ok 4604 - prepend multiple to uint8 array works (2)
            ok 4605 - prepend multiple to uint8 array works (3)
            ok 4606 - prepend multiple to uint8 array works (4)
            ok 4607 - prepend multiple to uint8 array works (5)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4608 - Cannot prepend non-int/Int to uint8 array (multiple unshift)
            ok 4609 - shift from uint8 array works (1)
            ok 4610 - shift from uint8 array works (2)
            ok 4611 - can initialize uint8 from Range
            ok 4612 - Number of elems after splice uint8 array
            ok 4613 - Splice on uint8 array did the right thing (1)
            ok 4614 - Splice on uint8 array did the right thing (2)
            ok 4615 - Splice on uint8 array did the right thing (3)
            ok 4616 - Splice on uint8 array did the right thing (4)
            ok 4617 - Splice on uint8 array did the right thing (5)
            ok 4618 - Number of returned spliced values from uint8 array
            ok 4619 - Correct value in splice returned from uint8 array (1)
            ok 4620 - Correct value in splice returned from uint8 array (2)
            ok 4621 - .Str space-separates on uint8 array
            ok 4622 - .gist space-separates on uint8 array
            ok 4623 - .raku includes type and int values on uint8 array
            ok 4624 - does slice return same type
            ok 4625 - does slice handle containerized range
            ok 4626 - Flattening uint8 array in call works
            ok 4627 - does join a uint8 array
            ok 4628 - does emptying a uint8 array really empty
            ok 4629 - does join handle holes in a uint8 array
            ok 4630 - List-assigning uint8 array to untyped works (1)
            ok 4631 - List-assigning uint8 array to untyped works (2)
            ok 4632 - List-assigning uint8 array to untyped works (3)
            ok 4633 - List-assign uint8 array surrounded by literals (1)
            ok 4634 - List-assign uint8 array surrounded by literals (2)
            ok 4635 - List-assign uint8 array surrounded by literals (3)
            ok 4636 - List-assign uint8 array surrounded by literals (4)
            ok 4637 - List-assign uint8 array surrounded by literals (5)
            ok 4638 - List-assign untyped array of Int to uint8 array (1)
            ok 4639 - List-assign untyped array of Int to uint8 array (2)
            ok 4640 - List-assign untyped array of Int to uint8 array (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4641 - List-assigning incompatible untyped array to uint8 array dies
            ok 4642 - Smartmatching same uint8 arrays works
            ok 4643 - Smartmatching different uint8 arrays works
            ok 4644 - Can we sort uint8 array
            ok 4645 - Can we sort 2-element sorted uint8 array
            ok 4646 - Can we sort 2-element unsorted uint8 array
            ok 4647 - Can we sort 1-element uint8 array
            ok 4648 - Can we sort 0-element uint8 array
            # Testing uint16 array
            ok 4649 - uint16 array type is Positional
            ok 4650 - uint16 array type is Positional[uint16]
            ok 4651 - uint16 array type .of is uint16
            ok 4652 - uint16 array is Positional
            ok 4653 - uint16 array is Positional[uint16]
            ok 4654 - uint16 array .of is uint16
            ok 4655 - uint16 array is Positional
            ok 4656 - uint16 array is Positional[uint16]
            ok 4657 - uint16 array .of is uint16
            ok 4658 - .new from uint16 array is Positional
            ok 4659 - .new from uint16 array Positional[uint16]
            ok 4660 - .new from uint16 array .of is uint16
            ok 4661 - New uint16 array has no elems
            ok 4662 - New uint16 array has end of -1
            ok 4663 - New uint16 array Int-ifies to 0
            ok 4664 - New uint16 array numifies to 0
            ok 4665 - New uint16 array is falsey
            ok 4666 - Empty uint16 array is not lazy
            ok 4667 - Accessing non-existing on uint16 array gives 0
            ok 4668 - Elems do not grow just from an access on uint16 array
            ok 4669 - Can store integer in an uint16 array
            ok 4670 - Can get value from uint16 array
            ok 4671 - The elems grew as expected on uint16 array
            ok 4672 - uint16 array becomes truthy when it has an element
            ok 4673 - Can slice-assign to an uint16 array
            ok 4674 - Can get slice-assigned value from uint16 array (1)
            ok 4675 - Can get slice-assigned value from uint16 array (2)
            ok 4676 - The elems grew as expected on uint16 array
            ok 4677 - The end value matches grown elems on uint16 array
            ok 4678 - Int-ifies to grown number of elems on uint16 array
            ok 4679 - Numifies to grown number of elems on uint16 array
            ok 4680 - uint16 array with values is not lazy
            ok 4681 - Can assign non-contiguously to uint16 array
            ok 4682 - Elems behind non-contiguous assign are 0 on uint16 array
            ok 4683 - Non-contiguous assignment works on uint16 array
            ok 4684 - Can also get last element on uint16 array
            ok 4685 - Can clear uint16 array by assigning empty list
            ok 4686 - Cleared uint16 array has no elems
            ok 4687 - Cleared uint16 array has end of -1
            ok 4688 - Cleared uint16 array Int-ifies to 0
            ok 4689 - Cleared uint16 array numifies to 0
            ok 4690 - Cleared uint16 array is falsey
            ok 4691 - Can assign integer range to uint16 array
            ok 4692 - Got correct elems from range assign on uint16 array
            ok 4693 - Got correct element from range assign on uint16 array (1)
            ok 4694 - Got correct element from range assign on uint16 array (2)
            ok 4695 - :exists works on uint16 array (1)
            ok 4696 - :exists works on uint16 array (2)
            ok 4697 - :exists works on uint16 array (3)
            ok 4698 - Can call uint16 array constructor with a single value
            ok 4699 - Correct number of elems set in constructor of uint16 array
            ok 4700 - Correct element value set by constructor of uint16 array
            ok 4701 - Can call uint16 array constructor with values
            ok 4702 - Correct number of elems set in constructor of uint16 array
            ok 4703 - Correct elem value set by constructor of uint16 array (1)
            ok 4704 - Correct elem value set by constructor of uint16 array (2)
            ok 4705 - Correct elem value set by constructor of uint16 array (3)
            ok 4706 - Correct elem value set by constructor of uint16 array (4)
            ok 4707 - Can also get last 2 elements on uint16 array
            ok 4708 - uint16 array .flat returns a Seq
            ok 4709 - uint16 array .eager returns identity
            ok 4710 - Can iterate over uint16 array
            ok 4711 - Mutating for loop on uint16 array works (1)
            ok 4712 - Mutating for loop on uint16 array works (2)
            ok 4713 - Mutating for loop on uint16 array works (3)
            ok 4714 - Mutating for loop on uint16 array works (4)
            ok 4715 - Can map over uint16 array
            ok 4716 - Mutating map on uint16 array works (1)
            ok 4717 - Mutating map on uint16 array works (2)
            ok 4718 - Mutating map on uint16 array works (3)
            ok 4719 - Mutating map on uint16 array works (4)
            ok 4720 - grep a uint16 array
            ok 4721 - uint16 array.grep(Int)
            ok 4722 - uint16 array.grep(Int, :k)
            ok 4723 - uint16 array.grep(Int, :kv)
            ok 4724 - uint16 array.grep(Int, :p)
            ok 4725 - uint16 array.grep(Int, :v)
            ok 4726 - uint16 array.grep(Int)
            ok 4727 - uint16 array.grep(Int, :k)
            ok 4728 - uint16 array.grep(Int, :kv)
            ok 4729 - uint16 array.grep(Int, :p)
            ok 4730 - uint16 array.grep(Int, :v)
            ok 4731 - Can use reduce meta-op on a uint16 array
            ok 4732 - .values from a uint16 array
            ok 4733 - .pairup from a uint16 array
            ok 4734 - .keys from a uint16 array
            ok 4735 - .pairs from a uint16 array
            ok 4736 - .antipairs from a uint16 array
            ok 4737 - .kv from a uint16 array
            ok 4738 - .pick from a uint16 array
            ok 4739 - .roll from a uint16 array
            ok 4740 - uint16 array.unique
            ok 4741 - uint16 array.repeated
            ok 4742 - uint16 array.squish
                1..4
                ok 1 - code dies
                ok 2 - right exception type (X::Cannot::Empty)
                ok 3 - .action matches pop
                ok 4 - .what matches array[uint16]
            ok 4743 - Trying to pop an empty uint16 array dies
                1..4
                ok 1 - code dies
                ok 2 - right exception type (X::Cannot::Empty)
                ok 3 - .action matches shift
                ok 4 - .what matches array[uint16]
            ok 4744 - Trying to shift an empty uint16 array dies
            ok 4745 - can push to uint16 array
            ok 4746 - push to uint16 array works (1)
            ok 4747 - push to uint16 array works (2)
                1..3
                ok 1 - code dies
                ok 2 - right exception type (X::TypeCheck)
                ok 3 - .got matches (Str)
            ok 4748 - Cannot push non-int/Int to uint16 array
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4749 - Cannot bind to uint16 array
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4750 - Cannot delete from uint16 array
            ok 4751 - can push multiple to uint16 array
            ok 4752 - push multiple to uint16 array works (1)
            ok 4753 - push multiple to uint16 array works (2)
            ok 4754 - push multiple to uint16 array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4755 - Cannot push non-int/Int to uint16 array (multiple push)
            ok 4756 - can append to uint16 array
            ok 4757 - append to uint16 array works (1)
            ok 4758 - append to uint16 array works (2)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4759 - Cannot append non-int/Int to uint16 array
            ok 4760 - can append multiple to uint16 array
            ok 4761 - append multiple to uint16 array works (1)
            ok 4762 - append multiple to uint16 array works (2)
            ok 4763 - append multiple to uint16 array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4764 - Cannot append non-int/Int to uint16 array (multiple append)
            ok 4765 - pop from uint16 array works (1)
            ok 4766 - pop from uint16 array works (2)
            ok 4767 - can unshift to uint16 array
            ok 4768 - unshift to uint16 array works (1)
            ok 4769 - unshift to uint16 array works (2)
            ok 4770 - unshift to uint16 array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4771 - Cannot unshift non-int/Int to uint16 array
            ok 4772 - can unshift multiple to uint16 array
            ok 4773 - unshift multiple to uint16 array works (1)
            ok 4774 - unshift multiple to uint16 array works (2)
            ok 4775 - unshift multiple to uint16 array works (3)
            ok 4776 - unshift multiple to uint16 array works (4)
            ok 4777 - unshift multiple to uint16 array works (5)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4778 - Cannot unshift non-int/Int to uint16 array (multiple unshift)
            ok 4779 - can prepend to uint16 array
            ok 4780 - prepend to uint16 array works (1)
            ok 4781 - prepend to uint16 array works (2)
            ok 4782 - prepend to uint16 array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4783 - Cannot prepend non-int/Int to uint16 array
            ok 4784 - can prepend multiple to uint16 array
            ok 4785 - unshift multiple to uint16 array works (1)
            ok 4786 - prepend multiple to uint16 array works (2)
            ok 4787 - prepend multiple to uint16 array works (3)
            ok 4788 - prepend multiple to uint16 array works (4)
            ok 4789 - prepend multiple to uint16 array works (5)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4790 - Cannot prepend non-int/Int to uint16 array (multiple unshift)
            ok 4791 - shift from uint16 array works (1)
            ok 4792 - shift from uint16 array works (2)
            ok 4793 - can initialize uint16 from Range
            ok 4794 - Number of elems after splice uint16 array
            ok 4795 - Splice on uint16 array did the right thing (1)
            ok 4796 - Splice on uint16 array did the right thing (2)
            ok 4797 - Splice on uint16 array did the right thing (3)
            ok 4798 - Splice on uint16 array did the right thing (4)
            ok 4799 - Splice on uint16 array did the right thing (5)
            ok 4800 - Number of returned spliced values from uint16 array
            ok 4801 - Correct value in splice returned from uint16 array (1)
            ok 4802 - Correct value in splice returned from uint16 array (2)
            ok 4803 - .Str space-separates on uint16 array
            ok 4804 - .gist space-separates on uint16 array
            ok 4805 - .raku includes type and int values on uint16 array
            ok 4806 - does slice return same type
            ok 4807 - does slice handle containerized range
            ok 4808 - Flattening uint16 array in call works
            ok 4809 - does join a uint16 array
            ok 4810 - does emptying a uint16 array really empty
            ok 4811 - does join handle holes in a uint16 array
            ok 4812 - List-assigning uint16 array to untyped works (1)
            ok 4813 - List-assigning uint16 array to untyped works (2)
            ok 4814 - List-assigning uint16 array to untyped works (3)
            ok 4815 - List-assign uint16 array surrounded by literals (1)
            ok 4816 - List-assign uint16 array surrounded by literals (2)
            ok 4817 - List-assign uint16 array surrounded by literals (3)
            ok 4818 - List-assign uint16 array surrounded by literals (4)
            ok 4819 - List-assign uint16 array surrounded by literals (5)
            ok 4820 - List-assign untyped array of Int to uint16 array (1)
            ok 4821 - List-assign untyped array of Int to uint16 array (2)
            ok 4822 - List-assign untyped array of Int to uint16 array (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4823 - List-assigning incompatible untyped array to uint16 array dies
            ok 4824 - Smartmatching same uint16 arrays works
            ok 4825 - Smartmatching different uint16 arrays works
            ok 4826 - Can we sort uint16 array
            ok 4827 - Can we sort 2-element sorted uint16 array
            ok 4828 - Can we sort 2-element unsorted uint16 array
            ok 4829 - Can we sort 1-element uint16 array
            ok 4830 - Can we sort 0-element uint16 array
            # Testing uint32 array
            ok 4831 - uint32 array type is Positional
            ok 4832 - uint32 array type is Positional[uint32]
            ok 4833 - uint32 array type .of is uint32
            ok 4834 - uint32 array is Positional
            ok 4835 - uint32 array is Positional[uint32]
            ok 4836 - uint32 array .of is uint32
            ok 4837 - uint32 array is Positional
            ok 4838 - uint32 array is Positional[uint32]
            ok 4839 - uint32 array .of is uint32
            ok 4840 - .new from uint32 array is Positional
            ok 4841 - .new from uint32 array Positional[uint32]
            ok 4842 - .new from uint32 array .of is uint32
            ok 4843 - New uint32 array has no elems
            ok 4844 - New uint32 array has end of -1
            ok 4845 - New uint32 array Int-ifies to 0
            ok 4846 - New uint32 array numifies to 0
            ok 4847 - New uint32 array is falsey
            ok 4848 - Empty uint32 array is not lazy
            ok 4849 - Accessing non-existing on uint32 array gives 0
            ok 4850 - Elems do not grow just from an access on uint32 array
            ok 4851 - Can store integer in an uint32 array
            ok 4852 - Can get value from uint32 array
            ok 4853 - The elems grew as expected on uint32 array
            ok 4854 - uint32 array becomes truthy when it has an element
            ok 4855 - Can slice-assign to an uint32 array
            ok 4856 - Can get slice-assigned value from uint32 array (1)
            ok 4857 - Can get slice-assigned value from uint32 array (2)
            ok 4858 - The elems grew as expected on uint32 array
            ok 4859 - The end value matches grown elems on uint32 array
            ok 4860 - Int-ifies to grown number of elems on uint32 array
            ok 4861 - Numifies to grown number of elems on uint32 array
            ok 4862 - uint32 array with values is not lazy
            ok 4863 - Can assign non-contiguously to uint32 array
            ok 4864 - Elems behind non-contiguous assign are 0 on uint32 array
            ok 4865 - Non-contiguous assignment works on uint32 array
            ok 4866 - Can also get last element on uint32 array
            ok 4867 - Can clear uint32 array by assigning empty list
            ok 4868 - Cleared uint32 array has no elems
            ok 4869 - Cleared uint32 array has end of -1
            ok 4870 - Cleared uint32 array Int-ifies to 0
            ok 4871 - Cleared uint32 array numifies to 0
            ok 4872 - Cleared uint32 array is falsey
            ok 4873 - Can assign integer range to uint32 array
            ok 4874 - Got correct elems from range assign on uint32 array
            ok 4875 - Got correct element from range assign on uint32 array (1)
            ok 4876 - Got correct element from range assign on uint32 array (2)
            ok 4877 - :exists works on uint32 array (1)
            ok 4878 - :exists works on uint32 array (2)
            ok 4879 - :exists works on uint32 array (3)
            ok 4880 - Can call uint32 array constructor with a single value
            ok 4881 - Correct number of elems set in constructor of uint32 array
            ok 4882 - Correct element value set by constructor of uint32 array
            ok 4883 - Can call uint32 array constructor with values
            ok 4884 - Correct number of elems set in constructor of uint32 array
            ok 4885 - Correct elem value set by constructor of uint32 array (1)
            ok 4886 - Correct elem value set by constructor of uint32 array (2)
            ok 4887 - Correct elem value set by constructor of uint32 array (3)
            ok 4888 - Correct elem value set by constructor of uint32 array (4)
            ok 4889 - Can also get last 2 elements on uint32 array
            ok 4890 - uint32 array .flat returns a Seq
            ok 4891 - uint32 array .eager returns identity
            ok 4892 - Can iterate over uint32 array
            ok 4893 - Mutating for loop on uint32 array works (1)
            ok 4894 - Mutating for loop on uint32 array works (2)
            ok 4895 - Mutating for loop on uint32 array works (3)
            ok 4896 - Mutating for loop on uint32 array works (4)
            ok 4897 - Can map over uint32 array
            ok 4898 - Mutating map on uint32 array works (1)
            ok 4899 - Mutating map on uint32 array works (2)
            ok 4900 - Mutating map on uint32 array works (3)
            ok 4901 - Mutating map on uint32 array works (4)
            ok 4902 - grep a uint32 array
            ok 4903 - uint32 array.grep(Int)
            ok 4904 - uint32 array.grep(Int, :k)
            ok 4905 - uint32 array.grep(Int, :kv)
            ok 4906 - uint32 array.grep(Int, :p)
            ok 4907 - uint32 array.grep(Int, :v)
            ok 4908 - uint32 array.grep(Int)
            ok 4909 - uint32 array.grep(Int, :k)
            ok 4910 - uint32 array.grep(Int, :kv)
            ok 4911 - uint32 array.grep(Int, :p)
            ok 4912 - uint32 array.grep(Int, :v)
            ok 4913 - Can use reduce meta-op on a uint32 array
            ok 4914 - .values from a uint32 array
            ok 4915 - .pairup from a uint32 array
            ok 4916 - .keys from a uint32 array
            ok 4917 - .pairs from a uint32 array
            ok 4918 - .antipairs from a uint32 array
            ok 4919 - .kv from a uint32 array
            ok 4920 - .pick from a uint32 array
            ok 4921 - .roll from a uint32 array
            ok 4922 - uint32 array.unique
            ok 4923 - uint32 array.repeated
            ok 4924 - uint32 array.squish
                1..4
                ok 1 - code dies
                ok 2 - right exception type (X::Cannot::Empty)
                ok 3 - .action matches pop
                ok 4 - .what matches array[uint32]
            ok 4925 - Trying to pop an empty uint32 array dies
                1..4
                ok 1 - code dies
                ok 2 - right exception type (X::Cannot::Empty)
                ok 3 - .what matches array[uint32]
                ok 4 - .action matches shift
            ok 4926 - Trying to shift an empty uint32 array dies
            ok 4927 - can push to uint32 array
            ok 4928 - push to uint32 array works (1)
            ok 4929 - push to uint32 array works (2)
                1..3
                ok 1 - code dies
                ok 2 - right exception type (X::TypeCheck)
                ok 3 - .got matches (Str)
            ok 4930 - Cannot push non-int/Int to uint32 array
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4931 - Cannot bind to uint32 array
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4932 - Cannot delete from uint32 array
            ok 4933 - can push multiple to uint32 array
            ok 4934 - push multiple to uint32 array works (1)
            ok 4935 - push multiple to uint32 array works (2)
            ok 4936 - push multiple to uint32 array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4937 - Cannot push non-int/Int to uint32 array (multiple push)
            ok 4938 - can append to uint32 array
            ok 4939 - append to uint32 array works (1)
            ok 4940 - append to uint32 array works (2)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4941 - Cannot append non-int/Int to uint32 array
            ok 4942 - can append multiple to uint32 array
            ok 4943 - append multiple to uint32 array works (1)
            ok 4944 - append multiple to uint32 array works (2)
            ok 4945 - append multiple to uint32 array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4946 - Cannot append non-int/Int to uint32 array (multiple append)
            ok 4947 - pop from uint32 array works (1)
            ok 4948 - pop from uint32 array works (2)
            ok 4949 - can unshift to uint32 array
            ok 4950 - unshift to uint32 array works (1)
            ok 4951 - unshift to uint32 array works (2)
            ok 4952 - unshift to uint32 array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4953 - Cannot unshift non-int/Int to uint32 array
            ok 4954 - can unshift multiple to uint32 array
            ok 4955 - unshift multiple to uint32 array works (1)
            ok 4956 - unshift multiple to uint32 array works (2)
            ok 4957 - unshift multiple to uint32 array works (3)
            ok 4958 - unshift multiple to uint32 array works (4)
            ok 4959 - unshift multiple to uint32 array works (5)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4960 - Cannot unshift non-int/Int to uint32 array (multiple unshift)
            ok 4961 - can prepend to uint32 array
            ok 4962 - prepend to uint32 array works (1)
            ok 4963 - prepend to uint32 array works (2)
            ok 4964 - prepend to uint32 array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4965 - Cannot prepend non-int/Int to uint32 array
            ok 4966 - can prepend multiple to uint32 array
            ok 4967 - unshift multiple to uint32 array works (1)
            ok 4968 - prepend multiple to uint32 array works (2)
            ok 4969 - prepend multiple to uint32 array works (3)
            ok 4970 - prepend multiple to uint32 array works (4)
            ok 4971 - prepend multiple to uint32 array works (5)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 4972 - Cannot prepend non-int/Int to uint32 array (multiple unshift)
            ok 4973 - shift from uint32 array works (1)
            ok 4974 - shift from uint32 array works (2)
            ok 4975 - can initialize uint32 from Range
            ok 4976 - Number of elems after splice uint32 array
            ok 4977 - Splice on uint32 array did the right thing (1)
            ok 4978 - Splice on uint32 array did the right thing (2)
            ok 4979 - Splice on uint32 array did the right thing (3)
            ok 4980 - Splice on uint32 array did the right thing (4)
            ok 4981 - Splice on uint32 array did the right thing (5)
            ok 4982 - Number of returned spliced values from uint32 array
            ok 4983 - Correct value in splice returned from uint32 array (1)
            ok 4984 - Correct value in splice returned from uint32 array (2)
            ok 4985 - .Str space-separates on uint32 array
            ok 4986 - .gist space-separates on uint32 array
            ok 4987 - .raku includes type and int values on uint32 array
            ok 4988 - does slice return same type
            ok 4989 - does slice handle containerized range
            ok 4990 - Flattening uint32 array in call works
            ok 4991 - does join a uint32 array
            ok 4992 - does emptying a uint32 array really empty
            ok 4993 - does join handle holes in a uint32 array
            ok 4994 - List-assigning uint32 array to untyped works (1)
            ok 4995 - List-assigning uint32 array to untyped works (2)
            ok 4996 - List-assigning uint32 array to untyped works (3)
            ok 4997 - List-assign uint32 array surrounded by literals (1)
            ok 4998 - List-assign uint32 array surrounded by literals (2)
            ok 4999 - List-assign uint32 array surrounded by literals (3)
            ok 5000 - List-assign uint32 array surrounded by literals (4)
            ok 5001 - List-assign uint32 array surrounded by literals (5)
            ok 5002 - List-assign untyped array of Int to uint32 array (1)
            ok 5003 - List-assign untyped array of Int to uint32 array (2)
            ok 5004 - List-assign untyped array of Int to uint32 array (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 5005 - List-assigning incompatible untyped array to uint32 array dies
            ok 5006 - Smartmatching same uint32 arrays works
            ok 5007 - Smartmatching different uint32 arrays works
            ok 5008 - Can we sort uint32 array
            ok 5009 - Can we sort 2-element sorted uint32 array
            ok 5010 - Can we sort 2-element unsorted uint32 array
            ok 5011 - Can we sort 1-element uint32 array
            ok 5012 - Can we sort 0-element uint32 array
            # Testing uint64 array
            ok 5013 - uint64 array type is Positional
            ok 5014 - uint64 array type is Positional[uint64]
            ok 5015 - uint64 array type .of is uint64
            ok 5016 - uint64 array is Positional
            ok 5017 - uint64 array is Positional[uint64]
            ok 5018 - uint64 array .of is uint64
            ok 5019 - uint64 array is Positional
            ok 5020 - uint64 array is Positional[uint64]
            ok 5021 - uint64 array .of is uint64
            ok 5022 - .new from uint64 array is Positional
            ok 5023 - .new from uint64 array Positional[uint64]
            ok 5024 - .new from uint64 array .of is uint64
            ok 5025 - New uint64 array has no elems
            ok 5026 - New uint64 array has end of -1
            ok 5027 - New uint64 array Int-ifies to 0
            ok 5028 - New uint64 array numifies to 0
            ok 5029 - New uint64 array is falsey
            ok 5030 - Empty uint64 array is not lazy
            ok 5031 - Accessing non-existing on uint64 array gives 0
            ok 5032 - Elems do not grow just from an access on uint64 array
            ok 5033 - Can store integer in an uint64 array
            ok 5034 - Can get value from uint64 array
            ok 5035 - The elems grew as expected on uint64 array
            ok 5036 - uint64 array becomes truthy when it has an element
            ok 5037 - Can slice-assign to an uint64 array
            ok 5038 - Can get slice-assigned value from uint64 array (1)
            ok 5039 - Can get slice-assigned value from uint64 array (2)
            ok 5040 - The elems grew as expected on uint64 array
            ok 5041 - The end value matches grown elems on uint64 array
            ok 5042 - Int-ifies to grown number of elems on uint64 array
            ok 5043 - Numifies to grown number of elems on uint64 array
            ok 5044 - uint64 array with values is not lazy
            ok 5045 - Can assign non-contiguously to uint64 array
            ok 5046 - Elems behind non-contiguous assign are 0 on uint64 array
            ok 5047 - Non-contiguous assignment works on uint64 array
            ok 5048 - Can also get last element on uint64 array
            ok 5049 - Can clear uint64 array by assigning empty list
            ok 5050 - Cleared uint64 array has no elems
            ok 5051 - Cleared uint64 array has end of -1
            ok 5052 - Cleared uint64 array Int-ifies to 0
            ok 5053 - Cleared uint64 array numifies to 0
            ok 5054 - Cleared uint64 array is falsey
            ok 5055 - Can assign integer range to uint64 array
            ok 5056 - Got correct elems from range assign on uint64 array
            ok 5057 - Got correct element from range assign on uint64 array (1)
            ok 5058 - Got correct element from range assign on uint64 array (2)
            ok 5059 - :exists works on uint64 array (1)
            ok 5060 - :exists works on uint64 array (2)
            ok 5061 - :exists works on uint64 array (3)
            ok 5062 - Can call uint64 array constructor with a single value
            ok 5063 - Correct number of elems set in constructor of uint64 array
            ok 5064 - Correct element value set by constructor of uint64 array
            ok 5065 - Can call uint64 array constructor with values
            ok 5066 - Correct number of elems set in constructor of uint64 array
            ok 5067 - Correct elem value set by constructor of uint64 array (1)
            ok 5068 - Correct elem value set by constructor of uint64 array (2)
            ok 5069 - Correct elem value set by constructor of uint64 array (3)
            ok 5070 - Correct elem value set by constructor of uint64 array (4)
            ok 5071 - Can also get last 2 elements on uint64 array
            ok 5072 - uint64 array .flat returns a Seq
            ok 5073 - uint64 array .eager returns identity
            ok 5074 - Can iterate over uint64 array
            ok 5075 - Mutating for loop on uint64 array works (1)
            ok 5076 - Mutating for loop on uint64 array works (2)
            ok 5077 - Mutating for loop on uint64 array works (3)
            ok 5078 - Mutating for loop on uint64 array works (4)
            ok 5079 - Can map over uint64 array
            ok 5080 - Mutating map on uint64 array works (1)
            ok 5081 - Mutating map on uint64 array works (2)
            ok 5082 - Mutating map on uint64 array works (3)
            ok 5083 - Mutating map on uint64 array works (4)
            ok 5084 - grep a uint64 array
            ok 5085 - uint64 array.grep(Int)
            ok 5086 - uint64 array.grep(Int, :k)
            ok 5087 - uint64 array.grep(Int, :kv)
            ok 5088 - uint64 array.grep(Int, :p)
            ok 5089 - uint64 array.grep(Int, :v)
            ok 5090 - uint64 array.grep(Int)
            ok 5091 - uint64 array.grep(Int, :k)
            ok 5092 - uint64 array.grep(Int, :kv)
            ok 5093 - uint64 array.grep(Int, :p)
            ok 5094 - uint64 array.grep(Int, :v)
            ok 5095 - Can use reduce meta-op on a uint64 array
            ok 5096 - .values from a uint64 array
            ok 5097 - .pairup from a uint64 array
            ok 5098 - .keys from a uint64 array
            ok 5099 - .pairs from a uint64 array
            ok 5100 - .antipairs from a uint64 array
            ok 5101 - .kv from a uint64 array
            ok 5102 - .pick from a uint64 array
            ok 5103 - .roll from a uint64 array
            ok 5104 - uint64 array.unique
            ok 5105 - uint64 array.repeated
            ok 5106 - uint64 array.squish
                1..4
                ok 1 - code dies
                ok 2 - right exception type (X::Cannot::Empty)
                ok 3 - .what matches array[uint64]
                ok 4 - .action matches pop
            ok 5107 - Trying to pop an empty uint64 array dies
                1..4
                ok 1 - code dies
                ok 2 - right exception type (X::Cannot::Empty)
                ok 3 - .action matches shift
                ok 4 - .what matches array[uint64]
            ok 5108 - Trying to shift an empty uint64 array dies
            ok 5109 - can push to uint64 array
            ok 5110 - push to uint64 array works (1)
            ok 5111 - push to uint64 array works (2)
                1..3
                ok 1 - code dies
                ok 2 - right exception type (X::TypeCheck)
                ok 3 - .got matches (Str)
            ok 5112 - Cannot push non-int/Int to uint64 array
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 5113 - Cannot bind to uint64 array
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 5114 - Cannot delete from uint64 array
            ok 5115 - can push multiple to uint64 array
            ok 5116 - push multiple to uint64 array works (1)
            ok 5117 - push multiple to uint64 array works (2)
            ok 5118 - push multiple to uint64 array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 5119 - Cannot push non-int/Int to uint64 array (multiple push)
            ok 5120 - can append to uint64 array
            ok 5121 - append to uint64 array works (1)
            ok 5122 - append to uint64 array works (2)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 5123 - Cannot append non-int/Int to uint64 array
            ok 5124 - can append multiple to uint64 array
            ok 5125 - append multiple to uint64 array works (1)
            ok 5126 - append multiple to uint64 array works (2)
            ok 5127 - append multiple to uint64 array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 5128 - Cannot append non-int/Int to uint64 array (multiple append)
            ok 5129 - pop from uint64 array works (1)
            ok 5130 - pop from uint64 array works (2)
            ok 5131 - can unshift to uint64 array
            ok 5132 - unshift to uint64 array works (1)
            ok 5133 - unshift to uint64 array works (2)
            ok 5134 - unshift to uint64 array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 5135 - Cannot unshift non-int/Int to uint64 array
            ok 5136 - can unshift multiple to uint64 array
            ok 5137 - unshift multiple to uint64 array works (1)
            ok 5138 - unshift multiple to uint64 array works (2)
            ok 5139 - unshift multiple to uint64 array works (3)
            ok 5140 - unshift multiple to uint64 array works (4)
            ok 5141 - unshift multiple to uint64 array works (5)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 5142 - Cannot unshift non-int/Int to uint64 array (multiple unshift)
            ok 5143 - can prepend to uint64 array
            ok 5144 - prepend to uint64 array works (1)
            ok 5145 - prepend to uint64 array works (2)
            ok 5146 - prepend to uint64 array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 5147 - Cannot prepend non-int/Int to uint64 array
            ok 5148 - can prepend multiple to uint64 array
            ok 5149 - unshift multiple to uint64 array works (1)
            ok 5150 - prepend multiple to uint64 array works (2)
            ok 5151 - prepend multiple to uint64 array works (3)
            ok 5152 - prepend multiple to uint64 array works (4)
            ok 5153 - prepend multiple to uint64 array works (5)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 5154 - Cannot prepend non-int/Int to uint64 array (multiple unshift)
            ok 5155 - shift from uint64 array works (1)
            ok 5156 - shift from uint64 array works (2)
            ok 5157 - can initialize uint64 from Range
            ok 5158 - Number of elems after splice uint64 array
            ok 5159 - Splice on uint64 array did the right thing (1)
            ok 5160 - Splice on uint64 array did the right thing (2)
            ok 5161 - Splice on uint64 array did the right thing (3)
            ok 5162 - Splice on uint64 array did the right thing (4)
            ok 5163 - Splice on uint64 array did the right thing (5)
            ok 5164 - Number of returned spliced values from uint64 array
            ok 5165 - Correct value in splice returned from uint64 array (1)
            ok 5166 - Correct value in splice returned from uint64 array (2)
            ok 5167 - .Str space-separates on uint64 array
            ok 5168 - .gist space-separates on uint64 array
            ok 5169 - .raku includes type and int values on uint64 array
            ok 5170 - does slice return same type
            ok 5171 - does slice handle containerized range
            ok 5172 - Flattening uint64 array in call works
            ok 5173 - does join a uint64 array
            ok 5174 - does emptying a uint64 array really empty
            ok 5175 - does join handle holes in a uint64 array
            ok 5176 - List-assigning uint64 array to untyped works (1)
            ok 5177 - List-assigning uint64 array to untyped works (2)
            ok 5178 - List-assigning uint64 array to untyped works (3)
            ok 5179 - List-assign uint64 array surrounded by literals (1)
            ok 5180 - List-assign uint64 array surrounded by literals (2)
            ok 5181 - List-assign uint64 array surrounded by literals (3)
            ok 5182 - List-assign uint64 array surrounded by literals (4)
            ok 5183 - List-assign uint64 array surrounded by literals (5)
            ok 5184 - List-assign untyped array of Int to uint64 array (1)
            ok 5185 - List-assign untyped array of Int to uint64 array (2)
            ok 5186 - List-assign untyped array of Int to uint64 array (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 5187 - List-assigning incompatible untyped array to uint64 array dies
            ok 5188 - Smartmatching same uint64 arrays works
            ok 5189 - Smartmatching different uint64 arrays works
            ok 5190 - Can we sort uint64 array
            ok 5191 - Can we sort 2-element sorted uint64 array
            ok 5192 - Can we sort 2-element unsorted uint64 array
            ok 5193 - Can we sort 1-element uint64 array
            ok 5194 - Can we sort 0-element uint64 array
            # Testing uint array for unsigned features
            ok 5195 - assigning -1 on uint array passes value on through?
            not ok 5196 - negative value on uint array becomes positive # TODO highest bit length stays negative, RT #124088
            # Failed test 'negative value on uint array becomes positive'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-int.rakudo line 323
            # Testing uint8 array for unsigned features
            ok 5197 - assigning -1 on uint8 array passes value on through?
            ok 5198 - negative value on uint8 array becomes positive
            # Testing uint16 array for unsigned features
            ok 5199 - assigning -1 on uint16 array passes value on through?
            ok 5200 - negative value on uint16 array becomes positive
            # Testing uint32 array for unsigned features
            ok 5201 - assigning -1 on uint32 array passes value on through?
            ok 5202 - negative value on uint32 array becomes positive
            # Testing uint64 array for unsigned features
            ok 5203 - assigning -1 on uint64 array passes value on through?
            not ok 5204 - negative value on uint64 array becomes positive # TODO highest bit length stays negative, RT #124088
            # Failed test 'negative value on uint64 array becomes positive'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-int.rakudo line 323
            ok 5205 - Trying to assign ^Inf to an int array dies
            ok 5206 - is 1999999000000 == 1999999000000
            ok 5207 - did we survive the hole
# FUDGED!
            1..511
            # Testing num array
            ok 5208 - num array type is Positional
            ok 5209 - num array type is Positional[num]
            ok 5210 - num array type .of is num
            ok 5211 - num array is Positional
            ok 5212 - num array is Positional[num]
            ok 5213 - num array .of is num
            ok 5214 - num array is Positional
            ok 5215 - num array is Positional[num]
            ok 5216 - num array .of is num
            ok 5217 - .new from num array is Positional
            ok 5218 - .new from num array Positional[num]
            ok 5219 - .new from num array .of is num
            ok 5220 - New num array has no elems
            ok 5221 - New num array has end of -1
            ok 5222 - New num array Int-ifies to 0
            ok 5223 - New num array numifies to 0
            ok 5224 - New num array is falsey
            ok 5225 - Empty num array is not lazy
            ok 5226 - Accessing non-existing on num array gives 0
            ok 5227 - Elems do not grow just from an access on num array
            ok 5228 - Can store num in an num array
            ok 5229 - Can get value from num array
            ok 5230 - The elems grew as expected on num array
            ok 5231 - num array becomes truthy when it has an element
            ok 5232 - Can get slice-assigned value from num array (1)
            ok 5233 - Can get slice-assigned value from num array (2)
            ok 5234 - The elems grew as expected on num array
            ok 5235 - The end value matches grown elems on num array
            ok 5236 - Int-ifies to grown number of elems on num array
            ok 5237 - Numifies to grown number of elems on num array
            ok 5238 - num array with values is not lazy
            ok 5239 - are special IEEE values supported on num array
            ok 5240 - Can assign non-contiguously to num array
            ok 5241 - Elems non-contiguous assign 0 on num array
            ok 5242 - Non-contiguous assignment works on num array
            ok 5243 - Can also get last element on num array
            ok 5244 - Can clear num array by assigning empty list
            ok 5245 - Cleared num array has no elems
            ok 5246 - Cleared num array has end of -1
            ok 5247 - Cleared num array Int-ifies to 0
            ok 5248 - Cleared num array numifies to 0
            ok 5249 - Cleared num array is falsey
            ok 5250 - Got correct elems from range assign on num array
            ok 5251 - Correct elem from range assign on num array (1)
            ok 5252 - Correct elem from range assign on num array (2)
            ok 5253 - :exists works on num array (1)
            ok 5254 - :exists works on num array (2)
            ok 5255 - :exists works on num array (3)
            ok 5256 - Correct number of elems set in constructor of num array
            ok 5257 - Correct elem set by constructor of num array
            ok 5258 - Correct number of elems set in constructor of num array
            ok 5259 - Correct elem set by constructor of num array (1)
            ok 5260 - Correct elem set by constructor of num array (2)
            ok 5261 - Correct elem set by constructor of num array (3)
            ok 5262 - Correct elem set by constructor of num array (4)
            ok 5263 - num array .flat returns a Seq
            ok 5264 - num array .eager returns identity
            ok 5265 - # SKIP borkedness with num and iteration
            ok 5266 - Mutating for loop on num array works (1)
            ok 5267 - Mutating for loop on num array works (2)
            ok 5268 - Mutating for loop on num array works (3)
            ok 5269 - Mutating for loop on num array works (4)
            ok 5270 - Mutating map on num array works (1)
            ok 5271 - Mutating map on num array works (2)
            ok 5272 - Mutating map on num array works (3)
            ok 5273 - Mutating map on num array works (4)
            ok 5274 - Can grep a num array
            ok 5275 - num array.grep(Num)
            ok 5276 - num array.grep(Num, :k)
            ok 5277 - num array.grep(Num, :kv)
            ok 5278 - num array.grep(Num, :p)
            ok 5279 - num array.grep(Num, :v)
            ok 5280 - num array.grep(Num)
            ok 5281 - num array.grep(Num, :k)
            ok 5282 - num array.grep(Num, :kv)
            ok 5283 - num array.grep(Num, :p)
            ok 5284 - num array.grep(Num, :v)
            ok 5285 - Can use reduce meta-op on a num array
            ok 5286 - # SKIP cannot approx test Parcels
            ok 5287 - # SKIP cannot approx test Parcels
            ok 5288 - # SKIP nativeint.list loops on itself
            ok 5289 - # SKIP nativeint.list loops on itself
            ok 5290 - # SKIP nativeint.list loops on itself
            ok 5291 - # SKIP nativeint.list loops on itself
            ok 5292 - # SKIP nativeint.list loops on itself
            ok 5293 - # SKIP nativeint.list loops on itself
            ok 5294 - num array.unique
            ok 5295 - num array.repeated
            ok 5296 - num array.squish
                1..4
                ok 1 - code dies
                ok 2 - right exception type (X::Cannot::Empty)
                ok 3 - .action matches pop
                ok 4 - .what matches array[num]
            ok 5297 - Trying to pop an empty num array dies
                1..4
                ok 1 - code dies
                ok 2 - right exception type (X::Cannot::Empty)
                ok 3 - .action matches shift
                ok 4 - .what matches array[num]
            ok 5298 - Trying to shift an empty num array dies
                1..3
                ok 1 - code dies
                ok 2 - right exception type (Exception)
                ok 3 - .message matches Cannot bind to a native num array
            ok 5299 - Cannot push non-int/Int to num array
                1..3
                ok 1 - code dies
                ok 2 - right exception type (Exception)
                ok 3 - .message matches Cannot delete from a native num array
            ok 5300 - Cannot push non-int/Int to num array
                1..4
                ok 1 - code dies
                ok 2 - right exception type (X::Cannot::Lazy)
                ok 3 - .action matches initialize
                ok 4 - .what matches array[num]
            ok 5301 - Trying to initialize a num array with a right infinite list
                1..4
                ok 1 - code dies
                ok 2 - right exception type (X::Cannot::Lazy)
                ok 3 - .what matches array[num]
                ok 4 - .action matches initialize
            ok 5302 - Trying to initialize a num array with a left infinite list
            ok 5303 - push to num array works (1)
            ok 5304 - push to num array works (2)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 5305 - Cannot push non-num/Num to num array
            ok 5306 - push multiple to num array works (1)
            ok 5307 - push multiple to num array works (2)
            ok 5308 - push multiple to num array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 5309 - Cannot push non-num/Num to num array (multiple push)
            ok 5310 - append to num array works (1)
            ok 5311 - append to num array works (2)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 5312 - Cannot append non-num/Num to num array
            ok 5313 - append multiple to num array works (1)
            ok 5314 - append multiple to num array works (2)
            ok 5315 - append multiple to num array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 5316 - Cannot push non-num/Num to num array (multiple push)
            ok 5317 - pop from num array works (1)
            ok 5318 - pop from num array works (2)
            ok 5319 - unshift to num array works (1)
            ok 5320 - unshift to num array works (2)
            ok 5321 - unshift to num array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 5322 - Cannot unshift non-num/Num to num array
            ok 5323 - unshift multiple to num array works (1)
            ok 5324 - unshift multiple to num array works (2)
            ok 5325 - unshift multiple to num array works (3)
            ok 5326 - unshift multiple to num array works (4)
            ok 5327 - unshift multiple to num array works (5)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 5328 - Cannot unshift non-num/Num to num array (multiple unshift)
            ok 5329 - prepend to num array works (1)
            ok 5330 - prepend to num array works (2)
            ok 5331 - prepend to num array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 5332 - Cannot prepend non-num/Num to num array
            ok 5333 - prepend multiple to num array works (1)
            ok 5334 - prepend multiple to num array works (2)
            ok 5335 - prepend multiple to num array works (3)
            ok 5336 - prepend multiple to num array works (4)
            ok 5337 - prepend multiple to num array works (5)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 5338 - Cannot prepend non-num/Num to num array (multiple unshift)
            ok 5339 - shift from num array works (1)
            ok 5340 - shift from num array works (2)
            ok 5341 - Number of elems after splice num array
            ok 5342 - Splice on num array did the right thing (1)
            ok 5343 - Splice on num array did the right thing (2)
            ok 5344 - Splice on num array did the right thing (3)
            ok 5345 - Splice on num array did the right thing (4)
            ok 5346 - Splice on num array did the right thing (5)
            ok 5347 - Number of returned spliced values from num array
            ok 5348 - Correct value in splice from num array (1)
            ok 5349 - Correct value in splice from num array (2)
            ok 5350 - .Str space-separates on num array
            ok 5351 - .gist space-separates on num array
            ok 5352 - .raku includes type and num values on num array
            ok 5353 - does slice return same type
            ok 5354 - does slice handle containerized range
            ok 5355 - Flattening num array in call works
            ok 5356 - does join a num array
            ok 5357 - does emptying a num array really empty
            ok 5358 - does join handle holes in a num array
            ok 5359 - List-assign num array to untyped works (1)
            ok 5360 - List-assign num array to untyped works (2)
            ok 5361 - List-assign num array to untyped works (3)
            ok 5362 - List-assign num array surrounded by lits (1)
            ok 5363 - List-assign num array surrounded by lits (2)
            ok 5364 - List-assign num array surrounded by lits (3)
            ok 5365 - List-assign num array surrounded by lits (4)
            ok 5366 - List-assign num array surrounded by lits (5)
            ok 5367 - List-assign array of Num to num array (1)
            ok 5368 - List-assign array of Num to num array (2)
            ok 5369 - List-assign array of Num to num array (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 5370 - List-assigning incompatible untyped array to num array dies
            ok 5371 - Smartmatching same num arrays works
            ok 5372 - Smartmatching different num arrays works
            ok 5373 - Can we sort num array
            ok 5374 - Can we sort 2-element sorted num array
            ok 5375 - Can we sort 2-element unsorted num array
            ok 5376 - Can we sort 1-element num array
            ok 5377 - Can we sort 0-element num array
            # Testing num32 array
            ok 5378 - num32 array type is Positional
            ok 5379 - num32 array type is Positional[num32]
            ok 5380 - num32 array type .of is num32
            ok 5381 - num32 array is Positional
            ok 5382 - num32 array is Positional[num32]
            ok 5383 - num32 array .of is num32
            ok 5384 - num32 array is Positional
            ok 5385 - num32 array is Positional[num32]
            ok 5386 - num32 array .of is num32
            ok 5387 - .new from num32 array is Positional
            ok 5388 - .new from num32 array Positional[num32]
            ok 5389 - .new from num32 array .of is num32
            ok 5390 - New num32 array has no elems
            ok 5391 - New num32 array has end of -1
            ok 5392 - New num32 array Int-ifies to 0
            ok 5393 - New num32 array numifies to 0
            ok 5394 - New num32 array is falsey
            ok 5395 - Empty num32 array is not lazy
            ok 5396 - Accessing non-existing on num32 array gives 0
            ok 5397 - Elems do not grow just from an access on num32 array
            ok 5398 - Can store num in an num32 array
            ok 5399 - Can get value from num32 array
            ok 5400 - The elems grew as expected on num32 array
            ok 5401 - num32 array becomes truthy when it has an element
            ok 5402 - Can get slice-assigned value from num32 array (1)
            ok 5403 - Can get slice-assigned value from num32 array (2)
            ok 5404 - The elems grew as expected on num32 array
            ok 5405 - The end value matches grown elems on num32 array
            ok 5406 - Int-ifies to grown number of elems on num32 array
            ok 5407 - Numifies to grown number of elems on num32 array
            ok 5408 - num32 array with values is not lazy
            ok 5409 - are special IEEE values supported on num32 array
            ok 5410 - Can assign non-contiguously to num32 array
            ok 5411 - Elems non-contiguous assign 0 on num32 array
            ok 5412 - Non-contiguous assignment works on num32 array
            ok 5413 - Can also get last element on num32 array
            ok 5414 - Can clear num32 array by assigning empty list
            ok 5415 - Cleared num32 array has no elems
            ok 5416 - Cleared num32 array has end of -1
            ok 5417 - Cleared num32 array Int-ifies to 0
            ok 5418 - Cleared num32 array numifies to 0
            ok 5419 - Cleared num32 array is falsey
            ok 5420 - Got correct elems from range assign on num32 array
            ok 5421 - Correct elem from range assign on num32 array (1)
            ok 5422 - Correct elem from range assign on num32 array (2)
            ok 5423 - :exists works on num32 array (1)
            ok 5424 - :exists works on num32 array (2)
            ok 5425 - :exists works on num32 array (3)
            ok 5426 - Correct number of elems set in constructor of num32 array
            ok 5427 - Correct elem set by constructor of num32 array
            ok 5428 - Correct number of elems set in constructor of num32 array
            ok 5429 - Correct elem set by constructor of num32 array (1)
            ok 5430 - Correct elem set by constructor of num32 array (2)
            ok 5431 - Correct elem set by constructor of num32 array (3)
            ok 5432 - Correct elem set by constructor of num32 array (4)
            ok 5433 - num32 array .flat returns a Seq
            ok 5434 - num32 array .eager returns identity
            ok 5435 - # SKIP borkedness with num and iteration
            ok 5436 - Mutating for loop on num32 array works (1)
            ok 5437 - Mutating for loop on num32 array works (2)
            ok 5438 - Mutating for loop on num32 array works (3)
            ok 5439 - Mutating for loop on num32 array works (4)
            ok 5440 - Mutating map on num32 array works (1)
            ok 5441 - Mutating map on num32 array works (2)
            ok 5442 - Mutating map on num32 array works (3)
            ok 5443 - Mutating map on num32 array works (4)
            ok 5444 - Can grep a num32 array
            ok 5445 - skipping .grep/.first test for num32 as they will fail
            ok 5446 - skipping .grep/.first test for num32 as they will fail
            ok 5447 - skipping .grep/.first test for num32 as they will fail
            ok 5448 - skipping .grep/.first test for num32 as they will fail
            ok 5449 - skipping .grep/.first test for num32 as they will fail
            ok 5450 - skipping .grep/.first test for num32 as they will fail
            ok 5451 - skipping .grep/.first test for num32 as they will fail
            ok 5452 - skipping .grep/.first test for num32 as they will fail
            ok 5453 - skipping .grep/.first test for num32 as they will fail
            ok 5454 - skipping .grep/.first test for num32 as they will fail
            ok 5455 - Can use reduce meta-op on a num32 array
            ok 5456 - # SKIP cannot approx test Parcels
            ok 5457 - # SKIP cannot approx test Parcels
            ok 5458 - # SKIP nativeint.list loops on itself
            ok 5459 - # SKIP nativeint.list loops on itself
            ok 5460 - # SKIP nativeint.list loops on itself
            ok 5461 - # SKIP nativeint.list loops on itself
            ok 5462 - # SKIP nativeint.list loops on itself
            ok 5463 - # SKIP nativeint.list loops on itself
            ok 5464 - num32 array.unique
            ok 5465 - num32 array.repeated
            ok 5466 - num32 array.squish
                1..4
                ok 1 - code dies
                ok 2 - right exception type (X::Cannot::Empty)
                ok 3 - .what matches array[num32]
                ok 4 - .action matches pop
            ok 5467 - Trying to pop an empty num32 array dies
                1..4
                ok 1 - code dies
                ok 2 - right exception type (X::Cannot::Empty)
                ok 3 - .what matches array[num32]
                ok 4 - .action matches shift
            ok 5468 - Trying to shift an empty num32 array dies
                1..3
                ok 1 - code dies
                ok 2 - right exception type (Exception)
                ok 3 - .message matches Cannot bind to a native num array
            ok 5469 - Cannot push non-int/Int to num32 array
                1..3
                ok 1 - code dies
                ok 2 - right exception type (Exception)
                ok 3 - .message matches Cannot delete from a native num array
            ok 5470 - Cannot push non-int/Int to num32 array
                1..4
                ok 1 - code dies
                ok 2 - right exception type (X::Cannot::Lazy)
                ok 3 - .action matches initialize
                ok 4 - .what matches array[num32]
            ok 5471 - Trying to initialize a num32 array with a right infinite list
                1..4
                ok 1 - code dies
                ok 2 - right exception type (X::Cannot::Lazy)
                ok 3 - .what matches array[num32]
                ok 4 - .action matches initialize
            ok 5472 - Trying to initialize a num32 array with a left infinite list
            ok 5473 - push to num32 array works (1)
            ok 5474 - push to num32 array works (2)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 5475 - Cannot push non-num/Num to num32 array
            ok 5476 - push multiple to num32 array works (1)
            ok 5477 - push multiple to num32 array works (2)
            ok 5478 - push multiple to num32 array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 5479 - Cannot push non-num/Num to num32 array (multiple push)
            ok 5480 - append to num32 array works (1)
            ok 5481 - append to num32 array works (2)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 5482 - Cannot append non-num/Num to num32 array
            ok 5483 - append multiple to num32 array works (1)
            ok 5484 - append multiple to num32 array works (2)
            ok 5485 - append multiple to num32 array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 5486 - Cannot push non-num/Num to num32 array (multiple push)
            ok 5487 - pop from num32 array works (1)
            ok 5488 - pop from num32 array works (2)
            ok 5489 - unshift to num32 array works (1)
            ok 5490 - unshift to num32 array works (2)
            ok 5491 - unshift to num32 array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 5492 - Cannot unshift non-num/Num to num32 array
            ok 5493 - unshift multiple to num32 array works (1)
            ok 5494 - unshift multiple to num32 array works (2)
            ok 5495 - unshift multiple to num32 array works (3)
            ok 5496 - unshift multiple to num32 array works (4)
            ok 5497 - unshift multiple to num32 array works (5)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 5498 - Cannot unshift non-num/Num to num32 array (multiple unshift)
            ok 5499 - prepend to num32 array works (1)
            ok 5500 - prepend to num32 array works (2)
            ok 5501 - prepend to num32 array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 5502 - Cannot prepend non-num/Num to num32 array
            ok 5503 - prepend multiple to num32 array works (1)
            ok 5504 - prepend multiple to num32 array works (2)
            ok 5505 - prepend multiple to num32 array works (3)
            ok 5506 - prepend multiple to num32 array works (4)
            ok 5507 - prepend multiple to num32 array works (5)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 5508 - Cannot prepend non-num/Num to num32 array (multiple unshift)
            ok 5509 - shift from num32 array works (1)
            ok 5510 - shift from num32 array works (2)
            ok 5511 - Number of elems after splice num32 array
            ok 5512 - Splice on num32 array did the right thing (1)
            ok 5513 - Splice on num32 array did the right thing (2)
            ok 5514 - Splice on num32 array did the right thing (3)
            ok 5515 - Splice on num32 array did the right thing (4)
            ok 5516 - Splice on num32 array did the right thing (5)
            ok 5517 - Number of returned spliced values from num32 array
            ok 5518 - Correct value in splice from num32 array (1)
            ok 5519 - Correct value in splice from num32 array (2)
            ok 5520 - .Str space-separates on num32 array
            ok 5521 - .gist space-separates on num32 array
            ok 5522 - .raku includes type and num values on num32 array
            ok 5523 - does slice return same type
            ok 5524 - does slice handle containerized range
            ok 5525 - Flattening num32 array in call works
            ok 5526 - does join a num32 array
            ok 5527 - does emptying a num32 array really empty
            ok 5528 - does join handle holes in a num32 array
            ok 5529 - List-assign num32 array to untyped works (1)
            ok 5530 - List-assign num32 array to untyped works (2)
            ok 5531 - List-assign num32 array to untyped works (3)
            ok 5532 - List-assign num32 array surrounded by lits (1)
            ok 5533 - List-assign num32 array surrounded by lits (2)
            ok 5534 - List-assign num32 array surrounded by lits (3)
            ok 5535 - List-assign num32 array surrounded by lits (4)
            ok 5536 - List-assign num32 array surrounded by lits (5)
            ok 5537 - List-assign array of Num to num32 array (1)
            ok 5538 - List-assign array of Num to num32 array (2)
            ok 5539 - List-assign array of Num to num32 array (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 5540 - List-assigning incompatible untyped array to num32 array dies
            ok 5541 - Smartmatching same num32 arrays works
            ok 5542 - Smartmatching different num32 arrays works
            ok 5543 - Can we sort num32 array
            ok 5544 - Can we sort 2-element sorted num32 array
            ok 5545 - Can we sort 2-element unsorted num32 array
            ok 5546 - Can we sort 1-element num32 array
            ok 5547 - Can we sort 0-element num32 array
            # Testing num64 array
            ok 5548 - num64 array type is Positional
            ok 5549 - num64 array type is Positional[num64]
            ok 5550 - num64 array type .of is num64
            ok 5551 - num64 array is Positional
            ok 5552 - num64 array is Positional[num64]
            ok 5553 - num64 array .of is num64
            ok 5554 - num64 array is Positional
            ok 5555 - num64 array is Positional[num64]
            ok 5556 - num64 array .of is num64
            ok 5557 - .new from num64 array is Positional
            ok 5558 - .new from num64 array Positional[num64]
            ok 5559 - .new from num64 array .of is num64
            ok 5560 - New num64 array has no elems
            ok 5561 - New num64 array has end of -1
            ok 5562 - New num64 array Int-ifies to 0
            ok 5563 - New num64 array numifies to 0
            ok 5564 - New num64 array is falsey
            ok 5565 - Empty num64 array is not lazy
            ok 5566 - Accessing non-existing on num64 array gives 0
            ok 5567 - Elems do not grow just from an access on num64 array
            ok 5568 - Can store num in an num64 array
            ok 5569 - Can get value from num64 array
            ok 5570 - The elems grew as expected on num64 array
            ok 5571 - num64 array becomes truthy when it has an element
            ok 5572 - Can get slice-assigned value from num64 array (1)
            ok 5573 - Can get slice-assigned value from num64 array (2)
            ok 5574 - The elems grew as expected on num64 array
            ok 5575 - The end value matches grown elems on num64 array
            ok 5576 - Int-ifies to grown number of elems on num64 array
            ok 5577 - Numifies to grown number of elems on num64 array
            ok 5578 - num64 array with values is not lazy
            ok 5579 - are special IEEE values supported on num64 array
            ok 5580 - Can assign non-contiguously to num64 array
            ok 5581 - Elems non-contiguous assign 0 on num64 array
            ok 5582 - Non-contiguous assignment works on num64 array
            ok 5583 - Can also get last element on num64 array
            ok 5584 - Can clear num64 array by assigning empty list
            ok 5585 - Cleared num64 array has no elems
            ok 5586 - Cleared num64 array has end of -1
            ok 5587 - Cleared num64 array Int-ifies to 0
            ok 5588 - Cleared num64 array numifies to 0
            ok 5589 - Cleared num64 array is falsey
            ok 5590 - Got correct elems from range assign on num64 array
            ok 5591 - Correct elem from range assign on num64 array (1)
            ok 5592 - Correct elem from range assign on num64 array (2)
            ok 5593 - :exists works on num64 array (1)
            ok 5594 - :exists works on num64 array (2)
            ok 5595 - :exists works on num64 array (3)
            ok 5596 - Correct number of elems set in constructor of num64 array
            ok 5597 - Correct elem set by constructor of num64 array
            ok 5598 - Correct number of elems set in constructor of num64 array
            ok 5599 - Correct elem set by constructor of num64 array (1)
            ok 5600 - Correct elem set by constructor of num64 array (2)
            ok 5601 - Correct elem set by constructor of num64 array (3)
            ok 5602 - Correct elem set by constructor of num64 array (4)
            ok 5603 - num64 array .flat returns a Seq
            ok 5604 - num64 array .eager returns identity
            ok 5605 - # SKIP borkedness with num and iteration
            ok 5606 - Mutating for loop on num64 array works (1)
            ok 5607 - Mutating for loop on num64 array works (2)
            ok 5608 - Mutating for loop on num64 array works (3)
            ok 5609 - Mutating for loop on num64 array works (4)
            ok 5610 - Mutating map on num64 array works (1)
            ok 5611 - Mutating map on num64 array works (2)
            ok 5612 - Mutating map on num64 array works (3)
            ok 5613 - Mutating map on num64 array works (4)
            ok 5614 - Can grep a num64 array
            ok 5615 - num64 array.grep(Num)
            ok 5616 - num64 array.grep(Num, :k)
            ok 5617 - num64 array.grep(Num, :kv)
            ok 5618 - num64 array.grep(Num, :p)
            ok 5619 - num64 array.grep(Num, :v)
            ok 5620 - num64 array.grep(Num)
            ok 5621 - num64 array.grep(Num, :k)
            ok 5622 - num64 array.grep(Num, :kv)
            ok 5623 - num64 array.grep(Num, :p)
            ok 5624 - num64 array.grep(Num, :v)
            ok 5625 - Can use reduce meta-op on a num64 array
            ok 5626 - # SKIP cannot approx test Parcels
            ok 5627 - # SKIP cannot approx test Parcels
            ok 5628 - # SKIP nativeint.list loops on itself
            ok 5629 - # SKIP nativeint.list loops on itself
            ok 5630 - # SKIP nativeint.list loops on itself
            ok 5631 - # SKIP nativeint.list loops on itself
            ok 5632 - # SKIP nativeint.list loops on itself
            ok 5633 - # SKIP nativeint.list loops on itself
            ok 5634 - num64 array.unique
            ok 5635 - num64 array.repeated
            ok 5636 - num64 array.squish
                1..4
                ok 1 - code dies
                ok 2 - right exception type (X::Cannot::Empty)
                ok 3 - .action matches pop
                ok 4 - .what matches array[num64]
            ok 5637 - Trying to pop an empty num64 array dies
                1..4
                ok 1 - code dies
                ok 2 - right exception type (X::Cannot::Empty)
                ok 3 - .action matches shift
                ok 4 - .what matches array[num64]
            ok 5638 - Trying to shift an empty num64 array dies
                1..3
                ok 1 - code dies
                ok 2 - right exception type (Exception)
                ok 3 - .message matches Cannot bind to a native num array
            ok 5639 - Cannot push non-int/Int to num64 array
                1..3
                ok 1 - code dies
                ok 2 - right exception type (Exception)
                ok 3 - .message matches Cannot delete from a native num array
            ok 5640 - Cannot push non-int/Int to num64 array
                1..4
                ok 1 - code dies
                ok 2 - right exception type (X::Cannot::Lazy)
                ok 3 - .what matches array[num64]
                ok 4 - .action matches initialize
            ok 5641 - Trying to initialize a num64 array with a right infinite list
                1..4
                ok 1 - code dies
                ok 2 - right exception type (X::Cannot::Lazy)
                ok 3 - .what matches array[num64]
                ok 4 - .action matches initialize
            ok 5642 - Trying to initialize a num64 array with a left infinite list
            ok 5643 - push to num64 array works (1)
            ok 5644 - push to num64 array works (2)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 5645 - Cannot push non-num/Num to num64 array
            ok 5646 - push multiple to num64 array works (1)
            ok 5647 - push multiple to num64 array works (2)
            ok 5648 - push multiple to num64 array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 5649 - Cannot push non-num/Num to num64 array (multiple push)
            ok 5650 - append to num64 array works (1)
            ok 5651 - append to num64 array works (2)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 5652 - Cannot append non-num/Num to num64 array
            ok 5653 - append multiple to num64 array works (1)
            ok 5654 - append multiple to num64 array works (2)
            ok 5655 - append multiple to num64 array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 5656 - Cannot push non-num/Num to num64 array (multiple push)
            ok 5657 - pop from num64 array works (1)
            ok 5658 - pop from num64 array works (2)
            ok 5659 - unshift to num64 array works (1)
            ok 5660 - unshift to num64 array works (2)
            ok 5661 - unshift to num64 array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 5662 - Cannot unshift non-num/Num to num64 array
            ok 5663 - unshift multiple to num64 array works (1)
            ok 5664 - unshift multiple to num64 array works (2)
            ok 5665 - unshift multiple to num64 array works (3)
            ok 5666 - unshift multiple to num64 array works (4)
            ok 5667 - unshift multiple to num64 array works (5)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 5668 - Cannot unshift non-num/Num to num64 array (multiple unshift)
            ok 5669 - prepend to num64 array works (1)
            ok 5670 - prepend to num64 array works (2)
            ok 5671 - prepend to num64 array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 5672 - Cannot prepend non-num/Num to num64 array
            ok 5673 - prepend multiple to num64 array works (1)
            ok 5674 - prepend multiple to num64 array works (2)
            ok 5675 - prepend multiple to num64 array works (3)
            ok 5676 - prepend multiple to num64 array works (4)
            ok 5677 - prepend multiple to num64 array works (5)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 5678 - Cannot prepend non-num/Num to num64 array (multiple unshift)
            ok 5679 - shift from num64 array works (1)
            ok 5680 - shift from num64 array works (2)
            ok 5681 - Number of elems after splice num64 array
            ok 5682 - Splice on num64 array did the right thing (1)
            ok 5683 - Splice on num64 array did the right thing (2)
            ok 5684 - Splice on num64 array did the right thing (3)
            ok 5685 - Splice on num64 array did the right thing (4)
            ok 5686 - Splice on num64 array did the right thing (5)
            ok 5687 - Number of returned spliced values from num64 array
            ok 5688 - Correct value in splice from num64 array (1)
            ok 5689 - Correct value in splice from num64 array (2)
            ok 5690 - .Str space-separates on num64 array
            ok 5691 - .gist space-separates on num64 array
            ok 5692 - .raku includes type and num values on num64 array
            ok 5693 - does slice return same type
            ok 5694 - does slice handle containerized range
            ok 5695 - Flattening num64 array in call works
            ok 5696 - does join a num64 array
            ok 5697 - does emptying a num64 array really empty
            ok 5698 - does join handle holes in a num64 array
            ok 5699 - List-assign num64 array to untyped works (1)
            ok 5700 - List-assign num64 array to untyped works (2)
            ok 5701 - List-assign num64 array to untyped works (3)
            ok 5702 - List-assign num64 array surrounded by lits (1)
            ok 5703 - List-assign num64 array surrounded by lits (2)
            ok 5704 - List-assign num64 array surrounded by lits (3)
            ok 5705 - List-assign num64 array surrounded by lits (4)
            ok 5706 - List-assign num64 array surrounded by lits (5)
            ok 5707 - List-assign array of Num to num64 array (1)
            ok 5708 - List-assign array of Num to num64 array (2)
            ok 5709 - List-assign array of Num to num64 array (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 5710 - List-assigning incompatible untyped array to num64 array dies
            ok 5711 - Smartmatching same num64 arrays works
            ok 5712 - Smartmatching different num64 arrays works
            ok 5713 - Can we sort num64 array
            ok 5714 - Can we sort 2-element sorted num64 array
            ok 5715 - Can we sort 2-element unsorted num64 array
            ok 5716 - Can we sort 1-element num64 array
            ok 5717 - Can we sort 0-element num64 array
            ok 5718 - did we survive the hole
# FUDGED!
            1..1110
            # Testing int array
            ok 5719 - int array is Positional
            not ok 5720 - int array is Positional[int] # TODO apparently it is not a typed Positional
            # Failed test 'int array is Positional[int]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 20
            ok 5721 - int array .of is int
            ok 5722 - int array is Positional
            not ok 5723 - int array is Positional[int] # TODO apparently it is not a typed Positional
            # Failed test 'int array is Positional[int]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 26
            ok 5724 - int array .of is int
            ok 5725 - .new from int array is Positional
            not ok 5726 - .new from int array Positional[int] # TODO apparently it is not a typed Positional
            # Failed test '.new from int array Positional[int]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 30
            ok 5727 - .new from int array .of is int
            ok 5728 - New int array has 5 elems
            ok 5729 - New int array has end of -1
            ok 5730 - New int array Int-ifies to 5
            ok 5731 - New int array numifies to 5
            ok 5732 - Empty int array is not lazy
            ok 5733 - Accessing non-existing on int array dies
            ok 5734 - Elems do not grow just from an access on int array
            ok 5735 - Can store integer in an int array with Int index
            ok 5736 - Can get value from int array with Int index
            ok 5737 - can store integer in an $t array with int index
            ok 5738 - Can get value from int array with int index
            ok 5739 - Can slice-assign to an int array
            ok 5740 - Can get slice-assigned value from int array (1)
            ok 5741 - Can get slice-assigned value from int array (2)
            ok 5742 - :exists works on int array with int index
            ok 5743 - :exists works on int array with Int index
            ok 5744 - :exists works on int array when out of range
            ok 5745 - :!exists works on int array with int index
            ok 5746 - :!exists works on int array with Int index
            ok 5747 - :!exists works on int array when out of range
            ok 5748 - :delete dies on int array with int index
            ok 5749 - :delete dies on int array with Int index
            ok 5750 - :!delete works on int array with int index
            ok 5751 - :!delete works on int array with Int index
            ok 5752 - Can call int array constructor with a single value
            ok 5753 - Correct number of elems set in constructor of int array
            ok 5754 - Correct element value set by constructor of int array
            ok 5755 - Can call int array constructor with values
            ok 5756 - Correct number of elems set in constructor of int array
            ok 5757 - Correct elem value set by constructor of int array (1)
            ok 5758 - Correct elem value set by constructor of int array (2)
            ok 5759 - Correct elem value set by constructor of int array (3)
            ok 5760 - Correct elem value set by constructor of int array (4)
            ok 5761 - Can also get last 2 elements on int array
            ok 5762 - int array .flat returns a Seq
            ok 5763 - int array .eager returns identity
            ok 5764 - Mutating for loop on int array works (1)
            ok 5765 - Mutating for loop on int array works (2)
            ok 5766 - Mutating for loop on int array works (3)
            ok 5767 - Mutating for loop on int array works (4)
            ok 5768 - Can map over int array
            ok 5769 - Mutating map on int array works (1)
            ok 5770 - Mutating map on int array works (2)
            ok 5771 - Mutating map on int array works (3)
            ok 5772 - Mutating map on int array works (4)
            ok 5773 - grep a int array
            ok 5774 - int array.grep(Int)
            ok 5775 - int array.grep(Int, :k)
            ok 5776 - int array.grep(Int, :kv)
            ok 5777 - int array.grep(Int, :p)
            ok 5778 - int array.grep(Int, :v)
            ok 5779 - int array.grep(Int)
            ok 5780 - int array.grep(Int, :k)
            ok 5781 - int array.grep(Int, :kv)
            ok 5782 - int array.grep(Int, :p)
            ok 5783 - int array.grep(Int, :v)
            ok 5784 - Can use reduce meta-op on a int array
            ok 5785 - .values from a int array
            ok 5786 - .pairup from a int array
            ok 5787 - .keys from a int array
            ok 5788 - .pairs from a int array
            ok 5789 - .antipairs from a int array
            ok 5790 - .kv from a int array
            ok 5791 - .pick from a int array
            ok 5792 - .roll from a int array
            ok 5793 - int array.unique
            ok 5794 - int array.repeated
            ok 5795 - int array.squish
            ok 5796 - Trying to pop a shaped int array dies
            ok 5797 - Trying to shift a shaped int array dies
            ok 5798 - Trying to push a shaped int array dies
            ok 5799 - Trying to unshift a shaped int array dies
            ok 5800 - Cannot bind to a int array
            ok 5801 - Cannot delete from a int array
            ok 5802 - Cannot append to a int array
            ok 5803 - Cannot prepend to a int array
            ok 5804 - Cannot splice to a int array
            ok 5805 - .Str space-separates on int array
            ok 5806 - .gist space-separates on int array
            ok 5807 - .raku includes type and int values on int array
            ok 5808 - # SKIP STORE not working correctly yet)
            ok 5809 - does slice handle containerized range
            ok 5810 - does join a int array
            ok 5811 - Can clear int array by assigning empty list
            ok 5812 - does emptying a int array reset
            ok 5813 - does re-initializing a int array work
            ok 5814 - List-assigning int array to untyped works (1)
            ok 5815 - List-assigning int array to untyped works (2)
            ok 5816 - List-assigning int array to untyped works (3)
            ok 5817 - List-assign int array surrounded by literals (1)
            ok 5818 - List-assign int array surrounded by literals (2)
            ok 5819 - List-assign int array surrounded by literals (3)
            ok 5820 - List-assign int array surrounded by literals (4)
            ok 5821 - List-assign int array surrounded by literals (5)
            ok 5822 - List-assign untyped array of Int to int array (1)
            ok 5823 - List-assign untyped array of Int to int array (2)
            ok 5824 - List-assign untyped array of Int to int array (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 5825 - List-assigning incompatible untyped array to int array dies
            ok 5826 - Smartmatching same int arrays works
            ok 5827 - Can we sort int array
            ok 5828 - Can we sort 2-element sorted int array
            ok 5829 - Can we sort 1-element sorted int array
            # Testing int8 array
            ok 5830 - int8 array is Positional
            not ok 5831 - int8 array is Positional[int8] # TODO apparently it is not a typed Positional
            # Failed test 'int8 array is Positional[int8]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 20
            ok 5832 - int8 array .of is int8
            ok 5833 - int8 array is Positional
            not ok 5834 - int8 array is Positional[int8] # TODO apparently it is not a typed Positional
            # Failed test 'int8 array is Positional[int8]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 26
            ok 5835 - int8 array .of is int8
            ok 5836 - .new from int8 array is Positional
            not ok 5837 - .new from int8 array Positional[int8] # TODO apparently it is not a typed Positional
            # Failed test '.new from int8 array Positional[int8]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 30
            ok 5838 - .new from int8 array .of is int8
            ok 5839 - New int8 array has 5 elems
            ok 5840 - New int8 array has end of -1
            ok 5841 - New int8 array Int-ifies to 5
            ok 5842 - New int8 array numifies to 5
            ok 5843 - Empty int8 array is not lazy
            ok 5844 - Accessing non-existing on int8 array dies
            ok 5845 - Elems do not grow just from an access on int8 array
            ok 5846 - Can store integer in an int8 array with Int index
            ok 5847 - Can get value from int8 array with Int index
            ok 5848 - can store integer in an $t array with int index
            ok 5849 - Can get value from int8 array with int index
            ok 5850 - Can slice-assign to an int8 array
            ok 5851 - Can get slice-assigned value from int8 array (1)
            ok 5852 - Can get slice-assigned value from int8 array (2)
            ok 5853 - :exists works on int8 array with int index
            ok 5854 - :exists works on int8 array with Int index
            ok 5855 - :exists works on int8 array when out of range
            ok 5856 - :!exists works on int8 array with int index
            ok 5857 - :!exists works on int8 array with Int index
            ok 5858 - :!exists works on int8 array when out of range
            ok 5859 - :delete dies on int8 array with int index
            ok 5860 - :delete dies on int8 array with Int index
            ok 5861 - :!delete works on int8 array with int index
            ok 5862 - :!delete works on int8 array with Int index
            ok 5863 - Can call int8 array constructor with a single value
            ok 5864 - Correct number of elems set in constructor of int8 array
            ok 5865 - Correct element value set by constructor of int8 array
            ok 5866 - Can call int8 array constructor with values
            ok 5867 - Correct number of elems set in constructor of int8 array
            ok 5868 - Correct elem value set by constructor of int8 array (1)
            ok 5869 - Correct elem value set by constructor of int8 array (2)
            ok 5870 - Correct elem value set by constructor of int8 array (3)
            ok 5871 - Correct elem value set by constructor of int8 array (4)
            ok 5872 - Can also get last 2 elements on int8 array
            ok 5873 - int8 array .flat returns a Seq
            ok 5874 - int8 array .eager returns identity
            ok 5875 - Mutating for loop on int8 array works (1)
            ok 5876 - Mutating for loop on int8 array works (2)
            ok 5877 - Mutating for loop on int8 array works (3)
            ok 5878 - Mutating for loop on int8 array works (4)
            ok 5879 - Can map over int8 array
            ok 5880 - Mutating map on int8 array works (1)
            ok 5881 - Mutating map on int8 array works (2)
            ok 5882 - Mutating map on int8 array works (3)
            ok 5883 - Mutating map on int8 array works (4)
            ok 5884 - grep a int8 array
            ok 5885 - int8 array.grep(Int)
            ok 5886 - int8 array.grep(Int, :k)
            ok 5887 - int8 array.grep(Int, :kv)
            ok 5888 - int8 array.grep(Int, :p)
            ok 5889 - int8 array.grep(Int, :v)
            ok 5890 - int8 array.grep(Int)
            ok 5891 - int8 array.grep(Int, :k)
            ok 5892 - int8 array.grep(Int, :kv)
            ok 5893 - int8 array.grep(Int, :p)
            ok 5894 - int8 array.grep(Int, :v)
            ok 5895 - Can use reduce meta-op on a int8 array
            ok 5896 - .values from a int8 array
            ok 5897 - .pairup from a int8 array
            ok 5898 - .keys from a int8 array
            ok 5899 - .pairs from a int8 array
            ok 5900 - .antipairs from a int8 array
            ok 5901 - .kv from a int8 array
            ok 5902 - .pick from a int8 array
            ok 5903 - .roll from a int8 array
            ok 5904 - int8 array.unique
            ok 5905 - int8 array.repeated
            ok 5906 - int8 array.squish
            ok 5907 - Trying to pop a shaped int8 array dies
            ok 5908 - Trying to shift a shaped int8 array dies
            ok 5909 - Trying to push a shaped int8 array dies
            ok 5910 - Trying to unshift a shaped int8 array dies
            ok 5911 - Cannot bind to a int8 array
            ok 5912 - Cannot delete from a int8 array
            ok 5913 - Cannot append to a int8 array
            ok 5914 - Cannot prepend to a int8 array
            ok 5915 - Cannot splice to a int8 array
            ok 5916 - .Str space-separates on int8 array
            ok 5917 - .gist space-separates on int8 array
            ok 5918 - .raku includes type and int values on int8 array
            ok 5919 - # SKIP STORE not working correctly yet)
            ok 5920 - does slice handle containerized range
            ok 5921 - does join a int8 array
            ok 5922 - Can clear int8 array by assigning empty list
            ok 5923 - does emptying a int8 array reset
            ok 5924 - does re-initializing a int8 array work
            ok 5925 - List-assigning int8 array to untyped works (1)
            ok 5926 - List-assigning int8 array to untyped works (2)
            ok 5927 - List-assigning int8 array to untyped works (3)
            ok 5928 - List-assign int8 array surrounded by literals (1)
            ok 5929 - List-assign int8 array surrounded by literals (2)
            ok 5930 - List-assign int8 array surrounded by literals (3)
            ok 5931 - List-assign int8 array surrounded by literals (4)
            ok 5932 - List-assign int8 array surrounded by literals (5)
            ok 5933 - List-assign untyped array of Int to int8 array (1)
            ok 5934 - List-assign untyped array of Int to int8 array (2)
            ok 5935 - List-assign untyped array of Int to int8 array (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 5936 - List-assigning incompatible untyped array to int8 array dies
            ok 5937 - Smartmatching same int8 arrays works
            ok 5938 - Can we sort int8 array
            ok 5939 - Can we sort 2-element sorted int8 array
            ok 5940 - Can we sort 1-element sorted int8 array
            # Testing int16 array
            ok 5941 - int16 array is Positional
            not ok 5942 - int16 array is Positional[int16] # TODO apparently it is not a typed Positional
            # Failed test 'int16 array is Positional[int16]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 20
            ok 5943 - int16 array .of is int16
            ok 5944 - int16 array is Positional
            not ok 5945 - int16 array is Positional[int16] # TODO apparently it is not a typed Positional
            # Failed test 'int16 array is Positional[int16]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 26
            ok 5946 - int16 array .of is int16
            ok 5947 - .new from int16 array is Positional
            not ok 5948 - .new from int16 array Positional[int16] # TODO apparently it is not a typed Positional
            # Failed test '.new from int16 array Positional[int16]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 30
            ok 5949 - .new from int16 array .of is int16
            ok 5950 - New int16 array has 5 elems
            ok 5951 - New int16 array has end of -1
            ok 5952 - New int16 array Int-ifies to 5
            ok 5953 - New int16 array numifies to 5
            ok 5954 - Empty int16 array is not lazy
            ok 5955 - Accessing non-existing on int16 array dies
            ok 5956 - Elems do not grow just from an access on int16 array
            ok 5957 - Can store integer in an int16 array with Int index
            ok 5958 - Can get value from int16 array with Int index
            ok 5959 - can store integer in an $t array with int index
            ok 5960 - Can get value from int16 array with int index
            ok 5961 - Can slice-assign to an int16 array
            ok 5962 - Can get slice-assigned value from int16 array (1)
            ok 5963 - Can get slice-assigned value from int16 array (2)
            ok 5964 - :exists works on int16 array with int index
            ok 5965 - :exists works on int16 array with Int index
            ok 5966 - :exists works on int16 array when out of range
            ok 5967 - :!exists works on int16 array with int index
            ok 5968 - :!exists works on int16 array with Int index
            ok 5969 - :!exists works on int16 array when out of range
            ok 5970 - :delete dies on int16 array with int index
            ok 5971 - :delete dies on int16 array with Int index
            ok 5972 - :!delete works on int16 array with int index
            ok 5973 - :!delete works on int16 array with Int index
            ok 5974 - Can call int16 array constructor with a single value
            ok 5975 - Correct number of elems set in constructor of int16 array
            ok 5976 - Correct element value set by constructor of int16 array
            ok 5977 - Can call int16 array constructor with values
            ok 5978 - Correct number of elems set in constructor of int16 array
            ok 5979 - Correct elem value set by constructor of int16 array (1)
            ok 5980 - Correct elem value set by constructor of int16 array (2)
            ok 5981 - Correct elem value set by constructor of int16 array (3)
            ok 5982 - Correct elem value set by constructor of int16 array (4)
            ok 5983 - Can also get last 2 elements on int16 array
            ok 5984 - int16 array .flat returns a Seq
            ok 5985 - int16 array .eager returns identity
            ok 5986 - Mutating for loop on int16 array works (1)
            ok 5987 - Mutating for loop on int16 array works (2)
            ok 5988 - Mutating for loop on int16 array works (3)
            ok 5989 - Mutating for loop on int16 array works (4)
            ok 5990 - Can map over int16 array
            ok 5991 - Mutating map on int16 array works (1)
            ok 5992 - Mutating map on int16 array works (2)
            ok 5993 - Mutating map on int16 array works (3)
            ok 5994 - Mutating map on int16 array works (4)
            ok 5995 - grep a int16 array
            ok 5996 - int16 array.grep(Int)
            ok 5997 - int16 array.grep(Int, :k)
            ok 5998 - int16 array.grep(Int, :kv)
            ok 5999 - int16 array.grep(Int, :p)
            ok 6000 - int16 array.grep(Int, :v)
            ok 6001 - int16 array.grep(Int)
            ok 6002 - int16 array.grep(Int, :k)
            ok 6003 - int16 array.grep(Int, :kv)
            ok 6004 - int16 array.grep(Int, :p)
            ok 6005 - int16 array.grep(Int, :v)
            ok 6006 - Can use reduce meta-op on a int16 array
            ok 6007 - .values from a int16 array
            ok 6008 - .pairup from a int16 array
            ok 6009 - .keys from a int16 array
            ok 6010 - .pairs from a int16 array
            ok 6011 - .antipairs from a int16 array
            ok 6012 - .kv from a int16 array
            ok 6013 - .pick from a int16 array
            ok 6014 - .roll from a int16 array
            ok 6015 - int16 array.unique
            ok 6016 - int16 array.repeated
            ok 6017 - int16 array.squish
            ok 6018 - Trying to pop a shaped int16 array dies
            ok 6019 - Trying to shift a shaped int16 array dies
            ok 6020 - Trying to push a shaped int16 array dies
            ok 6021 - Trying to unshift a shaped int16 array dies
            ok 6022 - Cannot bind to a int16 array
            ok 6023 - Cannot delete from a int16 array
            ok 6024 - Cannot append to a int16 array
            ok 6025 - Cannot prepend to a int16 array
            ok 6026 - Cannot splice to a int16 array
            ok 6027 - .Str space-separates on int16 array
            ok 6028 - .gist space-separates on int16 array
            ok 6029 - .raku includes type and int values on int16 array
            ok 6030 - # SKIP STORE not working correctly yet)
            ok 6031 - does slice handle containerized range
            ok 6032 - does join a int16 array
            ok 6033 - Can clear int16 array by assigning empty list
            ok 6034 - does emptying a int16 array reset
            ok 6035 - does re-initializing a int16 array work
            ok 6036 - List-assigning int16 array to untyped works (1)
            ok 6037 - List-assigning int16 array to untyped works (2)
            ok 6038 - List-assigning int16 array to untyped works (3)
            ok 6039 - List-assign int16 array surrounded by literals (1)
            ok 6040 - List-assign int16 array surrounded by literals (2)
            ok 6041 - List-assign int16 array surrounded by literals (3)
            ok 6042 - List-assign int16 array surrounded by literals (4)
            ok 6043 - List-assign int16 array surrounded by literals (5)
            ok 6044 - List-assign untyped array of Int to int16 array (1)
            ok 6045 - List-assign untyped array of Int to int16 array (2)
            ok 6046 - List-assign untyped array of Int to int16 array (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 6047 - List-assigning incompatible untyped array to int16 array dies
            ok 6048 - Smartmatching same int16 arrays works
            ok 6049 - Can we sort int16 array
            ok 6050 - Can we sort 2-element sorted int16 array
            ok 6051 - Can we sort 1-element sorted int16 array
            # Testing int32 array
            ok 6052 - int32 array is Positional
            not ok 6053 - int32 array is Positional[int32] # TODO apparently it is not a typed Positional
            # Failed test 'int32 array is Positional[int32]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 20
            ok 6054 - int32 array .of is int32
            ok 6055 - int32 array is Positional
            not ok 6056 - int32 array is Positional[int32] # TODO apparently it is not a typed Positional
            # Failed test 'int32 array is Positional[int32]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 26
            ok 6057 - int32 array .of is int32
            ok 6058 - .new from int32 array is Positional
            not ok 6059 - .new from int32 array Positional[int32] # TODO apparently it is not a typed Positional
            # Failed test '.new from int32 array Positional[int32]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 30
            ok 6060 - .new from int32 array .of is int32
            ok 6061 - New int32 array has 5 elems
            ok 6062 - New int32 array has end of -1
            ok 6063 - New int32 array Int-ifies to 5
            ok 6064 - New int32 array numifies to 5
            ok 6065 - Empty int32 array is not lazy
            ok 6066 - Accessing non-existing on int32 array dies
            ok 6067 - Elems do not grow just from an access on int32 array
            ok 6068 - Can store integer in an int32 array with Int index
            ok 6069 - Can get value from int32 array with Int index
            ok 6070 - can store integer in an $t array with int index
            ok 6071 - Can get value from int32 array with int index
            ok 6072 - Can slice-assign to an int32 array
            ok 6073 - Can get slice-assigned value from int32 array (1)
            ok 6074 - Can get slice-assigned value from int32 array (2)
            ok 6075 - :exists works on int32 array with int index
            ok 6076 - :exists works on int32 array with Int index
            ok 6077 - :exists works on int32 array when out of range
            ok 6078 - :!exists works on int32 array with int index
            ok 6079 - :!exists works on int32 array with Int index
            ok 6080 - :!exists works on int32 array when out of range
            ok 6081 - :delete dies on int32 array with int index
            ok 6082 - :delete dies on int32 array with Int index
            ok 6083 - :!delete works on int32 array with int index
            ok 6084 - :!delete works on int32 array with Int index
            ok 6085 - Can call int32 array constructor with a single value
            ok 6086 - Correct number of elems set in constructor of int32 array
            ok 6087 - Correct element value set by constructor of int32 array
            ok 6088 - Can call int32 array constructor with values
            ok 6089 - Correct number of elems set in constructor of int32 array
            ok 6090 - Correct elem value set by constructor of int32 array (1)
            ok 6091 - Correct elem value set by constructor of int32 array (2)
            ok 6092 - Correct elem value set by constructor of int32 array (3)
            ok 6093 - Correct elem value set by constructor of int32 array (4)
            ok 6094 - Can also get last 2 elements on int32 array
            ok 6095 - int32 array .flat returns a Seq
            ok 6096 - int32 array .eager returns identity
            ok 6097 - Mutating for loop on int32 array works (1)
            ok 6098 - Mutating for loop on int32 array works (2)
            ok 6099 - Mutating for loop on int32 array works (3)
            ok 6100 - Mutating for loop on int32 array works (4)
            ok 6101 - Can map over int32 array
            ok 6102 - Mutating map on int32 array works (1)
            ok 6103 - Mutating map on int32 array works (2)
            ok 6104 - Mutating map on int32 array works (3)
            ok 6105 - Mutating map on int32 array works (4)
            ok 6106 - grep a int32 array
            ok 6107 - int32 array.grep(Int)
            ok 6108 - int32 array.grep(Int, :k)
            ok 6109 - int32 array.grep(Int, :kv)
            ok 6110 - int32 array.grep(Int, :p)
            ok 6111 - int32 array.grep(Int, :v)
            ok 6112 - int32 array.grep(Int)
            ok 6113 - int32 array.grep(Int, :k)
            ok 6114 - int32 array.grep(Int, :kv)
            ok 6115 - int32 array.grep(Int, :p)
            ok 6116 - int32 array.grep(Int, :v)
            ok 6117 - Can use reduce meta-op on a int32 array
            ok 6118 - .values from a int32 array
            ok 6119 - .pairup from a int32 array
            ok 6120 - .keys from a int32 array
            ok 6121 - .pairs from a int32 array
            ok 6122 - .antipairs from a int32 array
            ok 6123 - .kv from a int32 array
            ok 6124 - .pick from a int32 array
            ok 6125 - .roll from a int32 array
            ok 6126 - int32 array.unique
            ok 6127 - int32 array.repeated
            ok 6128 - int32 array.squish
            ok 6129 - Trying to pop a shaped int32 array dies
            ok 6130 - Trying to shift a shaped int32 array dies
            ok 6131 - Trying to push a shaped int32 array dies
            ok 6132 - Trying to unshift a shaped int32 array dies
            ok 6133 - Cannot bind to a int32 array
            ok 6134 - Cannot delete from a int32 array
            ok 6135 - Cannot append to a int32 array
            ok 6136 - Cannot prepend to a int32 array
            ok 6137 - Cannot splice to a int32 array
            ok 6138 - .Str space-separates on int32 array
            ok 6139 - .gist space-separates on int32 array
            ok 6140 - .raku includes type and int values on int32 array
            ok 6141 - # SKIP STORE not working correctly yet)
            ok 6142 - does slice handle containerized range
            ok 6143 - does join a int32 array
            ok 6144 - Can clear int32 array by assigning empty list
            ok 6145 - does emptying a int32 array reset
            ok 6146 - does re-initializing a int32 array work
            ok 6147 - List-assigning int32 array to untyped works (1)
            ok 6148 - List-assigning int32 array to untyped works (2)
            ok 6149 - List-assigning int32 array to untyped works (3)
            ok 6150 - List-assign int32 array surrounded by literals (1)
            ok 6151 - List-assign int32 array surrounded by literals (2)
            ok 6152 - List-assign int32 array surrounded by literals (3)
            ok 6153 - List-assign int32 array surrounded by literals (4)
            ok 6154 - List-assign int32 array surrounded by literals (5)
            ok 6155 - List-assign untyped array of Int to int32 array (1)
            ok 6156 - List-assign untyped array of Int to int32 array (2)
            ok 6157 - List-assign untyped array of Int to int32 array (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 6158 - List-assigning incompatible untyped array to int32 array dies
            ok 6159 - Smartmatching same int32 arrays works
            ok 6160 - Can we sort int32 array
            ok 6161 - Can we sort 2-element sorted int32 array
            ok 6162 - Can we sort 1-element sorted int32 array
            # Testing int64 array
            ok 6163 - int64 array is Positional
            not ok 6164 - int64 array is Positional[int64] # TODO apparently it is not a typed Positional
            # Failed test 'int64 array is Positional[int64]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 20
            ok 6165 - int64 array .of is int64
            ok 6166 - int64 array is Positional
            not ok 6167 - int64 array is Positional[int64] # TODO apparently it is not a typed Positional
            # Failed test 'int64 array is Positional[int64]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 26
            ok 6168 - int64 array .of is int64
            ok 6169 - .new from int64 array is Positional
            not ok 6170 - .new from int64 array Positional[int64] # TODO apparently it is not a typed Positional
            # Failed test '.new from int64 array Positional[int64]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 30
            ok 6171 - .new from int64 array .of is int64
            ok 6172 - New int64 array has 5 elems
            ok 6173 - New int64 array has end of -1
            ok 6174 - New int64 array Int-ifies to 5
            ok 6175 - New int64 array numifies to 5
            ok 6176 - Empty int64 array is not lazy
            ok 6177 - Accessing non-existing on int64 array dies
            ok 6178 - Elems do not grow just from an access on int64 array
            ok 6179 - Can store integer in an int64 array with Int index
            ok 6180 - Can get value from int64 array with Int index
            ok 6181 - can store integer in an $t array with int index
            ok 6182 - Can get value from int64 array with int index
            ok 6183 - Can slice-assign to an int64 array
            ok 6184 - Can get slice-assigned value from int64 array (1)
            ok 6185 - Can get slice-assigned value from int64 array (2)
            ok 6186 - :exists works on int64 array with int index
            ok 6187 - :exists works on int64 array with Int index
            ok 6188 - :exists works on int64 array when out of range
            ok 6189 - :!exists works on int64 array with int index
            ok 6190 - :!exists works on int64 array with Int index
            ok 6191 - :!exists works on int64 array when out of range
            ok 6192 - :delete dies on int64 array with int index
            ok 6193 - :delete dies on int64 array with Int index
            ok 6194 - :!delete works on int64 array with int index
            ok 6195 - :!delete works on int64 array with Int index
            ok 6196 - Can call int64 array constructor with a single value
            ok 6197 - Correct number of elems set in constructor of int64 array
            ok 6198 - Correct element value set by constructor of int64 array
            ok 6199 - Can call int64 array constructor with values
            ok 6200 - Correct number of elems set in constructor of int64 array
            ok 6201 - Correct elem value set by constructor of int64 array (1)
            ok 6202 - Correct elem value set by constructor of int64 array (2)
            ok 6203 - Correct elem value set by constructor of int64 array (3)
            ok 6204 - Correct elem value set by constructor of int64 array (4)
            ok 6205 - Can also get last 2 elements on int64 array
            ok 6206 - int64 array .flat returns a Seq
            ok 6207 - int64 array .eager returns identity
            ok 6208 - Mutating for loop on int64 array works (1)
            ok 6209 - Mutating for loop on int64 array works (2)
            ok 6210 - Mutating for loop on int64 array works (3)
            ok 6211 - Mutating for loop on int64 array works (4)
            ok 6212 - Can map over int64 array
            ok 6213 - Mutating map on int64 array works (1)
            ok 6214 - Mutating map on int64 array works (2)
            ok 6215 - Mutating map on int64 array works (3)
            ok 6216 - Mutating map on int64 array works (4)
            ok 6217 - grep a int64 array
            ok 6218 - int64 array.grep(Int)
            ok 6219 - int64 array.grep(Int, :k)
            ok 6220 - int64 array.grep(Int, :kv)
            ok 6221 - int64 array.grep(Int, :p)
            ok 6222 - int64 array.grep(Int, :v)
            ok 6223 - int64 array.grep(Int)
            ok 6224 - int64 array.grep(Int, :k)
            ok 6225 - int64 array.grep(Int, :kv)
            ok 6226 - int64 array.grep(Int, :p)
            ok 6227 - int64 array.grep(Int, :v)
            ok 6228 - Can use reduce meta-op on a int64 array
            ok 6229 - .values from a int64 array
            ok 6230 - .pairup from a int64 array
            ok 6231 - .keys from a int64 array
            ok 6232 - .pairs from a int64 array
            ok 6233 - .antipairs from a int64 array
            ok 6234 - .kv from a int64 array
            ok 6235 - .pick from a int64 array
            ok 6236 - .roll from a int64 array
            ok 6237 - int64 array.unique
            ok 6238 - int64 array.repeated
            ok 6239 - int64 array.squish
            ok 6240 - Trying to pop a shaped int64 array dies
            ok 6241 - Trying to shift a shaped int64 array dies
            ok 6242 - Trying to push a shaped int64 array dies
            ok 6243 - Trying to unshift a shaped int64 array dies
            ok 6244 - Cannot bind to a int64 array
            ok 6245 - Cannot delete from a int64 array
            ok 6246 - Cannot append to a int64 array
            ok 6247 - Cannot prepend to a int64 array
            ok 6248 - Cannot splice to a int64 array
            ok 6249 - .Str space-separates on int64 array
            ok 6250 - .gist space-separates on int64 array
            ok 6251 - .raku includes type and int values on int64 array
            ok 6252 - # SKIP STORE not working correctly yet)
            ok 6253 - does slice handle containerized range
            ok 6254 - does join a int64 array
            ok 6255 - Can clear int64 array by assigning empty list
            ok 6256 - does emptying a int64 array reset
            ok 6257 - does re-initializing a int64 array work
            ok 6258 - List-assigning int64 array to untyped works (1)
            ok 6259 - List-assigning int64 array to untyped works (2)
            ok 6260 - List-assigning int64 array to untyped works (3)
            ok 6261 - List-assign int64 array surrounded by literals (1)
            ok 6262 - List-assign int64 array surrounded by literals (2)
            ok 6263 - List-assign int64 array surrounded by literals (3)
            ok 6264 - List-assign int64 array surrounded by literals (4)
            ok 6265 - List-assign int64 array surrounded by literals (5)
            ok 6266 - List-assign untyped array of Int to int64 array (1)
            ok 6267 - List-assign untyped array of Int to int64 array (2)
            ok 6268 - List-assign untyped array of Int to int64 array (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 6269 - List-assigning incompatible untyped array to int64 array dies
            ok 6270 - Smartmatching same int64 arrays works
            ok 6271 - Can we sort int64 array
            ok 6272 - Can we sort 2-element sorted int64 array
            ok 6273 - Can we sort 1-element sorted int64 array
            # Testing uint array
            ok 6274 - uint array is Positional
            not ok 6275 - uint array is Positional[uint] # TODO apparently it is not a typed Positional
            # Failed test 'uint array is Positional[uint]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 20
            ok 6276 - uint array .of is uint
            ok 6277 - uint array is Positional
            not ok 6278 - uint array is Positional[uint] # TODO apparently it is not a typed Positional
            # Failed test 'uint array is Positional[uint]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 26
            ok 6279 - uint array .of is uint
            ok 6280 - .new from uint array is Positional
            not ok 6281 - .new from uint array Positional[uint] # TODO apparently it is not a typed Positional
            # Failed test '.new from uint array Positional[uint]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 30
            ok 6282 - .new from uint array .of is uint
            ok 6283 - New uint array has 5 elems
            ok 6284 - New uint array has end of -1
            ok 6285 - New uint array Int-ifies to 5
            ok 6286 - New uint array numifies to 5
            ok 6287 - Empty uint array is not lazy
            ok 6288 - Accessing non-existing on uint array dies
            ok 6289 - Elems do not grow just from an access on uint array
            ok 6290 - Can store integer in an uint array with Int index
            ok 6291 - Can get value from uint array with Int index
            ok 6292 - can store integer in an $t array with int index
            ok 6293 - Can get value from uint array with int index
            ok 6294 - Can slice-assign to an uint array
            ok 6295 - Can get slice-assigned value from uint array (1)
            ok 6296 - Can get slice-assigned value from uint array (2)
            ok 6297 - :exists works on uint array with int index
            ok 6298 - :exists works on uint array with Int index
            ok 6299 - :exists works on uint array when out of range
            ok 6300 - :!exists works on uint array with int index
            ok 6301 - :!exists works on uint array with Int index
            ok 6302 - :!exists works on uint array when out of range
            ok 6303 - :delete dies on uint array with int index
            ok 6304 - :delete dies on uint array with Int index
            ok 6305 - :!delete works on uint array with int index
            ok 6306 - :!delete works on uint array with Int index
            ok 6307 - Can call uint array constructor with a single value
            ok 6308 - Correct number of elems set in constructor of uint array
            ok 6309 - Correct element value set by constructor of uint array
            ok 6310 - Can call uint array constructor with values
            ok 6311 - Correct number of elems set in constructor of uint array
            ok 6312 - Correct elem value set by constructor of uint array (1)
            ok 6313 - Correct elem value set by constructor of uint array (2)
            ok 6314 - Correct elem value set by constructor of uint array (3)
            ok 6315 - Correct elem value set by constructor of uint array (4)
            ok 6316 - Can also get last 2 elements on uint array
            ok 6317 - uint array .flat returns a Seq
            ok 6318 - uint array .eager returns identity
            ok 6319 - Mutating for loop on uint array works (1)
            ok 6320 - Mutating for loop on uint array works (2)
            ok 6321 - Mutating for loop on uint array works (3)
            ok 6322 - Mutating for loop on uint array works (4)
            ok 6323 - Can map over uint array
            ok 6324 - Mutating map on uint array works (1)
            ok 6325 - Mutating map on uint array works (2)
            ok 6326 - Mutating map on uint array works (3)
            ok 6327 - Mutating map on uint array works (4)
            ok 6328 - grep a uint array
            ok 6329 - uint array.grep(Int)
            ok 6330 - uint array.grep(Int, :k)
            ok 6331 - uint array.grep(Int, :kv)
            ok 6332 - uint array.grep(Int, :p)
            ok 6333 - uint array.grep(Int, :v)
            ok 6334 - uint array.grep(Int)
            ok 6335 - uint array.grep(Int, :k)
            ok 6336 - uint array.grep(Int, :kv)
            ok 6337 - uint array.grep(Int, :p)
            ok 6338 - uint array.grep(Int, :v)
            ok 6339 - Can use reduce meta-op on a uint array
            ok 6340 - .values from a uint array
            ok 6341 - .pairup from a uint array
            ok 6342 - .keys from a uint array
            ok 6343 - .pairs from a uint array
            ok 6344 - .antipairs from a uint array
            ok 6345 - .kv from a uint array
            ok 6346 - .pick from a uint array
            ok 6347 - .roll from a uint array
            ok 6348 - uint array.unique
            ok 6349 - uint array.repeated
            ok 6350 - uint array.squish
            ok 6351 - Trying to pop a shaped uint array dies
            ok 6352 - Trying to shift a shaped uint array dies
            ok 6353 - Trying to push a shaped uint array dies
            ok 6354 - Trying to unshift a shaped uint array dies
            ok 6355 - Cannot bind to a uint array
            ok 6356 - Cannot delete from a uint array
            ok 6357 - Cannot append to a uint array
            ok 6358 - Cannot prepend to a uint array
            ok 6359 - Cannot splice to a uint array
            ok 6360 - .Str space-separates on uint array
            ok 6361 - .gist space-separates on uint array
            ok 6362 - .raku includes type and int values on uint array
            ok 6363 - # SKIP STORE not working correctly yet)
            ok 6364 - does slice handle containerized range
            ok 6365 - does join a uint array
            ok 6366 - Can clear uint array by assigning empty list
            ok 6367 - does emptying a uint array reset
            ok 6368 - does re-initializing a uint array work
            ok 6369 - List-assigning uint array to untyped works (1)
            ok 6370 - List-assigning uint array to untyped works (2)
            ok 6371 - List-assigning uint array to untyped works (3)
            ok 6372 - List-assign uint array surrounded by literals (1)
            ok 6373 - List-assign uint array surrounded by literals (2)
            ok 6374 - List-assign uint array surrounded by literals (3)
            ok 6375 - List-assign uint array surrounded by literals (4)
            ok 6376 - List-assign uint array surrounded by literals (5)
            ok 6377 - List-assign untyped array of Int to uint array (1)
            ok 6378 - List-assign untyped array of Int to uint array (2)
            ok 6379 - List-assign untyped array of Int to uint array (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 6380 - List-assigning incompatible untyped array to uint array dies
            ok 6381 - Smartmatching same uint arrays works
            ok 6382 - Can we sort uint array
            ok 6383 - Can we sort 2-element sorted uint array
            ok 6384 - Can we sort 1-element sorted uint array
            # Testing uint8 array
            ok 6385 - uint8 array is Positional
            not ok 6386 - uint8 array is Positional[uint8] # TODO apparently it is not a typed Positional
            # Failed test 'uint8 array is Positional[uint8]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 20
            ok 6387 - uint8 array .of is uint8
            ok 6388 - uint8 array is Positional
            not ok 6389 - uint8 array is Positional[uint8] # TODO apparently it is not a typed Positional
            # Failed test 'uint8 array is Positional[uint8]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 26
            ok 6390 - uint8 array .of is uint8
            ok 6391 - .new from uint8 array is Positional
            not ok 6392 - .new from uint8 array Positional[uint8] # TODO apparently it is not a typed Positional
            # Failed test '.new from uint8 array Positional[uint8]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 30
            ok 6393 - .new from uint8 array .of is uint8
            ok 6394 - New uint8 array has 5 elems
            ok 6395 - New uint8 array has end of -1
            ok 6396 - New uint8 array Int-ifies to 5
            ok 6397 - New uint8 array numifies to 5
            ok 6398 - Empty uint8 array is not lazy
            ok 6399 - Accessing non-existing on uint8 array dies
            ok 6400 - Elems do not grow just from an access on uint8 array
            ok 6401 - Can store integer in an uint8 array with Int index
            ok 6402 - Can get value from uint8 array with Int index
            ok 6403 - can store integer in an $t array with int index
            ok 6404 - Can get value from uint8 array with int index
            ok 6405 - Can slice-assign to an uint8 array
            ok 6406 - Can get slice-assigned value from uint8 array (1)
            ok 6407 - Can get slice-assigned value from uint8 array (2)
            ok 6408 - :exists works on uint8 array with int index
            ok 6409 - :exists works on uint8 array with Int index
            ok 6410 - :exists works on uint8 array when out of range
            ok 6411 - :!exists works on uint8 array with int index
            ok 6412 - :!exists works on uint8 array with Int index
            ok 6413 - :!exists works on uint8 array when out of range
            ok 6414 - :delete dies on uint8 array with int index
            ok 6415 - :delete dies on uint8 array with Int index
            ok 6416 - :!delete works on uint8 array with int index
            ok 6417 - :!delete works on uint8 array with Int index
            ok 6418 - Can call uint8 array constructor with a single value
            ok 6419 - Correct number of elems set in constructor of uint8 array
            ok 6420 - Correct element value set by constructor of uint8 array
            ok 6421 - Can call uint8 array constructor with values
            ok 6422 - Correct number of elems set in constructor of uint8 array
            ok 6423 - Correct elem value set by constructor of uint8 array (1)
            ok 6424 - Correct elem value set by constructor of uint8 array (2)
            ok 6425 - Correct elem value set by constructor of uint8 array (3)
            ok 6426 - Correct elem value set by constructor of uint8 array (4)
            ok 6427 - Can also get last 2 elements on uint8 array
            ok 6428 - uint8 array .flat returns a Seq
            ok 6429 - uint8 array .eager returns identity
            ok 6430 - Mutating for loop on uint8 array works (1)
            ok 6431 - Mutating for loop on uint8 array works (2)
            ok 6432 - Mutating for loop on uint8 array works (3)
            ok 6433 - Mutating for loop on uint8 array works (4)
            ok 6434 - Can map over uint8 array
            ok 6435 - Mutating map on uint8 array works (1)
            ok 6436 - Mutating map on uint8 array works (2)
            ok 6437 - Mutating map on uint8 array works (3)
            ok 6438 - Mutating map on uint8 array works (4)
            ok 6439 - grep a uint8 array
            ok 6440 - uint8 array.grep(Int)
            ok 6441 - uint8 array.grep(Int, :k)
            ok 6442 - uint8 array.grep(Int, :kv)
            ok 6443 - uint8 array.grep(Int, :p)
            ok 6444 - uint8 array.grep(Int, :v)
            ok 6445 - uint8 array.grep(Int)
            ok 6446 - uint8 array.grep(Int, :k)
            ok 6447 - uint8 array.grep(Int, :kv)
            ok 6448 - uint8 array.grep(Int, :p)
            ok 6449 - uint8 array.grep(Int, :v)
            ok 6450 - Can use reduce meta-op on a uint8 array
            ok 6451 - .values from a uint8 array
            ok 6452 - .pairup from a uint8 array
            ok 6453 - .keys from a uint8 array
            ok 6454 - .pairs from a uint8 array
            ok 6455 - .antipairs from a uint8 array
            ok 6456 - .kv from a uint8 array
            ok 6457 - .pick from a uint8 array
            ok 6458 - .roll from a uint8 array
            ok 6459 - uint8 array.unique
            ok 6460 - uint8 array.repeated
            ok 6461 - uint8 array.squish
            ok 6462 - Trying to pop a shaped uint8 array dies
            ok 6463 - Trying to shift a shaped uint8 array dies
            ok 6464 - Trying to push a shaped uint8 array dies
            ok 6465 - Trying to unshift a shaped uint8 array dies
            ok 6466 - Cannot bind to a uint8 array
            ok 6467 - Cannot delete from a uint8 array
            ok 6468 - Cannot append to a uint8 array
            ok 6469 - Cannot prepend to a uint8 array
            ok 6470 - Cannot splice to a uint8 array
            ok 6471 - .Str space-separates on uint8 array
            ok 6472 - .gist space-separates on uint8 array
            ok 6473 - .raku includes type and int values on uint8 array
            ok 6474 - # SKIP STORE not working correctly yet)
            ok 6475 - does slice handle containerized range
            ok 6476 - does join a uint8 array
            ok 6477 - Can clear uint8 array by assigning empty list
            ok 6478 - does emptying a uint8 array reset
            ok 6479 - does re-initializing a uint8 array work
            ok 6480 - List-assigning uint8 array to untyped works (1)
            ok 6481 - List-assigning uint8 array to untyped works (2)
            ok 6482 - List-assigning uint8 array to untyped works (3)
            ok 6483 - List-assign uint8 array surrounded by literals (1)
            ok 6484 - List-assign uint8 array surrounded by literals (2)
            ok 6485 - List-assign uint8 array surrounded by literals (3)
            ok 6486 - List-assign uint8 array surrounded by literals (4)
            ok 6487 - List-assign uint8 array surrounded by literals (5)
            ok 6488 - List-assign untyped array of Int to uint8 array (1)
            ok 6489 - List-assign untyped array of Int to uint8 array (2)
            ok 6490 - List-assign untyped array of Int to uint8 array (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 6491 - List-assigning incompatible untyped array to uint8 array dies
            ok 6492 - Smartmatching same uint8 arrays works
            ok 6493 - Can we sort uint8 array
            ok 6494 - Can we sort 2-element sorted uint8 array
            ok 6495 - Can we sort 1-element sorted uint8 array
            # Testing uint16 array
            ok 6496 - uint16 array is Positional
            not ok 6497 - uint16 array is Positional[uint16] # TODO apparently it is not a typed Positional
            # Failed test 'uint16 array is Positional[uint16]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 20
            ok 6498 - uint16 array .of is uint16
            ok 6499 - uint16 array is Positional
            not ok 6500 - uint16 array is Positional[uint16] # TODO apparently it is not a typed Positional
            # Failed test 'uint16 array is Positional[uint16]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 26
            ok 6501 - uint16 array .of is uint16
            ok 6502 - .new from uint16 array is Positional
            not ok 6503 - .new from uint16 array Positional[uint16] # TODO apparently it is not a typed Positional
            # Failed test '.new from uint16 array Positional[uint16]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 30
            ok 6504 - .new from uint16 array .of is uint16
            ok 6505 - New uint16 array has 5 elems
            ok 6506 - New uint16 array has end of -1
            ok 6507 - New uint16 array Int-ifies to 5
            ok 6508 - New uint16 array numifies to 5
            ok 6509 - Empty uint16 array is not lazy
            ok 6510 - Accessing non-existing on uint16 array dies
            ok 6511 - Elems do not grow just from an access on uint16 array
            ok 6512 - Can store integer in an uint16 array with Int index
            ok 6513 - Can get value from uint16 array with Int index
            ok 6514 - can store integer in an $t array with int index
            ok 6515 - Can get value from uint16 array with int index
            ok 6516 - Can slice-assign to an uint16 array
            ok 6517 - Can get slice-assigned value from uint16 array (1)
            ok 6518 - Can get slice-assigned value from uint16 array (2)
            ok 6519 - :exists works on uint16 array with int index
            ok 6520 - :exists works on uint16 array with Int index
            ok 6521 - :exists works on uint16 array when out of range
            ok 6522 - :!exists works on uint16 array with int index
            ok 6523 - :!exists works on uint16 array with Int index
            ok 6524 - :!exists works on uint16 array when out of range
            ok 6525 - :delete dies on uint16 array with int index
            ok 6526 - :delete dies on uint16 array with Int index
            ok 6527 - :!delete works on uint16 array with int index
            ok 6528 - :!delete works on uint16 array with Int index
            ok 6529 - Can call uint16 array constructor with a single value
            ok 6530 - Correct number of elems set in constructor of uint16 array
            ok 6531 - Correct element value set by constructor of uint16 array
            ok 6532 - Can call uint16 array constructor with values
            ok 6533 - Correct number of elems set in constructor of uint16 array
            ok 6534 - Correct elem value set by constructor of uint16 array (1)
            ok 6535 - Correct elem value set by constructor of uint16 array (2)
            ok 6536 - Correct elem value set by constructor of uint16 array (3)
            ok 6537 - Correct elem value set by constructor of uint16 array (4)
            ok 6538 - Can also get last 2 elements on uint16 array
            ok 6539 - uint16 array .flat returns a Seq
            ok 6540 - uint16 array .eager returns identity
            ok 6541 - Mutating for loop on uint16 array works (1)
            ok 6542 - Mutating for loop on uint16 array works (2)
            ok 6543 - Mutating for loop on uint16 array works (3)
            ok 6544 - Mutating for loop on uint16 array works (4)
            ok 6545 - Can map over uint16 array
            ok 6546 - Mutating map on uint16 array works (1)
            ok 6547 - Mutating map on uint16 array works (2)
            ok 6548 - Mutating map on uint16 array works (3)
            ok 6549 - Mutating map on uint16 array works (4)
            ok 6550 - grep a uint16 array
            ok 6551 - uint16 array.grep(Int)
            ok 6552 - uint16 array.grep(Int, :k)
            ok 6553 - uint16 array.grep(Int, :kv)
            ok 6554 - uint16 array.grep(Int, :p)
            ok 6555 - uint16 array.grep(Int, :v)
            ok 6556 - uint16 array.grep(Int)
            ok 6557 - uint16 array.grep(Int, :k)
            ok 6558 - uint16 array.grep(Int, :kv)
            ok 6559 - uint16 array.grep(Int, :p)
            ok 6560 - uint16 array.grep(Int, :v)
            ok 6561 - Can use reduce meta-op on a uint16 array
            ok 6562 - .values from a uint16 array
            ok 6563 - .pairup from a uint16 array
            ok 6564 - .keys from a uint16 array
            ok 6565 - .pairs from a uint16 array
            ok 6566 - .antipairs from a uint16 array
            ok 6567 - .kv from a uint16 array
            ok 6568 - .pick from a uint16 array
            ok 6569 - .roll from a uint16 array
            ok 6570 - uint16 array.unique
            ok 6571 - uint16 array.repeated
            ok 6572 - uint16 array.squish
            ok 6573 - Trying to pop a shaped uint16 array dies
            ok 6574 - Trying to shift a shaped uint16 array dies
            ok 6575 - Trying to push a shaped uint16 array dies
            ok 6576 - Trying to unshift a shaped uint16 array dies
            ok 6577 - Cannot bind to a uint16 array
            ok 6578 - Cannot delete from a uint16 array
            ok 6579 - Cannot append to a uint16 array
            ok 6580 - Cannot prepend to a uint16 array
            ok 6581 - Cannot splice to a uint16 array
            ok 6582 - .Str space-separates on uint16 array
            ok 6583 - .gist space-separates on uint16 array
            ok 6584 - .raku includes type and int values on uint16 array
            ok 6585 - # SKIP STORE not working correctly yet)
            ok 6586 - does slice handle containerized range
            ok 6587 - does join a uint16 array
            ok 6588 - Can clear uint16 array by assigning empty list
            ok 6589 - does emptying a uint16 array reset
            ok 6590 - does re-initializing a uint16 array work
            ok 6591 - List-assigning uint16 array to untyped works (1)
            ok 6592 - List-assigning uint16 array to untyped works (2)
            ok 6593 - List-assigning uint16 array to untyped works (3)
            ok 6594 - List-assign uint16 array surrounded by literals (1)
            ok 6595 - List-assign uint16 array surrounded by literals (2)
            ok 6596 - List-assign uint16 array surrounded by literals (3)
            ok 6597 - List-assign uint16 array surrounded by literals (4)
            ok 6598 - List-assign uint16 array surrounded by literals (5)
            ok 6599 - List-assign untyped array of Int to uint16 array (1)
            ok 6600 - List-assign untyped array of Int to uint16 array (2)
            ok 6601 - List-assign untyped array of Int to uint16 array (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 6602 - List-assigning incompatible untyped array to uint16 array dies
            ok 6603 - Smartmatching same uint16 arrays works
            ok 6604 - Can we sort uint16 array
            ok 6605 - Can we sort 2-element sorted uint16 array
            ok 6606 - Can we sort 1-element sorted uint16 array
            # Testing uint32 array
            ok 6607 - uint32 array is Positional
            not ok 6608 - uint32 array is Positional[uint32] # TODO apparently it is not a typed Positional
            # Failed test 'uint32 array is Positional[uint32]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 20
            ok 6609 - uint32 array .of is uint32
            ok 6610 - uint32 array is Positional
            not ok 6611 - uint32 array is Positional[uint32] # TODO apparently it is not a typed Positional
            # Failed test 'uint32 array is Positional[uint32]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 26
            ok 6612 - uint32 array .of is uint32
            ok 6613 - .new from uint32 array is Positional
            not ok 6614 - .new from uint32 array Positional[uint32] # TODO apparently it is not a typed Positional
            # Failed test '.new from uint32 array Positional[uint32]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 30
            ok 6615 - .new from uint32 array .of is uint32
            ok 6616 - New uint32 array has 5 elems
            ok 6617 - New uint32 array has end of -1
            ok 6618 - New uint32 array Int-ifies to 5
            ok 6619 - New uint32 array numifies to 5
            ok 6620 - Empty uint32 array is not lazy
            ok 6621 - Accessing non-existing on uint32 array dies
            ok 6622 - Elems do not grow just from an access on uint32 array
            ok 6623 - Can store integer in an uint32 array with Int index
            ok 6624 - Can get value from uint32 array with Int index
            ok 6625 - can store integer in an $t array with int index
            ok 6626 - Can get value from uint32 array with int index
            ok 6627 - Can slice-assign to an uint32 array
            ok 6628 - Can get slice-assigned value from uint32 array (1)
            ok 6629 - Can get slice-assigned value from uint32 array (2)
            ok 6630 - :exists works on uint32 array with int index
            ok 6631 - :exists works on uint32 array with Int index
            ok 6632 - :exists works on uint32 array when out of range
            ok 6633 - :!exists works on uint32 array with int index
            ok 6634 - :!exists works on uint32 array with Int index
            ok 6635 - :!exists works on uint32 array when out of range
            ok 6636 - :delete dies on uint32 array with int index
            ok 6637 - :delete dies on uint32 array with Int index
            ok 6638 - :!delete works on uint32 array with int index
            ok 6639 - :!delete works on uint32 array with Int index
            ok 6640 - Can call uint32 array constructor with a single value
            ok 6641 - Correct number of elems set in constructor of uint32 array
            ok 6642 - Correct element value set by constructor of uint32 array
            ok 6643 - Can call uint32 array constructor with values
            ok 6644 - Correct number of elems set in constructor of uint32 array
            ok 6645 - Correct elem value set by constructor of uint32 array (1)
            ok 6646 - Correct elem value set by constructor of uint32 array (2)
            ok 6647 - Correct elem value set by constructor of uint32 array (3)
            ok 6648 - Correct elem value set by constructor of uint32 array (4)
            ok 6649 - Can also get last 2 elements on uint32 array
            ok 6650 - uint32 array .flat returns a Seq
            ok 6651 - uint32 array .eager returns identity
            ok 6652 - Mutating for loop on uint32 array works (1)
            ok 6653 - Mutating for loop on uint32 array works (2)
            ok 6654 - Mutating for loop on uint32 array works (3)
            ok 6655 - Mutating for loop on uint32 array works (4)
            ok 6656 - Can map over uint32 array
            ok 6657 - Mutating map on uint32 array works (1)
            ok 6658 - Mutating map on uint32 array works (2)
            ok 6659 - Mutating map on uint32 array works (3)
            ok 6660 - Mutating map on uint32 array works (4)
            ok 6661 - grep a uint32 array
            ok 6662 - uint32 array.grep(Int)
            ok 6663 - uint32 array.grep(Int, :k)
            ok 6664 - uint32 array.grep(Int, :kv)
            ok 6665 - uint32 array.grep(Int, :p)
            ok 6666 - uint32 array.grep(Int, :v)
            ok 6667 - uint32 array.grep(Int)
            ok 6668 - uint32 array.grep(Int, :k)
            ok 6669 - uint32 array.grep(Int, :kv)
            ok 6670 - uint32 array.grep(Int, :p)
            ok 6671 - uint32 array.grep(Int, :v)
            ok 6672 - Can use reduce meta-op on a uint32 array
            ok 6673 - .values from a uint32 array
            ok 6674 - .pairup from a uint32 array
            ok 6675 - .keys from a uint32 array
            ok 6676 - .pairs from a uint32 array
            ok 6677 - .antipairs from a uint32 array
            ok 6678 - .kv from a uint32 array
            ok 6679 - .pick from a uint32 array
            ok 6680 - .roll from a uint32 array
            ok 6681 - uint32 array.unique
            ok 6682 - uint32 array.repeated
            ok 6683 - uint32 array.squish
            ok 6684 - Trying to pop a shaped uint32 array dies
            ok 6685 - Trying to shift a shaped uint32 array dies
            ok 6686 - Trying to push a shaped uint32 array dies
            ok 6687 - Trying to unshift a shaped uint32 array dies
            ok 6688 - Cannot bind to a uint32 array
            ok 6689 - Cannot delete from a uint32 array
            ok 6690 - Cannot append to a uint32 array
            ok 6691 - Cannot prepend to a uint32 array
            ok 6692 - Cannot splice to a uint32 array
            ok 6693 - .Str space-separates on uint32 array
            ok 6694 - .gist space-separates on uint32 array
            ok 6695 - .raku includes type and int values on uint32 array
            ok 6696 - # SKIP STORE not working correctly yet)
            ok 6697 - does slice handle containerized range
            ok 6698 - does join a uint32 array
            ok 6699 - Can clear uint32 array by assigning empty list
            ok 6700 - does emptying a uint32 array reset
            ok 6701 - does re-initializing a uint32 array work
            ok 6702 - List-assigning uint32 array to untyped works (1)
            ok 6703 - List-assigning uint32 array to untyped works (2)
            ok 6704 - List-assigning uint32 array to untyped works (3)
            ok 6705 - List-assign uint32 array surrounded by literals (1)
            ok 6706 - List-assign uint32 array surrounded by literals (2)
            ok 6707 - List-assign uint32 array surrounded by literals (3)
            ok 6708 - List-assign uint32 array surrounded by literals (4)
            ok 6709 - List-assign uint32 array surrounded by literals (5)
            ok 6710 - List-assign untyped array of Int to uint32 array (1)
            ok 6711 - List-assign untyped array of Int to uint32 array (2)
            ok 6712 - List-assign untyped array of Int to uint32 array (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 6713 - List-assigning incompatible untyped array to uint32 array dies
            ok 6714 - Smartmatching same uint32 arrays works
            ok 6715 - Can we sort uint32 array
            ok 6716 - Can we sort 2-element sorted uint32 array
            ok 6717 - Can we sort 1-element sorted uint32 array
            # Testing uint64 array
            ok 6718 - uint64 array is Positional
            not ok 6719 - uint64 array is Positional[uint64] # TODO apparently it is not a typed Positional
            # Failed test 'uint64 array is Positional[uint64]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 20
            ok 6720 - uint64 array .of is uint64
            ok 6721 - uint64 array is Positional
            not ok 6722 - uint64 array is Positional[uint64] # TODO apparently it is not a typed Positional
            # Failed test 'uint64 array is Positional[uint64]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 26
            ok 6723 - uint64 array .of is uint64
            ok 6724 - .new from uint64 array is Positional
            not ok 6725 - .new from uint64 array Positional[uint64] # TODO apparently it is not a typed Positional
            # Failed test '.new from uint64 array Positional[uint64]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-int.rakudo line 30
            ok 6726 - .new from uint64 array .of is uint64
            ok 6727 - New uint64 array has 5 elems
            ok 6728 - New uint64 array has end of -1
            ok 6729 - New uint64 array Int-ifies to 5
            ok 6730 - New uint64 array numifies to 5
            ok 6731 - Empty uint64 array is not lazy
            ok 6732 - Accessing non-existing on uint64 array dies
            ok 6733 - Elems do not grow just from an access on uint64 array
            ok 6734 - Can store integer in an uint64 array with Int index
            ok 6735 - Can get value from uint64 array with Int index
            ok 6736 - can store integer in an $t array with int index
            ok 6737 - Can get value from uint64 array with int index
            ok 6738 - Can slice-assign to an uint64 array
            ok 6739 - Can get slice-assigned value from uint64 array (1)
            ok 6740 - Can get slice-assigned value from uint64 array (2)
            ok 6741 - :exists works on uint64 array with int index
            ok 6742 - :exists works on uint64 array with Int index
            ok 6743 - :exists works on uint64 array when out of range
            ok 6744 - :!exists works on uint64 array with int index
            ok 6745 - :!exists works on uint64 array with Int index
            ok 6746 - :!exists works on uint64 array when out of range
            ok 6747 - :delete dies on uint64 array with int index
            ok 6748 - :delete dies on uint64 array with Int index
            ok 6749 - :!delete works on uint64 array with int index
            ok 6750 - :!delete works on uint64 array with Int index
            ok 6751 - Can call uint64 array constructor with a single value
            ok 6752 - Correct number of elems set in constructor of uint64 array
            ok 6753 - Correct element value set by constructor of uint64 array
            ok 6754 - Can call uint64 array constructor with values
            ok 6755 - Correct number of elems set in constructor of uint64 array
            ok 6756 - Correct elem value set by constructor of uint64 array (1)
            ok 6757 - Correct elem value set by constructor of uint64 array (2)
            ok 6758 - Correct elem value set by constructor of uint64 array (3)
            ok 6759 - Correct elem value set by constructor of uint64 array (4)
            ok 6760 - Can also get last 2 elements on uint64 array
            ok 6761 - uint64 array .flat returns a Seq
            ok 6762 - uint64 array .eager returns identity
            ok 6763 - Mutating for loop on uint64 array works (1)
            ok 6764 - Mutating for loop on uint64 array works (2)
            ok 6765 - Mutating for loop on uint64 array works (3)
            ok 6766 - Mutating for loop on uint64 array works (4)
            ok 6767 - Can map over uint64 array
            ok 6768 - Mutating map on uint64 array works (1)
            ok 6769 - Mutating map on uint64 array works (2)
            ok 6770 - Mutating map on uint64 array works (3)
            ok 6771 - Mutating map on uint64 array works (4)
            ok 6772 - grep a uint64 array
            ok 6773 - uint64 array.grep(Int)
            ok 6774 - uint64 array.grep(Int, :k)
            ok 6775 - uint64 array.grep(Int, :kv)
            ok 6776 - uint64 array.grep(Int, :p)
            ok 6777 - uint64 array.grep(Int, :v)
            ok 6778 - uint64 array.grep(Int)
            ok 6779 - uint64 array.grep(Int, :k)
            ok 6780 - uint64 array.grep(Int, :kv)
            ok 6781 - uint64 array.grep(Int, :p)
            ok 6782 - uint64 array.grep(Int, :v)
            ok 6783 - Can use reduce meta-op on a uint64 array
            ok 6784 - .values from a uint64 array
            ok 6785 - .pairup from a uint64 array
            ok 6786 - .keys from a uint64 array
            ok 6787 - .pairs from a uint64 array
            ok 6788 - .antipairs from a uint64 array
            ok 6789 - .kv from a uint64 array
            ok 6790 - .pick from a uint64 array
            ok 6791 - .roll from a uint64 array
            ok 6792 - uint64 array.unique
            ok 6793 - uint64 array.repeated
            ok 6794 - uint64 array.squish
            ok 6795 - Trying to pop a shaped uint64 array dies
            ok 6796 - Trying to shift a shaped uint64 array dies
            ok 6797 - Trying to push a shaped uint64 array dies
            ok 6798 - Trying to unshift a shaped uint64 array dies
            ok 6799 - Cannot bind to a uint64 array
            ok 6800 - Cannot delete from a uint64 array
            ok 6801 - Cannot append to a uint64 array
            ok 6802 - Cannot prepend to a uint64 array
            ok 6803 - Cannot splice to a uint64 array
            ok 6804 - .Str space-separates on uint64 array
            ok 6805 - .gist space-separates on uint64 array
            ok 6806 - .raku includes type and int values on uint64 array
            ok 6807 - # SKIP STORE not working correctly yet)
            ok 6808 - does slice handle containerized range
            ok 6809 - does join a uint64 array
            ok 6810 - Can clear uint64 array by assigning empty list
            ok 6811 - does emptying a uint64 array reset
            ok 6812 - does re-initializing a uint64 array work
            ok 6813 - List-assigning uint64 array to untyped works (1)
            ok 6814 - List-assigning uint64 array to untyped works (2)
            ok 6815 - List-assigning uint64 array to untyped works (3)
            ok 6816 - List-assign uint64 array surrounded by literals (1)
            ok 6817 - List-assign uint64 array surrounded by literals (2)
            ok 6818 - List-assign uint64 array surrounded by literals (3)
            ok 6819 - List-assign uint64 array surrounded by literals (4)
            ok 6820 - List-assign uint64 array surrounded by literals (5)
            ok 6821 - List-assign untyped array of Int to uint64 array (1)
            ok 6822 - List-assign untyped array of Int to uint64 array (2)
            ok 6823 - List-assign untyped array of Int to uint64 array (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 6824 - List-assigning incompatible untyped array to uint64 array dies
            ok 6825 - Smartmatching same uint64 arrays works
            ok 6826 - Can we sort uint64 array
            ok 6827 - Can we sort 2-element sorted uint64 array
            ok 6828 - Can we sort 1-element sorted uint64 array
# FUDGED!
            1..333
            # Testing num array
            ok 6829 - num array is Positional
            not ok 6830 - num array is Positional[num] # TODO apparently it is not a typed Positional
            # Failed test 'num array is Positional[num]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-num.rakudo line 18
            ok 6831 - num array .of is num
            ok 6832 - num array is Positional
            not ok 6833 - num array is Positional[num] # TODO apparently it is not a typed Positional
            # Failed test 'num array is Positional[num]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-num.rakudo line 24
            ok 6834 - num array .of is num
            ok 6835 - .new from num array is Positional
            not ok 6836 - .new from num array Positional[num] # TODO apparently it is not a typed Positional
            # Failed test '.new from num array Positional[num]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-num.rakudo line 28
            ok 6837 - .new from num array .of is num
            ok 6838 - New num array has 5 elems
            ok 6839 - New num array has end of -1
            ok 6840 - New num array Int-ifies to 5
            ok 6841 - New num array numifies to 5
            ok 6842 - Empty num array is not lazy
            ok 6843 - Accessing non-existing on num array dies
            ok 6844 - Elems do not grow just from an access on num array
            ok 6845 - Can store num in an num array with Int index
            ok 6846 - Can get value from num array with Int index
            ok 6847 - can store num in an $t array with int index
            ok 6848 - Can get value from num array with int index
            ok 6849 - Can slice-assign to num array
            ok 6850 - Can get slice-assigned value from num array (1)
            ok 6851 - Can get slice-assigned value from num array (2)
            ok 6852 - :exists works on num array with int index
            ok 6853 - :exists works on num array with Int index
            ok 6854 - :exists works on num array when out of range
            ok 6855 - :!exists works on num array with int index
            ok 6856 - :!exists works on num array with Int index
            ok 6857 - :!exists works on num array when out of range
            ok 6858 - :delete dies on num array with int index
            ok 6859 - :delete dies on num array with Int index
            ok 6860 - :!delete works on num array with int index
            ok 6861 - :!delete works on num array with Int index
            ok 6862 - Can call num array constructor with a single value
            ok 6863 - Correct number of elems set in constructor of num array
            ok 6864 - Correct element value set by constructor of num array
            ok 6865 - Can call num array constructor with values
            ok 6866 - Correct number of elems set in constructor of num array
            ok 6867 - Correct elem value set by constructor of num array (1)
            ok 6868 - Correct elem value set by constructor of num array (2)
            ok 6869 - Correct elem value set by constructor of num array (3)
            ok 6870 - Correct elem value set by constructor of num array (4)
            ok 6871 - Can also get last 2 elements on num array
            ok 6872 - num array .flat returns a Seq
            ok 6873 - num array .eager returns identity
            ok 6874 - Mutating for loop on num array works (1)
            ok 6875 - Mutating for loop on num array works (2)
            ok 6876 - Mutating for loop on num array works (3)
            ok 6877 - Mutating for loop on num array works (4)
            ok 6878 - Can map over num array
            ok 6879 - Mutating map on num array works (1)
            ok 6880 - Mutating map on num array works (2)
            ok 6881 - Mutating map on num array works (3)
            ok 6882 - Mutating map on num array works (4)
            ok 6883 - grep a num array
            ok 6884 - num array.grep(Num)
            ok 6885 - num array.grep(Num, :k)
            ok 6886 - num array.grep(Num, :kv)
            ok 6887 - num array.grep(Num, :p)
            ok 6888 - num array.grep(Num, :v)
            ok 6889 - num array.grep(Num)
            ok 6890 - num array.grep(Num, :k)
            ok 6891 - num array.grep(Num, :kv)
            ok 6892 - num array.grep(Num, :p)
            ok 6893 - num array.grep(Num, :v)
            ok 6894 - Can use reduce meta-op on a num array
            ok 6895 - .values from a num array
            ok 6896 - .pairup from a num array
            ok 6897 - .keys from a num array
            ok 6898 - .pairs from a num array
            ok 6899 - .antipairs from a num array
            ok 6900 - .kv from a num array
            ok 6901 - .pick from a num array
            ok 6902 - .roll from a num array
            ok 6903 - num array.unique
            ok 6904 - num array.repeated
            ok 6905 - num array.squish
            ok 6906 - Trying to pop a shaped num array dies
            ok 6907 - Trying to shift a shaped num array dies
            ok 6908 - Trying to push a shaped num array dies
            ok 6909 - Trying to unshift a shaped num array dies
            ok 6910 - Cannot bind to a num array
            ok 6911 - Cannot delete from a num array
            ok 6912 - Cannot append to a num array
            ok 6913 - Cannot prepend to a num array
            ok 6914 - Cannot splice to a num array
            ok 6915 - .Str space-separates on num array
            ok 6916 - .gist space-separates on num array
            ok 6917 - .raku includes type and num values on num array
            ok 6918 - # SKIP STORE not working correctly yet)
            ok 6919 - does slice handle containerized range
            ok 6920 - does join a num array
            ok 6921 - Can clear num array by assigning empty list
            ok 6922 - does emptying a num array reset
            ok 6923 - does re-initializing a num array work
            ok 6924 - List-assigning num array to untyped works (1)
            ok 6925 - List-assigning num array to untyped works (2)
            ok 6926 - List-assigning num array to untyped works (3)
            ok 6927 - List-assign num array surrounded by literals (1)
            ok 6928 - List-assign num array surrounded by literals (2)
            ok 6929 - List-assign num array surrounded by literals (3)
            ok 6930 - List-assign num array surrounded by literals (4)
            ok 6931 - List-assign num array surrounded by literals (5)
            ok 6932 - List-assign untyped array of Num to num array (1)
            ok 6933 - List-assign untyped array of Num to num array (2)
            ok 6934 - List-assign untyped array of Num to num array (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 6935 - List-assigning incompatible untyped array to num array dies
            ok 6936 - Smartmatching same num arrays works
            ok 6937 - Can we sort num array
            ok 6938 - Can we sort 2-element sorted num array
            ok 6939 - Can we sort 1-element sorted num array
            # Testing num32 array
            ok 6940 - num32 array is Positional
            not ok 6941 - num32 array is Positional[num32] # TODO apparently it is not a typed Positional
            # Failed test 'num32 array is Positional[num32]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-num.rakudo line 18
            ok 6942 - num32 array .of is num32
            ok 6943 - num32 array is Positional
            not ok 6944 - num32 array is Positional[num32] # TODO apparently it is not a typed Positional
            # Failed test 'num32 array is Positional[num32]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-num.rakudo line 24
            ok 6945 - num32 array .of is num32
            ok 6946 - .new from num32 array is Positional
            not ok 6947 - .new from num32 array Positional[num32] # TODO apparently it is not a typed Positional
            # Failed test '.new from num32 array Positional[num32]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-num.rakudo line 28
            ok 6948 - .new from num32 array .of is num32
            ok 6949 - New num32 array has 5 elems
            ok 6950 - New num32 array has end of -1
            ok 6951 - New num32 array Int-ifies to 5
            ok 6952 - New num32 array numifies to 5
            ok 6953 - Empty num32 array is not lazy
            ok 6954 - Accessing non-existing on num32 array dies
            ok 6955 - Elems do not grow just from an access on num32 array
            ok 6956 - Can store num in an num32 array with Int index
            ok 6957 - Can get value from num32 array with Int index
            ok 6958 - can store num in an $t array with int index
            ok 6959 - Can get value from num32 array with int index
            ok 6960 - Can slice-assign to num32 array
            ok 6961 - Can get slice-assigned value from num32 array (1)
            ok 6962 - Can get slice-assigned value from num32 array (2)
            ok 6963 - :exists works on num32 array with int index
            ok 6964 - :exists works on num32 array with Int index
            ok 6965 - :exists works on num32 array when out of range
            ok 6966 - :!exists works on num32 array with int index
            ok 6967 - :!exists works on num32 array with Int index
            ok 6968 - :!exists works on num32 array when out of range
            ok 6969 - :delete dies on num32 array with int index
            ok 6970 - :delete dies on num32 array with Int index
            ok 6971 - :!delete works on num32 array with int index
            ok 6972 - :!delete works on num32 array with Int index
            ok 6973 - Can call num32 array constructor with a single value
            ok 6974 - Correct number of elems set in constructor of num32 array
            ok 6975 - Correct element value set by constructor of num32 array
            ok 6976 - Can call num32 array constructor with values
            ok 6977 - Correct number of elems set in constructor of num32 array
            ok 6978 - Correct elem value set by constructor of num32 array (1)
            ok 6979 - Correct elem value set by constructor of num32 array (2)
            ok 6980 - Correct elem value set by constructor of num32 array (3)
            ok 6981 - Correct elem value set by constructor of num32 array (4)
            ok 6982 - Can also get last 2 elements on num32 array
            ok 6983 - num32 array .flat returns a Seq
            ok 6984 - num32 array .eager returns identity
            ok 6985 - Mutating for loop on num32 array works (1)
            ok 6986 - Mutating for loop on num32 array works (2)
            ok 6987 - Mutating for loop on num32 array works (3)
            ok 6988 - Mutating for loop on num32 array works (4)
            ok 6989 - Can map over num32 array
            ok 6990 - Mutating map on num32 array works (1)
            ok 6991 - Mutating map on num32 array works (2)
            ok 6992 - Mutating map on num32 array works (3)
            ok 6993 - Mutating map on num32 array works (4)
            ok 6994 - grep a num32 array
            ok 6995 - num32 array.grep(Num)
            ok 6996 - num32 array.grep(Num, :k)
            ok 6997 - num32 array.grep(Num, :kv)
            ok 6998 - num32 array.grep(Num, :p)
            ok 6999 - num32 array.grep(Num, :v)
            ok 7000 - num32 array.grep(Num)
            ok 7001 - num32 array.grep(Num, :k)
            ok 7002 - num32 array.grep(Num, :kv)
            ok 7003 - num32 array.grep(Num, :p)
            ok 7004 - num32 array.grep(Num, :v)
            ok 7005 - Can use reduce meta-op on a num32 array
            ok 7006 - .values from a num32 array
            ok 7007 - .pairup from a num32 array
            ok 7008 - .keys from a num32 array
            ok 7009 - .pairs from a num32 array
            ok 7010 - .antipairs from a num32 array
            ok 7011 - .kv from a num32 array
            ok 7012 - .pick from a num32 array
            ok 7013 - .roll from a num32 array
            ok 7014 - num32 array.unique
            ok 7015 - num32 array.repeated
            ok 7016 - num32 array.squish
            ok 7017 - Trying to pop a shaped num32 array dies
            ok 7018 - Trying to shift a shaped num32 array dies
            ok 7019 - Trying to push a shaped num32 array dies
            ok 7020 - Trying to unshift a shaped num32 array dies
            ok 7021 - Cannot bind to a num32 array
            ok 7022 - Cannot delete from a num32 array
            ok 7023 - Cannot append to a num32 array
            ok 7024 - Cannot prepend to a num32 array
            ok 7025 - Cannot splice to a num32 array
            ok 7026 - .Str space-separates on num32 array
            ok 7027 - .gist space-separates on num32 array
            ok 7028 - .raku includes type and num values on num32 array
            ok 7029 - # SKIP STORE not working correctly yet)
            ok 7030 - does slice handle containerized range
            ok 7031 - does join a num32 array
            ok 7032 - Can clear num32 array by assigning empty list
            ok 7033 - does emptying a num32 array reset
            ok 7034 - does re-initializing a num32 array work
            ok 7035 - List-assigning num32 array to untyped works (1)
            ok 7036 - List-assigning num32 array to untyped works (2)
            ok 7037 - List-assigning num32 array to untyped works (3)
            ok 7038 - List-assign num32 array surrounded by literals (1)
            ok 7039 - List-assign num32 array surrounded by literals (2)
            ok 7040 - List-assign num32 array surrounded by literals (3)
            ok 7041 - List-assign num32 array surrounded by literals (4)
            ok 7042 - List-assign num32 array surrounded by literals (5)
            ok 7043 - List-assign untyped array of Num to num32 array (1)
            ok 7044 - List-assign untyped array of Num to num32 array (2)
            ok 7045 - List-assign untyped array of Num to num32 array (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 7046 - List-assigning incompatible untyped array to num32 array dies
            ok 7047 - Smartmatching same num32 arrays works
            ok 7048 - Can we sort num32 array
            ok 7049 - Can we sort 2-element sorted num32 array
            ok 7050 - Can we sort 1-element sorted num32 array
            # Testing num64 array
            ok 7051 - num64 array is Positional
            not ok 7052 - num64 array is Positional[num64] # TODO apparently it is not a typed Positional
            # Failed test 'num64 array is Positional[num64]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-num.rakudo line 18
            ok 7053 - num64 array .of is num64
            ok 7054 - num64 array is Positional
            not ok 7055 - num64 array is Positional[num64] # TODO apparently it is not a typed Positional
            # Failed test 'num64 array is Positional[num64]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-num.rakudo line 24
            ok 7056 - num64 array .of is num64
            ok 7057 - .new from num64 array is Positional
            not ok 7058 - .new from num64 array Positional[num64] # TODO apparently it is not a typed Positional
            # Failed test '.new from num64 array Positional[num64]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-num.rakudo line 28
            ok 7059 - .new from num64 array .of is num64
            ok 7060 - New num64 array has 5 elems
            ok 7061 - New num64 array has end of -1
            ok 7062 - New num64 array Int-ifies to 5
            ok 7063 - New num64 array numifies to 5
            ok 7064 - Empty num64 array is not lazy
            ok 7065 - Accessing non-existing on num64 array dies
            ok 7066 - Elems do not grow just from an access on num64 array
            ok 7067 - Can store num in an num64 array with Int index
            ok 7068 - Can get value from num64 array with Int index
            ok 7069 - can store num in an $t array with int index
            ok 7070 - Can get value from num64 array with int index
            ok 7071 - Can slice-assign to num64 array
            ok 7072 - Can get slice-assigned value from num64 array (1)
            ok 7073 - Can get slice-assigned value from num64 array (2)
            ok 7074 - :exists works on num64 array with int index
            ok 7075 - :exists works on num64 array with Int index
            ok 7076 - :exists works on num64 array when out of range
            ok 7077 - :!exists works on num64 array with int index
            ok 7078 - :!exists works on num64 array with Int index
            ok 7079 - :!exists works on num64 array when out of range
            ok 7080 - :delete dies on num64 array with int index
            ok 7081 - :delete dies on num64 array with Int index
            ok 7082 - :!delete works on num64 array with int index
            ok 7083 - :!delete works on num64 array with Int index
            ok 7084 - Can call num64 array constructor with a single value
            ok 7085 - Correct number of elems set in constructor of num64 array
            ok 7086 - Correct element value set by constructor of num64 array
            ok 7087 - Can call num64 array constructor with values
            ok 7088 - Correct number of elems set in constructor of num64 array
            ok 7089 - Correct elem value set by constructor of num64 array (1)
            ok 7090 - Correct elem value set by constructor of num64 array (2)
            ok 7091 - Correct elem value set by constructor of num64 array (3)
            ok 7092 - Correct elem value set by constructor of num64 array (4)
            ok 7093 - Can also get last 2 elements on num64 array
            ok 7094 - num64 array .flat returns a Seq
            ok 7095 - num64 array .eager returns identity
            ok 7096 - Mutating for loop on num64 array works (1)
            ok 7097 - Mutating for loop on num64 array works (2)
            ok 7098 - Mutating for loop on num64 array works (3)
            ok 7099 - Mutating for loop on num64 array works (4)
            ok 7100 - Can map over num64 array
            ok 7101 - Mutating map on num64 array works (1)
            ok 7102 - Mutating map on num64 array works (2)
            ok 7103 - Mutating map on num64 array works (3)
            ok 7104 - Mutating map on num64 array works (4)
            ok 7105 - grep a num64 array
            ok 7106 - num64 array.grep(Num)
            ok 7107 - num64 array.grep(Num, :k)
            ok 7108 - num64 array.grep(Num, :kv)
            ok 7109 - num64 array.grep(Num, :p)
            ok 7110 - num64 array.grep(Num, :v)
            ok 7111 - num64 array.grep(Num)
            ok 7112 - num64 array.grep(Num, :k)
            ok 7113 - num64 array.grep(Num, :kv)
            ok 7114 - num64 array.grep(Num, :p)
            ok 7115 - num64 array.grep(Num, :v)
            ok 7116 - Can use reduce meta-op on a num64 array
            ok 7117 - .values from a num64 array
            ok 7118 - .pairup from a num64 array
            ok 7119 - .keys from a num64 array
            ok 7120 - .pairs from a num64 array
            ok 7121 - .antipairs from a num64 array
            ok 7122 - .kv from a num64 array
            ok 7123 - .pick from a num64 array
            ok 7124 - .roll from a num64 array
            ok 7125 - num64 array.unique
            ok 7126 - num64 array.repeated
            ok 7127 - num64 array.squish
            ok 7128 - Trying to pop a shaped num64 array dies
            ok 7129 - Trying to shift a shaped num64 array dies
            ok 7130 - Trying to push a shaped num64 array dies
            ok 7131 - Trying to unshift a shaped num64 array dies
            ok 7132 - Cannot bind to a num64 array
            ok 7133 - Cannot delete from a num64 array
            ok 7134 - Cannot append to a num64 array
            ok 7135 - Cannot prepend to a num64 array
            ok 7136 - Cannot splice to a num64 array
            ok 7137 - .Str space-separates on num64 array
            ok 7138 - .gist space-separates on num64 array
            ok 7139 - .raku includes type and num values on num64 array
            ok 7140 - # SKIP STORE not working correctly yet)
            ok 7141 - does slice handle containerized range
            ok 7142 - does join a num64 array
            ok 7143 - Can clear num64 array by assigning empty list
            ok 7144 - does emptying a num64 array reset
            ok 7145 - does re-initializing a num64 array work
            ok 7146 - List-assigning num64 array to untyped works (1)
            ok 7147 - List-assigning num64 array to untyped works (2)
            ok 7148 - List-assigning num64 array to untyped works (3)
            ok 7149 - List-assign num64 array surrounded by literals (1)
            ok 7150 - List-assign num64 array surrounded by literals (2)
            ok 7151 - List-assign num64 array surrounded by literals (3)
            ok 7152 - List-assign num64 array surrounded by literals (4)
            ok 7153 - List-assign num64 array surrounded by literals (5)
            ok 7154 - List-assign untyped array of Num to num64 array (1)
            ok 7155 - List-assign untyped array of Num to num64 array (2)
            ok 7156 - List-assign untyped array of Num to num64 array (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 7157 - List-assigning incompatible untyped array to num64 array dies
            ok 7158 - Smartmatching same num64 arrays works
            ok 7159 - Can we sort num64 array
            ok 7160 - Can we sort 2-element sorted num64 array
            ok 7161 - Can we sort 1-element sorted num64 array
# FUDGED!
            1..111
            # Testing str array
            ok 7162 - str array is Positional
            not ok 7163 - str array is Positional[str] # TODO apparently it is not a typed Positional
            # Failed test 'str array is Positional[str]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-str.rakudo line 13
            ok 7164 - str array .of is str
            ok 7165 - str array is Positional
            not ok 7166 - str array is Positional[str] # TODO apparently it is not a typed Positional
            # Failed test 'str array is Positional[str]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-str.rakudo line 19
            ok 7167 - str array .of is str
            ok 7168 - .new from str array is Positional
            not ok 7169 - .new from str array Positional[str] # TODO apparently it is not a typed Positional
            # Failed test '.new from str array Positional[str]'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S09-typed-arrays/native-shape1-str.rakudo line 23
            ok 7170 - .new from str array .of is str
            ok 7171 - New str array has 5 elems
            ok 7172 - New str array has end of -1
            ok 7173 - New str array Int-ifies to 5
            ok 7174 - New str array numifies to 5
            ok 7175 - Empty str array is not lazy
            ok 7176 - Accessing non-existing on str array dies
            ok 7177 - Elems do not grow just from an access on str array
            ok 7178 - Can store string in an str array with Int index
            ok 7179 - Can get value from str array with Int index
            ok 7180 - can store string in an $t array with int index
            ok 7181 - Can get value from str array with int index
            ok 7182 - Can slice-assign to an str array
            ok 7183 - Can get slice-assigned value from str array (1)
            ok 7184 - Can get slice-assigned value from str array (2)
            ok 7185 - :exists works on str array with int index
            ok 7186 - :exists works on str array with Int index
            ok 7187 - :exists works on str array when out of range
            ok 7188 - :!exists works on str array with int index
            ok 7189 - :!exists works on str array with Int index
            ok 7190 - :!exists works on str array when out of range
            ok 7191 - :delete dies on str array with int index
            ok 7192 - :delete dies on str array with Int index
            ok 7193 - :!delete works on str array with int index
            ok 7194 - :!delete works on str array with Int index
            ok 7195 - Can call str array constructor with a single value
            ok 7196 - Correct number of elems set in constructor of str array
            ok 7197 - Correct element value set by constructor of str array
            ok 7198 - Can call str array constructor with values
            ok 7199 - Correct number of elems set in constructor of str array
            ok 7200 - Correct elem value set by constructor of str array (1)
            ok 7201 - Correct elem value set by constructor of str array (2)
            ok 7202 - Correct elem value set by constructor of str array (3)
            ok 7203 - Correct elem value set by constructor of str array (4)
            ok 7204 - Can also get last 2 elements on str array
            ok 7205 - str array .flat returns a Seq
            ok 7206 - str array .eager returns identity
            ok 7207 - Mutating for loop on str array works (1)
            ok 7208 - Mutating for loop on str array works (2)
            ok 7209 - Mutating for loop on str array works (3)
            ok 7210 - Mutating for loop on str array works (4)
            ok 7211 - Can map over str array
            ok 7212 - Mutating map on str array works (1)
            ok 7213 - Mutating map on str array works (2)
            ok 7214 - Mutating map on str array works (3)
            ok 7215 - Mutating map on str array works (4)
            ok 7216 - grep a str array
            ok 7217 - str array.grep(Str)
            ok 7218 - str array.grep(Str, :k)
            ok 7219 - str array.grep(Str, :kv)
            ok 7220 - str array.grep(Str, :p)
            ok 7221 - str array.grep(Str, :v)
            ok 7222 - str array.grep(Str)
            ok 7223 - str array.grep(Str, :k)
            ok 7224 - str array.grep(Str, :kv)
            ok 7225 - str array.grep(Str, :p)
            ok 7226 - str array.grep(Str, :v)
            ok 7227 - Can use reduce meta-op on a str array
            ok 7228 - .values from a str array
            ok 7229 - .pairup from a str array
            ok 7230 - .keys from a str array
            ok 7231 - .pairs from a str array
            ok 7232 - .antipairs from a str array
            ok 7233 - .kv from a str array
            ok 7234 - .pick from a str array
            ok 7235 - .roll from a str array
            ok 7236 - str array.unique
            ok 7237 - str array.repeated
            ok 7238 - str array.squish
            ok 7239 - Trying to pop a shaped str array dies
            ok 7240 - Trying to shift a shaped str array dies
            ok 7241 - Trying to push a shaped str array dies
            ok 7242 - Trying to unshift a shaped str array dies
            ok 7243 - Cannot bind to a str array
            ok 7244 - Cannot delete from a str array
            ok 7245 - Cannot append to a str array
            ok 7246 - Cannot prepend to a str array
            ok 7247 - Cannot splice to a str array
            ok 7248 - .Str space-separates on str array
            ok 7249 - .gist space-separates on str array
            ok 7250 - .raku includes type and str values on str array
            ok 7251 - # SKIP STORE not working correctly yet)
            ok 7252 - does slice handle containerized range
            ok 7253 - does join a str array
            ok 7254 - Can clear str array by assigning empty list
            ok 7255 - does emptying a str array reset
            ok 7256 - does re-initializing a str array work
            ok 7257 - List-assigning str array to untyped works (1)
            ok 7258 - List-assigning str array to untyped works (2)
            ok 7259 - List-assigning str array to untyped works (3)
            ok 7260 - List-assign str array surrounded by literals (1)
            ok 7261 - List-assign str array surrounded by literals (2)
            ok 7262 - List-assign str array surrounded by literals (3)
            ok 7263 - List-assign str array surrounded by literals (4)
            ok 7264 - List-assign str array surrounded by literals (5)
            ok 7265 - List-assign untyped array of Str to str array (1)
            ok 7266 - List-assign untyped array of Str to str array (2)
            ok 7267 - List-assign untyped array of Str to str array (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 7268 - List-assigning incompatible untyped array to str array dies
            ok 7269 - Smartmatching same str arrays works
            ok 7270 - Can we sort str array
            ok 7271 - Can we sort 2-element sorted str array
            ok 7272 - Can we sort 1-element sorted str array
# FUDGED!
            1..183
            # Testing str array
            ok 7273 - str array type is Positional
            ok 7274 - str array type is Positional[str]
            ok 7275 - str array type .of is str
            ok 7276 - str array is Positional
            ok 7277 - str array is Positional[str]
            ok 7278 - str array .of is str
            ok 7279 - str array is Positional
            ok 7280 - str array is Positional[str]
            ok 7281 - str array .of is str
            ok 7282 - .new from str array is Positional
            ok 7283 - .new from str array Positional[str]
            ok 7284 - .new from str array .of is str
            ok 7285 - New str array has no elems
            ok 7286 - New str array has end of -1
            ok 7287 - New str array Int-ifies to 0
            ok 7288 - New str array numifies to 0
            ok 7289 - New str array is falsey
            ok 7290 - Empty str array is not lazy
            ok 7291 - # SKIP non-existing str elements return null_s
            ok 7292 - Elems do not grow just from an access on str array
            ok 7293 - Can store string in an str array
            ok 7294 - Can get value from str array
            ok 7295 - The elems grew as expected on str array
            ok 7296 - str array becomes truthy when it has an element
            ok 7297 - Can slice-assign to an str array
            ok 7298 - Can get slice-assigned value from str array (1)
            ok 7299 - Can get slice-assigned value from str array (2)
            ok 7300 - The elems grew as expected on str array
            ok 7301 - The end value matches grown elems on str array
            ok 7302 - Int-ifies to grown number of elems on str array
            ok 7303 - Numifies to grown number of elems on str array
            ok 7304 - str array with values is not lazy
            ok 7305 - Can assign non-contiguously to str array
            ok 7306 - # SKIP non-existing str elements return null_s
            ok 7307 - Non-contiguous assignment works on str array
            ok 7308 - Can also get last element on str array
            ok 7309 - Can clear str array by assigning empty list
            ok 7310 - Cleared str array has no elems
            ok 7311 - Cleared str array has end of -1
            ok 7312 - Cleared str array Int-ifies to 0
            ok 7313 - Cleared str array numifies to 0
            ok 7314 - Cleared str array is falsey
            ok 7315 - Can assign Str range to str array
            ok 7316 - Got correct elems from range assign on str array
            ok 7317 - Got correct element from range assign on str array (1)
            ok 7318 - Got correct element from range assign on str array (2)
            ok 7319 - :exists works on str array (1)
            ok 7320 - :exists works on str array (2)
            ok 7321 - :exists works on str array (3)
            ok 7322 - Can call str array constructor with a single value
            ok 7323 - Correct number of elems set in constructor of str array
            ok 7324 - Correct element value set by constructor of str array
            ok 7325 - Can call str array constructor with values
            ok 7326 - Correct number of elems set in constructor of str array
            ok 7327 - Correct elem value set by constructor of str array (1)
            ok 7328 - Correct elem value set by constructor of str array (2)
            ok 7329 - Correct elem value set by constructor of str array (3)
            ok 7330 - Correct elem value set by constructor of str array (4)
            ok 7331 - Can also get last 2 elements on str array
            ok 7332 - str array .flat returns a Seq
            ok 7333 - str array .eager returns identity
            ok 7334 - Can iterate over str array
            ok 7335 - Mutating for loop on str array works (1)
            ok 7336 - Mutating for loop on str array works (2)
            ok 7337 - Mutating for loop on str array works (3)
            ok 7338 - Mutating for loop on str array works (4)
            ok 7339 - Can map over str array
            ok 7340 - Mutating map on str array works (1)
            ok 7341 - Mutating map on str array works (2)
            ok 7342 - Mutating map on str array works (3)
            ok 7343 - Mutating map on str array works (4)
            ok 7344 - Can grep a str array
            ok 7345 - str array.grep(Str)
            ok 7346 - str array.grep(Str, :k)
            ok 7347 - str array.grep(Str, :kv)
            ok 7348 - str array.grep(Str, :p)
            ok 7349 - str array.grep(Str, :v)
            ok 7350 - str array.grep(Str)
            ok 7351 - str array.grep(Str, :k)
            ok 7352 - str array.grep(Str, :kv)
            ok 7353 - str array.grep(Str, :p)
            ok 7354 - str array.grep(Str, :v)
            ok 7355 - Can use reduce meta-op on a str array
            ok 7356 - .values from a str array
            ok 7357 - .pairup from a str array
            ok 7358 - .keys from a str array
            ok 7359 - .pairs from a str array
            ok 7360 - .antipairs from a str array
            ok 7361 - .kv from a str array
            ok 7362 - .pick from a str array
            ok 7363 - .roll from a str array
            ok 7364 - str array.unique
            ok 7365 - str array.repeated
            ok 7366 - str array.squish
                1..4
                ok 1 - code dies
                ok 2 - right exception type (X::Cannot::Empty)
                ok 3 - .what matches array[str]
                ok 4 - .action matches pop
            ok 7367 - Trying to pop an empty str array dies
                1..4
                ok 1 - code dies
                ok 2 - right exception type (X::Cannot::Empty)
                ok 3 - .what matches array[str]
                ok 4 - .action matches shift
            ok 7368 - Trying to shift an empty str array dies
            ok 7369 - can push to str array
            ok 7370 - push to str array works (1)
            ok 7371 - push to str array works (2)
                1..3
                ok 1 - code dies
                ok 2 - right exception type (X::TypeCheck)
                ok 3 - .got matches (Int)
            ok 7372 - Cannot push non-str/Str to str array
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 7373 - Cannot bind to str array
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 7374 - Cannot delete from str array
            ok 7375 - can push multiple to str array
            ok 7376 - push multiple to str array works (1)
            ok 7377 - push multiple to str array works (2)
            ok 7378 - push multiple to str array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 7379 - Cannot push non-str/Str to str array (multiple push)
            ok 7380 - can append to str array
            ok 7381 - append to str array works (1)
            ok 7382 - append to str array works (2)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 7383 - Cannot append non-str/Str to str array
            ok 7384 - can append multiple to str array
            ok 7385 - append multiple to str array works (1)
            ok 7386 - append multiple to str array works (2)
            ok 7387 - append multiple to str array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 7388 - Cannot append non-str/Str to str array (multiple append)
            ok 7389 - pop from str array works (1)
            ok 7390 - pop from str array works (2)
            ok 7391 - can unshift to str array
            ok 7392 - unshift to str array works (1)
            ok 7393 - unshift to str array works (2)
            ok 7394 - unshift to str array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 7395 - Cannot unshift non-str/Str to str array
            ok 7396 - can unshift multiple to str array
            ok 7397 - unshift multiple to str array works (1)
            ok 7398 - unshift multiple to str array works (2)
            ok 7399 - unshift multiple to str array works (3)
            ok 7400 - unshift multiple to str array works (4)
            ok 7401 - unshift multiple to str array works (5)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 7402 - Cannot unshift non-str/Str to str array (multiple unshift)
            ok 7403 - can prepend to str array
            ok 7404 - prepend to str array works (1)
            ok 7405 - prepend to str array works (2)
            ok 7406 - prepend to str array works (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 7407 - Cannot prepend non-str/Str to str array
            ok 7408 - can prepend multiple to str array
            ok 7409 - unshift multiple to str array works (1)
            ok 7410 - prepend multiple to str array works (2)
            ok 7411 - prepend multiple to str array works (3)
            ok 7412 - prepend multiple to str array works (4)
            ok 7413 - prepend multiple to str array works (5)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 7414 - Cannot prepend non-str/Str to str array (multiple unshift)
            ok 7415 - shift from str array works (1)
            ok 7416 - shift from str array works (2)
            ok 7417 - can initialize str from Range
            ok 7418 - Number of elems after splice str array
            ok 7419 - Splice on str array did the right thing (1)
            ok 7420 - Splice on str array did the right thing (2)
            ok 7421 - Splice on str array did the right thing (3)
            ok 7422 - Splice on str array did the right thing (4)
            ok 7423 - Splice on str array did the right thing (5)
            ok 7424 - Number of returned spliced values from str array
            ok 7425 - Correct value in splice returned from str array (1)
            ok 7426 - Correct value in splice returned from str array (2)
            ok 7427 - .Str space-separates on str array
            ok 7428 - .gist space-separates on str array
            ok 7429 - .raku includes type and int values on str array
            ok 7430 - does slice return same type
            ok 7431 - does slice handle containerized range
            ok 7432 - Flattening str array in call works
            ok 7433 - does join a str array
            ok 7434 - does emptying a str array really empty
            ok 7435 - does join handle holes in a str array
            ok 7436 - Smartmatching same str arrays works
            ok 7437 - Smartmatching different str arrays works
            ok 7438 - Can we sort str array
            ok 7439 - Can we sort 2-element sorted str array
            ok 7440 - Can we sort 2-element unsorted str array
            ok 7441 - Can we sort 1-element str array
            ok 7442 - Can we sort 0-element str array
            ok 7443 - List-assigning str array to untyped works (1)
            ok 7444 - List-assigning str array to untyped works (2)
            ok 7445 - List-assigning str array to untyped works (3)
            ok 7446 - List-assign str array surrounded by literals (1)
            ok 7447 - List-assign str array surrounded by literals (2)
            ok 7448 - List-assign str array surrounded by literals (3)
            ok 7449 - List-assign str array surrounded by literals (4)
            ok 7450 - List-assign str array surrounded by literals (5)
            ok 7451 - List-assign untyped array of Str to str array (1)
            ok 7452 - List-assign untyped array of Str to str array (2)
            ok 7453 - List-assign untyped array of Str to str array (3)
                1..2
                ok 1 - code dies
                ok 2 - right exception type (Exception)
            ok 7454 - List-assigning incompatible untyped array to str array dies
            ok 7455 - did we survive the hole
# FUDGED!
            1..17
            ok 7456 - A) merge multis without protos
            ok 7457 - A) doesn't import non-exported multis
            ok 7458 - A) doesn't dispatch to wrong signature
            ok 7459 - B) merge multis with proto in module
            ok 7460 - C) merge multis with proto before import
            ok 7461 - C) our multi is still there
                1..3
                not ok 1 - 'proto sub Dfoo( Mu ) { * }' died # TODO huh?
                # Failed test ''proto sub Dfoo( Mu ) { * }' died'
                # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S11-modules/import-multi.rakudo line 52
                ok 2 - # SKIP Code did not die, can not check exception
                ok 3 - # SKIP Code did not die, can not check exception
            not ok 7462 - did we throws-like X::Redeclaration? # TODO huh?
            # Failed test 'did we throws-like X::Redeclaration?'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S11-modules/import-multi.rakudo line 52
            ok 7463 - D) merge multis with proto after import
            ok 7464 - D) our multi is still there
            ok 7465 - E) merge multis with proto before import and in module
            ok 7466 - E) our multi is still there
                1..3
                not ok 1 - 'proto sub Ffoo( Mu ) { * }' died # TODO it just dies, can't check using throws-like
                # Failed test ''proto sub Ffoo( Mu ) { * }' died'
                # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S11-modules/import-multi.rakudo line 82
                ok 2 - # SKIP Code did not die, can not check exception
                ok 3 - # SKIP Code did not die, can not check exception
            not ok 7467 - did we throws-like X::Redeclaration? # TODO it just dies, can't check using throws-like
            # Failed test 'did we throws-like X::Redeclaration?'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S11-modules/import-multi.rakudo line 82
            ok 7468 - F) merge multis with proto after import and in module
            ok 7469 - F) our multi is still there
            ok 7470 - # SKIP A symbol "&Gfoo" has already been exported
            ok 7471 - H) trait "is awesome" applied
            ok 7472 - H) standard traits like "is export" still work
# FUDGED!
            1..8
            # Test for class attribute initialization
            not ok 7473 - Try to initialize public attribute
            # Failed test 'Try to initialize public attribute'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-attributes/augment-and-initialization.rakudo line 19
            # Error: You tried to augment class T1, but it does not exist
            not ok 7474 - Try to initialize private attribute
            # Failed test 'Try to initialize private attribute'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-attributes/augment-and-initialization.rakudo line 22
            # Error: You tried to augment class T2, but it does not exist
            not ok 7475 - non-compiling test # TODO Unimplemented yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-attributes/augment-and-initialization.rakudo line 40
            ok 7476 - Try to access the initialized private attribute.
            not ok 7477 - Testing value for initialized private attribue. # TODO Augmentation attributes support is not implemented
            # Failed test 'Testing value for initialized private attribue.'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-attributes/augment-and-initialization.rakudo line 44
            # expected: '2'
            #      got: (Nil)
            not ok 7478 - non-compiling test # TODO Unimplemented yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-attributes/augment-and-initialization.rakudo line 53
            ok 7479 - Try to access the private attribute which is initialized by constructor.
            not ok 7480 - Testing value for private attribue which is initialized by constructor. # TODO Augmentation attributes support is not implemented
            # Failed test 'Testing value for private attribue which is initialized by constructor.'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-attributes/augment-and-initialization.rakudo line 57
            # expected: '4'
            #      got: (Nil)
# FUDGED!
            1..152
                1..2
                ok 1 - 'has $.x;' died
                ok 2 - right exception type (X::Attribute::NoPackage)
            ok 7481 - 'has' only works inside of class|role definitions
            ok 7482 - ... our Foo1 instance was created
            ok 7483 - .. checking autogenerated accessor existence
            ok 7484 - ... $foo.can("bar") should have returned true
            ok 7485 - .. autogenerated accessor works
            ok 7486 - .. autogenerated accessor works w/out parens
            ok 7487 - ... our Foo2 instance was created
            ok 7488 - .. checking autogenerated accessor existence
            ok 7489 - .. autogenerated accessor works
            ok 7490 - .. autogenerated accessor works w/out parens
            ok 7491 - attributes are ro by default
            ok 7492 - ... our Foo3 instance was created
            ok 7493 - .. checking autogenerated accessor existence
            ok 7494 - ... $foo.can("bar") should have returned true
            ok 7495 - .. autogenerated accessor works
            ok 7496 - .. autogenerated mutator as lvalue works
            ok 7497 - .. autogenerated mutator as lvalue set the value correctly
            ok 7498 - ... our Foo4 instance was created
            ok 7499 - .. checking autogenerated accessor existence
            ok 7500 - ... our Foo4a instance was created
            ok 7501 - .. checking autogenerated accessor existence
            ok 7502 - ... our Foo5 instance was created
            ok 7503 - setting a public rw attribute
            ok 7504 - getting a public rw attribute
            ok 7505 - setting a public ro attribute (1)
            ok 7506 - getting a public ro attribute (1)
            not ok 7507 - setting a public ro attribute (2) # TODO ro on list attributes
            # Failed test 'setting a public ro attribute (2)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-attributes/instance.rakudo line 107
            not ok 7508 - getting a public ro attribute (2) # TODO ro on list attributes
            # Failed test 'getting a public ro attribute (2)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-attributes/instance.rakudo line 110
            # expected: '2'
            #      got: '5'
            ok 7509 - modifiying a private attribute (1)
            ok 7510 - getting a private attribute (1)
            ok 7511 - modifiying a private attribute (2)
            ok 7512 - getting a private attribute (2)
            ok 7513 - ... our Foo6 instance was created
            ok 7514 - getting a public rw attribute (1)
            ok 7515 - getting a public ro attribute (2)
            ok 7516 - getting a private ro attribute (3)
            ok 7517 - ... our Foo6a instance was created
            ok 7518 - getting a public rw attribute (1)
            ok 7519 - getting a public rw attribute (2)
            ok 7520 - getting a private ro attribute (3)
            ok 7521 - ... our Foo6b instance was created
            ok 7522 - getting a public rw attribute (1)
            ok 7523 - getting a public rw attribute (2)
            ok 7524 - default attribute value (1)
            ok 7525 - default attribute value (4)
            ok 7526 - forty_two_supplier() was actually executed
            ok 7527 - forty_two_supplier() is executed per instantiation
            ok 7528 - optional attribute should take default value without passed-in value
            ok 7529 - ... optional non-attribute should too
            ok 7530 - optional attribute should take passed-in value over default
            ok 7531 - ... optional non-attribute should too
            ok 7532 - ... our Foo8 instance was created
            ok 7533 - BUILD received $foo
            ok 7534 - BUILD received $bar
            ok 7535 - cannot pass positional to .new
            ok 7536 - ... our Foo10 instance was created
            ok 7537 - BUILD received $foo
            ok 7538 - BUILD received $bar
            ok 7539 - BUILD received $self
            ok 7540 - .WHAT on attributes
            ok 7541 - .WHAT on attributes of same type as class
            ok 7542 - type check on recursive data structure
            ok 7543 - .WHAT on recursive data structure
            ok 7544 - use of self in closure on RHS of attr init works
            ok 7545 - attribute cloned
            ok 7546 - attribute cloned
            ok 7547 - changed attribute on clone...
            ok 7548 - ...and original not affected
            ok 7549 - clone with parameters...
            ok 7550 - ...leaves original intact...
            ok 7551 - ...and copies what we did not change.
            ok 7552 - original object not modified
            ok 7553 - cloned object has its own attributes
            ok 7554 - original object not modified
            ok 7555 - cloned object has new attributes
            ok 7556 - @.a[0] works
            ok 7557 - @.a[*-2] works
            ok 7558 - @.a[*-1] works
            ok 7559 - Can index array attributes with non-integers
            not ok 7560 - can not assign to @.array attribute # TODO ro array/hash with accessor
            # Failed test 'can not assign to @.array attribute'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-attributes/instance.rakudo line 382
            not ok 7561 - can not assign to %.hash attribute # TODO ro array/hash with accessor
            # Failed test 'can not assign to %.hash attribute'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-attributes/instance.rakudo line 383
            ok 7562 - can assign to @!array attribute
            ok 7563 - can assign to %!hash attribute
            ok 7564 - could use whitespace after "has ("
            ok 7565 - .. and a newline within the has() declarator
            ok 7566 - === works on typed attribute initialized with proto-object
            ok 7567 - C_Test.new().a worked
            ok 7568 - my $o = f(); $o.a worked
            ok 7569 - f().a worked (part 1)
            ok 7570 - g().a worked (part 2)
            ok 7571 - Initialized outside constructor
            ok 7572 - Get appears to have worked
            ok 7573 - Get Worked!
            ok 7574 - Initialized inside constructor
            ok 7575 - Get appears to have worked
            ok 7576 - Get Worked!
            ok 7577 - created object with typed attributes
            ok 7578 - typed public array attribute is empty
            ok 7579 - typed public hash attribute is empty
            ok 7580 - typed private array attribute is empty
            ok 7581 - typed private hash attribute is empty
            ok 7582 - array attribute is typed
            ok 7583 - Can assign to typed drw-array-attrib
            ok 7584 - Can insert into typed rw-array-attrib
            ok 7585 - Can push onto typed rw-array-attrib
            ok 7586 - ... all of the above actually worked (not only lived)
            ok 7587 - type enforced on array attrib (assignment)
            ok 7588 - type enforced on array attrib (item assignment)
            ok 7589 - type enforced on array attrib (push)
            ok 7590 - no autovivification (typed array)
            not ok 7591 - ... all of the above actually did nothing (not just died) # TODO over-eager auto-vivification bugs
            # Failed test '... all of the above actually did nothing (not just died)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-attributes/instance.rakudo line 478
            # expected: '2|3|4|5'
            #      got: '2|3|4|5|1'
            ok 7592 - hash attribute is typed
            ok 7593 - assign to typed hash attrib
            ok 7594 - insertion into typed hash attrib
            ok 7595 - pushing onto typed hash attrib
            ok 7596 - ... all of them worked
            ok 7597 - Type enforced (hash, assignment)
            ok 7598 - Type enforced (hash, insertion)
            ok 7599 - Type enforced (hash, push)
            ok 7600 - No autovivification (typed hash)
            ok 7601 - hash still unchanged
            ok 7602 - Can initialize one attribute based on another (1)
            ok 7603 - Can initialize one attribute based on another (2)
            ok 7604 - Can initialize one attribute based on another (3)
            ok 7605 - &!m = sub { ... } works and an be called
            ok 7606 - &.a = { ... } works and also declares &!a
            ok 7607 - &.a has accessor returning closure
            ok 7608 - &!m = method { ... } and self.&!m() work
            ok 7609 - Test class include another class which inherited from same role
            ok 7610 - dies: trying to modify instance attribute when invocant is type object
            ok 7611 - binding to an attribute works
            ok 7612 - # SKIP dubious test - the initializer becomes a submethod here, implying a scope RT  \#124908
            ok 7613 - Can call a method all()
            ok 7614 - Can use outer lexicals in attribut initialization
            ok 7615 - Can use lexicals in attribut initialization
            ok 7616 - list assignment to attributes (1)
            ok 7617 - list assignment to attributes (type)
            ok 7618 - list assignment to attributes (2)
            ok 7619 - presence of BUILD does not prevent assignment of default values
                1..2
                ok 1 - 'my class AccessorClash { has @.a; has &.a }' died
                ok 2 - right exception type (Exception)
            ok 7620 - cannot have two attributes with same accessor name
                1..2
                ok 1 - 'class RT74274 { has $!a }; my $a = RT74274.new(a => 42);
                #     my $method = method { return $!a }; $a.$method()' died
                ok 2 - right exception type (Exception)
            ok 7621 - cannot sneak in access to private attribute through the backdoor
            ok 7622 - Scalar containers respected in attribute initialization
            ok 7623 - Can use .list to remove container
            ok 7624 - initializing with [...] follows one-arg rule
            ok 7625 - initializing with $[...] is still one item
            ok 7626 - Attribute declaration can be in sub-scope too
            ok 7627 - can shadow an attribute with a lexical
            ok 7628 - can 'is rw' multiple declared has attributes
                1..5
                ok 1 - 'class Zapis { has $.a is bar; }' died
                ok 2 - right exception type (X::Comp::Trait::Unknown)
                ok 3 - .subtype matches bar
                ok 4 - .declaring matches n attribute
                ok 5 - .type matches is
            ok 7629 - did we throws-like X::Comp::Trait::Unknown?
                1..5
                ok 1 - 'class Zapwill { has $.a will bar { ... } }' died
                ok 2 - right exception type (X::Comp::Trait::Unknown)
                ok 3 - .declaring matches n attribute
                ok 4 - .subtype matches bar
                ok 5 - .type matches will
            ok 7630 - did we throws-like X::Comp::Trait::Unknown?
            ok 7631 - is rw accessor method marked rw
            ok 7632 - readonly accessor method not marked rw
# FUDGED!
            1..14
            ok 7633 - normal attribute
            ok 7634 - can't change a non-rw attribute
            ok 7635 - attribute didn't change value
            ok 7636 - mutators not called yet
            ok 7637 - mutator called during object construction
            ok 7638 - accessor by sub was called 
            ok 7639 - mutator by sub was called
            ok 7640 - attribute with overridden mutator by sub
            ok 7641 - accessor and mutator by sub were called
            ok 7642 - # SKIP RT  \#126198
            ok 7643 - # SKIP RT  \#126198
            ok 7644 - # SKIP RT  \#126198
            ok 7645 - # SKIP RT  \#126198
            ok 7646 - # SKIP RT  \#126198
# FUDGED!
            1..49
            ok 7647 - Can read ro int attr default value
            ok 7648 - Can read ro num attr default value
            ok 7649 - Can read ro str attr default value
            ok 7650 - Cannot write to native int ro attr
            ok 7651 - Cannot write to native num ro attr
            ok 7652 - Cannot write to native str ro attr
            ok 7653 - Can read rw int attr default value
            ok 7654 - Can read rw num attr default value
            ok 7655 - Can read rw str attr default value
            ok 7656 - Can write to native int rw attr
            ok 7657 - Can write to native num rw attr
            ok 7658 - Can write to native str rw attr
            ok 7659 - Can read back rw int attr changed value
            ok 7660 - Can read back rw num attr changed value
            ok 7661 - Can read back rw str attr changed value
            ok 7662 - Attributes really updated
            ok 7663 - Cannot update int rw attr with non-int (1)
            ok 7664 - Cannot update int rw attr with non-int (2)
            ok 7665 - Cannot update num rw attr with non-num (1)
            ok 7666 - Cannot update num rw attr with non-num (2)
            ok 7667 - Cannot update str rw attr with non-str (1)
            ok 7668 - Cannot update str rw attr with non-str (2)
            ok 7669 - Can read ro int attr value from constructor
            ok 7670 - Can read ro num attr value from constructor
            ok 7671 - Can read ro str attr value from constructor
            ok 7672 - Can read rw int attr value from constructor
            ok 7673 - Can read rw num attr value from constructor
            ok 7674 - Can read rw str attr value from constructor
            ok 7675 - Can write to native int rw attr set by constructor
            ok 7676 - Can write to native num rw attr set by constructor
            ok 7677 - Can write to native str rw attr set by constructor
            ok 7678 - Can read back rw int attr changed value
            ok 7679 - Can read back rw num attr changed value
            ok 7680 - Can read back rw str attr changed value
            ok 7681 - Attributes really updated
            ok 7682 - Non-twigil native attr defaults work
            ok 7683 - Can set non-twigil native int attr
            ok 7684 - The update took effect
            ok 7685 - Can set non-twigil native num attr
            ok 7686 - The update took effect
            ok 7687 - Can set non-twigil native str attr
            ok 7688 - The update took effect
                1..2
                ok 1 - code dies
                ok 2 - right exception type (X::Syntax::NoSelf)
            ok 7689 - did we throws-like X::Syntax::NoSelf?
            ok 7690 - uint64 native attribute accessor works
            ok 7691 - uint64 native attribute use in method works
            not ok 7692 - large unsigned ints
            # Failed test 'large unsigned ints'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-attributes/native.rakudo line 138
            # expected: 255
            #      got: -1
            ok 7693 - unsigned int sanity
            not ok 7694 - large unsigned ints # TODO RT #131122
            # Failed test 'large unsigned ints'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-attributes/native.rakudo line 150
            # expected: 200
            #      got: -56
                1..5
                ok 1 - run 1
                ok 2 - run 2
                ok 3 - run 3
                ok 4 - run 4
                ok 5 - run 5
            ok 7695 - ops on native attributes
# FUDGED!
            1..18
            ok 7696 - instantiated the class
            ok 7697 - isa check works
            not ok 7698 - .WHAT.gist stringifies to () # TODO Anonymous class stringification (?)
            # Failed test '.WHAT.gist stringifies to ()'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-class/anonymous.rakudo line 15
            # expected: '()'
            #      got: '(<anon|27>)'
            ok 7699 - can call methods on anonymous classes
            ok 7700 - can call methods on anonymous classes
            ok 7701 - anonymous classes can have attributes
            ok 7702 - anonymous class creation
            ok 7703 - instantiation of anonymous class
            ok 7704 - calling a method on an instance of an anonymous class (1)
            ok 7705 - calling a method on an instance of an anonymous class (2)
            ok 7706 - anonymous class isa TestParent
            ok 7707 - inherited method from TestParent
            ok 7708 - can get anonymous class instance once
            ok 7709 - can get anonymous class instance twice
            ok 7710 - anonymous class stringified works
            ok 7711 - anonymous class numified works
                1..2
                ok 1 - 'anon class C { }; C.WHAT; ' died
                ok 2 - right exception type (X::Undeclared::Symbols)
            ok 7712 - anon class is actually anon
            ok 7713 - anonymous classes are distinct
# FUDGED!
            1..14
            ok 7714 - basic method call works
            ok 7715 - added method call works
            ok 7716 - augment on non-existent class dies
            ok 7717 - can augment lexical class
            ok 7718 - can augment Hash
                1..2
                ok 1 - '
                #     class MethodClash { method foo() { 3 } };
                #     augment class MethodClash { method foo() { 3 } };
                # ' died
                ok 2 - right exception type (X::Syntax::Augment::WithoutMonkeyTyping)
            ok 7719 - cannot override a method by monkey-typing
            ok 7720 - augmenting a class which has a role composed works
            ok 7721 - # SKIP redeclaration of symbol Bar
            ok 7722 - # SKIP redeclaration of symbol Bar
            ok 7723 - cannot add multis with augment
            ok 7724 - integers produced from ranges have augmented methods
            ok 7725 - used to crash rakudo
            ok 7726 - used to crash rakudo
            not ok 7727 - Augmenting a nested package lives
            # Failed test 'Augmenting a nested package lives'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-class/augment-supersede.rakudo line 108
            # Error: Redeclaration of symbol 'A'.
# FUDGED!
            1..7
            ok 7728 - instantiated a class
            ok 7729 - initializing attributes in new
            ok 7730 - death to instantiating nonexistent class
            ok 7731 - error for "NoSuchClass.new()" mentions NoSuchClass
            ok 7732 - death to instantiating nonexistent::class
            not ok 7733 - error for "NoSuch::Subclass.new()" mentions NoSuch::Subclass # TODO error reporting
            # Failed test 'error for "NoSuch::Subclass.new()" mentions NoSuch::Subclass'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-class/instantiate.rakudo line 34
            ok 7734 - instantiating from class name string creates a Str object
# FUDGED!
            1..3
            ok 7735 - set attribute
            ok 7736 - # SKIP initialization of parent attributes
            ok 7737 - # SKIP initialization of parent attributes
# FUDGED!
            1..9
            ok 7738 - Can stub a class, and later on declare it
            ok 7739 - Can stub a role, and later on declare it
            ok 7740 - Can stub a module, and later on declare it
            not ok 7741 - Can stub a package, and later on implement it as a class # TODO nom regression
            # Failed test 'Can stub a package, and later on implement it as a class'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-class/stubs.rakudo line 17
            # Error: The following packages were stubbed but not defined:
            #     Test::StubD
                1..2
                ok 1 - 'my class StubbedButNotDeclared { ... }' died
                ok 2 - right exception type (X::Package::Stubbed)
            ok 7742 - stubbing a class but not providing a definition dies
                1..3
                ok 1 - code dies
                ok 2 - right exception type (X::Package::Stubbed)
                not ok 3 - .message matches The following packages were stubbed but not defined:
                #     A
                # Failed test '.message matches The following packages were stubbed but not defined:
                #                 #     A'
                # at SETTING::src/core.c/Any-iterable-methods.pm6 line 627
                # Expected: The following packages were stubbed but not defined:
                #     A
                # Got:      The following packages were stubbed but not defined:
                #     Abyss::Server::Mod::A
                # You failed 1 test of 3
            not ok 7743 - did we throws-like X::Package::Stubbed?
            # Failed test 'did we throws-like X::Package::Stubbed?'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-class/stubs.rakudo line 25
                1..4
                ok 1 - code dies
                ok 2 - right exception type (X::Inheritance::NotComposed)
                not ok 3 - .parent-name matches A
                # Failed test '.parent-name matches A'
                # at SETTING::src/core.c/Any-iterable-methods.pm6 line 627
                # Expected: A
                # Got:      Abyss::Server::Mod::A
                not ok 4 - .child-name matches B
                # Failed test '.child-name matches B'
                # at SETTING::src/core.c/Any-iterable-methods.pm6 line 627
                # Expected: B
                # Got:      Abyss::Server::Mod::B
                # You failed 2 tests of 4
            not ok 7744 - did we throws-like X::Inheritance::NotComposed?
            # Failed test 'did we throws-like X::Inheritance::NotComposed?'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-class/stubs.rakudo line 28
                1..2
                    1..4
                    ok 1 - …
                    ok 2 - ...
                    ok 3 - !!!
                    ok 4 - ???
                ok 1 - lives when stubbed, then defined
                    1..4
                        1..2
                        ok 1 - 'my class Foo { …   }' died
                        ok 2 - right exception type (X::Package::Stubbed)
                    ok 1 - …
                        1..2
                        ok 1 - 'my class Foo { ... }' died
                        ok 2 - right exception type (X::Package::Stubbed)
                    ok 2 - ...
                        1..2
                        ok 1 - 'my class Foo { !!! }' died
                        ok 2 - right exception type (X::Package::Stubbed)
                    ok 3 - !!!
                        1..2
                        ok 1 - 'my class Foo { ??? }' died
                        ok 2 - right exception type (X::Package::Stubbed)
                    ok 4 - ???
                ok 2 - throws when stubbed, and never defined
            ok 7745 - all forms of yadas work to stub classes
            ok 7746 - Can stub a class in a core namespace
# FUDGED!
            1..28
            ok 7747 - coercion type on the inside
            ok 7748 - Coercion type coerces
            ok 7749 - Coercion type coerces to correct value
                1..2
                ok 1 - ' sub g(Str(Cool) $x) { $x }; g(Any) ' died
                ok 2 - right exception type (X::TypeCheck::Binding)
            ok 7750 - coercion type still type-checks
Impossible coercion from 'Abyss::Server::Mod::Parent' into 'Abyss::Server::Mod::Child': no acceptable coercion method found
  in sub c at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-coercion/coercion-types.rakudo line 33
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-coercion/coercion-types.rakudo line 34
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-coercion/coercion-types.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

            1..12
            ok 7751 - Called Parent's BUILD method once
            ok 7752 - Called Child's BUILD method once
            ok 7753 - submethods were called in right order (Parent first)
            ok 7754 - submethods were called with the correct arguments
            ok 7755 - can call child's methods in parent's BUILD
            ok 7756 - initilized called in the right order (MI)
            ok 7757 - BUILD called once
            not ok 7758 - method BUILD produces a compile-time warning # TODO method BUILD should warn
            # Failed test 'method BUILD produces a compile-time warning'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-construction/BUILD.rakudo line 99
            #      got err: ""
            ok 7759 - can call BUILD without providing a value for a !-twigiled named parameter
            ok 7760 - BUILD provided by role can use attributes in signature
                1..2
                ok 1 - code returned a Failure
                    1..3
                    ok 1 - code dies
                    ok 2 - right exception type (X::AdHoc)
                    ok 3 - .message matches noway
                ok 2 - Failure threw when sunk
            ok 7761 - fail in BUILD works
                1..15
                ok 1 - str
                ok 2 - byte
                ok 3 - int
                ok 4 - int8
                ok 5 - int16
                ok 6 - int32
                ok 7 - int64
                ok 8 - uint
                ok 9 - uint8
                ok 10 - uint16
                ok 11 - uint32
                ok 12 - uint64
                ok 13 - num
                ok 14 - num32
                ok 15 - num64
            ok 7762 - BUILD with a native typed attribute
# FUDGED!
            1..28
            ok 7763 - can instantiate class with parent attributes
            ok 7764 - ... worked for the child
            ok 7765 - ... worked for the parent
            ok 7766 - # SKIP parent attributes in initialization
            ok 7767 - # SKIP parent attributes in initialization
            ok 7768 - # SKIP parent attributes in initialization
            ok 7769 - # SKIP parent attributes in initialization
            ok 7770 - # SKIP parent attributes in initialization
            ok 7771 - # SKIP parent attributes in initialization
            ok 7772 - # SKIP parent attributes in initialization
            ok 7773 - # SKIP parent attributes in initialization
            ok 7774 - # SKIP parent attributes in initialization
            ok 7775 - NewClass is not .defined
            ok 7776 - class asked to build itself refuses
            ok 7777 - NewClass is still not .defined
            not ok 7778 - die trying to instantiate missing class # TODO nested package handling does't quite get this one right
            # Failed test 'die trying to instantiate missing class'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-construction/new.rakudo line 67
            ok 7779 - can delegate to self.Mu::new
            ok 7780 - ... got the right attribute (1)
            ok 7781 - ... got the right attribute (2)
            ok 7782 - Mu.new is a multi method
            ok 7783 - multi-constructor class alternate (positional) constructor
            ok 7784 - multi-constructor class alternate default named constructor
            ok 7785 - Can call nextwith in .new
            ok 7786 - RT  \#100780
            ok 7787 - multi method($) does not break attribute initialization
            ok 7788 - Can call .=new on a variable of a lexical type
            ok 7789 - Initialization of attributes in multiple inheritance works (1)
            ok 7790 - Initialization of attributes in multiple inheritance works (2)
# FUDGED!
Potential difficulties:
    Redeclaration of symbol 'b and c'.
    at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-enums/basic.rakudo:127
    ------> [32m    my enum S2 <b c d>[33m⏏[31m;[0m
            1..54
            ok 7791 - First item of an enum is 0
            ok 7792 - Last item has the right value
            ok 7793 - Values exported into namespace too.
            ok 7794 - Values exported into namespace too.
            ok 7795 - Can construct ranges from Pair values
            ok 7796 - Can do arithmetics with Pair values
            not ok 7797 - Can test with .does() for enum type # TODO rakudo#1296 butting issue on Str and Enum
            # Failed test 'Can test with .does() for enum type'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-enums/basic.rakudo line 31
            not ok 7798 - Can smartmatch for enum type # TODO rakudo#1296 butting issue on Str and Enum
            # Failed test 'Can smartmatch for enum type'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-enums/basic.rakudo line 32
            not ok 7799 - Can Smartmatch for enum value # TODO rakudo#1296 butting issue on Str and Enum
            # Failed test 'Can Smartmatch for enum value'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-enums/basic.rakudo line 33
            not ok 7800 - given/when with enum values # TODO rakudo#1296 butting issue on Str and Enum
            # Failed test 'given/when with enum values'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-enums/basic.rakudo line 39
            # expected: '1'
            #      got: '0'
            not ok 7801 - given/when with enum values # TODO rakudo#1296 butting issue on Str and Enum
            # Failed test 'given/when with enum values'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-enums/basic.rakudo line 45
            # expected: '2'
            #      got: '0'
            ok 7802 - .raku on long form of Pair key
            ok 7803 - .raku on short form of Pair value
            ok 7804 - .key on long form of Pair value
            ok 7805 - .key on short form of Pair value
            ok 7806 - .WHAT.gist on enum value stringifies to the enum name
            ok 7807 - enum with parens works and non-0 starting point works
            ok 7808 - .raku works on enum with parens
            ok 7809 - .key works on enum with parens
            ok 7810 - Pair of one element works.
            ok 7811 - empty enum can be constructed
            ok 7812 - empty enum with () can be constructed
            ok 7813 - can assign enum value to typed variable with long name
            ok 7814 - can assign enum value to typed variable with short name
            ok 7815 - enum as a type enforces checks
            ok 7816 - short name of the enum without parenthesis is an enum
            ok 7817 - short name with parenthesis is a sub
            ok 7818 - Color.pick assigns to Color var
            ok 7819 - Color.pick.isa
            ok 7820 - .pick on enums
            ok 7821 - .pick(2) on enums
            ok 7822 - enum element of enum with double colons is in namespace
            ok 7823 - enum keys (1)
            ok 7824 - enum keys (2)
            ok 7825 - RT  \#75370 enum name
                1..5
                ok 1 - code dies
                ok 2 - right exception type (X::PoisonedAlias)
                ok 3 - .package-name matches S2
                ok 4 - .package-type matches enum
                ok 5 - .alias matches b
            ok 7826 - did we throws-like X::PoisonedAlias?
            ok 7827 - still can access redeclared enum values via package
            ok 7828 - .enums returns a Map
                1..2
                ok 1 - enum element has correct value
                ok 2 - .enums are all correct
            ok 7829 - dynamically created lists can be used to define an enum
                1..3
                ok 1 - first element
                ok 2 - second element
                ok 3 - element with duped value
            ok 7830 - Enumeration:D.kv
                1..3
                ok 1 - first element
                ok 2 - second element
                ok 3 - element with duped value
            ok 7831 - Enumeration:D.pair
                1..3
                ok 1 - first element
                ok 2 - second element
                ok 3 - element with duped value
            ok 7832 - Enumeration:D.Int
                1..10
                ok 1 - .pred on first element, returns first element
                ok 2 - .pred on second element, returns first element
                ok 3 - .pred on 3rd element, returns 2nd element, even if values are same
                ok 4 - .pred on last element, returns previous, even if values are same
                ok 5 - .succ on first element, returns second element
                ok 6 - .succ second element, returns third one, even if values are same
                ok 7 - .succ 4th element, returns 5th element, even if values are same
                ok 8 - .succ last element, returns last element
                ok 9 - .pred on enum with 1 value works
                ok 10 - .succ on enum with 1 value works
            ok 7833 - .pred/.succ
                1..6
                ok 1 - different enums; different values => different
                ok 2 - different enums; same values => different
                ok 3 - type object vs. instance => different
                ok 4 - same enums => same (1)
                ok 5 - same enums => same (2)
                ok 6 - type object vs. type object => same
            ok 7834 - === on different enums with same values
            ok 7835 - Bool.enums returns a Map, not a Hash
            ok 7836 - build enum using Z=> operator properly
            ok 7837 - can build enum using Z=> operator
                1..3
                not ok 1 - Block
                # Failed test 'Block'
                # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-enums/basic.rakudo line 217
                # Error: Redeclaration of symbol 'B'.
                ok 2 - Code
                ok 3 - Code
                # You failed 1 test of 3
            not ok 7838 - can build enum with built-ins' names
            # Failed test 'can build enum with built-ins' names'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-enums/basic.rakudo line 217
            ok 7839 - enums can be created via Seq of Pairs
                1..5
                ok 1 - (1)
                ok 2 - (2)
                ok 3 - (3)
                ok 4 - (4)
                ok 5 - (5)
            ok 7840 - can provide enum values via Pairs
            ok 7841 - can create enum with a Hash
            ok 7842 - "NumericStringyEnumeration" uses key as .Str value
            ok 7843 - Pair elements in the list given to enum declaration work
            ok 7844 - Coercing an enum from a coercion of an enum from an int works
# FUDGED!
            1..6
            ok 7845 - stringy enum first value
            ok 7846 - stringy enum first value
                1..2
                ok 1 - 'my enum B (a => 1, b => "bar")' died
                ok 2 - right exception type (Exception)
            ok 7847 - mixed type enums are forbidden
            not ok 7848 - ... unless that type covers both enum value types # TODO NYI
            # Failed test '... unless that type covers both enum value types'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-enums/non-int.rakudo line 15
            # Error: Incompatible MROs in P6opaque rebless for types Int and C
                1..2
                ok 1 - 'my Str enum D (a => 1)' died
                ok 2 - right exception type (Exception)
            ok 7849 - violating an explicit type constraint dies
            ok 7850 - Str enum correctly uses string-increment
# FUDGED!
            1..60
            ok 7851 - enum itself stringififes
            ok 7852 - enum.WHAT returned a value
            ok 7853 - enum.raku returned a value
            ok 7854 - # SKIP NYI
            ok 7855 - # SKIP NYI
            ok 7856 - # SKIP NYI
            ok 7857 - # SKIP NYI
            ok 7858 - # SKIP NYI
            ok 7859 - # SKIP NYI
            ok 7860 - # SKIP NYI
            ok 7861 - # SKIP NYI
            ok 7862 - # SKIP NYI
            ok 7863 - # SKIP NYI
            ok 7864 - # SKIP NYI
            ok 7865 - # SKIP NYI
            ok 7866 - # SKIP NYI
            ok 7867 - # SKIP NYI
            ok 7868 - # SKIP does day::Tue
            ok 7869 - # SKIP does day::Tue
            ok 7870 - # SKIP does day::Tue
            ok 7871 - # SKIP does day::Tue
            ok 7872 - # SKIP does day::Tue
            ok 7873 - # SKIP does day::Tue
            ok 7874 - # SKIP does day::Tue
            ok 7875 - # SKIP does day::Tue
            ok 7876 - # SKIP does day::Tue
            ok 7877 - # SKIP does day::Tue
            ok 7878 - # SKIP does day::Tue
            ok 7879 - # SKIP does day::Tue
            ok 7880 - # SKIP does day::Tue
            ok 7881 - # SKIP does day::Tue
            ok 7882 - # SKIP does &day::("Tue")
            ok 7883 - # SKIP does &day::("Tue")
            ok 7884 - # SKIP does &day::("Tue")
            ok 7885 - # SKIP does &day::("Tue")
            ok 7886 - # SKIP does &day::("Tue")
            ok 7887 - # SKIP does &day::("Tue")
            ok 7888 - # SKIP does &day::("Tue")
            ok 7889 - # SKIP does &day::("Tue")
            ok 7890 - # SKIP does &day::("Tue")
            ok 7891 - # SKIP does &day::("Tue")
            ok 7892 - # SKIP does &day::("Tue")
            ok 7893 - # SKIP does &day::("Tue")
            ok 7894 - # SKIP does &day::("Tue")
            ok 7895 - # SKIP does &day::("Tue")
            ok 7896 - # SKIP does &day::("Tue")
            ok 7897 - method on short name pick up the one from the enum
            ok 7898 - method on long name pick up the one from the enum
            ok 7899 - True.raku
            ok 7900 - Bool::True.raku
            ok 7901 - simple assignment from enum
            ok 7902 - assignment from enum works
                1..2
                ok 1 - 'RT66886::c' died
                ok 2 - right exception type (Exception)
            ok 7903 - accessing non-value of enum dies proper-like
            ok 7904 - can index enum by number
            ok 7905 - enum and math and index
            ok 7906 - marking enum export does not die
                1..2
(A+{<anon|8>})
                not ok 1 - 'enum rt_101900 < a b >; class A { }; note A but rt_101900::a' died # TODO RT #101900
                # Failed test ''enum rt_101900 < a b >; class A { }; note A but rt_101900::a' died'
                # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-enums/thorough.rakudo line 112
                ok 2 - # SKIP Code did not die, can not check exception
            not ok 7907 - Cannot mixin an enum into a class # TODO RT #101900
            # Failed test 'Cannot mixin an enum into a class'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-enums/thorough.rakudo line 112
            ok 7908 - .can(...) on an enum
            ok 7909 - .^can(...) on an enum
            ok 7910 - Can mix a private method into an enum value
# FUDGED!
            1..38
            ok 7911 - Still alive after new
            ok 7912 - The direct object notation call without arguments
            ok 7913 - The indirect object notation call without arguments without ()
            ok 7914 - The indirect object notation call without arguments with ()
            ok 7915 - Still alive after new
            ok 7916 - The direct object notation call with argument
            ok 7917 - The indirect object notation call with argument without ()
            ok 7918 - The indirect object notation call with argument with ()
Could not find symbol '&Confused' in 'X::Syntax'
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-methods/indirect_notation.rakudo line 45
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-methods/indirect_notation.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

            1..29
            ok 7919 - Foo.new() worked (1)
            ok 7920 - Foo's BUILD was called
            ok 7921 - Bar's BUILD counter not available
            ok 7922 - Bar.new() worked
            ok 7923 - Foo's BUILD was called again
            ok 7924 - Bar's BUILD was called, too
            ok 7925 - Foo.new() worked (2)
            ok 7926 - Foo's BUILD was called again
            ok 7927 - Baz.new() worked
            ok 7928 - Grtz.new() worked
            ok 7929 - can call submethod on parent class
            ok 7930 - Baz's submethod blarb was called
            ok 7931 - Grtz's submethod blarb was not called
            ok 7932 - can call submethod on child class
            ok 7933 - Baz's submethod blarb was not called
            ok 7934 - Grtz's submethod blarb was called now
            ok 7935 - $obj.Class::submthod
            ok 7936 - Baz's submethod blarb was called now
            ok 7937 - Grtz's submethod blarb was not called again
            ok 7938 - # SKIP outer lexicals in roles
            ok 7939 - # SKIP outer lexicals in roles
            ok 7940 - # SKIP roles and submethods
            ok 7941 - # SKIP roles and submethods
            ok 7942 - # SKIP roles and submethods
            ok 7943 - # SKIP roles and submethods
            ok 7944 - BUILD() should allow default values of optional params in signature
            ok 7945 - ... or value passed in
            ok 7946 - Bool method in class is used in boolificiation
            ok 7947 - Bool submethod in class is used in boolificiation
# FUDGED!
            1..91
            ok 7948 - we can compile subtype declarations
            ok 7949 - and we can use them, too
            ok 7950 - and they actually work
            ok 7951 - we can compile subtype declarations
            ok 7952 - and we can use them, too
            ok 7953 - and they actually work
            ok 7954 - subset types refine candidate matches
            ok 7955 - 3 is an odd num
            ok 7956 - objects of Int::Odd don't get even
            ok 7957 - subtypes are undefined
            ok 7958 - calling sub worked
            ok 7959 - calling sub did not work
            ok 7960 - Int accepted by Int::Odd
            ok 7961 - 
            ok 7962 - our var is a Int::Even
            ok 7963 - setting a Int::Even to an odd value dies
            ok 7964 - lexically declared subtype went out of scope
            ok 7965 - basic sanity (1)
            ok 7966 - basic sanity (2)
            ok 7967 - creating a new Num::Multiple
            ok 7968 - creating a new Num::Multiple actually worked
            ok 7969 - negative test also works
            ok 7970 - variable kept previous value
            ok 7971 - changed subtype definition worked
                1..3
                ok 1 - code dies
                ok 2 - right exception type (Exception)
                ok 3 - .message matches 1 is not even
            ok 7972 - custom subset errors can be created with fail()
            ok 7973 - where /regex/ works (positive)
Could not find symbol '&Assignment' in 'X::TypeCheck'
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-subset/subtypes.rakudo line 116
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-subset/subtypes.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

            1..5
            not ok 7974 - &method is implemented, consider unfudging this test # TODO Canary test for &method
            # Failed test '&method is implemented, consider unfudging this test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S13-syntax/aliasing.rakudo line 11
            # Error: Undeclared routine:
            #     bar used at line 1. Did you mean 'VAR', 'bag'?
            # 
            not ok 7975 - ::= is implemented, consider unfudging this test # TODO Canary test for ::=
            # Failed test '::= is implemented, consider unfudging this test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S13-syntax/aliasing.rakudo line 14
            # Error: "::=" not yet implemented. Sorry.
Error while constructing error object:Could not locate compile-time value for symbol Comp::NYI
            not ok 7976 - non-compiling test # TODO Requires &method and ::= to be implemented
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S13-syntax/aliasing.rakudo line 42
            not ok 7977 - non-compiling test # TODO Requires &method and ::= to be implemented
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S13-syntax/aliasing.rakudo line 42
            not ok 7978 - non-compiling test # TODO Requires &method and ::= to be implemented
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S13-syntax/aliasing.rakudo line 42
# FUDGED!
            1..28
            ok 7979 - imperative does to apply a parametrized role (1)
            ok 7980 - attribute was initialized correctly (1)
            ok 7981 - .HOW.does gives correct information (1-1)
            ok 7982 - .^does gives correct information (1-1)
            ok 7983 - .HOW.does gives correct information (1-2)
            ok 7984 - .^does gives correct information (1-2)
            ok 7985 - imperative does to apply a parametrized role (2)
            ok 7986 - attribute was initialized correctly (2)
            ok 7987 - .HOW.does gives correct information (2-1)
            ok 7988 - .^does gives correct information (2-1)
            ok 7989 - .HOW.does gives correct information (2-2)
            ok 7990 - .^does gives correct information (2-2)
            ok 7991 - imperative does to apply a parametrized role (3)
            ok 7992 - .HOW.does gives correct information (3-1)
            ok 7993 - .^does gives correct information (3-1)
            ok 7994 - .HOW.does gives correct information (3-2)
            ok 7995 - .^does gives correct information (3-2)
            ok 7996 - type information was processed correctly (1)
            ok 7997 - type information was processed correctly (2)
            ok 7998 - imperative does to apply a parametrized role (4)
            ok 7999 - .HOW.does gives correct information (4-1)
            ok 8000 - .^does gives correct information (4-1)
            not ok 8001 - .HOW.does gives correct information (4-3) # TODO .does with parametric roles
            # Failed test '.HOW.does gives correct information (4-3)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S14-roles/parameterized-mixin.rakudo line 97
            not ok 8002 - .^does gives correct information (4-3) # TODO .does with parametric roles
            # Failed test '.^does gives correct information (4-3)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S14-roles/parameterized-mixin.rakudo line 99
            ok 8003 - .type works correctly
            ok 8004 - .name works correctly
            ok 8005 - Parametric role used first time uses correct default value
            ok 8006 - Parametric role used a second time uses correct default value
# FUDGED!
            1..16
            ok 8007 - can call sub that has had a trait applied to it by role name with arg
            ok 8008 - description role applied and set with argument
            ok 8009 - can call sub that has had a trait applied to it by role name without arg
            ok 8010 - description role applied without argument
            ok 8011 - can call sub that has had a trait applied to it by named param with arg
            ok 8012 - named trait handler applied other role set with argument
            ok 8013 - can call sub that has had a trait applied to it by named param without arg
            ok 8014 - named trait handler applied other role without argument
            ok 8015 - Can call subroutine that was wrapped by a trait
            not ok 8016 - and the wrapper has been called once # TODO trait mod / .wrap interaction
            # Failed test 'and the wrapper has been called once'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S14-traits/routines.rakudo line 52
            # expected: 'wrap'
            #      got: ''
            ok 8017 - [BUG] multi without proto gets wrong lexical lookup chain (RT  \#112664)
            not ok 8018 - declaration of a sub with an unknown trait mentions trait_mod:<is> in dispatch error
            # Failed test 'declaration of a sub with an unknown trait mentions trait_mod:<is> in dispatch error'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S14-traits/routines.rakudo line 70
            # Could not locate compile-time value for symbol Inheritance::UnknownParent
            ok 8019 - wrapping a routine at compile time makes it soft
            ok 8020 - Applying traits to submethods works
Could not find symbol '&NotFound' in 'X::Method'
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S14-traits/routines.rakudo line 92
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S14-traits/routines.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

            1..4
            ok 8021 - Reading UTF-8 file as NFG (one grapheme)
            ok 8022 - Reading UTF-8 file as NFG (a few graphemes)
            ok 8023 - # SKIP writing utf16 NYI
            ok 8024 - # SKIP writing utf16 NYI
# FUDGED!
            1..10
            ok 8025 - # SKIP NFC quoting adverb NYI RT  \#124995
            ok 8026 - # SKIP NFC quoting adverb NYI RT  \#124995
            ok 8027 - # SKIP NFC quoting adverb NYI RT  \#124995
            ok 8028 - # SKIP NFC quoting adverb NYI RT  \#124995
            ok 8029 - # SKIP NFC quoting adverb NYI RT  \#124995
            ok 8030 - # SKIP NFD quoting adverb NYI RT  \#124996
            ok 8031 - # SKIP NFD quoting adverb NYI RT  \#124996
            ok 8032 - # SKIP NFD quoting adverb NYI RT  \#124996
            ok 8033 - # SKIP NFD quoting adverb NYI RT  \#124996
            ok 8034 - # SKIP NFD quoting adverb NYI RT  \#124996
# FUDGED!
            1..10
            ok 8035 - # SKIP NFKC type NYI RT  \#124989
            ok 8036 - # SKIP NFKC type NYI RT  \#124989
            ok 8037 - # SKIP NFKC type NYI RT  \#124989
            ok 8038 - # SKIP NFKC type NYI RT  \#124989
            ok 8039 - # SKIP NFKC type NYI RT  \#124989
            ok 8040 - # SKIP NFKD type NYI
            ok 8041 - # SKIP NFKD type NYI
            ok 8042 - # SKIP NFKD type NYI
            ok 8043 - # SKIP NFKD type NYI
            ok 8044 - # SKIP NFKD type NYI
# FUDGED!
WARNING: unhandled Failure detected in DESTROY. If you meant to ignore it, you can mark it as handled by calling .Bool, .so, .not, or .defined methods. The Failure was:
No value 'foo' found in enum FF
  in block <unit> at EVAL_1183 line 1
  in sub eval_exception at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 714
  in sub eval-lives-ok at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 580
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-enums/basic.rakudo line 266
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S12-enums/basic.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

            1..4
            ok 8045 - Strings are of type Str by default.
            ok 8046 - # SKIP :nfg adverb NYI
            ok 8047 - Str.chars returns number of graphemes.
            ok 8048 - Str.ord returns first NFC codepoint for NFG grapheme
# FUDGED!
            1..48
            ok 8049 - uniname an empty string yields Nil
            ok 8050 - uninames an empty string yields an empty list
            ok 8051 - ''.uniname yields Nil
            ok 8052 - ''.uninames yields an empty list
Could not find symbol '&NoMatch' in 'X::Multi'
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S15-unicode-information/uniname.rakudo line 18
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

            1..11
            # Using file temp-16-filehandles-filestat-56562-1.temp
            # Using file temp-16-filehandles-filestat-56562-2.temp
            ok 8053 - IO.modified should be greater than pre-creation timestamp
            ok 8054 - IO.changed should be greater than pre-creation timestamp
            ok 8055 - IO.accessed should be greater than pre-creation timestamp
            ok 8056 - IO.modified should be updated when file content changes
            ok 8057 - IO.changed should be updated when file content changes
            ok 8058 - # SKIP TODO figure out a better way for noatime systems
            ok 8059 - IO.modified should NOT be updated when file mode is altered
            ok 8060 - IO.changed should be updated when file mode is altered
            ok 8061 - IO.changed and IO.modified should differ after file mode change
            ok 8062 - Test file temp-16-filehandles-filestat-56562-1.temp was successfully removed
            ok 8063 - Test file temp-16-filehandles-filestat-56562-2.temp was successfully removed
# FUDGED!
            1..128
            ok 8064 - file test from before spec revision 27503 is error
            ok 8065 - ~~:d returns true on directories
            ok 8066 - can :d-test against non-existing dir and live
            ok 8067 - can :d-test against non-existing dir and return false
            ok 8068 - ~~:f returns true on files
            ok 8069 - ~~:e returns true on files
            ok 8070 - ~~:e returns true on directories
            ok 8071 - ~~:r returns true on readable files
            ok 8072 - ~~:w returns true on writable files
            ok 8073 - # SKIP 'rakudo-m' is not present (interactive mode?)
            ok 8074 - ~~:x returns true on cwd()able directories
            ok 8075 - ~~:f returns false on directories
            ok 8076 - ~~:r returns true on a readable directory
            ok 8077 - ~~:d returns false on non-existent directories
            ok 8078 - ~~:r returns false on non-existent directories
            ok 8079 - ~~:w returns false on non-existent directories
            ok 8080 - ~~:x returns false on non-existent directories
            ok 8081 - ~~:f returns false on non-existent directories
            ok 8082 - ~~:f returns false on non-existent files
            ok 8083 - ~~:r returns false on non-existent files
            ok 8084 - ~~:w returns false on non-existent files
            ok 8085 - ~~:x returns false on non-existent files
            ok 8086 - ~~:f returns false on non-existent files
            ok 8087 - ~~:s returns size on existent files
            ok 8088 - ~~:s returns false on non-existent files
            ok 8089 - ~~:z returns false on existent files
            ok 8090 - ~~:z returns false on non-existent files
            ok 8091 - ~~:z returns inverse boolified size on directories
            ok 8092 - ~~:z returns true for an empty file
            ok 8093 - # SKIP :M, :C, :A
            ok 8094 - # SKIP :M, :C, :A
            ok 8095 - # SKIP :M, :C, :A
            ok 8096 - # SKIP no file README
            ok 8097 - # SKIP no file README
            ok 8098 - # SKIP no file README
            ok 8099 - # SKIP :M, :C, :A
            ok 8100 - # SKIP :M, :C, :A
            ok 8101 - # SKIP :M, :C, :A
            ok 8102 - f(...) works
            ok 8103 - - f(...) does not call the ~~:f filetest
            ok 8104 - - f(...) does not call the ~~:f filetest
            ok 8105 - can :l-test against non-existing file and live
            ok 8106 - ~~:l returns false on non-existent files
            ok 8107 - .l on broken symlinks gives True
Could not find symbol '&DoesNotExist' in 'X::IO'
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S16-filehandles/filetest.rakudo line 151
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S16-filehandles/filetest.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

            1..1
            not ok 8108 - IO::Socket::INet.getpeername works # TODO getpeername is not implemented yet
            # Failed test 'IO::Socket::INet.getpeername works'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S16-unfiled/getpeername.rakudo line 18
# FUDGED!
            1..2
            ok 8109 - # SKIP contextual rebinding regression
            ok 8110 - # SKIP contextual rebinding regression
# FUDGED!
            1..47
            ok 8111 - The object is-a 'Proc::Async'
            ok 8112 - 
            ok 8113 - 
            ok 8114 - program not yet started
            ok 8115 - Not opened for writing
            ok 8116 - The object is-a 'Promise'
            ok 8117 - program has been started
Could not find symbol '&AlreadyStarted' in 'X::Proc::Async'
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S17-procasync/basic.rakudo line 30
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

            1..16
            ok 8118 - could we write the tester
            ok 8119 - did the tester arrive ok
            ok 8120 - The object is-a 'Proc::Async'
            ok 8121 - 
            ok 8122 - 
            ok 8123 - STDOUT should be empty
            ok 8124 - STDERR should be empty
            ok 8125 - The object is-a 'Promise'
            ok 8126 - The object is-a 'Promise'
            ok 8127 - The object is-a 'Promise'
            ok 8128 - did the close of STDIN work
            ok 8129 - # SKIP Flapping tests
            ok 8130 - # SKIP Flapping tests
            ok 8131 - # SKIP Flapping tests
            ok 8132 - # SKIP Flapping tests
            ok 8133 - # SKIP Flapping tests
# FUDGED!
WARNINGS for /Users/tobiuo/class/seminar/Abyss-Server/roast/S17-scheduler/basic.rakudo:
Useless use of constant integer 1 in sink context (use Nil instead to suppress this warning) (lines 96, 108, 123, 135)
            1..34
            ok 8134 - ThreadPoolScheduler does Scheduler role
            ok 8135 - ThreadPoolScheduler returns a value before cuing
            ok 8136 - # SKIP waiting for new '.loads' semantics
            ok 8137 - # SKIP waiting for new '.loads' semantics
            ok 8138 - # SKIP waiting for new '.loads' semantics
            ok 8139 - # SKIP waiting for new '.loads' semantics
            ok 8140 - # SKIP waiting for new '.loads' semantics
            ok 8141 - # SKIP waiting for new '.loads' semantics
            ok 8142 - # SKIP waiting for new '.loads' semantics
            ok 8143 - # SKIP waiting for new '.loads' semantics
            ok 8144 - # SKIP waiting for new '.loads' semantics
            ok 8145 - # SKIP waiting for new '.loads' semantics
            ok 8146 - ThreadPoolScheduler cannot combine :in and :at
            ok 8147 - ThreadPoolScheduler cannot combine :every with :in and :at
            ok 8148 - ThreadPoolScheduler cannot combine :catch with :in and :at
            ok 8149 - ThreadPoolScheduler cannot combine :every/:catch with :in and :at
            ok 8150 - ThreadPoolScheduler cannot combine :every, :times and :stop
            ok 8151 - CurrentThreadScheduler does Scheduler role
            ok 8152 - Cued code on CurrentThreadScheduler ran
            ok 8153 - can we cancel (1)
            ok 8154 - Code was cued to CurrentThreadScheduler by default
            ok 8155 - can we cancel (2)
            ok 8156 - CurrentThreadScheduler setting uncaught_handler works
            ok 8157 - CurrentThreadScheduler passed correct exception to handler
            ok 8158 - can we cancel (3)
            ok 8159 - Code run on CurrentThreadScheduler, then handler
            ok 8160 - can we cancel (4)
            ok 8161 - Catch handler on CurrentThreadScheduler not run if no error
            ok 8162 - CurrentThreadScheduler cannot specify :every in CurrentThreadScheduler
            ok 8163 - CurrentThreadScheduler cannot combine :in and :at
            ok 8164 - CurrentThreadScheduler cannot combine :every with :in and :at
            ok 8165 - CurrentThreadScheduler cannot combine :catch with :in and :at
            ok 8166 - CurrentThreadScheduler cannot combine :every/:catch with :in and :at
            ok 8167 - CurrentThreadScheduler cannot combine :every, :times and :stop
# FUDGED!
            1..13
            ok 8168 - can not be called as a class method
            # **** scheduling with ThreadPoolScheduler
            ok 8169 - # SKIP doesn't work or can't test
            ok 8170 - # SKIP doesn't work or can't test
            ok 8171 - # SKIP doesn't work or can't test
            ok 8172 - # SKIP doesn't work or can't test
            ok 8173 - delaying by 0 is a noop
                1..5
                ok 1 - Supply appears to be doing Supply
                ok 2 - Supply appears to NOT be live
                ok 3 - noop delay got a tap
                ok 4 - noop delay was really done
                ok 5 - noop delay
            ok 8174 - noop delay
            # **** scheduling with CurrentThreadScheduler
            ok 8175 - # SKIP doesn't work or can't test
            ok 8176 - # SKIP doesn't work or can't test
            ok 8177 - # SKIP doesn't work or can't test
            ok 8178 - # SKIP doesn't work or can't test
            ok 8179 - delaying by 0 is a noop
                1..5
                ok 1 - Supply appears to be doing Supply
                ok 2 - Supply appears to NOT be live
                ok 3 - noop delay got a tap
                ok 4 - noop delay was really done
                ok 5 - noop delay
            ok 8180 - noop delay
# FUDGED!
            1..32
            ok 8181 - can not be called as a class method
            not ok 8182 - no param version illegal # TODO only deprecated so far
            # Failed test 'no param version illegal'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S17-supply/rotor.rakudo line 9
            # **** scheduling with ThreadPoolScheduler
                1..5
                ok 1 - Supply appears to be doing Supply
                ok 2 - Supply appears to NOT be live
                ok 3 - we can rotor with negative gap got a tap
                ok 4 - we can rotor with negative gap was really done
                ok 5 - we can rotor with negative gap
            ok 8183 - we can rotor with negative gap
                1..5
                ok 1 - Supply appears to be doing Supply
                ok 2 - Supply appears to NOT be live
                ok 3 - we can rotor with negative gap without partial got a tap
                ok 4 - we can rotor with negative gap without partial was really done
                ok 5 - we can rotor with negative gap without partial
            ok 8184 - we can rotor with negative gap without partial
                1..5
                ok 1 - Supply appears to be doing Supply
                ok 2 - Supply appears to NOT be live
                ok 3 - we can rotor with negative gap with partial got a tap
                ok 4 - we can rotor with negative gap with partial was really done
                ok 5 - we can rotor with negative gap with partial
            ok 8185 - we can rotor with negative gap with partial
                1..5
                ok 1 - Supply appears to be doing Supply
                ok 2 - Supply appears to NOT be live
                ok 3 - we can rotor without gap with 3 got a tap
                ok 4 - we can rotor without gap with 3 was really done
                ok 5 - we can rotor without gap with 3
            ok 8186 - we can rotor without gap with 3
                1..5
                ok 1 - Supply appears to be doing Supply
                ok 2 - Supply appears to NOT be live
                ok 3 - we can rotor without gap without partial with 3 got a tap
                ok 4 - we can rotor without gap without partial with 3 was really done
                ok 5 - we can rotor without gap without partial with 3
            ok 8187 - we can rotor without gap without partial with 3
                1..5
                ok 1 - Supply appears to be doing Supply
                ok 2 - Supply appears to NOT be live
                ok 3 - we can rotor without gap with partial with 3 got a tap
                ok 4 - we can rotor without gap with partial with 3 was really done
                ok 5 - we can rotor without gap with partial with 3
            ok 8188 - we can rotor without gap with partial with 3
                1..5
                ok 1 - Supply appears to be doing Supply
                ok 2 - Supply appears to NOT be live
                ok 3 - we can rotor without gap with 3 => 0 got a tap
                ok 4 - we can rotor without gap with 3 => 0 was really done
                ok 5 - we can rotor without gap with 3 => 0
            ok 8189 - we can rotor without gap with 3 => 0
                1..5
                ok 1 - Supply appears to be doing Supply
                ok 2 - Supply appears to NOT be live
                ok 3 - we can rotor without gap without partial with 3 => 0 got a tap
                ok 4 - we can rotor without gap without partial with 3 => 0 was really done
                ok 5 - we can rotor without gap without partial with 3 => 0
            ok 8190 - we can rotor without gap without partial with 3 => 0
                1..5
                ok 1 - Supply appears to be doing Supply
                ok 2 - Supply appears to NOT be live
                ok 3 - we can rotor without gap with partial with 3 => 0 got a tap
                ok 4 - we can rotor without gap with partial with 3 => 0 was really done
                ok 5 - we can rotor without gap with partial with 3 => 0
            ok 8191 - we can rotor without gap with partial with 3 => 0
                1..5
                ok 1 - Supply appears to be doing Supply
                ok 2 - Supply appears to NOT be live
                ok 3 - we can rotor with positive gap got a tap
                ok 4 - we can rotor with positive gap was really done
                ok 5 - we can rotor with positive gap
            ok 8192 - we can rotor with positive gap
                1..5
                ok 1 - Supply appears to be doing Supply
                ok 2 - Supply appears to NOT be live
                ok 3 - we can rotor with positive gap without partial got a tap
                ok 4 - we can rotor with positive gap without partial was really done
                ok 5 - we can rotor with positive gap without partial
            ok 8193 - we can rotor with positive gap without partial
                1..5
                ok 1 - Supply appears to be doing Supply
                ok 2 - Supply appears to NOT be live
                ok 3 - we can rotor with positive gap with partial got a tap
                ok 4 - we can rotor with positive gap with partial was really done
                ok 5 - we can rotor with positive gap with partial
            ok 8194 - we can rotor with positive gap with partial
                1..5
                ok 1 - Supply appears to be doing Supply
                ok 2 - Supply appears to NOT be live
                ok 3 - we can rotor with multiple different gaps got a tap
                ok 4 - we can rotor with multiple different gaps was really done
                ok 5 - we can rotor with multiple different gaps
            ok 8195 - we can rotor with multiple different gaps
                1..5
                ok 1 - Supply appears to be doing Supply
                ok 2 - Supply appears to NOT be live
                ok 3 - we can rotor with multiple different gaps without partial got a tap
                ok 4 - we can rotor with multiple different gaps without partial was really done
                ok 5 - we can rotor with multiple different gaps without partial
            ok 8196 - we can rotor with multiple different gaps without partial
                1..5
                ok 1 - Supply appears to be doing Supply
                ok 2 - Supply appears to NOT be live
                ok 3 - we can rotor with multiple different gaps with partial got a tap
                ok 4 - we can rotor with multiple different gaps with partial was really done
                ok 5 - we can rotor with multiple different gaps with partial
            ok 8197 - we can rotor with multiple different gaps with partial
            # **** scheduling with CurrentThreadScheduler
                1..5
                ok 1 - Supply appears to be doing Supply
                ok 2 - Supply appears to NOT be live
                ok 3 - we can rotor with negative gap got a tap
                ok 4 - we can rotor with negative gap was really done
                ok 5 - we can rotor with negative gap
            ok 8198 - we can rotor with negative gap
                1..5
                ok 1 - Supply appears to be doing Supply
                ok 2 - Supply appears to NOT be live
                ok 3 - we can rotor with negative gap without partial got a tap
                ok 4 - we can rotor with negative gap without partial was really done
                ok 5 - we can rotor with negative gap without partial
            ok 8199 - we can rotor with negative gap without partial
                1..5
                ok 1 - Supply appears to be doing Supply
                ok 2 - Supply appears to NOT be live
                ok 3 - we can rotor with negative gap with partial got a tap
                ok 4 - we can rotor with negative gap with partial was really done
                ok 5 - we can rotor with negative gap with partial
            ok 8200 - we can rotor with negative gap with partial
                1..5
                ok 1 - Supply appears to be doing Supply
                ok 2 - Supply appears to NOT be live
                ok 3 - we can rotor without gap with 3 got a tap
                ok 4 - we can rotor without gap with 3 was really done
                ok 5 - we can rotor without gap with 3
            ok 8201 - we can rotor without gap with 3
                1..5
                ok 1 - Supply appears to be doing Supply
                ok 2 - Supply appears to NOT be live
                ok 3 - we can rotor without gap without partial with 3 got a tap
                ok 4 - we can rotor without gap without partial with 3 was really done
                ok 5 - we can rotor without gap without partial with 3
            ok 8202 - we can rotor without gap without partial with 3
                1..5
                ok 1 - Supply appears to be doing Supply
                ok 2 - Supply appears to NOT be live
                ok 3 - we can rotor without gap with partial with 3 got a tap
                ok 4 - we can rotor without gap with partial with 3 was really done
                ok 5 - we can rotor without gap with partial with 3
            ok 8203 - we can rotor without gap with partial with 3
                1..5
                ok 1 - Supply appears to be doing Supply
                ok 2 - Supply appears to NOT be live
                ok 3 - we can rotor without gap with 3 => 0 got a tap
                ok 4 - we can rotor without gap with 3 => 0 was really done
                ok 5 - we can rotor without gap with 3 => 0
            ok 8204 - we can rotor without gap with 3 => 0
                1..5
                ok 1 - Supply appears to be doing Supply
                ok 2 - Supply appears to NOT be live
                ok 3 - we can rotor without gap without partial with 3 => 0 got a tap
                ok 4 - we can rotor without gap without partial with 3 => 0 was really done
                ok 5 - we can rotor without gap without partial with 3 => 0
            ok 8205 - we can rotor without gap without partial with 3 => 0
                1..5
                ok 1 - Supply appears to be doing Supply
                ok 2 - Supply appears to NOT be live
                ok 3 - we can rotor without gap with partial with 3 => 0 got a tap
                ok 4 - we can rotor without gap with partial with 3 => 0 was really done
                ok 5 - we can rotor without gap with partial with 3 => 0
            ok 8206 - we can rotor without gap with partial with 3 => 0
                1..5
                ok 1 - Supply appears to be doing Supply
                ok 2 - Supply appears to NOT be live
                ok 3 - we can rotor with positive gap got a tap
                ok 4 - we can rotor with positive gap was really done
                ok 5 - we can rotor with positive gap
            ok 8207 - we can rotor with positive gap
                1..5
                ok 1 - Supply appears to be doing Supply
                ok 2 - Supply appears to NOT be live
                ok 3 - we can rotor with positive gap without partial got a tap
                ok 4 - we can rotor with positive gap without partial was really done
                ok 5 - we can rotor with positive gap without partial
            ok 8208 - we can rotor with positive gap without partial
                1..5
                ok 1 - Supply appears to be doing Supply
                ok 2 - Supply appears to NOT be live
                ok 3 - we can rotor with positive gap with partial got a tap
                ok 4 - we can rotor with positive gap with partial was really done
                ok 5 - we can rotor with positive gap with partial
            ok 8209 - we can rotor with positive gap with partial
                1..5
                ok 1 - Supply appears to be doing Supply
                ok 2 - Supply appears to NOT be live
                ok 3 - we can rotor with multiple different gaps got a tap
                ok 4 - we can rotor with multiple different gaps was really done
                ok 5 - we can rotor with multiple different gaps
            ok 8210 - we can rotor with multiple different gaps
                1..5
                ok 1 - Supply appears to be doing Supply
                ok 2 - Supply appears to NOT be live
                ok 3 - we can rotor with multiple different gaps without partial got a tap
                ok 4 - we can rotor with multiple different gaps without partial was really done
                ok 5 - we can rotor with multiple different gaps without partial
            ok 8211 - we can rotor with multiple different gaps without partial
                1..5
                ok 1 - Supply appears to be doing Supply
                ok 2 - Supply appears to NOT be live
                ok 3 - we can rotor with multiple different gaps with partial got a tap
                ok 4 - we can rotor with multiple different gaps with partial was really done
                ok 5 - we can rotor with multiple different gaps with partial
            ok 8212 - we can rotor with multiple different gaps with partial
# FUDGED!
            1..7
            ok 8213 - can not be called as a class method
            # **** scheduling with ThreadPoolScheduler
            ok 8214 - # SKIP doesn't work or can't test
            ok 8215 - stable by 0 is a noop
                1..5
                ok 1 - Supply appears to be doing Supply
                ok 2 - Supply appears to NOT be live
                ok 3 - noop stable got a tap
                ok 4 - noop stable was really done
                ok 5 - noop stable
            ok 8216 - noop stable
            # **** scheduling with CurrentThreadScheduler
            ok 8217 - # SKIP doesn't work or can't test
            ok 8218 - stable by 0 is a noop
                1..5
                ok 1 - Supply appears to be doing Supply
                ok 2 - Supply appears to NOT be live
                ok 3 - noop stable got a tap
                ok 4 - noop stable was really done
                ok 5 - noop stable
            ok 8219 - noop stable
# FUDGED!
            1..6
Use of Nil in string context
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/packages/Test-Helpers/lib/Test/Util.pm6 (Test::Util) line 233
No such method 'queue' for invocant of type 'CurrentThreadScheduler'
  in sub get_out at /Users/tobiuo/class/seminar/Abyss-Server/roast/packages/Test-Helpers/lib/Test/Util.pm6 (Test::Util) line 229
  in sub is_run at /Users/tobiuo/class/seminar/Abyss-Server/roast/packages/Test-Helpers/lib/Test/Util.pm6 (Test::Util) line 135
  in sub is_run at /Users/tobiuo/class/seminar/Abyss-Server/roast/packages/Test-Helpers/lib/Test/Util.pm6 (Test::Util) line 129
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S19-command-line-options/02-dash-n.rakudo line 29
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

            1..3
Use of Nil in string context
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/packages/Test-Helpers/lib/Test/Util.pm6 (Test::Util) line 233
No such method 'queue' for invocant of type 'CurrentThreadScheduler'
  in sub get_out at /Users/tobiuo/class/seminar/Abyss-Server/roast/packages/Test-Helpers/lib/Test/Util.pm6 (Test::Util) line 229
  in sub is_run at /Users/tobiuo/class/seminar/Abyss-Server/roast/packages/Test-Helpers/lib/Test/Util.pm6 (Test::Util) line 135
  in sub is_run at /Users/tobiuo/class/seminar/Abyss-Server/roast/packages/Test-Helpers/lib/Test/Util.pm6 (Test::Util) line 129
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S19-command-line-options/04-negation.rakudo line 15
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S19-command-line-options/04-negation.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 20
  in block <unit> at other/startup.p6 line 7

            1..1
Use of Nil in string context
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/packages/Test-Helpers/lib/Test/Util.pm6 (Test::Util) line 233
No such method 'queue' for invocant of type 'CurrentThreadScheduler'
  in sub get_out at /Users/tobiuo/class/seminar/Abyss-Server/roast/packages/Test-Helpers/lib/Test/Util.pm6 (Test::Util) line 229
  in sub is_run at /Users/tobiuo/class/seminar/Abyss-Server/roast/packages/Test-Helpers/lib/Test/Util.pm6 (Test::Util) line 135
  in sub is_run at /Users/tobiuo/class/seminar/Abyss-Server/roast/packages/Test-Helpers/lib/Test/Util.pm6 (Test::Util) line 129
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S19-command-line-options/05-delimited-options.rakudo line 14
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 20
  in block <unit> at other/startup.p6 line 7

            1..12
Error while constructing error object:Could not locate compile-time value for symbol Undeclared::Symbols
            not ok 8220 - non-compiling test # TODO Module Test doesn't implement force_todo yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S24-testing/2-force_todo.rakudo line 22
            not ok 8221 - non-compiling test # TODO Module Test doesn't implement force_todo yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S24-testing/2-force_todo.rakudo line 22
            not ok 8222 - non-compiling test # TODO Module Test doesn't implement force_todo yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S24-testing/2-force_todo.rakudo line 22
            not ok 8223 - non-compiling test # TODO Module Test doesn't implement force_todo yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S24-testing/2-force_todo.rakudo line 22
            not ok 8224 - non-compiling test # TODO Module Test doesn't implement force_todo yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S24-testing/2-force_todo.rakudo line 22
            not ok 8225 - non-compiling test # TODO Module Test doesn't implement force_todo yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S24-testing/2-force_todo.rakudo line 22
            not ok 8226 - non-compiling test # TODO Module Test doesn't implement force_todo yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S24-testing/2-force_todo.rakudo line 22
            not ok 8227 - non-compiling test # TODO Module Test doesn't implement force_todo yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S24-testing/2-force_todo.rakudo line 22
            not ok 8228 - non-compiling test # TODO Module Test doesn't implement force_todo yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S24-testing/2-force_todo.rakudo line 22
            not ok 8229 - non-compiling test # TODO Module Test doesn't implement force_todo yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S24-testing/2-force_todo.rakudo line 22
            not ok 8230 - non-compiling test # TODO Module Test doesn't implement force_todo yet
            # Failed test 'non-compiling test'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S24-testing/2-force_todo.rakudo line 22
            not ok 8231 - force_todo is implemented # TODO Canary test for &Test::force_todo
            # Failed test 'force_todo is implemented'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S24-testing/2-force_todo.rakudo line 26
            # Error: Undeclared routine:
            #     force_todo used at line 1
            # 
# FUDGED!
            1..1
                1..19
                ok 1 - is config<numbered>:exists
                ok 2 - ok config<numbered>
                ok 3 - is config<numbered>:exists
                ok 4 - ok config<numbered>
                ok 5 - is term "foo"
                ok 6 - is config<numbered>:exists
                ok 7 - ok config<numbered>
                ok 8 - is config<numbered>:exists
                ok 9 - ok config<numbered>
                ok 10 - is config<numbered>:exists
                ok 11 - ok config<numbered>
                ok 12 - is config<numbered>:exists
                ok 13 - ok config<numbered>
                ok 14 - is config<numbered>:exists
                ok 15 - ok config<numbered>
                ok 16 - is config<numbered>:exists
                ok 17 - ok config<numbered>
                ok 18 - is config<numbered>:exists
                ok 19 - ok config<numbered>
            ok 8232 - :numbered alias abbreviated blocks
# FUDGED!
            1..30
            ok 8233 - EVAL runs code in the proper lexical scope
            ok 8234 - simple EVAL works and returns the value
            ok 8235 - simple EVAL using variable defined outside
            ok 8236 - EVAL does not trap die
Error while constructing error object:Could not locate compile-time value for symbol Syntax::Confused
            ok 8237 - EVAL throws on syntax error
            ok 8238 - EVAL dies on fatal use
            ok 8239 - block EVAL is gone
            ok 8240 - EVAL works inside class methods
            ok 8241 - EVAL works inside instance methods
            ok 8242 - EVAL works inside class methods, with outer lexicals
            ok 8243 - EVAL works inside instance methods, with outer lexicals
            ok 8244 - EVAL(Buf)
            ok 8245 - # SKIP Buf.EVAL NYI (if ever)
            ok 8246 - EVAL of non-string works
            ok 8247 - .EVAL of non-string works
            ok 8248 - EVAL of non-string variable works
            ok 8249 - .EVAL of non-string variable works
            ok 8250 - can execute the same EVAL multiple times, without surrounding block
            ok 8251 - EVAL in bogus language mentions the language
            ok 8252 - method form of EVAL sees outer lexicals
            ok 8253 - presence of low level types doesn't cause EVAL error
            ok 8254 - Can EVAL with a sigilless var
            ok 8255 - EVAL with sigilless var gives correct result
            ok 8256 - EVAL's package does not leak to the surrounding compilation unit
Use of Nil in string context
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/packages/Test-Helpers/lib/Test/Util.pm6 (Test::Util) line 233
No such method 'queue' for invocant of type 'CurrentThreadScheduler'
  in sub get_out at /Users/tobiuo/class/seminar/Abyss-Server/roast/packages/Test-Helpers/lib/Test/Util.pm6 (Test::Util) line 229
  in sub is_run at /Users/tobiuo/class/seminar/Abyss-Server/roast/packages/Test-Helpers/lib/Test/Util.pm6 (Test::Util) line 135
  in sub is_run at /Users/tobiuo/class/seminar/Abyss-Server/roast/packages/Test-Helpers/lib/Test/Util.pm6 (Test::Util) line 129
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S29-context/eval.rakudo line 118
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

            1..259
            ok 8257 - ord() works for \32 == ' '
            ok 8258 - chr() works for \32 == ' '
            ok 8259 - ord() works for \33 == '!'
            ok 8260 - chr() works for \33 == '!'
            ok 8261 - ord() works for \34 == '"'
            ok 8262 - chr() works for \34 == '"'
            ok 8263 - ord() works for \35 == ' \#'
            ok 8264 - chr() works for \35 == ' \#'
            ok 8265 - ord() works for \36 == '$'
            ok 8266 - chr() works for \36 == '$'
            ok 8267 - ord() works for \37 == '%'
            ok 8268 - chr() works for \37 == '%'
            ok 8269 - ord() works for \38 == '&'
            ok 8270 - chr() works for \38 == '&'
            ok 8271 - ord() works for \39 == '''
            ok 8272 - chr() works for \39 == '''
            ok 8273 - ord() works for \40 == '('
            ok 8274 - chr() works for \40 == '('
            ok 8275 - ord() works for \41 == ')'
            ok 8276 - chr() works for \41 == ')'
            ok 8277 - ord() works for \42 == '*'
            ok 8278 - chr() works for \42 == '*'
            ok 8279 - ord() works for \43 == '+'
            ok 8280 - chr() works for \43 == '+'
            ok 8281 - ord() works for \44 == ','
            ok 8282 - chr() works for \44 == ','
            ok 8283 - ord() works for \45 == '-'
            ok 8284 - chr() works for \45 == '-'
            ok 8285 - ord() works for \46 == '.'
            ok 8286 - chr() works for \46 == '.'
            ok 8287 - ord() works for \47 == '/'
            ok 8288 - chr() works for \47 == '/'
            ok 8289 - ord() works for \48 == '0'
            ok 8290 - chr() works for \48 == '0'
            ok 8291 - ord() works for \49 == '1'
            ok 8292 - chr() works for \49 == '1'
            ok 8293 - ord() works for \50 == '2'
            ok 8294 - chr() works for \50 == '2'
            ok 8295 - ord() works for \51 == '3'
            ok 8296 - chr() works for \51 == '3'
            ok 8297 - ord() works for \52 == '4'
            ok 8298 - chr() works for \52 == '4'
            ok 8299 - ord() works for \53 == '5'
            ok 8300 - chr() works for \53 == '5'
            ok 8301 - ord() works for \54 == '6'
            ok 8302 - chr() works for \54 == '6'
            ok 8303 - ord() works for \55 == '7'
            ok 8304 - chr() works for \55 == '7'
            ok 8305 - ord() works for \56 == '8'
            ok 8306 - chr() works for \56 == '8'
            ok 8307 - ord() works for \57 == '9'
            ok 8308 - chr() works for \57 == '9'
            ok 8309 - ord() works for \58 == ':'
            ok 8310 - chr() works for \58 == ':'
            ok 8311 - ord() works for \59 == ';'
            ok 8312 - chr() works for \59 == ';'
            ok 8313 - ord() works for \60 == '<'
            ok 8314 - chr() works for \60 == '<'
            ok 8315 - ord() works for \61 == '='
            ok 8316 - chr() works for \61 == '='
            ok 8317 - ord() works for \62 == '>'
            ok 8318 - chr() works for \62 == '>'
            ok 8319 - ord() works for \63 == '?'
            ok 8320 - chr() works for \63 == '?'
            ok 8321 - ord() works for \64 == '@'
            ok 8322 - chr() works for \64 == '@'
            ok 8323 - ord() works for \65 == 'A'
            ok 8324 - chr() works for \65 == 'A'
            ok 8325 - ord() works for \66 == 'B'
            ok 8326 - chr() works for \66 == 'B'
            ok 8327 - ord() works for \67 == 'C'
            ok 8328 - chr() works for \67 == 'C'
            ok 8329 - ord() works for \68 == 'D'
            ok 8330 - chr() works for \68 == 'D'
            ok 8331 - ord() works for \69 == 'E'
            ok 8332 - chr() works for \69 == 'E'
            ok 8333 - ord() works for \70 == 'F'
            ok 8334 - chr() works for \70 == 'F'
            ok 8335 - ord() works for \71 == 'G'
            ok 8336 - chr() works for \71 == 'G'
            ok 8337 - ord() works for \72 == 'H'
            ok 8338 - chr() works for \72 == 'H'
            ok 8339 - ord() works for \73 == 'I'
            ok 8340 - chr() works for \73 == 'I'
            ok 8341 - ord() works for \74 == 'J'
            ok 8342 - chr() works for \74 == 'J'
            ok 8343 - ord() works for \75 == 'K'
            ok 8344 - chr() works for \75 == 'K'
            ok 8345 - ord() works for \76 == 'L'
            ok 8346 - chr() works for \76 == 'L'
            ok 8347 - ord() works for \77 == 'M'
            ok 8348 - chr() works for \77 == 'M'
            ok 8349 - ord() works for \78 == 'N'
            ok 8350 - chr() works for \78 == 'N'
            ok 8351 - ord() works for \79 == 'O'
            ok 8352 - chr() works for \79 == 'O'
            ok 8353 - ord() works for \80 == 'P'
            ok 8354 - chr() works for \80 == 'P'
            ok 8355 - ord() works for \81 == 'Q'
            ok 8356 - chr() works for \81 == 'Q'
            ok 8357 - ord() works for \82 == 'R'
            ok 8358 - chr() works for \82 == 'R'
            ok 8359 - ord() works for \83 == 'S'
            ok 8360 - chr() works for \83 == 'S'
            ok 8361 - ord() works for \84 == 'T'
            ok 8362 - chr() works for \84 == 'T'
            ok 8363 - ord() works for \85 == 'U'
            ok 8364 - chr() works for \85 == 'U'
            ok 8365 - ord() works for \86 == 'V'
            ok 8366 - chr() works for \86 == 'V'
            ok 8367 - ord() works for \87 == 'W'
            ok 8368 - chr() works for \87 == 'W'
            ok 8369 - ord() works for \88 == 'X'
            ok 8370 - chr() works for \88 == 'X'
            ok 8371 - ord() works for \89 == 'Y'
            ok 8372 - chr() works for \89 == 'Y'
            ok 8373 - ord() works for \90 == 'Z'
            ok 8374 - chr() works for \90 == 'Z'
            ok 8375 - ord() works for \91 == '['
            ok 8376 - chr() works for \91 == '['
            ok 8377 - ord() works for \92 == '\'
            ok 8378 - chr() works for \92 == '\'
            ok 8379 - ord() works for \93 == ']'
            ok 8380 - chr() works for \93 == ']'
            ok 8381 - ord() works for \94 == '^'
            ok 8382 - chr() works for \94 == '^'
            ok 8383 - ord() works for \95 == '_'
            ok 8384 - chr() works for \95 == '_'
            ok 8385 - ord() works for \96 == '`'
            ok 8386 - chr() works for \96 == '`'
            ok 8387 - ord() works for \97 == 'a'
            ok 8388 - chr() works for \97 == 'a'
            ok 8389 - ord() works for \98 == 'b'
            ok 8390 - chr() works for \98 == 'b'
            ok 8391 - ord() works for \99 == 'c'
            ok 8392 - chr() works for \99 == 'c'
            ok 8393 - ord() works for \100 == 'd'
            ok 8394 - chr() works for \100 == 'd'
            ok 8395 - ord() works for \101 == 'e'
            ok 8396 - chr() works for \101 == 'e'
            ok 8397 - ord() works for \102 == 'f'
            ok 8398 - chr() works for \102 == 'f'
            ok 8399 - ord() works for \103 == 'g'
            ok 8400 - chr() works for \103 == 'g'
            ok 8401 - ord() works for \104 == 'h'
            ok 8402 - chr() works for \104 == 'h'
            ok 8403 - ord() works for \105 == 'i'
            ok 8404 - chr() works for \105 == 'i'
            ok 8405 - ord() works for \106 == 'j'
            ok 8406 - chr() works for \106 == 'j'
            ok 8407 - ord() works for \107 == 'k'
            ok 8408 - chr() works for \107 == 'k'
            ok 8409 - ord() works for \108 == 'l'
            ok 8410 - chr() works for \108 == 'l'
            ok 8411 - ord() works for \109 == 'm'
            ok 8412 - chr() works for \109 == 'm'
            ok 8413 - ord() works for \110 == 'n'
            ok 8414 - chr() works for \110 == 'n'
            ok 8415 - ord() works for \111 == 'o'
            ok 8416 - chr() works for \111 == 'o'
            ok 8417 - ord() works for \112 == 'p'
            ok 8418 - chr() works for \112 == 'p'
            ok 8419 - ord() works for \113 == 'q'
            ok 8420 - chr() works for \113 == 'q'
            ok 8421 - ord() works for \114 == 'r'
            ok 8422 - chr() works for \114 == 'r'
            ok 8423 - ord() works for \115 == 's'
            ok 8424 - chr() works for \115 == 's'
            ok 8425 - ord() works for \116 == 't'
            ok 8426 - chr() works for \116 == 't'
            ok 8427 - ord() works for \117 == 'u'
            ok 8428 - chr() works for \117 == 'u'
            ok 8429 - ord() works for \118 == 'v'
            ok 8430 - chr() works for \118 == 'v'
            ok 8431 - ord() works for \119 == 'w'
            ok 8432 - chr() works for \119 == 'w'
            ok 8433 - ord() works for \120 == 'x'
            ok 8434 - chr() works for \120 == 'x'
            ok 8435 - ord() works for \121 == 'y'
            ok 8436 - chr() works for \121 == 'y'
            ok 8437 - ord() works for \122 == 'z'
            ok 8438 - chr() works for \122 == 'z'
            ok 8439 - ord() works for \123 == '{'
            ok 8440 - chr() works for \123 == '{'
            ok 8441 - ord() works for \124 == '|'
            ok 8442 - chr() works for \124 == '|'
            ok 8443 - ord() works for \125 == '}'
            ok 8444 - chr() works for \125 == '}'
            ok 8445 - ord() works for \126 == '~'
            ok 8446 - chr() works for \126 == '~'
            ok 8447 - ord() works for \228 == 'ä'
            ok 8448 - chr() works for \228 == 'ä'
            ok 8449 - ord() works for \8364 == '€'
            ok 8450 - chr() works for \8364 == '€'
            ok 8451 - ord() works for \187 == '»'
            ok 8452 - chr() works for \187 == '»'
            ok 8453 - ord() works for \171 == '«'
            ok 8454 - chr() works for \171 == '«'
            ok 8455 - ord() works for \0
            ok 8456 - chr() works for \0
            ok 8457 - ord() works for \1
            ok 8458 - chr() works for \1
            ok 8459 - ord() works for \3
            ok 8460 - chr() works for \3
            ok 8461 - ord(chr(0)) is 0
            ok 8462 - ord(chr(1)) is 1
            ok 8463 - ord(chr(2)) is 2
            ok 8464 - ord(chr(3)) is 3
            ok 8465 - ord(chr(4)) is 4
            ok 8466 - ord(chr(5)) is 5
            ok 8467 - ord(chr(6)) is 6
            ok 8468 - ord(chr(7)) is 7
            ok 8469 - ord(chr(8)) is 8
            ok 8470 - ord(chr(9)) is 9
            ok 8471 - ord(chr(10)) is 10
            ok 8472 - ord(chr(11)) is 11
            ok 8473 - ord(chr(12)) is 12
            ok 8474 - ord(chr(13)) is 13
            ok 8475 - ord(chr(14)) is 14
            ok 8476 - ord(chr(15)) is 15
            ok 8477 - ord(chr(16)) is 16
            ok 8478 - ord(chr(17)) is 17
            ok 8479 - ord(chr(18)) is 18
            ok 8480 - ord(chr(19)) is 19
            ok 8481 - ord(chr(20)) is 20
            ok 8482 - ord(chr(21)) is 21
            ok 8483 - ord(chr(22)) is 22
            ok 8484 - ord(chr(23)) is 23
            ok 8485 - ord(chr(24)) is 24
            ok 8486 - ord(chr(25)) is 25
            ok 8487 - ord(chr(26)) is 26
            ok 8488 - ord(chr(27)) is 27
            ok 8489 - ord(chr(28)) is 28
            ok 8490 - ord(chr(29)) is 29
            ok 8491 - ord(chr(30)) is 30
            ok 8492 - ord(chr(31)) is 31
            ok 8493 - ords() works as expected
            ok 8494 - chrs() method works as expected
            ok 8495 - chrs(ords()) round-trips correctly
            ok 8496 - ords(chrs()) round-trips correctly
            ok 8497 - there's a .ord method
            ok 8498 - there's a .chr method
            ok 8499 - there's a .ords method
            ok 8500 - there's a .chrs method
            ok 8501 - ords > chrs round-trips correctly
            ok 8502 - chrs > ords round-trips correctly
            ok 8503 - chrs works with a list of ints
            not ok 8504 - chr of surrogate # TODO chr surrogate
            # Failed test 'chr of surrogate'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S29-conversions/ord_and_chr.rakudo line 155
            ok 8505 - chr of noncharacter
            ok 8506 - chr of noncharacter
            ok 8507 - chr out of range (max)
            ok 8508 - chr out of range (negative)
            ok 8509 - ord("") returns an undefined value
            ok 8510 - ord of named high character
            ok 8511 - chr > ord round trip of high character
            ok 8512 - .ord gives first NFC codepoint (1)
            ok 8513 - .ord gives first NFC codepoint (2)
            ok 8514 - chrs works with a list of numifiable strings
                1..6
                    1..2
                    ok 1 - 'chr 2⁶³-1' died
                    ok 2 - right exception type (Exception)
                ok 1 - "chr 2⁶³-1"
                    1..2
                    ok 1 - '(2⁶³-1).chr' died
                    ok 2 - right exception type (Exception)
                ok 2 - "(2⁶³-1).chr"
                    1..2
                    ok 1 - 'chr 2⁶³' died
                    ok 2 - right exception type (Exception)
                ok 3 - "chr 2⁶³"
                    1..2
                    ok 1 - '2⁶³.chr' died
                    ok 2 - right exception type (Exception)
                ok 4 - "2⁶³.chr"
                    1..2
                    ok 1 - 'chr 2¹⁰⁰' died
                    ok 2 - right exception type (Exception)
                ok 5 - "chr 2¹⁰⁰"
                    1..2
                    ok 1 - '(2¹⁰⁰).chr' died
                    ok 2 - right exception type (Exception)
                ok 6 - "(2¹⁰⁰).chr"
            ok 8515 - chr with large codepoints throws useful error
# FUDGED!
            1..38
            ok 8516 - we have 4 elements in the array
            ok 8517 - pop(@pop) works
            ok 8518 - we have 3 elements in the array
            ok 8519 - pop @pop works
            ok 8520 - we have 2 elements in the array
            ok 8521 - @pop.pop() works
            ok 8522 - we have 1 element in the array
            ok 8523 - @pop.pop works
            ok 8524 - we have 1 element in the array
            ok 8525 - @pop.pop works
            ok 8526 - we have no more element in the array
            ok 8527 - after the array is exhausted pop() returns undefined
            ok 8528 - after the array is exhausted pop() returns Failure
            ok 8529 - we have 4 elements in the array
            ok 8530 - inline pop(@pop) works
            ok 8531 - we have 3 elements in the array
            ok 8532 - inline pop @pop works
            ok 8533 - we have 2 elements in the array
            ok 8534 - inline @pop.pop() works
            ok 8535 - we have 1 element in the array
            ok 8536 - inline @pop.pop works
            ok 8537 - we have no more element in the array
            ok 8538 - after the array is exhausted pop() returns undefined
            ok 8539 - after the array is exhausted pop() returns Failure
            ok 8540 - this will return 3
            ok 8541 - this will return undefined
            ok 8542 - [].pop is a Failure
            ok 8543 - pop on an un-initialized array returns undefined
            ok 8544 - pop off uninitialized array is a Failure
Could not find symbol '&Argument' in 'X::TypeCheck'
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-array/pop.rakudo line 82
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-array/pop.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

            1..392
                1..2
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 1 - Array sub: whole
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 2 - Array method: whole
            ok 8545 - Array whole
                1..2
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 1 - Array sub: simple 1 elem
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 2 - Array method: simple 1 elem
            ok 8546 - Array simple 1 elem
                1..2
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 1 - Array sub: simple 2 elems
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 2 - Array method: simple 2 elems
            ok 8547 - Array simple 2 elems
                1..2
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 1 - Array sub: simple 2 elems, as Str
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 2 - Array method: simple 2 elems, as Str
            ok 8548 - Array simple 2 elems, as Str
                1..2
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 1 - Array sub: simple rest
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 2 - Array method: simple rest
            ok 8549 - Array simple rest
                1..2
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 1 - Array sub: simple rest *
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 2 - Array method: simple rest *
            ok 8550 - Array simple rest *
                1..2
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 1 - Array sub: none rest
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 2 - Array method: none rest
            ok 8551 - Array none rest
                1..2
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 1 - Array sub: none * rest
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 2 - Array method: none * rest
            ok 8552 - Array none * rest
                1..2
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 1 - Array sub: end rest
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 2 - Array method: end rest
            ok 8553 - Array end rest
                1..2
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 1 - Array sub: end some
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 2 - Array method: end some
            ok 8554 - Array end some
                1..2
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 1 - Array sub: end some callable
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 2 - Array method: end some callable
            ok 8555 - Array end some callable
                1..2
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 1 - Array sub: push none
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 2 - Array method: push none
            ok 8556 - Array push none
                1..2
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 1 - Array sub: push none *
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 2 - Array method: push none *
            ok 8557 - Array push none *
                1..2
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 1 - Array sub: push none callable
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 2 - Array method: push none callable
            ok 8558 - Array push none callable
                1..2
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 1 - Array sub: push two
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 2 - Array method: push two
            ok 8559 - Array push two
                1..2
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 1 - Array sub: push two *
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 2 - Array method: push two *
            ok 8560 - Array push two *
                1..2
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 1 - Array sub: push self
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 2 - Array method: push self
            ok 8561 - Array push self
                1..2
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 1 - Array sub: push self *
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 2 - Array method: push self *
            ok 8562 - Array push self *
                1..2
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 1 - Array sub: unshift
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 2 - Array method: unshift
            ok 8563 - Array unshift
                1..2
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 1 - Array sub: unshift none
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 2 - Array method: unshift none
            ok 8564 - Array unshift none
                1..2
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 1 - Array sub: unshift self
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 2 - Array method: unshift self
            ok 8565 - Array unshift self
                1..2
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 1 - Array sub: replace self
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 2 - Array method: replace self
            ok 8566 - Array replace self
                1..2
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 1 - Array sub: replace 1 with 1
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 2 - Array method: replace 1 with 1
            ok 8567 - Array replace 1 with 1
                1..2
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 1 - Array sub: replace 1 with range
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 2 - Array method: replace 1 with range
            ok 8568 - Array replace 1 with range
                1..2
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 1 - Array sub: replace 1 with none
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 2 - Array method: replace 1 with none
            ok 8569 - Array replace 1 with none
                1..2
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 1 - Array sub: replace 1 with self
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 2 - Array method: replace 1 with self
            ok 8570 - Array replace 1 with self
                1..2
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 1 - Array sub: replace none with 1
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 2 - Array method: replace none with 1
            ok 8571 - Array replace none with 1
                1..2
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 1 - Array sub: replace none with range
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 2 - Array method: replace none with range
            ok 8572 - Array replace none with range
                1..2
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 1 - Array sub: replace none with none
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 2 - Array method: replace none with none
            ok 8573 - Array replace none with none
                1..2
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 1 - Array sub: replace none with self
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 2 - Array method: replace none with self
            ok 8574 - Array replace none with self
                1..2
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 1 - Array sub: remove 1 past end
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 2 - Array method: remove 1 past end
            ok 8575 - Array remove 1 past end
                1..2
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 1 - Array sub: remove 1 past end + push
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 2 - Array method: remove 1 past end + push
            ok 8576 - Array remove 1 past end + push
                1..2
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 1 - Array sub: remove whatever past end + push
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 2 - Array method: remove whatever past end + push
            ok 8577 - Array remove whatever past end + push
                1..2
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 1 - Array sub: two *, no list
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 2 - Array method: two *, no list
            ok 8578 - Array two *, no list
                1..2
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 1 - Array sub: two * with a given list
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 2 - Array method: two * with a given list
            ok 8579 - Array two * with a given list
                1..2
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 1 - Array sub: .splice(Callable, Whatever)
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 2 - Array method: .splice(Callable, Whatever)
            ok 8580 - Array .splice(Callable, Whatever)
                1..2
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 1 - Array sub: .splice(Callable, Whatever, List)
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 2 - Array method: .splice(Callable, Whatever, List)
            ok 8581 - Array .splice(Callable, Whatever, List)
                1..2
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 1 - Array sub: .splice(Int, Callable, List)
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 2 - Array method: .splice(Int, Callable, List)
            ok 8582 - Array .splice(Int, Callable, List)
                1..2
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 1 - Array sub: .splice(Callable, Int, List)
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 2 - Array method: .splice(Callable, Int, List)
            ok 8583 - Array .splice(Callable, Int, List)
                1..2
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 1 - Array sub: .splice(Callable, Callable, List)
                    1..4
                    ok 1 - return types match
                    ok 2 - return results match
                    ok 3 - remainder types match
                    ok 4 - remainder results match
                ok 2 - Array method: .splice(Callable, Callable, List)
            ok 8584 - Array .splice(Callable, Callable, List)
WARNING: unhandled Failure detected in DESTROY. If you meant to ignore it, you can mark it as handled by calling .Bool, .so, .not, or .defined methods. The Failure was:
Cannot pop from an empty Array
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-array/pop.rakudo line 76
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-array/pop.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

WARNING: unhandled Failure detected in DESTROY. If you meant to ignore it, you can mark it as handled by calling .Bool, .so, .not, or .defined methods. The Failure was:
Cannot pop from an empty Array
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-array/pop.rakudo line 69
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-array/pop.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

WARNING: unhandled Failure detected in DESTROY. If you meant to ignore it, you can mark it as handled by calling .Bool, .so, .not, or .defined methods. The Failure was:
Cannot pop from an empty Array
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-array/pop.rakudo line 62
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-array/pop.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

WARNING: unhandled Failure detected in DESTROY. If you meant to ignore it, you can mark it as handled by calling .Bool, .so, .not, or .defined methods. The Failure was:
Cannot pop from an empty Array
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-array/pop.rakudo line 41
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-array/pop.rakudo line 12
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

Could not find symbol '&Lazy' in 'X::Cannot'
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-array/splice.rakudo line 153
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-array/splice.rakudo line 52
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

            1..129
            ok 8585 - Hash.AT-KEY
            ok 8586 - Hash.AT-KEY =
            ok 8587 - Hash.AT-KEY (changed)
            ok 8588 - Hash.EXISTS-KEY (existing)
            ok 8589 - !Hash.EXISTS-KEY (non-existing)
            ok 8590 - Hash.ASSIGN-KEY (existing)
            ok 8591 - Hash.AT-KEY (existing ASSIGN-KEY)
            ok 8592 - Hash.ASSIGN-KEY (non-existing)
            ok 8593 - Hash.AT-KEY (non-existing ASSIGN-KEY)
            ok 8594 - Hash.BIND-KEY (existing)
            ok 8595 - Hash.AT-KEY (existing BIND-KEY)
            ok 8596 - Hash.AT-KEY (changed existing BIND-KEY)
            ok 8597 - Hash.BIND-KEY (non-existing)
            ok 8598 - Hash.AT-KEY (non-existing BIND-KEY)
            ok 8599 - Hash.AT-KEY (changed non-existing BIND-KEY)
            ok 8600 - Hash.DELETE-KEY (existing)
            ok 8601 - !Hash.EXISTS-KEY (existing DELETE-KEY)
            ok 8602 - Hash.DELETE-KEY (non-existing)
            ok 8603 - !Hash.EXISTS-KEY (non-existing DELETE-KEY)
            ok 8604 - Hash[Int].AT-KEY
            ok 8605 - Hash[Int].AT-KEY =
            ok 8606 - Hash[Int].AT-KEY (changed)
            ok 8607 - Hash[Int].EXISTS-KEY (existing)
            ok 8608 - !Hash[Int].EXISTS-KEY (non-existing)
            ok 8609 - Hash[Int].ASSIGN-KEY (existing)
            ok 8610 - Hash[Int].AT-KEY (existing ASSIGN-KEY)
            ok 8611 - Hash[Int].ASSIGN-KEY (non-existing)
            ok 8612 - Hash[Int].AT-KEY (non-existing ASSIGN-KEY)
            ok 8613 - Hash[Int].BIND-KEY (existing)
            ok 8614 - Hash[Int].AT-KEY (existing BIND-KEY)
            ok 8615 - Hash[Int].AT-KEY (changed existing BIND-KEY)
            ok 8616 - Hash[Int].BIND-KEY (non-existing)
            ok 8617 - Hash[Int].AT-KEY (non-existing BIND-KEY)
            ok 8618 - Hash[Int].AT-KEY (changed non-existing BIND-KEY)
            ok 8619 - Hash[Int].DELETE-KEY (existing)
            ok 8620 - !Hash[Int].EXISTS-KEY (existing DELETE-KEY)
            ok 8621 - Hash[Int].DELETE-KEY (non-existing)
            ok 8622 - !Hash[Int].EXISTS-KEY (non-existing DELETE-KEY)
            ok 8623 - Hash[Int,Any].AT-KEY
            ok 8624 - Hash[Int,Any].AT-KEY =
            ok 8625 - Hash[Int,Any].AT-KEY (changed)
            ok 8626 - Hash[Int,Any].EXISTS-KEY (existing)
            ok 8627 - !Hash[Int,Any].EXISTS-KEY (non-existing)
            ok 8628 - Hash[Int,Any].ASSIGN-KEY (existing)
            ok 8629 - Hash[Int,Any].AT-KEY (existing ASSIGN-KEY)
            ok 8630 - Hash[Int,Any].ASSIGN-KEY (non-existing)
            ok 8631 - Hash[Int,Any].AT-KEY (non-existing ASSIGN-KEY)
            ok 8632 - Hash[Int,Any].BIND-KEY (existing)
            ok 8633 - Hash[Int,Any].AT-KEY (existing BIND-KEY)
            ok 8634 - Hash[Int,Any].AT-KEY (changed existing BIND-KEY)
            ok 8635 - Hash[Int,Any].BIND-KEY (non-existing)
            ok 8636 - Hash[Int,Any].AT-KEY (non-existing BIND-KEY)
            ok 8637 - Hash[Int,Any].AT-KEY (changed non-existing BIND-KEY)
            ok 8638 - Hash[Int,Any].DELETE-KEY (existing)
            ok 8639 - !Hash[Int,Any].EXISTS-KEY (existing DELETE-KEY)
            ok 8640 - Hash[Int,Any].DELETE-KEY (non-existing)
            ok 8641 - !Hash[Int,Any].EXISTS-KEY (non-existing DELETE-KEY)
            ok 8642 - $a.EXISTS-KEY (undefined)
            ok 8643 - $a.AT-KEY (undefined)
            ok 8644 - $a.AT-KEY = (undefined)
            ok 8645 - $a.AT-KEY (defined)
            ok 8646 - $a.EXISTS-KEY (defined)
            ok 8647 - $a.DELETE-KEY (defined)
            ok 8648 - $a.EXISTS-KEY (after delete)
            ok 8649 - $a.ASSIGN-KEY (undefined)
            ok 8650 - $a.AT-KEY (defined)
            ok 8651 - $a.DELETE-KEY (defined)
            ok 8652 - $a.EXISTS-KEY (after delete)
            ok 8653 - $a.BIND-KEY (undefined)
            ok 8654 - $a.AT-KEY (defined)
            not ok 8655 - $a.AT-KEY (defined) # TODO binding to a key in an undefine doesn't work?
            # Failed test '$a.AT-KEY (defined)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-basics/xxKEY.rakudo line 70
            # expected: '65'
            #      got: '42'
            not ok 8656 - $a.DELETE-KEY (defined) # TODO binding to a key in an undefine doesn't work?
            # Failed test '$a.DELETE-KEY (defined)'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-basics/xxKEY.rakudo line 71
            # expected: '65'
            #      got: '42'
            ok 8657 - $a.EXISTS-KEY (after delete)
            ok 8658 - $a.DELETE-KEY (undefined)
            ok 8659 - $a.EXISTS-KEY (after delete)
            ok 8660 - $s.EXISTS-KEY
            ok 8661 - !$s.EXISTS-KEY
            ok 8662 - $s.AT-KEY
Could not find symbol '&Bind' in 'X'
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-basics/xxKEY.rakudo line 87
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-basics/xxKEY.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

            1..64
            ok 8663 - Array.elems (original)
            ok 8664 - Array.AT-POS
            ok 8665 - Array.AT-POS =
            ok 8666 - Array.AT-POS (changed)
            ok 8667 - Array.EXISTS-POS (existing)
            ok 8668 - !Array.EXISTS-POS (non-existing)
            ok 8669 - Array.ASSIGN-POS (existing)
            ok 8670 - Array.AT-POS (existing ASSIGN-POS)
            ok 8671 - Array.ASSIGN-POS (non-existing)
            ok 8672 - Array.AT-POS (non-existing ASSIGN-POS)
            ok 8673 - Array.elens (one added)
            ok 8674 - Array.BIND-POS (existing)
            ok 8675 - Array.AT-POS (existing BIND-POS)
            ok 8676 - Array.AT-POS (changed existing BIND-POS)
            ok 8677 - Array.BIND-POS (non-existing)
            ok 8678 - Array.AT-POS (non-existing BIND-POS)
            ok 8679 - Array.AT-POS (changed non-existing BIND-POS)
            ok 8680 - Array.DELETE-POS (existing)
            ok 8681 - !Array.EXISTS-POS (existing DELETE-POS)
            ok 8682 - Array.DELETE-POS (non-existing)
            ok 8683 - !Array.EXISTS-POS (non-existing DELETE-POS)
            ok 8684 - Array[Int].elems (original)
            ok 8685 - Array[Int].AT-POS
            ok 8686 - Array[Int].AT-POS =
            ok 8687 - Array[Int].AT-POS (changed)
            ok 8688 - Array[Int].EXISTS-POS (existing)
            ok 8689 - !Array[Int].EXISTS-POS (non-existing)
            ok 8690 - Array[Int].ASSIGN-POS (existing)
            ok 8691 - Array[Int].AT-POS (existing ASSIGN-POS)
            ok 8692 - Array[Int].ASSIGN-POS (non-existing)
            ok 8693 - Array[Int].AT-POS (non-existing ASSIGN-POS)
            ok 8694 - Array[Int].elens (one added)
            ok 8695 - Array[Int].BIND-POS (existing)
            ok 8696 - Array[Int].AT-POS (existing BIND-POS)
            ok 8697 - Array[Int].AT-POS (changed existing BIND-POS)
            ok 8698 - Array[Int].BIND-POS (non-existing)
            ok 8699 - Array[Int].AT-POS (non-existing BIND-POS)
            ok 8700 - Array[Int].AT-POS (changed non-existing BIND-POS)
            ok 8701 - Array[Int].DELETE-POS (existing)
            ok 8702 - !Array[Int].EXISTS-POS (existing DELETE-POS)
            ok 8703 - Array[Int].DELETE-POS (non-existing)
            ok 8704 - !Array[Int].EXISTS-POS (non-existing DELETE-POS)
            ok 8705 - $a.EXISTS-POS (undefined)
            ok 8706 - $a.AT-POS (undefined)
            ok 8707 - $a.AT-POS = (undefined)
            ok 8708 - $a.AT-POS (defined)
            ok 8709 - $a.EXISTS-POS (defined)
            ok 8710 - $a.DELETE-POS (defined)
            ok 8711 - $a.EXISTS-POS (after delete)
            ok 8712 - $a.ASSIGN-POS (undefined)
            ok 8713 - $a.AT-POS (defined)
            ok 8714 - $a.DELETE-POS (defined)
            ok 8715 - $a.EXISTS-POS (after delete)
            ok 8716 - # SKIP No such method 'BIND-POS' for invocant of type 'Any'
            ok 8717 - # SKIP No such method 'BIND-POS' for invocant of type 'Any'
            ok 8718 - # SKIP No such method 'BIND-POS' for invocant of type 'Any'
            ok 8719 - # SKIP No such method 'BIND-POS' for invocant of type 'Any'
            ok 8720 - # SKIP No such method 'BIND-POS' for invocant of type 'Any'
            ok 8721 - $a.DELETE-POS (undefined)
            ok 8722 - $a.EXISTS-POS (after delete)
            ok 8723 - 2 dimensional EXISTS-POS with Failure
            ok 8724 - 3 dimensional EXISTS-POS with Failure
            ok 8725 - 4 dimensional EXISTS-POS with Failure
            ok 8726 - Could we change the "element" without creating ASSIGN-POS?
# FUDGED!
            1..6
            ok 8727 - # SKIP cat NYI
            ok 8728 - # SKIP cat NYI
            ok 8729 - # SKIP cat NYI
            ok 8730 - # SKIP cat NYI
            ok 8731 - # SKIP cat NYI
            ok 8732 - # SKIP cat NYI
# FUDGED!
            1..14
            ok 8733 - simple zip
            ok 8734 - also with Z char
            ok 8735 - zip of 3 arrays
            ok 8736 - also with Z char
            ok 8737 - zip uses length of shortest
            ok 8738 - # SKIP lvalue zip
            ok 8739 - # SKIP lvalue zip
            ok 8740 - infix:<Z> imposes list context
            ok 8741 - can mix arrays and ranges for infix:<Z>
            ok 8742 - can mix arrays and ranges for infix:<Z>
            ok 8743 - zip:with works on list associative
            ok 8744 - zip:with works on left associative
            not ok 8745 - zip:with works on right associative
            # Failed test 'zip:with works on right associative'
            # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-container/zip.rakudo line 69
            # expected: '1 2417851639229258349412352'
            #      got: '1 4096'
            ok 8746 - zip:with works on chain associative
# FUDGED!
WARNING: unhandled Failure detected in DESTROY. If you meant to ignore it, you can mark it as handled by calling .Bool, .so, .not, or .defined methods. The Failure was:
Index out of range. Is: -1, should be in 0..^Inf
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-basics/xxPOS.rakudo line 90
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-basics/xxPOS.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

WARNING: unhandled Failure detected in DESTROY. If you meant to ignore it, you can mark it as handled by calling .Bool, .so, .not, or .defined methods. The Failure was:
Index out of range. Is: -1, should be in 0..^Inf
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-basics/xxPOS.rakudo line 88
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-basics/xxPOS.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

WARNING: unhandled Failure detected in DESTROY. If you meant to ignore it, you can mark it as handled by calling .Bool, .so, .not, or .defined methods. The Failure was:
Index out of range. Is: -1, should be in 0..^Inf
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-basics/xxPOS.rakudo line 86
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-basics/xxPOS.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

            1..267
                1..3
Error while constructing error object:Could not locate compile-time value for symbol Comp::AdHoc
                ok 1 - '42 +' died
                ok 2 - right exception type (Exception)
                ok 3 - .message matches rx/term/
            ok 8747 - missing rhs of infix
Could not find symbol '&AsStr' in 'X::Buf'
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-exceptions/misc2.rakudo line 10
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

            1..15
            ok 8748 - # SKIP unspecced
            ok 8749 - Test existence for single key. (adverb)
            ok 8750 - Test existence for single key. (adverb 2)
            ok 8751 - Defined 0 value for key: none
            ok 8752 - Defined 1 value for key: one
            ok 8753 - NOT Defined value for key: nothing
            ok 8754 - empty hash stays same when read from (1)
            ok 8755 - empty hash stays same when read from (2)
            ok 8756 - empty hash stays same when read from (3)
            ok 8757 - taking a reference to a hash element does not auto-vivify the element
            ok 8758 - empty hash stays same when read from (4)
            ok 8759 - populated hash stays same when read from (1)
            ok 8760 - populated hash stays same when read from (2)
            ok 8761 - populated hash stays same when read from (3)
            ok 8762 - populated hash stays same when read from (4)
# FUDGED!
            1..10
Could not find symbol '&Resolve' in 'X::IO'
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-io/child-secure.rakudo line 72
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-io/child-secure.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

Could not locate compile-time value for symbol TypeCheck::Argument
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

            1..30
                1..4
                ok 1 - default
                ok 2 - changed
                ok 3 - attributes get set on next handles
                ok 4 - can set .nl-in to a string
            ok 8763 - chomp method and nl-in method
                1..4
                ok 1 - we have some IO::Handles that are open before calling .close
                ok 2 - .close returns True
                ok 3 - all of original IO::Handles got closed
                ok 4 - all the handles get removed and active handle is niled
            ok 8764 - close method
                1..12
                ok 1 - \()
                ok 2 - \("")
                ok 3 - \("♥")
                ok 4 - \("♥", 2)
                ok 5 - \(0)
                ok 6 - \(1)
                ok 7 - \(5)
                ok 8 - \(1000)
                ok 9 - \(2, 3)
                ok 10 - \(/../)
                ok 11 - \(/../, 2)
                ok 12 - \(/<:alpha>/, 3)
            ok 8765 - comb method
                1..3
                ok 1 - we have some IO::Handles that are open before calling .DESTROY
                ok 2 - all of original IO::Handles got closed
                ok 3 - all the handles get removed and active handle is niled
            ok 8766 - DESTROY method
                1..4
                ok 1 - default
                ok 2 - can change via .new
                    1..3
assign requires a concrete object (got a Rakudo::Internals::LoweredAwayLexical type object instead)
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-io/io-cathandle.rakudo line 96
  in sub subtest at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 435
  in sub subtest at /Users/tobiuo/src/git/rakudo/install/share/perl6/core/sources/2D4A7CA10695CD2B374573413D261A660E282E2A (Test) line 424
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-io/io-cathandle.rakudo line 87
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

                    1..52
Use of uninitialized value $*CWD of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-io/io-path-cygwin.rakudo line 9
                    ok 1 - Can create IO::Path::Cygwin
                    ok 2 - volume "/foo/bar" -> ""
                    ok 3 - dirname "/foo/bar" -> "/foo"
                    ok 4 - basename "/foo/bar" -> "bar"
                    ok 5 - volume "C:foo\\bar\" -> "C:"
                    ok 6 - dirname "C:foo\\bar\" -> "foo"
                    ok 7 - basename "C:foo\\bar\" -> "bar"
                    ok 8 - .path returns Str of path
                    ok 9 - .raku loopback
                    ok 10 - volume "//server/share/" -> ""/server/share"
                    ok 11 - dirname "\\server\share\" -> "\"
                    ok 12 - basename "\\server\share\" -> "\"
                    ok 13 - "\\server\share" restringifies to itself
                    ok 14 - volume "//server/share/a" -> ""//server/share"
                    ok 15 - dirname "//server/share/a" -> "/"
                    ok 16 - basename "//server/share/a" -> "a"
                    ok 17 - "//server/share/a" restringifies to itself
                    ok 18 - current directory
                    ok 19 - parent directory
                        1..2
                        ok 1 - code dies
                        ok 2 - right exception type (Exception)
                    ok 20 - no path not allowed
                        1..2
                        ok 1 - code dies
                        ok 2 - right exception type (Exception)
                    ok 21 - empty not allowed
                    ok 22 - cleanup '/usr/////local/./bin/.\./perl/' -> '/usr/local/bin/perl'
                    ok 23 - relative path is-relative
                    ok 24 - relative path ! is-absolute
                    ok 25 - absolute path ! is-relative
                    ok 26 - absolute path is-absolute
                    ok 27 - UNC path is-absolute
                    ok 28 - UNC path with forward slash is-absolute
                    ok 29 - path beginning with backslash is absolute
                    ok 30 - "A:\" is absolute
                    ok 31 - "A:b" is relative
                    ok 32 - absolute path from $*CWD
                    ok 33 - absolute path specified
                    ok 34 - relative path specified
                    ok 35 - relative inverts absolute
                    ok 36 - absolute inverts relative
                    not ok 37 - absolute inverts relative with resolve # TODO resolve NYI, needs nqp::readlink
                    # Failed test 'absolute inverts relative with resolve'
                    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-io/io-path-cygwin.rakudo line 66
                    # expected: '\foo\bar'
                    #      got: '/zip/loc/../../foo/bar'
                    ok 38 - parent of 'foo/bar' is 'foo'
                    ok 39 - parent of 'foo' is '.'
                    ok 40 - parent of '.' is '..'
                    ok 41 - parent of '..' is '../..'
                    ok 42 - parent at top level is '/'
                    ok 43 - parent of root is '/'
                    ok 44 - parent of root ('\') is '/'
                    ok 45 - append to root
                    ok 46 - append to cwd
                    ok 47 - succ basic
                    ok 48 - succ x 2
                    ok 49 - pred basic
                    ok 50 - succ only effects basename
                    ok 51 - pred only effects basename
                    ok 52 - .absolute on paths starting with `-` does not produce empty string
# FUDGED!
                    1..37
Use of uninitialized value $*CWD of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-io/io-path-unix.rakudo line 9
                    ok 53 - Can create IO::Path::Unix
                    ok 54 - volume is empty on POSIX
                    ok 55 - dirname "/foo/bar" -> "/foo"
                    ok 56 - basename "/foo/bar" -> "bar"
                    ok 57 - dirname "foo//bar//" -> "foo"
                    ok 58 - basename "foo//bar//" -> "bar"
                    ok 59 - .path returns Str
IO::Path::Unix.new("foo//bar//", :CWD("/zip/loc"))
                    ok 60 - .raku loopback
                    ok 61 - current directory
                    ok 62 - parent directory
                        1..2
                        ok 1 - code dies
                        ok 2 - right exception type (Exception)
                    ok 63 - no path not allowed
                        1..2
                        ok 1 - code dies
                        ok 2 - right exception type (Exception)
                    ok 64 - empty not allowed
                    ok 65 - cleanup '/usr/////local/./bin/././perl/' -> '/usr/local/bin/perl'
                    ok 66 - relative path is-relative
                    ok 67 - relative path ! is-absolute
                    ok 68 - absolute path ! is-relative
                    ok 69 - absolute path is-absolute
                    ok 70 - absolute path from $*CWD
                    ok 71 - absolute path specified
                    ok 72 - relative path specified
                    ok 73 - relative inverts absolute
                    ok 74 - absolute inverts relative
                    not ok 75 - absolute inverts relative with resolve # TODO resolve NYI, needs nqp::readlink
                    # Failed test 'absolute inverts relative with resolve'
                    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-io/io-path-unix.rakudo line 51
                    # expected: '/foo/bar'
                    #      got: '/zip/loc/../../foo/bar'
                    ok 76 - parent of 'foo/bar' is 'foo'
                    ok 77 - parent of 'foo' is '.'
                    ok 78 - parent of '.' is '..'
                    ok 79 - parent of '..' is '../..'
                    ok 80 - parent at top level is '/'
                    ok 81 - parent of root is '/'
                    ok 82 - append to root
                    ok 83 - append to cwd
                    ok 84 - succ basic
                    ok 85 - succ x 2
                    ok 86 - pred basic
                    ok 87 - succ only effects basename
                    ok 88 - pred only effects basename
                    ok 89 - .absolute on paths starting with `-` does not produce empty string
# FUDGED!
                    1..51
Use of uninitialized value $*CWD of type Any in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-io/io-path-win.rakudo line 8
                    ok 90 - Can create IO::Path::Win32
                    ok 91 - volume "\foo\bar" -> ""
                    ok 92 - dirname "\foo\bar" -> "\foo"
                    ok 93 - basename "\foo\bar" -> "bar"
                    ok 94 - volume "C:foo//bar//" -> "C:"
                    ok 95 - dirname "C:foo//bar//" -> "foo"
                    ok 96 - basename "C:foo//bar//" -> "bar"
                    ok 97 - .path returns Str
                    ok 98 - .raku loopback
                    ok 99 - volume "\\server\share\" -> ""\\server\share"
                    ok 100 - dirname "\\server\share\" -> "\"
                    ok 101 - basename "\\server\share\" -> "\"
                    ok 102 - "\\server\share\" restringifies to itself
                    ok 103 - volume "//server/share/a" -> ""//server/share"
                    ok 104 - directory "//server/share/a" -> "/"
                    ok 105 - basename "//server/share/a" -> "a"
                    ok 106 - "//server/share/a" restringifies to itself
                    ok 107 - current directory
                    ok 108 - parent directory
                        1..2
                        ok 1 - code dies
                        ok 2 - right exception type (Exception)
                    ok 109 - no path not allowed
                        1..2
                        ok 1 - code dies
                        ok 2 - right exception type (Exception)
                    ok 110 - empty not allowed
                    ok 111 - cleanup '/usr/////local/./bin/././perl/' -> '\usr\local\bin\perl'
                    ok 112 - relative path is-relative
                    ok 113 - relative path ! is-absolute
                    ok 114 - absolute path ! is-relative
                    ok 115 - absolute path is-absolute
                    ok 116 - UNC path is-absolute
                    ok 117 - UNC path with forward slash is-absolute
                    ok 118 - path beginning with forward slash is absolute
                    ok 119 - "A:\" is absolute
                    ok 120 - "A:b" is relative
                    ok 121 - absolute path from $*CWD
                    ok 122 - absolute path specified
                    ok 123 - relative path specified
                    ok 124 - relative inverts absolute
                    ok 125 - absolute inverts relative
                    not ok 126 - absolute inverts relative with resolve # TODO resolve NYI, needs nqp::readlink
                    # Failed test 'absolute inverts relative with resolve'
                    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-io/io-path-win.rakudo line 66
                    # expected: '\foo\bar'
                    #      got: 'C:\zip\loc\..\..\foo\bar'
                    ok 127 - parent of 'foo/bar' is 'foo'
                    ok 128 - parent of 'foo' is '.'
                    ok 129 - parent of '.' is '..'
                    ok 130 - parent of '..' is '../..'
                    ok 131 - parent at top level is '/'
                    ok 132 - parent of root is '/'
                    ok 133 - append to root
                    ok 134 - append to cwd
                    ok 135 - succ basic
                    ok 136 - succ x 2
                    ok 137 - pred basic
                    ok 138 - succ only effects basename
                    ok 139 - pred only effects basename
                    ok 140 - .absolute on paths starting with `-` does not produce empty string
# FUDGED!
                    1..7
                    ok 141 - /private/var/folders/b5/yttfnvk10cj5500y1q5mmnrr0000gn/T/perl6_roast_startup_p6_line12_0_84873678756750691613283799 exists
                    ok 142 - /private/var/folders/b5/yttfnvk10cj5500y1q5mmnrr0000gn/T/perl6_roast_startup_p6_line12_0_84873678756750691613283799 is a directory
Could not find symbol '&Rmdir' in 'X::IO'
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-io/mkdir_rmdir.rakudo line 22
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-io/mkdir_rmdir.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 20
  in block <unit> at other/startup.p6 line 7

Could not locate compile-time value for symbol TypeCheck::Argument
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

                    1..26
                    ok 143 - first(, :end, :k) returns an Int
                    ok 144 - returned value by first() is correct
                    ok 145 - first(, :end, :k) returns an Int
                    ok 146 - returned value by first(, :end, :k) is correct
                    ok 147 - method form of first, :end, :k returns an Int
                    ok 148 - method form of first, :end, :k returns the expected item
                    ok 149 - # SKIP adverbial block
                    ok 150 - # SKIP adverbial block
                    ok 151 - first, :end, :k returns Nil on unsuccessful match
                    ok 152 - first(, :end, :k) search for odd elements successful
                    ok 153 - Matching closure in first(, :end, :k) is only executed twice
                    ok 154 - method form of first, :end, :k with range returns the expected item
                    ok 155 - method form of first, :end, :k with range returns the expected item
                    ok 156 - first by type Str works
                    ok 157 - first by type Int works
                    ok 158 - first by type Rat works
                    ok 159 - first by regex /o/
                    ok 160 - first by regex /ob/
                    ok 161 - first by regex /l.*o/
                    ok 162 - .first, :end, :k also takes a junction as matcher
                    ok 163 - .first, :end, :k also takes a junction as matcher (sub form)
Could not find symbol '&Bool' in 'X::Match'
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-list/first-end-k.rakudo line 76
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-list/first-end-k.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

                    1..25
                    ok 164 - first() returns an Int
                    ok 165 - returned value by first() is correct
                    ok 166 - first() returns an Int
                    ok 167 - returned value by first() is correct
                    ok 168 - method form of first returns an Int
                    ok 169 - method form of first returns the expected item
                    ok 170 - # SKIP adverbial block
                    ok 171 - # SKIP adverbial block
                    ok 172 - first returns Nil on unsuccessful match
                    ok 173 - first() search for odd elements successful
                    ok 174 - Matching closure in first() is only executed once
                    ok 175 - method form of first with range returns the expected item
                    ok 176 - method form of first with range returns the expected item
                    ok 177 - first by type Str works
                    ok 178 - first by type Int works
                    ok 179 - first by type Rat works
                    ok 180 - first by regex /o/
                    ok 181 - first by regex /ob/
                    ok 182 - first by regex /l.*o/
                    ok 183 - .first also takes a junction as matcher
                    ok 184 - .first also takes a junction as matcher (sub form)
Could not find symbol '&Bool' in 'X::Match'
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-list/first-k.rakudo line 76
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-list/first-k.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

                    1..31
                    ok 185 - first() returns an Int
                    ok 186 - returned value by first() is correct
                    ok 187 - first() returns an Int
                    ok 188 - returned value by first() is correct
                    ok 189 - method form of first returns an Int
                    ok 190 - method form of first returns the expected item
                    ok 191 - # SKIP adverbial block
                    ok 192 - # SKIP adverbial block
                    ok 193 - first returns undefined unsuccessful match
                    ok 194 - first() search for odd elements successful
                    ok 195 - Matching closure in first() is only executed once
                    ok 196 - method form of first with range returns the expected item
                    ok 197 - method form of first with range returns the expected item
                    ok 198 - Looking up first by type Str works
                    ok 199 - Looking up first by type Int works
                    ok 200 - Looking up first by type Rat works
                    ok 201 - Looking up first by regex /o/
                    ok 202 - Looking up first by regex /ob/
                    ok 203 - Looking up first by regex /l.*o/
                    ok 204 - .first also takes a junction as matcher
                    ok 205 - .first also takes a junction as matcher (sub form)
                    ok 206 - first() returns Nil when no values match
                    ok 207 - .first returns Nil when no values match
Could not find symbol '&Bool' in 'X::Match'
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-list/first.rakudo line 82
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-list/first.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

                    1..40
                    ok 208 - do we get Ints
                    ok 209 - simple direct test of sub
                    ok 210 - simple direct test of method
                    ok 211 - we got a list back
                    ok 212 - got the value we expected
                    ok 213 - got the value we expected
                    ok 214 - got the value we expected
                    ok 215 - got the value we expected
                    ok 216 - got the value we expected
                    ok 217 - # SKIP adverbial block
                    ok 218 - # SKIP adverbial block
                    ok 219 - # SKIP adverbial block
                    ok 220 - # SKIP adverbial block
                    ok 221 - # SKIP adverbial block
                    ok 222 - # SKIP adverbial block
                    ok 223 - # SKIP adverbial block
                    ok 224 - # SKIP adverbial block
                    ok 225 - # SKIP adverbial block
                    ok 226 - # SKIP adverbial block
                    ok 227 - # SKIP adverbial block
                    ok 228 - # SKIP adverbial block
                    not ok 229 - we got a list back # TODO closure as non-final argument
                    # Failed test 'we got a list back'
                    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-list/grep-k.rakudo line 52
                    # expected: '5'
                    #      got: '0'
                    not ok 230 - got the value we expected # TODO closure as non-final argument
                    # Failed test 'got the value we expected'
                    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-list/grep-k.rakudo line 53
                    # expected: '0'
                    #      got: (Any)
                    not ok 231 - got the value we expected # TODO closure as non-final argument
                    # Failed test 'got the value we expected'
                    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-list/grep-k.rakudo line 54
                    # expected: '2'
                    #      got: (Any)
                    not ok 232 - got the value we expected # TODO closure as non-final argument
                    # Failed test 'got the value we expected'
                    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-list/grep-k.rakudo line 55
                    # expected: '4'
                    #      got: (Any)
                    not ok 233 - got the value we expected # TODO closure as non-final argument
                    # Failed test 'got the value we expected'
                    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-list/grep-k.rakudo line 56
                    # expected: '6'
                    #      got: (Any)
                    not ok 234 - got the value we expected # TODO closure as non-final argument
                    # Failed test 'got the value we expected'
                    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-list/grep-k.rakudo line 57
                    # expected: '8'
                    #      got: (Any)
                    ok 235 - method form of grep works on numbers
                    ok 236 - method form of grep works on strings
                    ok 237 - mutating $_ in grep works (1)
                    ok 238 - mutating $_ in grep works (2)
                    ok 239 - last works in grep
                    ok 240 - next works in grep
                    ok 241 - .grep with non-Code matcher
                    ok 242 - grep with non-Code matcher
                    ok 243 - Junction matcher
Could not find symbol '&Bool' in 'X::Match'
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-list/grep-k.rakudo line 104
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-list/grep-k.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

                    1..49
                    ok 244 - we got a list back
                    ok 245 - got the value we expected
                    ok 246 - got the value we expected
                    ok 247 - got the value we expected
                    ok 248 - got the value we expected
                    ok 249 - got the value we expected
                    ok 250 - # SKIP adverbial block
                    ok 251 - # SKIP adverbial block
                    ok 252 - # SKIP adverbial block
                    ok 253 - # SKIP adverbial block
                    ok 254 - # SKIP adverbial block
                    ok 255 - # SKIP adverbial block
                    ok 256 - # SKIP adverbial block
                    ok 257 - # SKIP adverbial block
                    ok 258 - # SKIP adverbial block
                    ok 259 - # SKIP adverbial block
                    ok 260 - # SKIP adverbial block
                    ok 261 - # SKIP adverbial block
                    ok 262 - method form of grep works on numbers
                    ok 263 - method form of grep works on strings
                    ok 264 - mutating $_ in grep works (1)
                    ok 265 - mutating $_ in grep works (2)
                    ok 266 - last works in grep
                    ok 267 - next works in grep
                    ok 268 - last in grep on infinite list
                    ok 269 - redo works in grep (1)
                    ok 270 - redo works in grep (2)
                    ok 271 - .grep with non-Code matcher
                    ok 272 - grep() with non-Code matcher
                    ok 273 - grep takes two at a time
                    ok 274 - Junction matcher
                    ok 275 - Non-empty return value from grep is true (1)
                    ok 276 - Non-empty return value from grep is true (2)
                    ok 277 - Empty return value from grep is false
                    ok 278 - chained greps work
Could not find symbol '&Bool' in 'X::Match'
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-list/grep.rakudo line 135
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-list/grep.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

WARNINGS for /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-list/map.rakudo:
Useless use of $_ in sink context (line 221)
                    1..61
                    ok 279 - sub form: we got a list back
                    ok 280 - got the values we expected
                    ok 281 - # SKIP adverbial block
                    ok 282 - # SKIP adverbial block
                    ok 283 - invcant colon method form: we got a list back
                    ok 284 - got the values we expected
                    ok 285 - # SKIP closure as non-final argument
                    ok 286 - # SKIP closure as non-final argument
                    ok 287 - Slip returned from closure interpolates elements
                    ok 288 - got the values we expected
                    ok 289 - multiple statements in block: we got a list back
                    ok 290 - got the values we expect
                    ok 291 - heuristic for block - looks like a closure
                    ok 292 - The object is-a 'Hash'
                    ok 293 -  got the hash we expect
                    ok 294 - map() works with 2-ary functions
                    ok 295 - map() works with 3-ary functions
                    ok 296 - map() works with 4-ary functions
                    ok 297 - map() works with 5-ary functions
                    ok 298 - argument number mismatch on odd-numbered list
                    ok 299 - method form of map works on numbers
                    ok 300 - method form of map works on strings
                    ok 301 - map of constant list works
                    ok 302 - should be 3 elements
                    ok 303 - should be 6 elements (bare block)
                    ok 304 - flattens with .Slip
                    ok 305 - mutating $_ in map works (1)
                    ok 306 - mutating $_ in map works (2)
                    ok 307 - intern method in map
                    ok 308 - extern method in map
                    ok 309 - map works with the map body returning an empty list
                    ok 310 - map works with the map body returning an empty array
                    ok 311 - map works with the map body returning an empty arrayitem
                    ok 312 - map works with the map body returning an empty arrayitem variable
                    ok 313 - map works with the map body returning undefined
                    ok 314 - map works with the map body returning an undefined variable
                    ok 315 - map works with the map body returning () for each iteration
                    ok 316 - map took 2 elements at a time
                    ok 317 - first element ok
                    ok 318 - second element ok
                    ok 319 - third element ok
                    ok 320 - map should't flatten our arrayitem (1)
                    ok 321 - map should't flatten our arrayitem (2)
                    ok 322 - map should't flatten our arrayitem (3)
                    ok 323 - dependency for following test (1)
assign requires a concrete object (got a Rakudo::Internals::LoweredAwayLexical type object instead)
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-list/map.rakudo line 218
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-list/map.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

Potential difficulties:
    Leading 0 has no meaning. If you meant to create an octal number, use '0o' prefix; like, '0o042'. If you meant to create a string, please add quotation marks.
    at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-list/sort.rakudo:309
    ------> [32m      (<42i>, <42i1>, <0042[33m⏏[31mi>, <42i66>).sort,[0m
    Leading 0 has no meaning. If you meant to create an octal number, use '0o' prefix; like, '0o042'. If you meant to create a string, please add quotation marks.
    at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-list/sort.rakudo:310
    ------> [32m      (<0042[33m⏏[31mi>, <42i>, <42i1>, <42i66>),[0m
                    1..50
                    ok 324 - array of numbers was sorted
                    ok 325 - array of numbers was sorted (w/out parens)
                    ok 326 - array of mixed numbers including Inf
                    ok 327 - array of numbers was sorted (using invocant form)
                    ok 328 - ... with explicit spaceship
                    ok 329 - ... with explicit spaceship (using invocant form)
                    ok 330 - ... reverse sort with explicit spaceship
                    ok 331 - ... reverse sort with explicit spaceship (using invocant form)
                    ok 332 - array of strings was sorted
                    ok 333 - array of strings was sorted (w/out parens)
                    ok 334 - array of strings was sorted (using invocant form)
                    ok 335 - ... with explicit cmp
                    ok 336 - ... with explicit cmp (using invocant form)
                    ok 337 - ... sort keys by string value
                    ok 338 - ... sort keys by string value (using invocant form)
                    ok 339 - ... sort keys by numeric value
                    ok 340 - ... sort keys by numeric value (using invocant form)
                    ok 341 - can sort with automated Schwartzian Transform
                    ok 342 - %hash.sort returns a List of Pairs
                    ok 343 - sort with unary sub
                    ok 344 - sort with arity 0 closure is stable
                    ok 345 - sort with arity 1 closure is stable
                    ok 346 - sort with arity 2 closure is stable
                    ok 347 - method form of sort should work on numbers
                    ok 348 - method form of sort should work on strings
                    ok 349 - method form of sort should work on lists
                    ok 350 - sort by class name
                        1..2
                        ok 1 - code dies
                        ok 2 - right exception type (Exception)
                    ok 351 - sort does not accept 0-arity sub
                        1..2
                        ok 1 - '(1..10).sort(&rand)' died
                        ok 2 - right exception type (Exception)
                    ok 352 - sort does not accept &rand
                    ok 353 - sorting by stringified class instance (name and memory address)
                    ok 354 - .sort stored in a sub returns a List
                    ok 355 - &sort stored in a sub returns a List
                    ok 356 - detached .sort returns a List
                    ok 357 - auto-primed *.sort returns a Seq
                    ok 358 - .sort on reified empty array does not crash
                        1..13
                        ok 1 - empty, no args
                        ok 2 - empty, 1-arity
                        ok 3 - empty, 2-arity
                        ok 4 - 1 item, no args
                        ok 5 - 1 item, 1-arity
                        ok 6 - 1 item, 2-arity
                        ok 7 - 2-item, no args (1)
                        ok 8 - 2-item, no args (2)
                        ok 9 - 2-item, 1-arity (1)
                        ok 10 - 2-item, 1-arity (2)
                        ok 11 - 2-item, 2-arity (2)
                        ok 12 - 2-item, 2-arity (1)
                        ok 13 - 2-item, 2-arity (3)
                    ok 359 - degenerate cases
                    ok 360 - no crashes when using &lc in .sort
                    ok 361 - is sorting a 2 elem list with a mapper stable?
Could not find symbol '&Junction' in 'X::Cannot'
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-list/sort.rakudo line 265
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-list/sort.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

                    1..46
                    ok 362 - "-17".abs == 17 # TODO awaiting https://github.com/rakudo/rakudo/pull/3849
                    ok 363 - NotComplex.new.abs == $magic.abs
                    ok 364 - "3".conj == 3
                    ok 365 - NotComplex.new.conj == $magic.conj
                    ok 366 - "3".exp == 3.exp
                    ok 367 - NotComplex.new.exp == $magic.exp
                    ok 368 - "3".exp("2") == 3.exp(2)
                    ok 369 - NotComplex.new.exp("2") == $magic.exp("2")
                    ok 370 - "3".exp(NotComplex.new) == 3.exp($magic)
                    ok 371 - NotComplex.new.exp(NotComplex.new) == $magic.exp($magic)
                    ok 372 - "17".log == 17.log
                    ok 373 - NotComplex.new.log == $magic.log
                    ok 374 - "17".log("17") == 17.log(17)
                    ok 375 - NotComplex.new.log("17") == $magic.log(17)
                    ok 376 - "17".log("17") == 17.log(17)
                    ok 377 - NotComplex.new.log(NotComplex.new) == $magic.log($magic)
                    ok 378 - "17".log10 == 17.log10
                    ok 379 - NotComplex.new.log10 == $magic.log10
                    ok 380 - "17".sqrt == 17.sqrt
                    ok 381 - NotComplex.new.sqrt == $magic.sqrt
                    ok 382 - root 2.0305431848689306+0i found once
                    ok 383 - root 1.243349105940104e-16+2.0305431848689306i found once
                    ok 384 - root -2.0305431848689306+2.486698211880208e-16i found once
                    ok 385 - root -3.730047317820312e-16-2.0305431848689306i found once
                    ok 386 - root 1.2466105363113318+0.4731614097078769i found once
                    ok 387 - root -1.033075069053144+0.8430156882170183i found once
                    ok 388 - root -0.21353546725818734-1.3161770979248952i found once
                    ok 389 - "17"i == 17i
                    ok 390 - (NotComplex.new)i == $magic\i
                    ok 391 - # SKIP angle conversion
                    ok 392 - # SKIP angle conversion
                    ok 393 - # SKIP angle conversion
                    ok 394 - # SKIP angle conversion
                    ok 395 - "17.25".floor == 17.25.floor
                    ok 396 - "17.25".ceiling == 17.25.ceiling
                    ok 397 - "17.25".round == 17.25.round
                    ok 398 - "17.25".round("0.1") == 17.25.round(0.1)
                    ok 399 - "17.25".truncate == 17.25.truncate
                    ok 400 - "17".sign == 1
                    ok 401 - "-17".sign == -1
                    ok 402 - "0".sign == 0
                    ok 403 - "17".cis == 17.cis
                    ok 404 - <4+2i>.cis
                    ok 405 - i.cis
                    ok 406 - "17".unpolar("42") == 17.unpolar(42)
                        1..15
                        ok 1 - truncate(Array)
                        ok 2 - truncate(Bool::True)
                        ok 3 - truncate(Bool::False)
                        ok 4 - truncate(Cool)
                        ok 5 - truncate(Duration)
                        ok 6 - truncate(Map)
                        ok 7 - truncate(FatRat)
                        ok 8 - truncate(Hash)
                        ok 9 - truncate(Instant)
                        ok 10 - truncate(List)
                        ok 11 - truncate(Match)
                        ok 12 - truncate(Num)
                        ok 13 - truncate(Range)
                        ok 14 - truncate(Seq)
                        ok 15 - truncate(Stash)
                    ok 407 - truncate() with Cools
# FUDGED!
                    1..29
                    ok 408 - got the log of 5
                    ok 409 - got the log of 0.1
                    ok 410 - log(8, 2) is 3
                    ok 411 - log(42, 23)
                    ok 412 - log(42, 23) with strings
                    ok 413 - got the log10 of 5
                    ok 414 - got the log10 of 0.1
                    ok 415 - log(0) = -Inf
                    ok 416 - log(Inf) = Inf
                    ok 417 - log(-Inf) = NaN
                    ok 418 - log(NaN) = NaN
                    ok 419 - log10(0) = -Inf
                    ok 420 - log10(Inf) = Inf
                    ok 421 - log10(-Inf) = NaN
                    ok 422 - log10(NaN) = NaN
                    ok 423 - got the log of -1
                    ok 424 - got the log10 of -1
                    ok 425 - got the log of -e
                    ok 426 - got the log10 of -10
                    ok 427 - log10(10)=1
                    ok 428 - got log of exp(i pi/4)
                    ok 429 - got the log of i (complex unit)
                    ok 430 - got the log10 of i
                    ok 431 - got log10 of exp(i pi/4)
                    ok 432 - got the log of -i (complex unit)
                    ok 433 - got the log10 of -i (complex unit)
                    ok 434 -  (i).log10 = - i  * pi/(2 log(10))
                    ok 435 - log10 of a complex returns a complex, not a list
                    not ok 436 - Can take the log of very large Ints # TODO HugeInt.log
                    # Failed test 'Can take the log of very large Ints'
                    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-num/log.rakudo line 75
                    #     expected approximately: 1000
                    #                        got: Inf
                    # maximum relative tolerance: 1e-06
                    # actual relative difference: NaN
# FUDGED!
                    1..89
                    ok 437 - 0 ** 0 ==  1
                    not ok 438 - 0 ** 1 ==  0
                    # Failed test '0 ** 1 ==  0'
                    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-num/power.rakudo line 9
                    # expected: 0
                    #      got: 0
                    ok 439 - 1 **  2 ==  1
                    ok 440 - 4 **  0 ==  1
                    ok 441 - 4 **  1 ==  4
                    ok 442 - 4 **  2 == 16
                    ok 443 -   0 ** 4553535345364535345634543534 == 0
                    ok 444 -   1 ** 4553535345364535345634543534 == 1
                    ok 445 - 1e0 ** 4553535345364535345634543534 == 1
                    ok 446 -  -1 ** 4553535345364535345634543534 == 1
                    ok 447 -  -1 ** 4553535345364535345634543533  == -1
                    ok 448 - 4 ** .5 ==  2
                    ok 449 - 4 ** (1/2) == 2 
                    ok 450 - 4 ** (-1/2) == 1/2 
                    ok 451 - -2 ** 2 = 4
                    ok 452 - 1**Inf=1
                    ok 453 - 0**Inf=0
                    ok 454 - Inf**2 = Inf
                    ok 455 - (-Inf)**3 = -Inf
                    ok 456 - Inf**Inf = Inf
                    ok 457 - NaN propagates with integer powers
                    ok 458 - NaN propagates with numeric powers
                    ok 459 - 0**NaN=NaN
                    not ok 460 - NaN**1i=NaN # TODO wrong results for "NaN" used with "**"
                    # Failed test 'NaN**1i=NaN'
                    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-num/power.rakudo line 40
                    # expected: NaN
                    #      got: <NaN+NaN\i>
                    not ok 461 - 1i**NaN=NaN # TODO wrong results for "NaN" used with "**"
                    # Failed test '1i**NaN=NaN'
                    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-num/power.rakudo line 41
                    # expected: NaN
                    #      got: <NaN+NaN\i>
                    ok 462 - NaN**0=1
                    ok 463 - 1**NaN=1
                    ok 464 - NaN**NaN=NaN
                    ok 465 - Inf**NaN=NaN
                    ok 466 - NaN**Inf=NaN
                    ok 467 - e **  .5 ==   exp(.5)
                    ok 468 - e ** 2.5 ==  exp(2.5)
                    ok 469 - (4+0i) ** 2 == 16
                    ok 470 - i ** 4 == 1
                    ok 471 - (4+0i) ** .5 == 2
                    ok 472 - i ** 2 == -1
                    ok 473 - i ** 3 == -i
                    ok 474 - 5i ** 3 = -125i
                    ok 475 - 3i ** 3 = -27i
                    ok 476 - -3i ** 3 = 27i
                    not ok 477 - (-1) ** -i is approx 23.1406926327793 # TODO i
                    # Failed test '(-1) ** -i is approx 23.1406926327793'
                    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-num/power.rakudo line 67
                    #     expected approximately: 23.1406926327793
                    #                        got: NaN+NaN\i
                    # maximum relative tolerance: 1e-06
                    # actual relative difference: NaN
                    ok 478 - quartic root of 8i ** 4 = 8i
                    ok 479 - quartic root of 8i ** 4 = 8i
                    ok 480 - quartic root of 8i ** 4 = 8i
                    ok 481 - quartic root of 8i ** 4 = 8i
                    ok 482 - e ** pi i = -1
                    ok 483 - (4+0i) ** (2+0i) == 16
                    ok 484 - 1.015 ** 200 is not NaN
                    ok 485 - 1.015 ** 200 == 19.6430286394751
                    ok 486 - 0⁰ ==  1
                    not ok 487 - 0¹ ==  0
                    # Failed test '0¹ ==  0'
                    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-num/power.rakudo line 88
                    # expected: 0
                    #      got: 0
                    ok 488 - 1² ==  1
                    ok 489 - 4⁰ ==  1
                    ok 490 - 4¹ ==  4
                    ok 491 - 4² == 16
                    ok 492 - 2³² == 2 ** 32
                    ok 493 - 2⁶⁴ == 2 ** 64
                    ok 494 - 10¹⁰⁰ == 10 ** 100
                    ok 495 - *⁰(0) ==  1
                    not ok 496 - *¹(0) ==  0
                    # Failed test '*¹(0) ==  0'
                    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-num/power.rakudo line 100
                    # expected: 0
                    #      got: 0
                    ok 497 - *²(1) ==  1
                    ok 498 - *⁰() ==  1
                    ok 499 - *¹() ==  4
                    ok 500 - *²() == 16
                    ok 501 - *³²(2) == 2 ** 32
                    ok 502 - *⁶⁴(2) == 2 ** 64
                    ok 503 - *¹⁰⁰(10) == 10 ** 100
                    ok 504 - 3³
                    ok 505 - 3⁴
                    ok 506 - 3⁵
                    ok 507 - 3⁶
                    ok 508 - 3⁷
                    ok 509 - 3⁸
                    ok 510 - 3⁹
                    ok 511 - 3¹⁰
                    ok 512 - 3¹³
                    ok 513 - (-1)¹²³
                    ok 514 -    0⁴⁵⁵³⁵³⁵³⁴⁵³⁶⁴⁵³⁵³⁴⁵ ==  0
                    ok 515 -    1⁴⁵⁵³⁵³⁵³⁴⁵³⁶⁴⁵³⁵³⁴⁵ ==  1
                    ok 516 -  1e0⁴⁵⁵³⁵³⁵³⁴⁵³⁶⁴⁵³⁵³⁴⁵ ==  1
                    ok 517 - (-1)⁴⁵⁵³⁵³⁵³⁴⁵³⁶⁴⁵³⁵³⁵⁴ ==  1
                    ok 518 - (-1)⁴⁵⁵³⁵³⁵³⁴⁵³⁶⁴⁵³⁵³⁴⁵ == -1
                    ok 519 - 4 ** ½ ==  2
                    ok 520 - 4 ** -½ == ½
                    ok 521 - 27 ** ⅓ ==  3
                    ok 522 - 27 ** ⅔ ==  9
                    ok 523 - 27 ** -⅓ == ⅓
                    ok 524 - 27 ** -⅔ == ⅑
                        1..75
                        ok 1 - ⁰¹²
                        ok 2 - ⁰⁺¹²
                        ok 3 - ⁰⁻¹²
                        ok 4 - ⁰¯¹² (macron)
                        ok 5 - 2**⁰²
                        ok 6 - ¹¹²
                        ok 7 - ¹⁺¹²
                        ok 8 - ¹⁻¹²
                        ok 9 - ¹¯¹² (macron)
                        ok 10 - 2**¹²
                        ok 11 - ²¹²
                        ok 12 - ²⁺¹²
                        ok 13 - ²⁻¹²
                        ok 14 - ²¯¹² (macron)
                        ok 15 - 2**²²
                        ok 16 - ³¹²
                        ok 17 - ³⁺¹²
                        ok 18 - ³⁻¹²
                        ok 19 - ³¯¹² (macron)
                        ok 20 - 2**³²
                        ok 21 - ⁴¹²
                        ok 22 - ⁴⁺¹²
                        ok 23 - ⁴⁻¹²
                        ok 24 - ⁴¯¹² (macron)
                        ok 25 - 2**⁴²
                        ok 26 - ⁵¹²
                        ok 27 - ⁵⁺¹²
                        ok 28 - ⁵⁻¹²
                        ok 29 - ⁵¯¹² (macron)
                        ok 30 - 2**⁵²
                        ok 31 - ⁶¹²
                        ok 32 - ⁶⁺¹²
                        ok 33 - ⁶⁻¹²
                        ok 34 - ⁶¯¹² (macron)
                        ok 35 - 2**⁶²
                        ok 36 - ⁷¹²
                        ok 37 - ⁷⁺¹²
                        ok 38 - ⁷⁻¹²
                        ok 39 - ⁷¯¹² (macron)
                        ok 40 - 2**⁷²
                        ok 41 - ⁸¹²
                        ok 42 - ⁸⁺¹²
                        ok 43 - ⁸⁻¹²
                        ok 44 - ⁸¯¹² (macron)
                        ok 45 - 2**⁸²
                        ok 46 - ⁹¹²
                        ok 47 - ⁹⁺¹²
                        ok 48 - ⁹⁻¹²
                        ok 49 - ⁹¯¹² (macron)
                        ok 50 - 2**⁹²
                        ok 51 - ⅟¹²
                        ok 52 - ⅟⁺¹²
                        ok 53 - ⅟⁻¹²
                        ok 54 - ⅟¯¹² (macron)
                        ok 55 - 2**⅟²
                        ok 56 - 𑁓¹²
                        ok 57 - 𑁓⁺¹²
                        ok 58 - 𑁓⁻¹²
                        ok 59 - 𑁓¯¹² (macron)
                        ok 60 - 2**𑁓²
                        ok 61 - ౸¹²
                        ok 62 - ౸⁺¹²
                        ok 63 - ౸⁻¹²
                        ok 64 - ౸¯¹² (macron)
                        ok 65 - 2**౸²
                        ok 66 - ㆒¹²
                        ok 67 - ㆒⁺¹²
                        ok 68 - ㆒⁻¹²
                        ok 69 - ㆒¯¹² (macron)
                        ok 70 - 2**㆒²
                        ok 71 - 𐌣¹²
                        ok 72 - 𐌣⁺¹²
                        ok 73 - 𐌣⁻¹²
                        ok 74 - 𐌣¯¹² (macron)
                        ok 75 - 2**𐌣²
                    ok 525 - power ops with uncommon No chars as terms work
# FUDGED!
                    1..113
                    ok 526 - rand returns numbers greater than or equal to 0
                    ok 527 - rand returns numbers less than 1
                    ok 528 - rand returns numbers in [0, 2)
                    ok 529 - rand returns numbers in [0, 2)
                    ok 530 - rand returns numbers in [0, 2)
                    ok 531 - rand returns numbers in [0, 2)
                    ok 532 - rand returns numbers in [0, 2)
                    ok 533 - rand returns numbers in [0, 2)
                    ok 534 - rand returns numbers in [0, 2)
                    ok 535 - rand returns numbers in [0, 2)
                    ok 536 - rand returns numbers in [0, 2)
                    ok 537 - rand returns numbers in [0, 2)
                    ok 538 - rand returns numbers in [0, 2)
                    ok 539 - rand returns numbers in [0, 2)
                    ok 540 - rand returns numbers in [0, 2)
                    ok 541 - rand returns numbers in [0, 2)
                    ok 542 - rand returns numbers in [0, 2)
                    ok 543 - rand returns numbers in [0, 2)
                    ok 544 - rand returns numbers in [0, 2)
                    ok 545 - rand returns numbers in [0, 2)
                    ok 546 - rand returns numbers in [0, 2)
                    ok 547 - rand returns numbers in [0, 2)
                    ok 548 - rand returns numbers in [0, 3)
                    ok 549 - rand returns numbers in [0, 3)
                    ok 550 - rand returns numbers in [0, 3)
                    ok 551 - rand returns numbers in [0, 3)
                    ok 552 - rand returns numbers in [0, 3)
                    ok 553 - rand returns numbers in [0, 3)
                    ok 554 - rand returns numbers in [0, 3)
                    ok 555 - rand returns numbers in [0, 3)
                    ok 556 - rand returns numbers in [0, 3)
                    ok 557 - rand returns numbers in [0, 3)
                    ok 558 - rand returns numbers in [0, 3)
                    ok 559 - rand returns numbers in [0, 3)
                    ok 560 - rand returns numbers in [0, 3)
                    ok 561 - rand returns numbers in [0, 3)
                    ok 562 - rand returns numbers in [0, 3)
                    ok 563 - rand returns numbers in [0, 3)
                    ok 564 - rand returns numbers in [0, 3)
                    ok 565 - rand returns numbers in [0, 3)
                    ok 566 - rand returns numbers in [0, 3)
                    ok 567 - rand returns numbers in [0, 3)
                    ok 568 - rand returns numbers in [0, 5)
                    ok 569 - rand returns numbers in [0, 5)
                    ok 570 - rand returns numbers in [0, 5)
                    ok 571 - rand returns numbers in [0, 5)
                    ok 572 - rand returns numbers in [0, 5)
                    ok 573 - rand returns numbers in [0, 5)
                    ok 574 - rand returns numbers in [0, 5)
                    ok 575 - rand returns numbers in [0, 5)
                    ok 576 - rand returns numbers in [0, 5)
                    ok 577 - rand returns numbers in [0, 5)
                    ok 578 - rand returns numbers in [0, 5)
                    ok 579 - rand returns numbers in [0, 5)
                    ok 580 - rand returns numbers in [0, 5)
                    ok 581 - rand returns numbers in [0, 5)
                    ok 582 - rand returns numbers in [0, 5)
                    ok 583 - rand returns numbers in [0, 5)
                    ok 584 - rand returns numbers in [0, 5)
                    ok 585 - rand returns numbers in [0, 5)
                    ok 586 - rand returns numbers in [0, 5)
                    ok 587 - rand returns numbers in [0, 5)
                    ok 588 - rand returns numbers in [0, 7)
                    ok 589 - rand returns numbers in [0, 7)
                    ok 590 - rand returns numbers in [0, 7)
                    ok 591 - rand returns numbers in [0, 7)
                    ok 592 - rand returns numbers in [0, 7)
                    ok 593 - rand returns numbers in [0, 7)
                    ok 594 - rand returns numbers in [0, 7)
                    ok 595 - rand returns numbers in [0, 7)
                    ok 596 - rand returns numbers in [0, 7)
                    ok 597 - rand returns numbers in [0, 7)
                    ok 598 - rand returns numbers in [0, 7)
                    ok 599 - rand returns numbers in [0, 7)
                    ok 600 - rand returns numbers in [0, 7)
                    ok 601 - rand returns numbers in [0, 7)
                    ok 602 - rand returns numbers in [0, 7)
                    ok 603 - rand returns numbers in [0, 7)
                    ok 604 - rand returns numbers in [0, 7)
                    ok 605 - rand returns numbers in [0, 7)
                    ok 606 - rand returns numbers in [0, 7)
                    ok 607 - rand returns numbers in [0, 7)
                    ok 608 - rand returns numbers in [0, 11)
                    ok 609 - rand returns numbers in [0, 11)
                    ok 610 - rand returns numbers in [0, 11)
                    ok 611 - rand returns numbers in [0, 11)
                    ok 612 - rand returns numbers in [0, 11)
                    ok 613 - rand returns numbers in [0, 11)
                    ok 614 - rand returns numbers in [0, 11)
                    ok 615 - rand returns numbers in [0, 11)
                    ok 616 - rand returns numbers in [0, 11)
                    ok 617 - rand returns numbers in [0, 11)
                    ok 618 - rand returns numbers in [0, 11)
                    ok 619 - rand returns numbers in [0, 11)
                    ok 620 - rand returns numbers in [0, 11)
                    ok 621 - rand returns numbers in [0, 11)
                    ok 622 - rand returns numbers in [0, 11)
                    ok 623 - rand returns numbers in [0, 11)
                    ok 624 - rand returns numbers in [0, 11)
                    ok 625 - rand returns numbers in [0, 11)
                    ok 626 - rand returns numbers in [0, 11)
                    ok 627 - rand returns numbers in [0, 11)
                    ok 628 - srand(1) lives and parses
                    ok 629 - srand() provides repeatability for rand
                    ok 630 - edge case: srand(0) provides repeatability
                    ok 631 - edge case: srand(0) not the same as srand(1)
                    ok 632 - srand(...) provides repeatability for rand
                    ok 633 - edge case: srand(0) provides repeatability
                    ok 634 - edge case: srand(0) not the same as srand(:seed(1))
                    ok 635 - # SKIP Test is too slow; srand call incorrect
                    ok 636 - Distribution is not very uneven
Could not find symbol '&Obsolete' in 'X'
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-num/rand.rakudo line 115
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-num/rand.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

                    1..62
                    ok 637 - ~<3+4i>
                    ok 638 - <3+4i>.Str
                    ok 639 - <3+4i>.gist
                    ok 640 - <3+4i>.raku
                    ok 641 - ~<3-4i>
                    ok 642 - <3-4i>.Str
                    ok 643 - <3-4i>.gist
                    ok 644 - <3-4i>.raku
                    ok 645 - ~<-3+4i>
                    ok 646 - <-3+4i>.Str
                    ok 647 - <-3+4i>.gist
                    ok 648 - <-3+4i>.raku
                    ok 649 - ~<3.5+4i>
                    ok 650 - <3.5+4i>.Str
                    ok 651 - <3.5+4i>.gist
                    ok 652 - <3.5+4i>.raku
                    ok 653 - ~<3+4.5i>
                    ok 654 - <3+4.5i>.Str
                    ok 655 - <3+4.5i>.gist
                    ok 656 - <3+4.5i>.raku
                    ok 657 - ~<Inf+3i>
                    ok 658 - <Inf+3i>.Str
                    ok 659 - <Inf+3i>.gist
                    ok 660 - <Inf+3i>.raku
                    ok 661 - ~<0+Inf\i>
                    ok 662 - <0+Inf\i>.Str
                    ok 663 - <0+Inf\i>.gist
                    ok 664 - <0+Inf\i>.raku
                    ok 665 - ~<-Inf+3i>
                    ok 666 - <-Inf+3i>.Str
                    ok 667 - <-Inf+3i>.gist
                    ok 668 - <-Inf+3i>.raku
                    ok 669 - ~<0-Inf\i>
                    ok 670 - <0-Inf\i>.Str
                    ok 671 - <0-Inf\i>.gist
                    ok 672 - <0-Inf\i>.raku
                    ok 673 - ~<NaN+3i>
                    ok 674 - <NaN+3i>.Str
                    ok 675 - <NaN+3i>.gist
                    ok 676 - <NaN+3i>.raku
                    ok 677 - ~<0+NaN\i>
                    ok 678 - <0+NaN\i>.Str
                    ok 679 - <0+NaN\i>.gist
                    ok 680 - <0+NaN\i>.raku
                    ok 681 - Complex.gist
                    ok 682 - Complex.raku
Use of uninitialized value of type Complex in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-num/stringify.rakudo line 37
                    ok 683 - ~Complex does not die
Use of uninitialized value of type Complex in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-num/stringify.rakudo line 38
                    ok 684 - Complex.Str does not die
                        1..7
                        ok 1 - ~<1/2>
                        ok 2 - <1/2>.Str
                        ok 3 - <1/2>.gist
                        ok 4 - <1/2>.raku
                        ok 5 - ~<1/2>.FatRat
                        ok 6 - <1/2>.FatRat.Str
                        ok 7 - <1/2>.FatRat.gist
                    ok 685 - Rat Stringification (0.5)
                        1..7
                        ok 1 - ~<-1/2>
                        ok 2 - <-1/2>.Str
                        ok 3 - <-1/2>.gist
                        ok 4 - <-1/2>.raku
                        ok 5 - ~<-1/2>.FatRat
                        ok 6 - <-1/2>.FatRat.Str
                        ok 7 - <-1/2>.FatRat.gist
                    ok 686 - Rat Stringification (-0.5)
                        1..7
                        ok 1 - ~<0/1>
                        ok 2 - <0/1>.Str
                        ok 3 - <0/1>.gist
                        ok 4 - <0/1>.raku
                        ok 5 - ~<0/1>.FatRat
                        ok 6 - <0/1>.FatRat.Str
                        ok 7 - <0/1>.FatRat.gist
                    ok 687 - Rat Stringification (0)
                        1..7
                        ok 1 - ~<1/1>
                        ok 2 - <1/1>.Str
                        ok 3 - <1/1>.gist
                        ok 4 - <1/1>.raku
                        ok 5 - ~<1/1>.FatRat
                        ok 6 - <1/1>.FatRat.Str
                        ok 7 - <1/1>.FatRat.gist
                    ok 688 - Rat Stringification (1)
                        1..7
                        ok 1 - ~<1/3>
                        ok 2 - <1/3>.Str
                        ok 3 - <1/3>.gist
                        ok 4 - <1/3>.raku
                        ok 5 - ~<1/3>.FatRat
                        ok 6 - <1/3>.FatRat.Str
                        ok 7 - <1/3>.FatRat.gist
                    ok 689 - Rat Stringification (0.333333)
                        1..7
                        ok 1 - ~<1000001/10000>
                        ok 2 - <1000001/10000>.Str
                        ok 3 - <1000001/10000>.gist
                        ok 4 - <1000001/10000>.raku
                        ok 5 - ~<1000001/10000>.FatRat
                        ok 6 - <1000001/10000>.FatRat.Str
                        ok 7 - <1000001/10000>.FatRat.gist
                    ok 690 - Rat Stringification (100.0001)
                        1..7
                        ok 1 - ~<-1000001/10000>
                        ok 2 - <-1000001/10000>.Str
                        ok 3 - <-1000001/10000>.gist
                        ok 4 - <-1000001/10000>.raku
                        ok 5 - ~<-1000001/10000>.FatRat
                        ok 6 - <-1000001/10000>.FatRat.Str
                        ok 7 - <-1000001/10000>.FatRat.gist
                    ok 691 - Rat Stringification (-100.0001)
                        1..7
                        ok 1 - ~<555555555555555555555555555555555555555555555/5>
                        ok 2 - <555555555555555555555555555555555555555555555/5>.Str
                        ok 3 - <555555555555555555555555555555555555555555555/5>.gist
                        ok 4 - <555555555555555555555555555555555555555555555/5>.raku
                        ok 5 - ~<555555555555555555555555555555555555555555555/5>.FatRat
                        ok 6 - <555555555555555555555555555555555555555555555/5>.FatRat.Str
                        ok 7 - <555555555555555555555555555555555555555555555/5>.FatRat.gist
                    ok 692 - Rat Stringification (111111111111111111111111111111111111111111111)
                        1..7
                        not ok 1 - ~<1797010299914431210413179829509605039731475627537851106401/1152921504606846976> # TODO big stuff
                        # Failed test '~<1797010299914431210413179829509605039731475627537851106401/1152921504606846976>'
                        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-num/stringify.rakudo line 72
                        # expected: '1558657976916843360832062017400788597510.058834953945635510598466400011830046423710882663726806640625'
                        #      got: '1558657976916843360832062017400788597510.0588349539456355106'
                        not ok 2 - <1797010299914431210413179829509605039731475627537851106401/1152921504606846976>.Str # TODO big stuff
                        # Failed test '<1797010299914431210413179829509605039731475627537851106401/1152921504606846976>.Str'
                        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-num/stringify.rakudo line 72
                        # expected: '1558657976916843360832062017400788597510.058834953945635510598466400011830046423710882663726806640625'
                        #      got: '1558657976916843360832062017400788597510.0588349539456355106'
                        not ok 3 - <1797010299914431210413179829509605039731475627537851106401/1152921504606846976>.gist # TODO big stuff
                        # Failed test '<1797010299914431210413179829509605039731475627537851106401/1152921504606846976>.gist'
                        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-num/stringify.rakudo line 72
                        # expected: '1558657976916843360832062017400788597510.058834953945635510598466400011830046423710882663726806640625'
                        #      got: '1558657976916843360832062017400788597510.0588349539456355106'
                        ok 4 - <1797010299914431210413179829509605039731475627537851106401/1152921504606846976>.raku
                        ok 5 - ~<1797010299914431210413179829509605039731475627537851106401/1152921504606846976>.FatRat
                        ok 6 - <1797010299914431210413179829509605039731475627537851106401/1152921504606846976>.FatRat.Str
                        ok 7 - <1797010299914431210413179829509605039731475627537851106401/1152921504606846976>.FatRat.gist
                    not ok 693 - Rat Stringification (1558657976916843360832062017400788597510.0588349539456355106) # TODO big stuff
                    # Failed test 'Rat Stringification (1558657976916843360832062017400788597510.0588349539456355106)'
                    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-num/stringify.rakudo line 72
                    ok 694 - Rat.gist
                    ok 695 - Rat.raku
Use of uninitialized value of type Rat in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-num/stringify.rakudo line 78
                    ok 696 - ~Rat does not die
Use of uninitialized value of type Rat in string context.
Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-num/stringify.rakudo line 79
                    ok 697 - Rat.Str does not die
                        1..6
                        ok 1 - pi
                        ok 2 - pi (.raku.EVAL roundtripped)
                        ok 3 - 0.1e0 does not get long string of zeros
                        ok 4 - 0.3e0 does not get long string of zeros
                        ok 5 - 0.1e0+0.2e0 gets 0.3000…
                        ok 6 - 2e25 and 20e24 stringify the same
                    ok 698 - no precision loss in stringification of Nums
# FUDGED!
                    1..7
                    ok 699 - can we serialize a simple scalar
                    ok 700 - can we roundtrip simple scalar
                    ok 701 - make sure any value can be stored
                    not ok 702 - can we serialize a scalar with constrained values # TODO cannot roundtrip constrained scalars yet
                    # Failed test 'can we serialize a scalar with constrained values'
                    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-scalar/perl.rakudo line 21
                    # expected: 'Int(1)'
                    #      got: '1'
                    ok 703 - can we roundtrip scalar constrained values
                    not ok 704 - make sure roundtripped values are Int # TODO cannot roundtrip constrained scalars yet
                    # Failed test 'make sure roundtripped values are Int'
                    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-scalar/perl.rakudo line 26
                        1..3
                        ok 1 - Result is same as original
                        ok 2 - Same .raku output
                        ok 3 - ...and no failures.
                    ok 705 - Rat.raku is idempotent
# FUDGED!
                    1..91
                    ok 706 - Mu is not defined
                    ok 707 - uninitialized lexicals are undefined
                    ok 708 - uninitialized package vars are undefined
                    ok 709 - initialized var is defined
Use of Nil in string context
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/packages/Test-Helpers/lib/Test/Util.pm6 (Test::Util) line 233
No such method 'queue' for invocant of type 'CurrentThreadScheduler'
  in sub get_out at /Users/tobiuo/class/seminar/Abyss-Server/roast/packages/Test-Helpers/lib/Test/Util.pm6 (Test::Util) line 229
  in sub is_run at /Users/tobiuo/class/seminar/Abyss-Server/roast/packages/Test-Helpers/lib/Test/Util.pm6 (Test::Util) line 135
  in sub is_run at /Users/tobiuo/class/seminar/Abyss-Server/roast/packages/Test-Helpers/lib/Test/Util.pm6 (Test::Util) line 129
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-scalar/undef.rakudo line 41
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-scalar/undef.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

                    1..41
                    ok 710 - $str.encode returns a blob8
                    ok 711 - encoding to ASCII
                    ok 712 - right length of Buf
                    ok 713 - encoding to UTF-8
                    ok 714 - right length of Buf
                    ok 715 - right length of Buf with \n
                    ok 716 - Non-translation of \n outside Windows
                    ok 717 - indexing a utf8 gives correct value (1)
                    ok 718 - indexing a utf8 gives correct value (1)
                    ok 719 - cp1252 encodes most C1 substitutes
                    ok 720 - cp1252 encode tolerates unassigned C1 characters
                        1..3
                        ok 1 - '"aouÄÖÜ".encode("latin1").decode("utf8")' died
                        ok 2 - right exception type (Exception)
                        ok 3 - .message matches rx:s:i/line 1 col\w* 4/
                    ok 721 - did we throws-like Exception?
                        1..3
                        ok 1 - '"ssß".encode("latin1").decode("utf8")' died
                        ok 2 - right exception type (Exception)
                        ok 3 - .message matches rx:s:i/term/
                    ok 722 - did we throws-like Exception?
                        1..3
                        ok 1 - '"aoaou".encode("latin1").decode("utf16")' died
                        ok 2 - right exception type (Exception)
                        not ok 3 - .message matches rx:s:i/line 1 col\w* 2|term/ # TODO RT#107204 should say line and column or mention term(ination)
                        # Failed test '.message matches rx:s:i/line 1 col\w* 2|term/'
                        # at SETTING::src/core.c/Any-iterable-methods.pm6 line 627
                        # Expected: rx:s:i/line 1 col\w* 2|term/
                        # Got:      Malformed UTF-16; odd number of bytes (5)
                    not ok 723 - did we throws-like Exception? # TODO RT#107204 should say line and column or mention term(ination)
                    # Failed test 'did we throws-like Exception?'
                    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-str/encode.rakudo line 39
                        1..3
                        ok 1 - '"aouÄÖÜ".encode("latin1").decode("utf16")' died
                        ok 2 - right exception type (Exception)
                        not ok 3 - .message matches rx:s:i/line 1 col\w* 2/ # TODO RT#107204 should say line and column
                        # Failed test '.message matches rx:s:i/line 1 col\w* 2/'
                        # at SETTING::src/core.c/Any-iterable-methods.pm6 line 627
                        # Expected: rx:s:i/line 1 col\w* 2/
                        # Got:      Malformed UTF-16; unexpected low surrogate
                    not ok 724 - did we throws-like Exception? # TODO RT#107204 should say line and column
                    # Failed test 'did we throws-like Exception?'
                    # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-str/encode.rakudo line 42
                    ok 725 - can index one element in a Buf
                    ok 726 - can slice-index a Buf
                    ok 727 - # SKIP We do not handle NDF yet RT  \#124687
                    ok 728 - encoding ä utf8 gives correct numbers
                    ok 729 - .decode returns a Str
                    ok 730 - decoding a Buf with UTF-8
                    ok 731 - decoding a Buf with Latin-1
                    ok 732 - cp1252 decodes most C1 substitutes
                    ok 733 - cp1252 decode tolerates unassigned C1 characters
                    ok 734 - Buf does Stringy
                    ok 735 - Buf does Positional
                    ok 736 - Buf.list gives a list of codepoints
                    ok 737 - encode a string to UTF-16 surrogate pair
                    ok 738 - creating utf16 Buf from a surrogate pair
                    ok 739 - indexing a utf16 gives correct value
                    ok 740 - indexing a utf16 gives correct value
                    ok 741 - decoding utf16 Buf to original value
                    ok 742 - Can encode noncharacters to UTF-8
                    ok 743 - Noncharacters round-trip with UTF-8
                        1..4
                            1..3
                            ok 1 - code dies
                            ok 2 - right exception type (Exception)
                            ok 3 - .message matches rx:s:i/Error encoding $encoding string/
                        ok 1 - No replacement dies
                        ok 2 - Default replacement
                        ok 3 - Zero-character replacement
                        ok 4 - Multi-character replacement
                    ok 744 - Non-ascii character
                        1..4
                            1..3
                            ok 1 - code dies
                            ok 2 - right exception type (Exception)
                            ok 3 - .message matches rx:s:i/Error encoding $encoding string/
                        ok 1 - No replacement dies
                        ok 2 - Default replacement
                        ok 3 - Zero-character replacement
                        ok 4 - Multi-character replacement
                    ok 745 - Non-latin-1 character
                        1..4
                            1..3
                            ok 1 - code dies
                            ok 2 - right exception type (Exception)
                            ok 3 - .message matches rx:s:i/Error encoding $encoding string/
                        ok 1 - No replacement dies
                        ok 2 - Default replacement
                        ok 3 - Zero-character replacement
                        ok 4 - Multi-character replacement
                    ok 746 - Non-windows-1252 character
                    ok 747 - utf-16 BOM handled ok
                    ok 748 - Can decode utf-8 buffer as if it were utf8-c8
                    ok 749 - Can decode utf-8 buffer as if it were utf16le
                    ok 750 - Can decode utf-8 buffer as if it were utf16be
# FUDGED!
                    1..63
                    ok 751 - Simple .indent(1)
                    ok 752 - Simple .indent(2)
                    ok 753 - Simple .indent(3)
                    ok 754 - Simple .indent(4)
                    ok 755 - New indent goes after existing - .indent(1)
                    ok 756 - New indent goes after existing - .indent(2)
                    ok 757 - New indent goes after existing - .indent(3)
                    ok 758 - New indent goes after existing - .indent(4)
                    ok 759 - Same space - .indent(1) prefix="\x[20]"
                    ok 760 - Same space - .indent(1) prefix="\x[2002]"
                    ok 761 - Same space - .indent(2) prefix="\x[20]"
                    ok 762 - Same space - .indent(2) prefix="\x[2002]"
                    ok 763 - Same space - .indent(3) prefix="\x[20]"
                    ok 764 - Same space - .indent(3) prefix="\x[2002]"
                    ok 765 - Same space - .indent(4) prefix="\x[20]"
                    ok 766 - Same space - .indent(4) prefix="\x[2002]"
                    ok 767 - Samespace indent should work for a full $?TABSTOP with \t
                    ok 768 - Mixed space - .indent(1) prefix="\x[20]"
                    ok 769 - Mixed space - .indent(1) prefix="\x[9]"
                    ok 770 - Mixed space - .indent(1) prefix="\x[2002]"
                    ok 771 - Mixed space - .indent(2) prefix="\x[20]"
                    ok 772 - Mixed space - .indent(2) prefix="\x[9]"
                    ok 773 - Mixed space - .indent(2) prefix="\x[2002]"
                    ok 774 - Mixed space - .indent(3) prefix="\x[20]"
                    ok 775 - Mixed space - .indent(3) prefix="\x[9]"
                    ok 776 - Mixed space - .indent(3) prefix="\x[2002]"
                    ok 777 - Mixed space - .indent(4) prefix="\x[20]"
                    ok 778 - Mixed space - .indent(4) prefix="\x[9]"
                    ok 779 - Mixed space - .indent(4) prefix="\x[2002]"
                    ok 780 - Mixed space - .indent(5) prefix="\x[20]"
                    ok 781 - Mixed space - .indent(5) prefix="\x[9]"
                    ok 782 - Mixed space - .indent(5) prefix="\x[2002]"
                    ok 783 - Mixed space - .indent(6) prefix="\x[20]"
                    ok 784 - Mixed space - .indent(6) prefix="\x[9]"
                    ok 785 - Mixed space - .indent(6) prefix="\x[2002]"
                    ok 786 - Mixed space - .indent(7) prefix="\x[20]"
                    ok 787 - Mixed space - .indent(7) prefix="\x[9]"
                    ok 788 - Mixed space - .indent(7) prefix="\x[2002]"
                    ok 789 - Mixed space - .indent(8) prefix="\x[20]"
                    ok 790 - Mixed space - .indent(8) prefix="\x[9]"
                    ok 791 - Mixed space - .indent(8) prefix="\x[2002]"
                    ok 792 - Simple outdent
                    ok 793 - Simple outdent with tab (explodes because we delete from left)
Asked to remove 4 spaces, but the shortest indent is 3 spaces
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-str/indent.rakudo line 61
                    ok 794 - Excess outdent test for correct output
                    ok 795 - Excess outdent test for warning
                    ok 796 - indent(*) on empty string
                    ok 797 - Whatever* outdent with at least 1 common indent
                    ok 798 - Whatever* outdent with one line flush left already
                    ok 799 - .indent(*) ignores empty lines
                    ok 800 - Tab explosion on outdent
                    ok 801 - Test that tabs explode from the right
                    ok 802 - Check that varying amounts of space before a tabstop explode in a visually consistent way
                    ok 803 - Spaces before a hard tab should be coalesced into the tabstop when exploding
                    ok 804 - Test that space-tab-tab outdent works as intended
                    ok 805 - Check that mixed spaces and tabs outdent correctly
                    ok 806 - Multiline indent test with tab-space indent
                    ok 807 - Multiline indent test with mixed line beginnings
                    ok 808 - Multiline $?TABSTOP-width indent with an unindented line and a tab-indented line
                    ok 809 - .indent(0) should be a no-op
                    ok 810 - .indent ignores empty lines
                    ok 811 - .indent accepts weird scalar input and coerces it to Int when necessary
                    ok 812 - Indentation should not be appended after a trailing \n
                        1..6
Use of Nil in string context
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/packages/Test-Helpers/lib/Test/Util.pm6 (Test::Util) line 233
No such method 'queue' for invocant of type 'CurrentThreadScheduler'
  in sub get_out at /Users/tobiuo/class/seminar/Abyss-Server/roast/packages/Test-Helpers/lib/Test/Util.pm6 (Test::Util) line 229
  in sub is_run at /Users/tobiuo/class/seminar/Abyss-Server/roast/packages/Test-Helpers/lib/Test/Util.pm6 (Test::Util) line 135
  in sub is_run at /Users/tobiuo/class/seminar/Abyss-Server/roast/packages/Test-Helpers/lib/Test/Util.pm6 (Test::Util) line 129
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-str/indent.rakudo line 149
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-str/indent.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

                        1..190
                        not ok 1 -  (type) # TODO https://github.com/rakudo/rakudo/issues/2409
                        # Failed test ' (type)'
                        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-str/numeric.rakudo line 19
                        # expected: '(Int)'
                        #      got: '(Int+{Abyss::Server::Mod::InitialAttribVal[Int]}+{Abyss::Server::Mod::InitialAttribVal[Int]}+{Abyss::Server::Mod::InitialAttribType[Code]}+{Abyss::Server::Mod::InitialAttribBoth[Str,Str]})'
                        ok 2 -  (value)
                        ok 3 -   (type)
                        ok 4 -   (value)
                        ok 5 -     (type)
                        ok 6 -     (value)
                        ok 7 - 123 (type)
                        ok 8 - 123 (value)
                        ok 9 -  123 (type)
                        ok 10 -  123 (value)
                        ok 11 - 0000123 (type)
                        ok 12 - 0000123 (value)
                        ok 13 - 1_2_3 (type)
                        ok 14 - 1_2_3 (value)
                        ok 15 - +123 (type)
                        ok 16 - +123 (value)
                        ok 17 - -123 (type)
                        ok 18 - -123 (value)
                        ok 19 - 3433683820292512484657849089281 (type)
                        ok 20 - 3433683820292512484657849089281 (value)
                        ok 21 - +"a+123" fails
                        ok 22 - +"123foo" fails
                        ok 23 - +"123+" fails
                        ok 24 - +"1__2" fails
                        ok 25 - +"123_" fails
                        ok 26 - +"123 and stuff" fails
                        ok 27 - 0b111 (type)
                        ok 28 - 0b111 (value)
                        ok 29 - 0b1_1_1 (type)
                        ok 30 - 0b1_1_1 (value)
                        ok 31 - +0b111 (type)
                        ok 32 - +0b111 (value)
                        ok 33 - -0b111 (type)
                        ok 34 - -0b111 (value)
                        ok 35 - 0b_1 (type)
                        ok 36 - 0b_1 (value)
                        ok 37 - +"0b112" fails
                        ok 38 - +"0b" fails
                        ok 39 - 0o77 (type)
                        ok 40 - 0o77 (value)
                        ok 41 - +0o77 (type)
                        ok 42 - +0o77 (value)
                        ok 43 - -0o77 (type)
                        ok 44 - -0o77 (value)
                        ok 45 - +"0o8" fails
                        ok 46 - 0d123 (type)
                        ok 47 - 0d123 (value)
                        ok 48 - -0d123 (type)
                        ok 49 - -0d123 (value)
                        ok 50 - +"0da" fails
                        ok 51 - 0x123 (type)
                        ok 52 - 0x123 (value)
                        ok 53 - -0x123 (type)
                        ok 54 - -0x123 (value)
                        ok 55 - 0xa0 (type)
                        ok 56 - 0xa0 (value)
                        ok 57 - -0xA0 (type)
                        ok 58 - -0xA0 (value)
                        ok 59 - +"0xag" fails
                        ok 60 - +"0xaf-" fails
                        ok 61 - :10<42> (type)
                        ok 62 - :10<42> (value)
                        ok 63 - -:10<42> (type)
                        ok 64 - -:10<42> (value)
                        ok 65 - -:1_0<4_2> (type)
                        ok 66 - -:1_0<4_2> (value)
                        ok 67 - :36<aZ> (type)
                        ok 68 - :36<aZ> (value)
                        ok 69 - :2<11> (type)
                        ok 70 - :2<11> (value)
                        ok 71 - +":2<2>" fails
                        ok 72 - +":37<8>" fails
                        ok 73 - +":10<8_>" fails
                        ok 74 - +":10<_8>" fails
                        ok 75 - +":18<>" fails
                        ok 76 - +":10<8" fails
                        ok 77 - +"123." fails
                        ok 78 - 123.0 (type)
                        ok 79 - 123.0 (value)
                        ok 80 - -123.0 (type)
                        ok 81 - -123.0 (value)
                        ok 82 - +123.0 (type)
                        ok 83 - +123.0 (value)
                        ok 84 - +1_2_3.0_0 (type)
                        ok 85 - +1_2_3.0_0 (value)
                        ok 86 - 3/2 (type)
                        ok 87 - 3/2 (value)
                        ok 88 - +3/2 (type)
                        ok 89 - +3/2 (value)
                        ok 90 - -3/2 (type)
                        ok 91 - -3/2 (value)
                        not ok 92 - +"-3/-2" fails # TODO Unsure of what val() should accept
                        # Failed test '+"-3/-2" fails'
                        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-str/numeric.rakudo line 83
                        not ok 93 - +"3/-2" fails # TODO Unsure of what val() should accept
                        # Failed test '+"3/-2" fails'
                        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-str/numeric.rakudo line 84
                        not ok 94 - +"+3/-2" fails # TODO Unsure of what val() should accept
                        # Failed test '+"+3/-2" fails'
                        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-str/numeric.rakudo line 85
                        not ok 95 - +"3.0/2" fails # TODO Unsure of what val() should accept
                        # Failed test '+"3.0/2" fails'
                        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-str/numeric.rakudo line 86
                        not ok 96 - +"3/2.0" fails # TODO Unsure of what val() should accept
                        # Failed test '+"3/2.0" fails'
                        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-str/numeric.rakudo line 87
                        ok 97 - -:10<4_2.3_5> (type)
                        ok 98 - -:10<4_2.3_5> (value)
                        ok 99 - -:8<4_2.3_5> (type)
                        ok 100 - -:8<4_2.3_5> (value)
                        ok 101 - +":2.4<01>" fails
                        ok 102 - +":10<12f>" fails
                        ok 103 - +":1b<10>" fails
                        ok 104 - +":10<>" fails
                        ok 105 - +":_2<01>" fails
                        ok 106 - +":2<_01>" fails
                        ok 107 - +":2<01_>" fails
                        ok 108 - +":_2_<_0_1_>_" fails
                        ok 109 - +":2<1.3>" fails
                        ok 110 - +"0b1.1e10" fails
                        ok 111 - +":2<10dlk" fails
                        ok 112 - +":2lks01>" fails
                        ok 113 - 123e0 (type)
                        ok 114 - 123e0 (value)
                        ok 115 - -123e0 (type)
                        ok 116 - -123e0 (value)
                        ok 117 - −123e0 (type)
                        ok 118 - −123e0 (value)
                        ok 119 - +123e0 (type)
                        ok 120 - +123e0 (value)
                        ok 121 - +123.0e0 (type)
                        ok 122 - +123.0e0 (value)
                        ok 123 - +123.0_1e2 (type)
                        ok 124 - +123.0_1e2 (value)
                        ok 125 - +123.0_1e0_2 (type)
                        ok 126 - +123.0_1e0_2 (value)
                        ok 127 - 123e-0 (type)
                        ok 128 - 123e-0 (value)
                        ok 129 - -123e+0 (type)
                        ok 130 - -123e+0 (value)
                        ok 131 - −123e+0 (type)
                        ok 132 - −123e+0 (value)
                        ok 133 - 123E0 (type)
                        ok 134 - 123E0 (value)
                        ok 135 - 1_2_3E0_0 (type)
                        ok 136 - 1_2_3E0_0 (value)
                        ok 137 - -123E0 (type)
                        ok 138 - -123E0 (value)
                        ok 139 - −123E0 (type)
                        ok 140 - −123E0 (value)
                        ok 141 - +123E0 (type)
                        ok 142 - +123E0 (value)
                        ok 143 - 123E-0 (type)
                        ok 144 - 123E-0 (value)
                        ok 145 - 123E−0 (type)
                        ok 146 - 123E−0 (value)
                        ok 147 - -123E+0 (type)
                        ok 148 - -123E+0 (value)
                        ok 149 - -123E+0_1 (type)
                        ok 150 - -123E+0_1 (value)
                        ok 151 - 1230E-1 (type)
                        ok 152 - 1230E-1 (value)
                        ok 153 - 1230E−1 (type)
                        ok 154 - 1230E−1 (value)
                        ok 155 - -12E+1 (type)
                        ok 156 - -12E+1 (value)
                        ok 157 - −12E+1 (type)
                        ok 158 - −12E+1 (value)
                        ok 159 - +"120e" fails
                        ok 160 - +"120e2_" fails
                        ok 161 - Inf
                        ok 162 - +Inf
                        ok 163 - -Inf
                        ok 164 - NaN
                        ok 165 - 1+2i (type)
                        ok 166 - 1+2i (value)
                        ok 167 - -1-2i (type)
                        ok 168 - -1-2i (value)
                        ok 169 - -1-2\i (type)
                        ok 170 - -1-2\i (value)
                        ok 171 - -1.0-2.0\i (type)
                        ok 172 - -1.0-2.0\i (value)
                        ok 173 - -1.0e0-2.0e0\i (type)
                        ok 174 - -1.0e0-2.0e0\i (value)
                        ok 175 - -1.0e0_0-2.0e0_0\i (type)
                        ok 176 - -1.0e0_0-2.0e0_0\i (value)
                        ok 177 - 3+Inf\i (type)
                        ok 178 - 3+Inf\i (value)
                        ok 179 - Inf+2e2i (type)
                        ok 180 - Inf+2e2i (value)
                        ok 181 - +"3+3i+4i" fails
                        ok 182 - +"3+3+4i" fails
                        ok 183 - +"3+Infi" fails
                        ok 184 - RT  \#100778
Could not find symbol '&Numeric' in 'X::Str'
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-str/numeric.rakudo line 164
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

                        1..65
                            1..41
                            ok 1 - split("","abcde")
                            ok 2 - "abcde".split("")
                            ok 3 - split("","abcde",:v)
                            ok 4 - "abcde".split("",:v)
                            ok 5 - split("","abcde",:k)
                            ok 6 - "abcde".split("",:k)
                            ok 7 - split("","abcde",:kv)
                            ok 8 - "abcde".split("",:kv)
                            ok 9 - split("","abcde",:p)
                            ok 10 - "abcde".split("",:p)
                            ok 11 - split("","abcde",:skip-empty)
                            ok 12 - "abcde".split("",:skip-empty)
                            ok 13 - split("","abcde",:v,:skip-empty)
                            ok 14 - "abcde".split("",:v,:skip-empty)
                            ok 15 - split("","abcde",:k,:skip-empty)
                            ok 16 - "abcde".split("",:k,:skip-empty)
                            ok 17 - split("","abcde",:kv,:skip-empty)
                            ok 18 - "abcde".split("",:kv,:skip-empty)
                            ok 19 - split("","abcde",:p,:skip-empty)
                            ok 20 - "abcde".split("",:p,:skip-empty)
                            ok 21 - split("","abcde",3)
                            ok 22 - "abcde".split("",3)
                            ok 23 - split("","abcde",3,:v)
                            ok 24 - "abcde".split("",3,:v)
                            ok 25 - split("","abcde",3,:k)
                            ok 26 - "abcde".split("",3,:k)
                            ok 27 - split("","abcde",3,:kv)
                            ok 28 - "abcde".split("",3,:kv)
                            ok 29 - split("","abcde",3,:p)
                            ok 30 - "abcde".split("",3,:p)
                            ok 31 - split("","abcde",3,:split-empty)
                            ok 32 - "abcde".split("",3,:split-empty)
                            ok 33 - split("","abcde",3,:v,:skip-empty)
                            ok 34 - "abcde".split("",3,:v,:skip-empty)
                            ok 35 - split("","abcde",3,:k,:skip-empty)
                            ok 36 - "abcde".split("",3,:k,:skip-empty)
                            ok 37 - split("","abcde",3,:kv,:skip-empty)
                            ok 38 - "abcde".split("",3,:kv,:skip-empty)
                            ok 39 - split("","abcde",3,:p,:skip-empty)
                            ok 40 - "abcde".split("",3,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 185 - tested "abcde" with "empty string"
                            1..41
                            ok 1 - split(/./,"abcd")
                            ok 2 - "abcd".split(/./)
                            ok 3 - split(/./,"abcd",:v)
                            ok 4 - "abcd".split(/./,:v)
                            ok 5 - split(/./,"abcd",:k)
                            ok 6 - "abcd".split(/./,:k)
                            ok 7 - split(/./,"abcd",:kv)
                            ok 8 - "abcd".split(/./,:kv)
                            ok 9 - split(/./,"abcd",:p)
                            ok 10 - "abcd".split(/./,:p)
                            ok 11 - split(/./,"abcd",:skip-empty)
                            ok 12 - "abcd".split(/./,:skip-empty)
                            ok 13 - split(/./,"abcd",:v,:skip-empty)
                            ok 14 - "abcd".split(/./,:v,:skip-empty)
                            ok 15 - split(/./,"abcd",:k,:skip-empty)
                            ok 16 - "abcd".split(/./,:k,:skip-empty)
                            ok 17 - split(/./,"abcd",:kv,:skip-empty)
                            ok 18 - "abcd".split(/./,:kv,:skip-empty)
                            ok 19 - split(/./,"abcd",:p,:skip-empty)
                            ok 20 - "abcd".split(/./,:p,:skip-empty)
                            ok 21 - split(/./,"abcd",3)
                            ok 22 - "abcd".split(/./,3)
                            ok 23 - split(/./,"abcd",3,:v)
                            ok 24 - "abcd".split(/./,3,:v)
                            ok 25 - split(/./,"abcd",3,:k)
                            ok 26 - "abcd".split(/./,3,:k)
                            ok 27 - split(/./,"abcd",3,:kv)
                            ok 28 - "abcd".split(/./,3,:kv)
                            ok 29 - split(/./,"abcd",3,:p)
                            ok 30 - "abcd".split(/./,3,:p)
                            ok 31 - split(/./,"abcd",3,:split-empty)
                            ok 32 - "abcd".split(/./,3,:split-empty)
                            ok 33 - split(/./,"abcd",3,:v,:skip-empty)
                            ok 34 - "abcd".split(/./,3,:v,:skip-empty)
                            ok 35 - split(/./,"abcd",3,:k,:skip-empty)
                            ok 36 - "abcd".split(/./,3,:k,:skip-empty)
                            ok 37 - split(/./,"abcd",3,:kv,:skip-empty)
                            ok 38 - "abcd".split(/./,3,:kv,:skip-empty)
                            ok 39 - split(/./,"abcd",3,:p,:skip-empty)
                            ok 40 - "abcd".split(/./,3,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 186 - tested "abcd" with "any character"
                            1..41
                            ok 1 - split("a","aaaa")
                            ok 2 - "aaaa".split("a")
                            ok 3 - split("a","aaaa",:v)
                            ok 4 - "aaaa".split("a",:v)
                            ok 5 - split("a","aaaa",:k)
                            ok 6 - "aaaa".split("a",:k)
                            ok 7 - split("a","aaaa",:kv)
                            ok 8 - "aaaa".split("a",:kv)
                            ok 9 - split("a","aaaa",:p)
                            ok 10 - "aaaa".split("a",:p)
                            ok 11 - split("a","aaaa",:skip-empty)
                            ok 12 - "aaaa".split("a",:skip-empty)
                            ok 13 - split("a","aaaa",:v,:skip-empty)
                            ok 14 - "aaaa".split("a",:v,:skip-empty)
                            ok 15 - split("a","aaaa",:k,:skip-empty)
                            ok 16 - "aaaa".split("a",:k,:skip-empty)
                            ok 17 - split("a","aaaa",:kv,:skip-empty)
                            ok 18 - "aaaa".split("a",:kv,:skip-empty)
                            ok 19 - split("a","aaaa",:p,:skip-empty)
                            ok 20 - "aaaa".split("a",:p,:skip-empty)
                            ok 21 - split("a","aaaa",3)
                            ok 22 - "aaaa".split("a",3)
                            ok 23 - split("a","aaaa",3,:v)
                            ok 24 - "aaaa".split("a",3,:v)
                            ok 25 - split("a","aaaa",3,:k)
                            ok 26 - "aaaa".split("a",3,:k)
                            ok 27 - split("a","aaaa",3,:kv)
                            ok 28 - "aaaa".split("a",3,:kv)
                            ok 29 - split("a","aaaa",3,:p)
                            ok 30 - "aaaa".split("a",3,:p)
                            ok 31 - split("a","aaaa",3,:split-empty)
                            ok 32 - "aaaa".split("a",3,:split-empty)
                            ok 33 - split("a","aaaa",3,:v,:skip-empty)
                            ok 34 - "aaaa".split("a",3,:v,:skip-empty)
                            ok 35 - split("a","aaaa",3,:k,:skip-empty)
                            ok 36 - "aaaa".split("a",3,:k,:skip-empty)
                            ok 37 - split("a","aaaa",3,:kv,:skip-empty)
                            ok 38 - "aaaa".split("a",3,:kv,:skip-empty)
                            ok 39 - split("a","aaaa",3,:p,:skip-empty)
                            ok 40 - "aaaa".split("a",3,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 187 - tested "aaaa" with "only chars matching \"a\""
                            1..41
                            ok 1 - split(/a/,"aaaa")
                            ok 2 - "aaaa".split(/a/)
                            ok 3 - split(/a/,"aaaa",:v)
                            ok 4 - "aaaa".split(/a/,:v)
                            ok 5 - split(/a/,"aaaa",:k)
                            ok 6 - "aaaa".split(/a/,:k)
                            ok 7 - split(/a/,"aaaa",:kv)
                            ok 8 - "aaaa".split(/a/,:kv)
                            ok 9 - split(/a/,"aaaa",:p)
                            ok 10 - "aaaa".split(/a/,:p)
                            ok 11 - split(/a/,"aaaa",:skip-empty)
                            ok 12 - "aaaa".split(/a/,:skip-empty)
                            ok 13 - split(/a/,"aaaa",:v,:skip-empty)
                            ok 14 - "aaaa".split(/a/,:v,:skip-empty)
                            ok 15 - split(/a/,"aaaa",:k,:skip-empty)
                            ok 16 - "aaaa".split(/a/,:k,:skip-empty)
                            ok 17 - split(/a/,"aaaa",:kv,:skip-empty)
                            ok 18 - "aaaa".split(/a/,:kv,:skip-empty)
                            ok 19 - split(/a/,"aaaa",:p,:skip-empty)
                            ok 20 - "aaaa".split(/a/,:p,:skip-empty)
                            ok 21 - split(/a/,"aaaa",3)
                            ok 22 - "aaaa".split(/a/,3)
                            ok 23 - split(/a/,"aaaa",3,:v)
                            ok 24 - "aaaa".split(/a/,3,:v)
                            ok 25 - split(/a/,"aaaa",3,:k)
                            ok 26 - "aaaa".split(/a/,3,:k)
                            ok 27 - split(/a/,"aaaa",3,:kv)
                            ok 28 - "aaaa".split(/a/,3,:kv)
                            ok 29 - split(/a/,"aaaa",3,:p)
                            ok 30 - "aaaa".split(/a/,3,:p)
                            ok 31 - split(/a/,"aaaa",3,:split-empty)
                            ok 32 - "aaaa".split(/a/,3,:split-empty)
                            ok 33 - split(/a/,"aaaa",3,:v,:skip-empty)
                            ok 34 - "aaaa".split(/a/,3,:v,:skip-empty)
                            ok 35 - split(/a/,"aaaa",3,:k,:skip-empty)
                            ok 36 - "aaaa".split(/a/,3,:k,:skip-empty)
                            ok 37 - split(/a/,"aaaa",3,:kv,:skip-empty)
                            ok 38 - "aaaa".split(/a/,3,:kv,:skip-empty)
                            ok 39 - split(/a/,"aaaa",3,:p,:skip-empty)
                            ok 40 - "aaaa".split(/a/,3,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 188 - tested "aaaa" with "only chars matching /a/"
                            1..41
                            ok 1 - split(rx:Perl5/a/,"aaaa")
                            ok 2 - "aaaa".split(rx:Perl5/a/)
                            ok 3 - split(rx:Perl5/a/,"aaaa",:v)
                            ok 4 - "aaaa".split(rx:Perl5/a/,:v)
                            ok 5 - split(rx:Perl5/a/,"aaaa",:k)
                            ok 6 - "aaaa".split(rx:Perl5/a/,:k)
                            ok 7 - split(rx:Perl5/a/,"aaaa",:kv)
                            ok 8 - "aaaa".split(rx:Perl5/a/,:kv)
                            ok 9 - split(rx:Perl5/a/,"aaaa",:p)
                            ok 10 - "aaaa".split(rx:Perl5/a/,:p)
                            ok 11 - split(rx:Perl5/a/,"aaaa",:skip-empty)
                            ok 12 - "aaaa".split(rx:Perl5/a/,:skip-empty)
                            ok 13 - split(rx:Perl5/a/,"aaaa",:v,:skip-empty)
                            ok 14 - "aaaa".split(rx:Perl5/a/,:v,:skip-empty)
                            ok 15 - split(rx:Perl5/a/,"aaaa",:k,:skip-empty)
                            ok 16 - "aaaa".split(rx:Perl5/a/,:k,:skip-empty)
                            ok 17 - split(rx:Perl5/a/,"aaaa",:kv,:skip-empty)
                            ok 18 - "aaaa".split(rx:Perl5/a/,:kv,:skip-empty)
                            ok 19 - split(rx:Perl5/a/,"aaaa",:p,:skip-empty)
                            ok 20 - "aaaa".split(rx:Perl5/a/,:p,:skip-empty)
                            ok 21 - split(rx:Perl5/a/,"aaaa",3)
                            ok 22 - "aaaa".split(rx:Perl5/a/,3)
                            ok 23 - split(rx:Perl5/a/,"aaaa",3,:v)
                            ok 24 - "aaaa".split(rx:Perl5/a/,3,:v)
                            ok 25 - split(rx:Perl5/a/,"aaaa",3,:k)
                            ok 26 - "aaaa".split(rx:Perl5/a/,3,:k)
                            ok 27 - split(rx:Perl5/a/,"aaaa",3,:kv)
                            ok 28 - "aaaa".split(rx:Perl5/a/,3,:kv)
                            ok 29 - split(rx:Perl5/a/,"aaaa",3,:p)
                            ok 30 - "aaaa".split(rx:Perl5/a/,3,:p)
                            ok 31 - split(rx:Perl5/a/,"aaaa",3,:split-empty)
                            ok 32 - "aaaa".split(rx:Perl5/a/,3,:split-empty)
                            ok 33 - split(rx:Perl5/a/,"aaaa",3,:v,:skip-empty)
                            ok 34 - "aaaa".split(rx:Perl5/a/,3,:v,:skip-empty)
                            ok 35 - split(rx:Perl5/a/,"aaaa",3,:k,:skip-empty)
                            ok 36 - "aaaa".split(rx:Perl5/a/,3,:k,:skip-empty)
                            ok 37 - split(rx:Perl5/a/,"aaaa",3,:kv,:skip-empty)
                            ok 38 - "aaaa".split(rx:Perl5/a/,3,:kv,:skip-empty)
                            ok 39 - split(rx:Perl5/a/,"aaaa",3,:p,:skip-empty)
                            ok 40 - "aaaa".split(rx:Perl5/a/,3,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 189 - tested "aaaa" with "only chars matching rx:Perl5/a/"
                            1..41
                            ok 1 - split(" ","foo bar baz")
                            ok 2 - "foo bar baz".split(" ")
                            ok 3 - split(" ","foo bar baz",:v)
                            ok 4 - "foo bar baz".split(" ",:v)
                            ok 5 - split(" ","foo bar baz",:k)
                            ok 6 - "foo bar baz".split(" ",:k)
                            ok 7 - split(" ","foo bar baz",:kv)
                            ok 8 - "foo bar baz".split(" ",:kv)
                            ok 9 - split(" ","foo bar baz",:p)
                            ok 10 - "foo bar baz".split(" ",:p)
                            ok 11 - split(" ","foo bar baz",:skip-empty)
                            ok 12 - "foo bar baz".split(" ",:skip-empty)
                            ok 13 - split(" ","foo bar baz",:v,:skip-empty)
                            ok 14 - "foo bar baz".split(" ",:v,:skip-empty)
                            ok 15 - split(" ","foo bar baz",:k,:skip-empty)
                            ok 16 - "foo bar baz".split(" ",:k,:skip-empty)
                            ok 17 - split(" ","foo bar baz",:kv,:skip-empty)
                            ok 18 - "foo bar baz".split(" ",:kv,:skip-empty)
                            ok 19 - split(" ","foo bar baz",:p,:skip-empty)
                            ok 20 - "foo bar baz".split(" ",:p,:skip-empty)
                            ok 21 - split(" ","foo bar baz",2)
                            ok 22 - "foo bar baz".split(" ",2)
                            ok 23 - split(" ","foo bar baz",2,:v)
                            ok 24 - "foo bar baz".split(" ",2,:v)
                            ok 25 - split(" ","foo bar baz",2,:k)
                            ok 26 - "foo bar baz".split(" ",2,:k)
                            ok 27 - split(" ","foo bar baz",2,:kv)
                            ok 28 - "foo bar baz".split(" ",2,:kv)
                            ok 29 - split(" ","foo bar baz",2,:p)
                            ok 30 - "foo bar baz".split(" ",2,:p)
                            ok 31 - split(" ","foo bar baz",2,:split-empty)
                            ok 32 - "foo bar baz".split(" ",2,:split-empty)
                            ok 33 - split(" ","foo bar baz",2,:v,:skip-empty)
                            ok 34 - "foo bar baz".split(" ",2,:v,:skip-empty)
                            ok 35 - split(" ","foo bar baz",2,:k,:skip-empty)
                            ok 36 - "foo bar baz".split(" ",2,:k,:skip-empty)
                            ok 37 - split(" ","foo bar baz",2,:kv,:skip-empty)
                            ok 38 - "foo bar baz".split(" ",2,:kv,:skip-empty)
                            ok 39 - split(" ","foo bar baz",2,:p,:skip-empty)
                            ok 40 - "foo bar baz".split(" ",2,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 190 - tested "foo bar baz" with " "
                            1..41
                            ok 1 - split(/ " " /,"foo bar baz")
                            ok 2 - "foo bar baz".split(/ " " /)
                            ok 3 - split(/ " " /,"foo bar baz",:v)
                            ok 4 - "foo bar baz".split(/ " " /,:v)
                            ok 5 - split(/ " " /,"foo bar baz",:k)
                            ok 6 - "foo bar baz".split(/ " " /,:k)
                            ok 7 - split(/ " " /,"foo bar baz",:kv)
                            ok 8 - "foo bar baz".split(/ " " /,:kv)
                            ok 9 - split(/ " " /,"foo bar baz",:p)
                            ok 10 - "foo bar baz".split(/ " " /,:p)
                            ok 11 - split(/ " " /,"foo bar baz",:skip-empty)
                            ok 12 - "foo bar baz".split(/ " " /,:skip-empty)
                            ok 13 - split(/ " " /,"foo bar baz",:v,:skip-empty)
                            ok 14 - "foo bar baz".split(/ " " /,:v,:skip-empty)
                            ok 15 - split(/ " " /,"foo bar baz",:k,:skip-empty)
                            ok 16 - "foo bar baz".split(/ " " /,:k,:skip-empty)
                            ok 17 - split(/ " " /,"foo bar baz",:kv,:skip-empty)
                            ok 18 - "foo bar baz".split(/ " " /,:kv,:skip-empty)
                            ok 19 - split(/ " " /,"foo bar baz",:p,:skip-empty)
                            ok 20 - "foo bar baz".split(/ " " /,:p,:skip-empty)
                            ok 21 - split(/ " " /,"foo bar baz",2)
                            ok 22 - "foo bar baz".split(/ " " /,2)
                            ok 23 - split(/ " " /,"foo bar baz",2,:v)
                            ok 24 - "foo bar baz".split(/ " " /,2,:v)
                            ok 25 - split(/ " " /,"foo bar baz",2,:k)
                            ok 26 - "foo bar baz".split(/ " " /,2,:k)
                            ok 27 - split(/ " " /,"foo bar baz",2,:kv)
                            ok 28 - "foo bar baz".split(/ " " /,2,:kv)
                            ok 29 - split(/ " " /,"foo bar baz",2,:p)
                            ok 30 - "foo bar baz".split(/ " " /,2,:p)
                            ok 31 - split(/ " " /,"foo bar baz",2,:split-empty)
                            ok 32 - "foo bar baz".split(/ " " /,2,:split-empty)
                            ok 33 - split(/ " " /,"foo bar baz",2,:v,:skip-empty)
                            ok 34 - "foo bar baz".split(/ " " /,2,:v,:skip-empty)
                            ok 35 - split(/ " " /,"foo bar baz",2,:k,:skip-empty)
                            ok 36 - "foo bar baz".split(/ " " /,2,:k,:skip-empty)
                            ok 37 - split(/ " " /,"foo bar baz",2,:kv,:skip-empty)
                            ok 38 - "foo bar baz".split(/ " " /,2,:kv,:skip-empty)
                            ok 39 - split(/ " " /,"foo bar baz",2,:p,:skip-empty)
                            ok 40 - "foo bar baz".split(/ " " /,2,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 191 - tested "foo bar baz" with / " " /
                            1..41
                            ok 1 - split(/ \s /,"foo bar baz")
                            ok 2 - "foo bar baz".split(/ \s /)
                            ok 3 - split(/ \s /,"foo bar baz",:v)
                            ok 4 - "foo bar baz".split(/ \s /,:v)
                            ok 5 - split(/ \s /,"foo bar baz",:k)
                            ok 6 - "foo bar baz".split(/ \s /,:k)
                            ok 7 - split(/ \s /,"foo bar baz",:kv)
                            ok 8 - "foo bar baz".split(/ \s /,:kv)
                            ok 9 - split(/ \s /,"foo bar baz",:p)
                            ok 10 - "foo bar baz".split(/ \s /,:p)
                            ok 11 - split(/ \s /,"foo bar baz",:skip-empty)
                            ok 12 - "foo bar baz".split(/ \s /,:skip-empty)
                            ok 13 - split(/ \s /,"foo bar baz",:v,:skip-empty)
                            ok 14 - "foo bar baz".split(/ \s /,:v,:skip-empty)
                            ok 15 - split(/ \s /,"foo bar baz",:k,:skip-empty)
                            ok 16 - "foo bar baz".split(/ \s /,:k,:skip-empty)
                            ok 17 - split(/ \s /,"foo bar baz",:kv,:skip-empty)
                            ok 18 - "foo bar baz".split(/ \s /,:kv,:skip-empty)
                            ok 19 - split(/ \s /,"foo bar baz",:p,:skip-empty)
                            ok 20 - "foo bar baz".split(/ \s /,:p,:skip-empty)
                            ok 21 - split(/ \s /,"foo bar baz",2)
                            ok 22 - "foo bar baz".split(/ \s /,2)
                            ok 23 - split(/ \s /,"foo bar baz",2,:v)
                            ok 24 - "foo bar baz".split(/ \s /,2,:v)
                            ok 25 - split(/ \s /,"foo bar baz",2,:k)
                            ok 26 - "foo bar baz".split(/ \s /,2,:k)
                            ok 27 - split(/ \s /,"foo bar baz",2,:kv)
                            ok 28 - "foo bar baz".split(/ \s /,2,:kv)
                            ok 29 - split(/ \s /,"foo bar baz",2,:p)
                            ok 30 - "foo bar baz".split(/ \s /,2,:p)
                            ok 31 - split(/ \s /,"foo bar baz",2,:split-empty)
                            ok 32 - "foo bar baz".split(/ \s /,2,:split-empty)
                            ok 33 - split(/ \s /,"foo bar baz",2,:v,:skip-empty)
                            ok 34 - "foo bar baz".split(/ \s /,2,:v,:skip-empty)
                            ok 35 - split(/ \s /,"foo bar baz",2,:k,:skip-empty)
                            ok 36 - "foo bar baz".split(/ \s /,2,:k,:skip-empty)
                            ok 37 - split(/ \s /,"foo bar baz",2,:kv,:skip-empty)
                            ok 38 - "foo bar baz".split(/ \s /,2,:kv,:skip-empty)
                            ok 39 - split(/ \s /,"foo bar baz",2,:p,:skip-empty)
                            ok 40 - "foo bar baz".split(/ \s /,2,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 192 - tested "foo bar baz" with / \s /
                            1..41
                            ok 1 - split(/ \s+ /,"foo bar baz")
                            ok 2 - "foo bar baz".split(/ \s+ /)
                            ok 3 - split(/ \s+ /,"foo bar baz",:v)
                            ok 4 - "foo bar baz".split(/ \s+ /,:v)
                            ok 5 - split(/ \s+ /,"foo bar baz",:k)
                            ok 6 - "foo bar baz".split(/ \s+ /,:k)
                            ok 7 - split(/ \s+ /,"foo bar baz",:kv)
                            ok 8 - "foo bar baz".split(/ \s+ /,:kv)
                            ok 9 - split(/ \s+ /,"foo bar baz",:p)
                            ok 10 - "foo bar baz".split(/ \s+ /,:p)
                            ok 11 - split(/ \s+ /,"foo bar baz",:skip-empty)
                            ok 12 - "foo bar baz".split(/ \s+ /,:skip-empty)
                            ok 13 - split(/ \s+ /,"foo bar baz",:v,:skip-empty)
                            ok 14 - "foo bar baz".split(/ \s+ /,:v,:skip-empty)
                            ok 15 - split(/ \s+ /,"foo bar baz",:k,:skip-empty)
                            ok 16 - "foo bar baz".split(/ \s+ /,:k,:skip-empty)
                            ok 17 - split(/ \s+ /,"foo bar baz",:kv,:skip-empty)
                            ok 18 - "foo bar baz".split(/ \s+ /,:kv,:skip-empty)
                            ok 19 - split(/ \s+ /,"foo bar baz",:p,:skip-empty)
                            ok 20 - "foo bar baz".split(/ \s+ /,:p,:skip-empty)
                            ok 21 - split(/ \s+ /,"foo bar baz",2)
                            ok 22 - "foo bar baz".split(/ \s+ /,2)
                            ok 23 - split(/ \s+ /,"foo bar baz",2,:v)
                            ok 24 - "foo bar baz".split(/ \s+ /,2,:v)
                            ok 25 - split(/ \s+ /,"foo bar baz",2,:k)
                            ok 26 - "foo bar baz".split(/ \s+ /,2,:k)
                            ok 27 - split(/ \s+ /,"foo bar baz",2,:kv)
                            ok 28 - "foo bar baz".split(/ \s+ /,2,:kv)
                            ok 29 - split(/ \s+ /,"foo bar baz",2,:p)
                            ok 30 - "foo bar baz".split(/ \s+ /,2,:p)
                            ok 31 - split(/ \s+ /,"foo bar baz",2,:split-empty)
                            ok 32 - "foo bar baz".split(/ \s+ /,2,:split-empty)
                            ok 33 - split(/ \s+ /,"foo bar baz",2,:v,:skip-empty)
                            ok 34 - "foo bar baz".split(/ \s+ /,2,:v,:skip-empty)
                            ok 35 - split(/ \s+ /,"foo bar baz",2,:k,:skip-empty)
                            ok 36 - "foo bar baz".split(/ \s+ /,2,:k,:skip-empty)
                            ok 37 - split(/ \s+ /,"foo bar baz",2,:kv,:skip-empty)
                            ok 38 - "foo bar baz".split(/ \s+ /,2,:kv,:skip-empty)
                            ok 39 - split(/ \s+ /,"foo bar baz",2,:p,:skip-empty)
                            ok 40 - "foo bar baz".split(/ \s+ /,2,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 193 - tested "foo bar baz" with / \s+ /
                            1..41
                            ok 1 - split(rx:Perl5/ /,"foo bar baz")
                            ok 2 - "foo bar baz".split(rx:Perl5/ /)
                            ok 3 - split(rx:Perl5/ /,"foo bar baz",:v)
                            ok 4 - "foo bar baz".split(rx:Perl5/ /,:v)
                            ok 5 - split(rx:Perl5/ /,"foo bar baz",:k)
                            ok 6 - "foo bar baz".split(rx:Perl5/ /,:k)
                            ok 7 - split(rx:Perl5/ /,"foo bar baz",:kv)
                            ok 8 - "foo bar baz".split(rx:Perl5/ /,:kv)
                            ok 9 - split(rx:Perl5/ /,"foo bar baz",:p)
                            ok 10 - "foo bar baz".split(rx:Perl5/ /,:p)
                            ok 11 - split(rx:Perl5/ /,"foo bar baz",:skip-empty)
                            ok 12 - "foo bar baz".split(rx:Perl5/ /,:skip-empty)
                            ok 13 - split(rx:Perl5/ /,"foo bar baz",:v,:skip-empty)
                            ok 14 - "foo bar baz".split(rx:Perl5/ /,:v,:skip-empty)
                            ok 15 - split(rx:Perl5/ /,"foo bar baz",:k,:skip-empty)
                            ok 16 - "foo bar baz".split(rx:Perl5/ /,:k,:skip-empty)
                            ok 17 - split(rx:Perl5/ /,"foo bar baz",:kv,:skip-empty)
                            ok 18 - "foo bar baz".split(rx:Perl5/ /,:kv,:skip-empty)
                            ok 19 - split(rx:Perl5/ /,"foo bar baz",:p,:skip-empty)
                            ok 20 - "foo bar baz".split(rx:Perl5/ /,:p,:skip-empty)
                            ok 21 - split(rx:Perl5/ /,"foo bar baz",2)
                            ok 22 - "foo bar baz".split(rx:Perl5/ /,2)
                            ok 23 - split(rx:Perl5/ /,"foo bar baz",2,:v)
                            ok 24 - "foo bar baz".split(rx:Perl5/ /,2,:v)
                            ok 25 - split(rx:Perl5/ /,"foo bar baz",2,:k)
                            ok 26 - "foo bar baz".split(rx:Perl5/ /,2,:k)
                            ok 27 - split(rx:Perl5/ /,"foo bar baz",2,:kv)
                            ok 28 - "foo bar baz".split(rx:Perl5/ /,2,:kv)
                            ok 29 - split(rx:Perl5/ /,"foo bar baz",2,:p)
                            ok 30 - "foo bar baz".split(rx:Perl5/ /,2,:p)
                            ok 31 - split(rx:Perl5/ /,"foo bar baz",2,:split-empty)
                            ok 32 - "foo bar baz".split(rx:Perl5/ /,2,:split-empty)
                            ok 33 - split(rx:Perl5/ /,"foo bar baz",2,:v,:skip-empty)
                            ok 34 - "foo bar baz".split(rx:Perl5/ /,2,:v,:skip-empty)
                            ok 35 - split(rx:Perl5/ /,"foo bar baz",2,:k,:skip-empty)
                            ok 36 - "foo bar baz".split(rx:Perl5/ /,2,:k,:skip-empty)
                            ok 37 - split(rx:Perl5/ /,"foo bar baz",2,:kv,:skip-empty)
                            ok 38 - "foo bar baz".split(rx:Perl5/ /,2,:kv,:skip-empty)
                            ok 39 - split(rx:Perl5/ /,"foo bar baz",2,:p,:skip-empty)
                            ok 40 - "foo bar baz".split(rx:Perl5/ /,2,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 194 - tested "foo bar baz" with rx:Perl5/ /
                            1..41
                            ok 1 - split(rx:Perl5/\s/,"foo bar baz")
                            ok 2 - "foo bar baz".split(rx:Perl5/\s/)
                            ok 3 - split(rx:Perl5/\s/,"foo bar baz",:v)
                            ok 4 - "foo bar baz".split(rx:Perl5/\s/,:v)
                            ok 5 - split(rx:Perl5/\s/,"foo bar baz",:k)
                            ok 6 - "foo bar baz".split(rx:Perl5/\s/,:k)
                            ok 7 - split(rx:Perl5/\s/,"foo bar baz",:kv)
                            ok 8 - "foo bar baz".split(rx:Perl5/\s/,:kv)
                            ok 9 - split(rx:Perl5/\s/,"foo bar baz",:p)
                            ok 10 - "foo bar baz".split(rx:Perl5/\s/,:p)
                            ok 11 - split(rx:Perl5/\s/,"foo bar baz",:skip-empty)
                            ok 12 - "foo bar baz".split(rx:Perl5/\s/,:skip-empty)
                            ok 13 - split(rx:Perl5/\s/,"foo bar baz",:v,:skip-empty)
                            ok 14 - "foo bar baz".split(rx:Perl5/\s/,:v,:skip-empty)
                            ok 15 - split(rx:Perl5/\s/,"foo bar baz",:k,:skip-empty)
                            ok 16 - "foo bar baz".split(rx:Perl5/\s/,:k,:skip-empty)
                            ok 17 - split(rx:Perl5/\s/,"foo bar baz",:kv,:skip-empty)
                            ok 18 - "foo bar baz".split(rx:Perl5/\s/,:kv,:skip-empty)
                            ok 19 - split(rx:Perl5/\s/,"foo bar baz",:p,:skip-empty)
                            ok 20 - "foo bar baz".split(rx:Perl5/\s/,:p,:skip-empty)
                            ok 21 - split(rx:Perl5/\s/,"foo bar baz",2)
                            ok 22 - "foo bar baz".split(rx:Perl5/\s/,2)
                            ok 23 - split(rx:Perl5/\s/,"foo bar baz",2,:v)
                            ok 24 - "foo bar baz".split(rx:Perl5/\s/,2,:v)
                            ok 25 - split(rx:Perl5/\s/,"foo bar baz",2,:k)
                            ok 26 - "foo bar baz".split(rx:Perl5/\s/,2,:k)
                            ok 27 - split(rx:Perl5/\s/,"foo bar baz",2,:kv)
                            ok 28 - "foo bar baz".split(rx:Perl5/\s/,2,:kv)
                            ok 29 - split(rx:Perl5/\s/,"foo bar baz",2,:p)
                            ok 30 - "foo bar baz".split(rx:Perl5/\s/,2,:p)
                            ok 31 - split(rx:Perl5/\s/,"foo bar baz",2,:split-empty)
                            ok 32 - "foo bar baz".split(rx:Perl5/\s/,2,:split-empty)
                            ok 33 - split(rx:Perl5/\s/,"foo bar baz",2,:v,:skip-empty)
                            ok 34 - "foo bar baz".split(rx:Perl5/\s/,2,:v,:skip-empty)
                            ok 35 - split(rx:Perl5/\s/,"foo bar baz",2,:k,:skip-empty)
                            ok 36 - "foo bar baz".split(rx:Perl5/\s/,2,:k,:skip-empty)
                            ok 37 - split(rx:Perl5/\s/,"foo bar baz",2,:kv,:skip-empty)
                            ok 38 - "foo bar baz".split(rx:Perl5/\s/,2,:kv,:skip-empty)
                            ok 39 - split(rx:Perl5/\s/,"foo bar baz",2,:p,:skip-empty)
                            ok 40 - "foo bar baz".split(rx:Perl5/\s/,2,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 195 - tested "foo bar baz" with rx:Perl5/\s/
                            1..41
                            ok 1 - split(rx:Perl5/\s+/,"foo bar baz")
                            ok 2 - "foo bar baz".split(rx:Perl5/\s+/)
                            ok 3 - split(rx:Perl5/\s+/,"foo bar baz",:v)
                            ok 4 - "foo bar baz".split(rx:Perl5/\s+/,:v)
                            ok 5 - split(rx:Perl5/\s+/,"foo bar baz",:k)
                            ok 6 - "foo bar baz".split(rx:Perl5/\s+/,:k)
                            ok 7 - split(rx:Perl5/\s+/,"foo bar baz",:kv)
                            ok 8 - "foo bar baz".split(rx:Perl5/\s+/,:kv)
                            ok 9 - split(rx:Perl5/\s+/,"foo bar baz",:p)
                            ok 10 - "foo bar baz".split(rx:Perl5/\s+/,:p)
                            ok 11 - split(rx:Perl5/\s+/,"foo bar baz",:skip-empty)
                            ok 12 - "foo bar baz".split(rx:Perl5/\s+/,:skip-empty)
                            ok 13 - split(rx:Perl5/\s+/,"foo bar baz",:v,:skip-empty)
                            ok 14 - "foo bar baz".split(rx:Perl5/\s+/,:v,:skip-empty)
                            ok 15 - split(rx:Perl5/\s+/,"foo bar baz",:k,:skip-empty)
                            ok 16 - "foo bar baz".split(rx:Perl5/\s+/,:k,:skip-empty)
                            ok 17 - split(rx:Perl5/\s+/,"foo bar baz",:kv,:skip-empty)
                            ok 18 - "foo bar baz".split(rx:Perl5/\s+/,:kv,:skip-empty)
                            ok 19 - split(rx:Perl5/\s+/,"foo bar baz",:p,:skip-empty)
                            ok 20 - "foo bar baz".split(rx:Perl5/\s+/,:p,:skip-empty)
                            ok 21 - split(rx:Perl5/\s+/,"foo bar baz",2)
                            ok 22 - "foo bar baz".split(rx:Perl5/\s+/,2)
                            ok 23 - split(rx:Perl5/\s+/,"foo bar baz",2,:v)
                            ok 24 - "foo bar baz".split(rx:Perl5/\s+/,2,:v)
                            ok 25 - split(rx:Perl5/\s+/,"foo bar baz",2,:k)
                            ok 26 - "foo bar baz".split(rx:Perl5/\s+/,2,:k)
                            ok 27 - split(rx:Perl5/\s+/,"foo bar baz",2,:kv)
                            ok 28 - "foo bar baz".split(rx:Perl5/\s+/,2,:kv)
                            ok 29 - split(rx:Perl5/\s+/,"foo bar baz",2,:p)
                            ok 30 - "foo bar baz".split(rx:Perl5/\s+/,2,:p)
                            ok 31 - split(rx:Perl5/\s+/,"foo bar baz",2,:split-empty)
                            ok 32 - "foo bar baz".split(rx:Perl5/\s+/,2,:split-empty)
                            ok 33 - split(rx:Perl5/\s+/,"foo bar baz",2,:v,:skip-empty)
                            ok 34 - "foo bar baz".split(rx:Perl5/\s+/,2,:v,:skip-empty)
                            ok 35 - split(rx:Perl5/\s+/,"foo bar baz",2,:k,:skip-empty)
                            ok 36 - "foo bar baz".split(rx:Perl5/\s+/,2,:k,:skip-empty)
                            ok 37 - split(rx:Perl5/\s+/,"foo bar baz",2,:kv,:skip-empty)
                            ok 38 - "foo bar baz".split(rx:Perl5/\s+/,2,:kv,:skip-empty)
                            ok 39 - split(rx:Perl5/\s+/,"foo bar baz",2,:p,:skip-empty)
                            ok 40 - "foo bar baz".split(rx:Perl5/\s+/,2,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 196 - tested "foo bar baz" with rx:Perl5/\s+/
                            1..41
                            ok 1 - split("s","thisisit")
                            ok 2 - "thisisit".split("s")
                            ok 3 - split("s","thisisit",:v)
                            ok 4 - "thisisit".split("s",:v)
                            ok 5 - split("s","thisisit",:k)
                            ok 6 - "thisisit".split("s",:k)
                            ok 7 - split("s","thisisit",:kv)
                            ok 8 - "thisisit".split("s",:kv)
                            ok 9 - split("s","thisisit",:p)
                            ok 10 - "thisisit".split("s",:p)
                            ok 11 - split("s","thisisit",:skip-empty)
                            ok 12 - "thisisit".split("s",:skip-empty)
                            ok 13 - split("s","thisisit",:v,:skip-empty)
                            ok 14 - "thisisit".split("s",:v,:skip-empty)
                            ok 15 - split("s","thisisit",:k,:skip-empty)
                            ok 16 - "thisisit".split("s",:k,:skip-empty)
                            ok 17 - split("s","thisisit",:kv,:skip-empty)
                            ok 18 - "thisisit".split("s",:kv,:skip-empty)
                            ok 19 - split("s","thisisit",:p,:skip-empty)
                            ok 20 - "thisisit".split("s",:p,:skip-empty)
                            ok 21 - split("s","thisisit",2)
                            ok 22 - "thisisit".split("s",2)
                            ok 23 - split("s","thisisit",2,:v)
                            ok 24 - "thisisit".split("s",2,:v)
                            ok 25 - split("s","thisisit",2,:k)
                            ok 26 - "thisisit".split("s",2,:k)
                            ok 27 - split("s","thisisit",2,:kv)
                            ok 28 - "thisisit".split("s",2,:kv)
                            ok 29 - split("s","thisisit",2,:p)
                            ok 30 - "thisisit".split("s",2,:p)
                            ok 31 - split("s","thisisit",2,:split-empty)
                            ok 32 - "thisisit".split("s",2,:split-empty)
                            ok 33 - split("s","thisisit",2,:v,:skip-empty)
                            ok 34 - "thisisit".split("s",2,:v,:skip-empty)
                            ok 35 - split("s","thisisit",2,:k,:skip-empty)
                            ok 36 - "thisisit".split("s",2,:k,:skip-empty)
                            ok 37 - split("s","thisisit",2,:kv,:skip-empty)
                            ok 38 - "thisisit".split("s",2,:kv,:skip-empty)
                            ok 39 - split("s","thisisit",2,:p,:skip-empty)
                            ok 40 - "thisisit".split("s",2,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 197 - tested "thisisit" with "s"
                            1..41
                            ok 1 - split(/s/,"thisisit")
                            ok 2 - "thisisit".split(/s/)
                            ok 3 - split(/s/,"thisisit",:v)
                            ok 4 - "thisisit".split(/s/,:v)
                            ok 5 - split(/s/,"thisisit",:k)
                            ok 6 - "thisisit".split(/s/,:k)
                            ok 7 - split(/s/,"thisisit",:kv)
                            ok 8 - "thisisit".split(/s/,:kv)
                            ok 9 - split(/s/,"thisisit",:p)
                            ok 10 - "thisisit".split(/s/,:p)
                            ok 11 - split(/s/,"thisisit",:skip-empty)
                            ok 12 - "thisisit".split(/s/,:skip-empty)
                            ok 13 - split(/s/,"thisisit",:v,:skip-empty)
                            ok 14 - "thisisit".split(/s/,:v,:skip-empty)
                            ok 15 - split(/s/,"thisisit",:k,:skip-empty)
                            ok 16 - "thisisit".split(/s/,:k,:skip-empty)
                            ok 17 - split(/s/,"thisisit",:kv,:skip-empty)
                            ok 18 - "thisisit".split(/s/,:kv,:skip-empty)
                            ok 19 - split(/s/,"thisisit",:p,:skip-empty)
                            ok 20 - "thisisit".split(/s/,:p,:skip-empty)
                            ok 21 - split(/s/,"thisisit",2)
                            ok 22 - "thisisit".split(/s/,2)
                            ok 23 - split(/s/,"thisisit",2,:v)
                            ok 24 - "thisisit".split(/s/,2,:v)
                            ok 25 - split(/s/,"thisisit",2,:k)
                            ok 26 - "thisisit".split(/s/,2,:k)
                            ok 27 - split(/s/,"thisisit",2,:kv)
                            ok 28 - "thisisit".split(/s/,2,:kv)
                            ok 29 - split(/s/,"thisisit",2,:p)
                            ok 30 - "thisisit".split(/s/,2,:p)
                            ok 31 - split(/s/,"thisisit",2,:split-empty)
                            ok 32 - "thisisit".split(/s/,2,:split-empty)
                            ok 33 - split(/s/,"thisisit",2,:v,:skip-empty)
                            ok 34 - "thisisit".split(/s/,2,:v,:skip-empty)
                            ok 35 - split(/s/,"thisisit",2,:k,:skip-empty)
                            ok 36 - "thisisit".split(/s/,2,:k,:skip-empty)
                            ok 37 - split(/s/,"thisisit",2,:kv,:skip-empty)
                            ok 38 - "thisisit".split(/s/,2,:kv,:skip-empty)
                            ok 39 - split(/s/,"thisisit",2,:p,:skip-empty)
                            ok 40 - "thisisit".split(/s/,2,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 198 - tested "thisisit" with /s/
                            1..41
                            ok 1 - split("|","|foo|bar|baz|zoo")
                            ok 2 - "|foo|bar|baz|zoo".split("|")
                            ok 3 - split("|","|foo|bar|baz|zoo",:v)
                            ok 4 - "|foo|bar|baz|zoo".split("|",:v)
                            ok 5 - split("|","|foo|bar|baz|zoo",:k)
                            ok 6 - "|foo|bar|baz|zoo".split("|",:k)
                            ok 7 - split("|","|foo|bar|baz|zoo",:kv)
                            ok 8 - "|foo|bar|baz|zoo".split("|",:kv)
                            ok 9 - split("|","|foo|bar|baz|zoo",:p)
                            ok 10 - "|foo|bar|baz|zoo".split("|",:p)
                            ok 11 - split("|","|foo|bar|baz|zoo",:skip-empty)
                            ok 12 - "|foo|bar|baz|zoo".split("|",:skip-empty)
                            ok 13 - split("|","|foo|bar|baz|zoo",:v,:skip-empty)
                            ok 14 - "|foo|bar|baz|zoo".split("|",:v,:skip-empty)
                            ok 15 - split("|","|foo|bar|baz|zoo",:k,:skip-empty)
                            ok 16 - "|foo|bar|baz|zoo".split("|",:k,:skip-empty)
                            ok 17 - split("|","|foo|bar|baz|zoo",:kv,:skip-empty)
                            ok 18 - "|foo|bar|baz|zoo".split("|",:kv,:skip-empty)
                            ok 19 - split("|","|foo|bar|baz|zoo",:p,:skip-empty)
                            ok 20 - "|foo|bar|baz|zoo".split("|",:p,:skip-empty)
                            ok 21 - split("|","|foo|bar|baz|zoo",3)
                            ok 22 - "|foo|bar|baz|zoo".split("|",3)
                            ok 23 - split("|","|foo|bar|baz|zoo",3,:v)
                            ok 24 - "|foo|bar|baz|zoo".split("|",3,:v)
                            ok 25 - split("|","|foo|bar|baz|zoo",3,:k)
                            ok 26 - "|foo|bar|baz|zoo".split("|",3,:k)
                            ok 27 - split("|","|foo|bar|baz|zoo",3,:kv)
                            ok 28 - "|foo|bar|baz|zoo".split("|",3,:kv)
                            ok 29 - split("|","|foo|bar|baz|zoo",3,:p)
                            ok 30 - "|foo|bar|baz|zoo".split("|",3,:p)
                            ok 31 - split("|","|foo|bar|baz|zoo",3,:split-empty)
                            ok 32 - "|foo|bar|baz|zoo".split("|",3,:split-empty)
                            ok 33 - split("|","|foo|bar|baz|zoo",3,:v,:skip-empty)
                            ok 34 - "|foo|bar|baz|zoo".split("|",3,:v,:skip-empty)
                            ok 35 - split("|","|foo|bar|baz|zoo",3,:k,:skip-empty)
                            ok 36 - "|foo|bar|baz|zoo".split("|",3,:k,:skip-empty)
                            ok 37 - split("|","|foo|bar|baz|zoo",3,:kv,:skip-empty)
                            ok 38 - "|foo|bar|baz|zoo".split("|",3,:kv,:skip-empty)
                            ok 39 - split("|","|foo|bar|baz|zoo",3,:p,:skip-empty)
                            ok 40 - "|foo|bar|baz|zoo".split("|",3,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 199 - tested "|foo|bar|baz|zoo" with "|"
                            1..41
                            ok 1 - split(/ \| /,"|foo|bar|baz|zoo")
                            ok 2 - "|foo|bar|baz|zoo".split(/ \| /)
                            ok 3 - split(/ \| /,"|foo|bar|baz|zoo",:v)
                            ok 4 - "|foo|bar|baz|zoo".split(/ \| /,:v)
                            ok 5 - split(/ \| /,"|foo|bar|baz|zoo",:k)
                            ok 6 - "|foo|bar|baz|zoo".split(/ \| /,:k)
                            ok 7 - split(/ \| /,"|foo|bar|baz|zoo",:kv)
                            ok 8 - "|foo|bar|baz|zoo".split(/ \| /,:kv)
                            ok 9 - split(/ \| /,"|foo|bar|baz|zoo",:p)
                            ok 10 - "|foo|bar|baz|zoo".split(/ \| /,:p)
                            ok 11 - split(/ \| /,"|foo|bar|baz|zoo",:skip-empty)
                            ok 12 - "|foo|bar|baz|zoo".split(/ \| /,:skip-empty)
                            ok 13 - split(/ \| /,"|foo|bar|baz|zoo",:v,:skip-empty)
                            ok 14 - "|foo|bar|baz|zoo".split(/ \| /,:v,:skip-empty)
                            ok 15 - split(/ \| /,"|foo|bar|baz|zoo",:k,:skip-empty)
                            ok 16 - "|foo|bar|baz|zoo".split(/ \| /,:k,:skip-empty)
                            ok 17 - split(/ \| /,"|foo|bar|baz|zoo",:kv,:skip-empty)
                            ok 18 - "|foo|bar|baz|zoo".split(/ \| /,:kv,:skip-empty)
                            ok 19 - split(/ \| /,"|foo|bar|baz|zoo",:p,:skip-empty)
                            ok 20 - "|foo|bar|baz|zoo".split(/ \| /,:p,:skip-empty)
                            ok 21 - split(/ \| /,"|foo|bar|baz|zoo",3)
                            ok 22 - "|foo|bar|baz|zoo".split(/ \| /,3)
                            ok 23 - split(/ \| /,"|foo|bar|baz|zoo",3,:v)
                            ok 24 - "|foo|bar|baz|zoo".split(/ \| /,3,:v)
                            ok 25 - split(/ \| /,"|foo|bar|baz|zoo",3,:k)
                            ok 26 - "|foo|bar|baz|zoo".split(/ \| /,3,:k)
                            ok 27 - split(/ \| /,"|foo|bar|baz|zoo",3,:kv)
                            ok 28 - "|foo|bar|baz|zoo".split(/ \| /,3,:kv)
                            ok 29 - split(/ \| /,"|foo|bar|baz|zoo",3,:p)
                            ok 30 - "|foo|bar|baz|zoo".split(/ \| /,3,:p)
                            ok 31 - split(/ \| /,"|foo|bar|baz|zoo",3,:split-empty)
                            ok 32 - "|foo|bar|baz|zoo".split(/ \| /,3,:split-empty)
                            ok 33 - split(/ \| /,"|foo|bar|baz|zoo",3,:v,:skip-empty)
                            ok 34 - "|foo|bar|baz|zoo".split(/ \| /,3,:v,:skip-empty)
                            ok 35 - split(/ \| /,"|foo|bar|baz|zoo",3,:k,:skip-empty)
                            ok 36 - "|foo|bar|baz|zoo".split(/ \| /,3,:k,:skip-empty)
                            ok 37 - split(/ \| /,"|foo|bar|baz|zoo",3,:kv,:skip-empty)
                            ok 38 - "|foo|bar|baz|zoo".split(/ \| /,3,:kv,:skip-empty)
                            ok 39 - split(/ \| /,"|foo|bar|baz|zoo",3,:p,:skip-empty)
                            ok 40 - "|foo|bar|baz|zoo".split(/ \| /,3,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 200 - tested "|foo|bar|baz|zoo" with / \| /
                            1..41
                            ok 1 - split("|","foo|bar|baz|zoo|")
                            ok 2 - "foo|bar|baz|zoo|".split("|")
                            ok 3 - split("|","foo|bar|baz|zoo|",:v)
                            ok 4 - "foo|bar|baz|zoo|".split("|",:v)
                            ok 5 - split("|","foo|bar|baz|zoo|",:k)
                            ok 6 - "foo|bar|baz|zoo|".split("|",:k)
                            ok 7 - split("|","foo|bar|baz|zoo|",:kv)
                            ok 8 - "foo|bar|baz|zoo|".split("|",:kv)
                            ok 9 - split("|","foo|bar|baz|zoo|",:p)
                            ok 10 - "foo|bar|baz|zoo|".split("|",:p)
                            ok 11 - split("|","foo|bar|baz|zoo|",:skip-empty)
                            ok 12 - "foo|bar|baz|zoo|".split("|",:skip-empty)
                            ok 13 - split("|","foo|bar|baz|zoo|",:v,:skip-empty)
                            ok 14 - "foo|bar|baz|zoo|".split("|",:v,:skip-empty)
                            ok 15 - split("|","foo|bar|baz|zoo|",:k,:skip-empty)
                            ok 16 - "foo|bar|baz|zoo|".split("|",:k,:skip-empty)
                            ok 17 - split("|","foo|bar|baz|zoo|",:kv,:skip-empty)
                            ok 18 - "foo|bar|baz|zoo|".split("|",:kv,:skip-empty)
                            ok 19 - split("|","foo|bar|baz|zoo|",:p,:skip-empty)
                            ok 20 - "foo|bar|baz|zoo|".split("|",:p,:skip-empty)
                            ok 21 - split("|","foo|bar|baz|zoo|",2)
                            ok 22 - "foo|bar|baz|zoo|".split("|",2)
                            ok 23 - split("|","foo|bar|baz|zoo|",2,:v)
                            ok 24 - "foo|bar|baz|zoo|".split("|",2,:v)
                            ok 25 - split("|","foo|bar|baz|zoo|",2,:k)
                            ok 26 - "foo|bar|baz|zoo|".split("|",2,:k)
                            ok 27 - split("|","foo|bar|baz|zoo|",2,:kv)
                            ok 28 - "foo|bar|baz|zoo|".split("|",2,:kv)
                            ok 29 - split("|","foo|bar|baz|zoo|",2,:p)
                            ok 30 - "foo|bar|baz|zoo|".split("|",2,:p)
                            ok 31 - split("|","foo|bar|baz|zoo|",2,:split-empty)
                            ok 32 - "foo|bar|baz|zoo|".split("|",2,:split-empty)
                            ok 33 - split("|","foo|bar|baz|zoo|",2,:v,:skip-empty)
                            ok 34 - "foo|bar|baz|zoo|".split("|",2,:v,:skip-empty)
                            ok 35 - split("|","foo|bar|baz|zoo|",2,:k,:skip-empty)
                            ok 36 - "foo|bar|baz|zoo|".split("|",2,:k,:skip-empty)
                            ok 37 - split("|","foo|bar|baz|zoo|",2,:kv,:skip-empty)
                            ok 38 - "foo|bar|baz|zoo|".split("|",2,:kv,:skip-empty)
                            ok 39 - split("|","foo|bar|baz|zoo|",2,:p,:skip-empty)
                            ok 40 - "foo|bar|baz|zoo|".split("|",2,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 201 - tested "foo|bar|baz|zoo|" with "|"
                            1..41
                            ok 1 - split(/ \| /,"foo|bar|baz|zoo|")
                            ok 2 - "foo|bar|baz|zoo|".split(/ \| /)
                            ok 3 - split(/ \| /,"foo|bar|baz|zoo|",:v)
                            ok 4 - "foo|bar|baz|zoo|".split(/ \| /,:v)
                            ok 5 - split(/ \| /,"foo|bar|baz|zoo|",:k)
                            ok 6 - "foo|bar|baz|zoo|".split(/ \| /,:k)
                            ok 7 - split(/ \| /,"foo|bar|baz|zoo|",:kv)
                            ok 8 - "foo|bar|baz|zoo|".split(/ \| /,:kv)
                            ok 9 - split(/ \| /,"foo|bar|baz|zoo|",:p)
                            ok 10 - "foo|bar|baz|zoo|".split(/ \| /,:p)
                            ok 11 - split(/ \| /,"foo|bar|baz|zoo|",:skip-empty)
                            ok 12 - "foo|bar|baz|zoo|".split(/ \| /,:skip-empty)
                            ok 13 - split(/ \| /,"foo|bar|baz|zoo|",:v,:skip-empty)
                            ok 14 - "foo|bar|baz|zoo|".split(/ \| /,:v,:skip-empty)
                            ok 15 - split(/ \| /,"foo|bar|baz|zoo|",:k,:skip-empty)
                            ok 16 - "foo|bar|baz|zoo|".split(/ \| /,:k,:skip-empty)
                            ok 17 - split(/ \| /,"foo|bar|baz|zoo|",:kv,:skip-empty)
                            ok 18 - "foo|bar|baz|zoo|".split(/ \| /,:kv,:skip-empty)
                            ok 19 - split(/ \| /,"foo|bar|baz|zoo|",:p,:skip-empty)
                            ok 20 - "foo|bar|baz|zoo|".split(/ \| /,:p,:skip-empty)
                            ok 21 - split(/ \| /,"foo|bar|baz|zoo|",2)
                            ok 22 - "foo|bar|baz|zoo|".split(/ \| /,2)
                            ok 23 - split(/ \| /,"foo|bar|baz|zoo|",2,:v)
                            ok 24 - "foo|bar|baz|zoo|".split(/ \| /,2,:v)
                            ok 25 - split(/ \| /,"foo|bar|baz|zoo|",2,:k)
                            ok 26 - "foo|bar|baz|zoo|".split(/ \| /,2,:k)
                            ok 27 - split(/ \| /,"foo|bar|baz|zoo|",2,:kv)
                            ok 28 - "foo|bar|baz|zoo|".split(/ \| /,2,:kv)
                            ok 29 - split(/ \| /,"foo|bar|baz|zoo|",2,:p)
                            ok 30 - "foo|bar|baz|zoo|".split(/ \| /,2,:p)
                            ok 31 - split(/ \| /,"foo|bar|baz|zoo|",2,:split-empty)
                            ok 32 - "foo|bar|baz|zoo|".split(/ \| /,2,:split-empty)
                            ok 33 - split(/ \| /,"foo|bar|baz|zoo|",2,:v,:skip-empty)
                            ok 34 - "foo|bar|baz|zoo|".split(/ \| /,2,:v,:skip-empty)
                            ok 35 - split(/ \| /,"foo|bar|baz|zoo|",2,:k,:skip-empty)
                            ok 36 - "foo|bar|baz|zoo|".split(/ \| /,2,:k,:skip-empty)
                            ok 37 - split(/ \| /,"foo|bar|baz|zoo|",2,:kv,:skip-empty)
                            ok 38 - "foo|bar|baz|zoo|".split(/ \| /,2,:kv,:skip-empty)
                            ok 39 - split(/ \| /,"foo|bar|baz|zoo|",2,:p,:skip-empty)
                            ok 40 - "foo|bar|baz|zoo|".split(/ \| /,2,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 202 - tested "foo|bar|baz|zoo|" with / \| /
                            1..41
                            ok 1 - split(rx:Perl5/\|/,"foo|bar|baz|zoo|")
                            ok 2 - "foo|bar|baz|zoo|".split(rx:Perl5/\|/)
                            ok 3 - split(rx:Perl5/\|/,"foo|bar|baz|zoo|",:v)
                            ok 4 - "foo|bar|baz|zoo|".split(rx:Perl5/\|/,:v)
                            ok 5 - split(rx:Perl5/\|/,"foo|bar|baz|zoo|",:k)
                            ok 6 - "foo|bar|baz|zoo|".split(rx:Perl5/\|/,:k)
                            ok 7 - split(rx:Perl5/\|/,"foo|bar|baz|zoo|",:kv)
                            ok 8 - "foo|bar|baz|zoo|".split(rx:Perl5/\|/,:kv)
                            ok 9 - split(rx:Perl5/\|/,"foo|bar|baz|zoo|",:p)
                            ok 10 - "foo|bar|baz|zoo|".split(rx:Perl5/\|/,:p)
                            ok 11 - split(rx:Perl5/\|/,"foo|bar|baz|zoo|",:skip-empty)
                            ok 12 - "foo|bar|baz|zoo|".split(rx:Perl5/\|/,:skip-empty)
                            ok 13 - split(rx:Perl5/\|/,"foo|bar|baz|zoo|",:v,:skip-empty)
                            ok 14 - "foo|bar|baz|zoo|".split(rx:Perl5/\|/,:v,:skip-empty)
                            ok 15 - split(rx:Perl5/\|/,"foo|bar|baz|zoo|",:k,:skip-empty)
                            ok 16 - "foo|bar|baz|zoo|".split(rx:Perl5/\|/,:k,:skip-empty)
                            ok 17 - split(rx:Perl5/\|/,"foo|bar|baz|zoo|",:kv,:skip-empty)
                            ok 18 - "foo|bar|baz|zoo|".split(rx:Perl5/\|/,:kv,:skip-empty)
                            ok 19 - split(rx:Perl5/\|/,"foo|bar|baz|zoo|",:p,:skip-empty)
                            ok 20 - "foo|bar|baz|zoo|".split(rx:Perl5/\|/,:p,:skip-empty)
                            ok 21 - split(rx:Perl5/\|/,"foo|bar|baz|zoo|",2)
                            ok 22 - "foo|bar|baz|zoo|".split(rx:Perl5/\|/,2)
                            ok 23 - split(rx:Perl5/\|/,"foo|bar|baz|zoo|",2,:v)
                            ok 24 - "foo|bar|baz|zoo|".split(rx:Perl5/\|/,2,:v)
                            ok 25 - split(rx:Perl5/\|/,"foo|bar|baz|zoo|",2,:k)
                            ok 26 - "foo|bar|baz|zoo|".split(rx:Perl5/\|/,2,:k)
                            ok 27 - split(rx:Perl5/\|/,"foo|bar|baz|zoo|",2,:kv)
                            ok 28 - "foo|bar|baz|zoo|".split(rx:Perl5/\|/,2,:kv)
                            ok 29 - split(rx:Perl5/\|/,"foo|bar|baz|zoo|",2,:p)
                            ok 30 - "foo|bar|baz|zoo|".split(rx:Perl5/\|/,2,:p)
                            ok 31 - split(rx:Perl5/\|/,"foo|bar|baz|zoo|",2,:split-empty)
                            ok 32 - "foo|bar|baz|zoo|".split(rx:Perl5/\|/,2,:split-empty)
                            ok 33 - split(rx:Perl5/\|/,"foo|bar|baz|zoo|",2,:v,:skip-empty)
                            ok 34 - "foo|bar|baz|zoo|".split(rx:Perl5/\|/,2,:v,:skip-empty)
                            ok 35 - split(rx:Perl5/\|/,"foo|bar|baz|zoo|",2,:k,:skip-empty)
                            ok 36 - "foo|bar|baz|zoo|".split(rx:Perl5/\|/,2,:k,:skip-empty)
                            ok 37 - split(rx:Perl5/\|/,"foo|bar|baz|zoo|",2,:kv,:skip-empty)
                            ok 38 - "foo|bar|baz|zoo|".split(rx:Perl5/\|/,2,:kv,:skip-empty)
                            ok 39 - split(rx:Perl5/\|/,"foo|bar|baz|zoo|",2,:p,:skip-empty)
                            ok 40 - "foo|bar|baz|zoo|".split(rx:Perl5/\|/,2,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 203 - tested "foo|bar|baz|zoo|" with rx:Perl5/\|/
                            1..41
                            ok 1 - split(", ","comma, separated, values")
                            ok 2 - "comma, separated, values".split(", ")
                            ok 3 - split(", ","comma, separated, values",:v)
                            ok 4 - "comma, separated, values".split(", ",:v)
                            ok 5 - split(", ","comma, separated, values",:k)
                            ok 6 - "comma, separated, values".split(", ",:k)
                            ok 7 - split(", ","comma, separated, values",:kv)
                            ok 8 - "comma, separated, values".split(", ",:kv)
                            ok 9 - split(", ","comma, separated, values",:p)
                            ok 10 - "comma, separated, values".split(", ",:p)
                            ok 11 - split(", ","comma, separated, values",:skip-empty)
                            ok 12 - "comma, separated, values".split(", ",:skip-empty)
                            ok 13 - split(", ","comma, separated, values",:v,:skip-empty)
                            ok 14 - "comma, separated, values".split(", ",:v,:skip-empty)
                            ok 15 - split(", ","comma, separated, values",:k,:skip-empty)
                            ok 16 - "comma, separated, values".split(", ",:k,:skip-empty)
                            ok 17 - split(", ","comma, separated, values",:kv,:skip-empty)
                            ok 18 - "comma, separated, values".split(", ",:kv,:skip-empty)
                            ok 19 - split(", ","comma, separated, values",:p,:skip-empty)
                            ok 20 - "comma, separated, values".split(", ",:p,:skip-empty)
                            ok 21 - split(", ","comma, separated, values",2)
                            ok 22 - "comma, separated, values".split(", ",2)
                            ok 23 - split(", ","comma, separated, values",2,:v)
                            ok 24 - "comma, separated, values".split(", ",2,:v)
                            ok 25 - split(", ","comma, separated, values",2,:k)
                            ok 26 - "comma, separated, values".split(", ",2,:k)
                            ok 27 - split(", ","comma, separated, values",2,:kv)
                            ok 28 - "comma, separated, values".split(", ",2,:kv)
                            ok 29 - split(", ","comma, separated, values",2,:p)
                            ok 30 - "comma, separated, values".split(", ",2,:p)
                            ok 31 - split(", ","comma, separated, values",2,:split-empty)
                            ok 32 - "comma, separated, values".split(", ",2,:split-empty)
                            ok 33 - split(", ","comma, separated, values",2,:v,:skip-empty)
                            ok 34 - "comma, separated, values".split(", ",2,:v,:skip-empty)
                            ok 35 - split(", ","comma, separated, values",2,:k,:skip-empty)
                            ok 36 - "comma, separated, values".split(", ",2,:k,:skip-empty)
                            ok 37 - split(", ","comma, separated, values",2,:kv,:skip-empty)
                            ok 38 - "comma, separated, values".split(", ",2,:kv,:skip-empty)
                            ok 39 - split(", ","comma, separated, values",2,:p,:skip-empty)
                            ok 40 - "comma, separated, values".split(", ",2,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 204 - tested "comma, separated, values" with ", "
                            1..41
                            ok 1 - split(/ ", " /,"comma, separated, values")
                            ok 2 - "comma, separated, values".split(/ ", " /)
                            ok 3 - split(/ ", " /,"comma, separated, values",:v)
                            ok 4 - "comma, separated, values".split(/ ", " /,:v)
                            ok 5 - split(/ ", " /,"comma, separated, values",:k)
                            ok 6 - "comma, separated, values".split(/ ", " /,:k)
                            ok 7 - split(/ ", " /,"comma, separated, values",:kv)
                            ok 8 - "comma, separated, values".split(/ ", " /,:kv)
                            ok 9 - split(/ ", " /,"comma, separated, values",:p)
                            ok 10 - "comma, separated, values".split(/ ", " /,:p)
                            ok 11 - split(/ ", " /,"comma, separated, values",:skip-empty)
                            ok 12 - "comma, separated, values".split(/ ", " /,:skip-empty)
                            ok 13 - split(/ ", " /,"comma, separated, values",:v,:skip-empty)
                            ok 14 - "comma, separated, values".split(/ ", " /,:v,:skip-empty)
                            ok 15 - split(/ ", " /,"comma, separated, values",:k,:skip-empty)
                            ok 16 - "comma, separated, values".split(/ ", " /,:k,:skip-empty)
                            ok 17 - split(/ ", " /,"comma, separated, values",:kv,:skip-empty)
                            ok 18 - "comma, separated, values".split(/ ", " /,:kv,:skip-empty)
                            ok 19 - split(/ ", " /,"comma, separated, values",:p,:skip-empty)
                            ok 20 - "comma, separated, values".split(/ ", " /,:p,:skip-empty)
                            ok 21 - split(/ ", " /,"comma, separated, values",2)
                            ok 22 - "comma, separated, values".split(/ ", " /,2)
                            ok 23 - split(/ ", " /,"comma, separated, values",2,:v)
                            ok 24 - "comma, separated, values".split(/ ", " /,2,:v)
                            ok 25 - split(/ ", " /,"comma, separated, values",2,:k)
                            ok 26 - "comma, separated, values".split(/ ", " /,2,:k)
                            ok 27 - split(/ ", " /,"comma, separated, values",2,:kv)
                            ok 28 - "comma, separated, values".split(/ ", " /,2,:kv)
                            ok 29 - split(/ ", " /,"comma, separated, values",2,:p)
                            ok 30 - "comma, separated, values".split(/ ", " /,2,:p)
                            ok 31 - split(/ ", " /,"comma, separated, values",2,:split-empty)
                            ok 32 - "comma, separated, values".split(/ ", " /,2,:split-empty)
                            ok 33 - split(/ ", " /,"comma, separated, values",2,:v,:skip-empty)
                            ok 34 - "comma, separated, values".split(/ ", " /,2,:v,:skip-empty)
                            ok 35 - split(/ ", " /,"comma, separated, values",2,:k,:skip-empty)
                            ok 36 - "comma, separated, values".split(/ ", " /,2,:k,:skip-empty)
                            ok 37 - split(/ ", " /,"comma, separated, values",2,:kv,:skip-empty)
                            ok 38 - "comma, separated, values".split(/ ", " /,2,:kv,:skip-empty)
                            ok 39 - split(/ ", " /,"comma, separated, values",2,:p,:skip-empty)
                            ok 40 - "comma, separated, values".split(/ ", " /,2,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 205 - tested "comma, separated, values" with / ", " /
                            1..41
                            ok 1 - split(/ "," \s /,"comma, separated, values")
                            ok 2 - "comma, separated, values".split(/ "," \s /)
                            ok 3 - split(/ "," \s /,"comma, separated, values",:v)
                            ok 4 - "comma, separated, values".split(/ "," \s /,:v)
                            ok 5 - split(/ "," \s /,"comma, separated, values",:k)
                            ok 6 - "comma, separated, values".split(/ "," \s /,:k)
                            ok 7 - split(/ "," \s /,"comma, separated, values",:kv)
                            ok 8 - "comma, separated, values".split(/ "," \s /,:kv)
                            ok 9 - split(/ "," \s /,"comma, separated, values",:p)
                            ok 10 - "comma, separated, values".split(/ "," \s /,:p)
                            ok 11 - split(/ "," \s /,"comma, separated, values",:skip-empty)
                            ok 12 - "comma, separated, values".split(/ "," \s /,:skip-empty)
                            ok 13 - split(/ "," \s /,"comma, separated, values",:v,:skip-empty)
                            ok 14 - "comma, separated, values".split(/ "," \s /,:v,:skip-empty)
                            ok 15 - split(/ "," \s /,"comma, separated, values",:k,:skip-empty)
                            ok 16 - "comma, separated, values".split(/ "," \s /,:k,:skip-empty)
                            ok 17 - split(/ "," \s /,"comma, separated, values",:kv,:skip-empty)
                            ok 18 - "comma, separated, values".split(/ "," \s /,:kv,:skip-empty)
                            ok 19 - split(/ "," \s /,"comma, separated, values",:p,:skip-empty)
                            ok 20 - "comma, separated, values".split(/ "," \s /,:p,:skip-empty)
                            ok 21 - split(/ "," \s /,"comma, separated, values",2)
                            ok 22 - "comma, separated, values".split(/ "," \s /,2)
                            ok 23 - split(/ "," \s /,"comma, separated, values",2,:v)
                            ok 24 - "comma, separated, values".split(/ "," \s /,2,:v)
                            ok 25 - split(/ "," \s /,"comma, separated, values",2,:k)
                            ok 26 - "comma, separated, values".split(/ "," \s /,2,:k)
                            ok 27 - split(/ "," \s /,"comma, separated, values",2,:kv)
                            ok 28 - "comma, separated, values".split(/ "," \s /,2,:kv)
                            ok 29 - split(/ "," \s /,"comma, separated, values",2,:p)
                            ok 30 - "comma, separated, values".split(/ "," \s /,2,:p)
                            ok 31 - split(/ "," \s /,"comma, separated, values",2,:split-empty)
                            ok 32 - "comma, separated, values".split(/ "," \s /,2,:split-empty)
                            ok 33 - split(/ "," \s /,"comma, separated, values",2,:v,:skip-empty)
                            ok 34 - "comma, separated, values".split(/ "," \s /,2,:v,:skip-empty)
                            ok 35 - split(/ "," \s /,"comma, separated, values",2,:k,:skip-empty)
                            ok 36 - "comma, separated, values".split(/ "," \s /,2,:k,:skip-empty)
                            ok 37 - split(/ "," \s /,"comma, separated, values",2,:kv,:skip-empty)
                            ok 38 - "comma, separated, values".split(/ "," \s /,2,:kv,:skip-empty)
                            ok 39 - split(/ "," \s /,"comma, separated, values",2,:p,:skip-empty)
                            ok 40 - "comma, separated, values".split(/ "," \s /,2,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 206 - tested "comma, separated, values" with / "," \s /
                            1..41
                            ok 1 - split(/ "," \s+ /,"comma, separated, values")
                            ok 2 - "comma, separated, values".split(/ "," \s+ /)
                            ok 3 - split(/ "," \s+ /,"comma, separated, values",:v)
                            ok 4 - "comma, separated, values".split(/ "," \s+ /,:v)
                            ok 5 - split(/ "," \s+ /,"comma, separated, values",:k)
                            ok 6 - "comma, separated, values".split(/ "," \s+ /,:k)
                            ok 7 - split(/ "," \s+ /,"comma, separated, values",:kv)
                            ok 8 - "comma, separated, values".split(/ "," \s+ /,:kv)
                            ok 9 - split(/ "," \s+ /,"comma, separated, values",:p)
                            ok 10 - "comma, separated, values".split(/ "," \s+ /,:p)
                            ok 11 - split(/ "," \s+ /,"comma, separated, values",:skip-empty)
                            ok 12 - "comma, separated, values".split(/ "," \s+ /,:skip-empty)
                            ok 13 - split(/ "," \s+ /,"comma, separated, values",:v,:skip-empty)
                            ok 14 - "comma, separated, values".split(/ "," \s+ /,:v,:skip-empty)
                            ok 15 - split(/ "," \s+ /,"comma, separated, values",:k,:skip-empty)
                            ok 16 - "comma, separated, values".split(/ "," \s+ /,:k,:skip-empty)
                            ok 17 - split(/ "," \s+ /,"comma, separated, values",:kv,:skip-empty)
                            ok 18 - "comma, separated, values".split(/ "," \s+ /,:kv,:skip-empty)
                            ok 19 - split(/ "," \s+ /,"comma, separated, values",:p,:skip-empty)
                            ok 20 - "comma, separated, values".split(/ "," \s+ /,:p,:skip-empty)
                            ok 21 - split(/ "," \s+ /,"comma, separated, values",2)
                            ok 22 - "comma, separated, values".split(/ "," \s+ /,2)
                            ok 23 - split(/ "," \s+ /,"comma, separated, values",2,:v)
                            ok 24 - "comma, separated, values".split(/ "," \s+ /,2,:v)
                            ok 25 - split(/ "," \s+ /,"comma, separated, values",2,:k)
                            ok 26 - "comma, separated, values".split(/ "," \s+ /,2,:k)
                            ok 27 - split(/ "," \s+ /,"comma, separated, values",2,:kv)
                            ok 28 - "comma, separated, values".split(/ "," \s+ /,2,:kv)
                            ok 29 - split(/ "," \s+ /,"comma, separated, values",2,:p)
                            ok 30 - "comma, separated, values".split(/ "," \s+ /,2,:p)
                            ok 31 - split(/ "," \s+ /,"comma, separated, values",2,:split-empty)
                            ok 32 - "comma, separated, values".split(/ "," \s+ /,2,:split-empty)
                            ok 33 - split(/ "," \s+ /,"comma, separated, values",2,:v,:skip-empty)
                            ok 34 - "comma, separated, values".split(/ "," \s+ /,2,:v,:skip-empty)
                            ok 35 - split(/ "," \s+ /,"comma, separated, values",2,:k,:skip-empty)
                            ok 36 - "comma, separated, values".split(/ "," \s+ /,2,:k,:skip-empty)
                            ok 37 - split(/ "," \s+ /,"comma, separated, values",2,:kv,:skip-empty)
                            ok 38 - "comma, separated, values".split(/ "," \s+ /,2,:kv,:skip-empty)
                            ok 39 - split(/ "," \s+ /,"comma, separated, values",2,:p,:skip-empty)
                            ok 40 - "comma, separated, values".split(/ "," \s+ /,2,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 207 - tested "comma, separated, values" with / "," \s+ /
                            1..41
                            ok 1 - split(rx:Perl5/, /,"comma, separated, values")
                            ok 2 - "comma, separated, values".split(rx:Perl5/, /)
                            ok 3 - split(rx:Perl5/, /,"comma, separated, values",:v)
                            ok 4 - "comma, separated, values".split(rx:Perl5/, /,:v)
                            ok 5 - split(rx:Perl5/, /,"comma, separated, values",:k)
                            ok 6 - "comma, separated, values".split(rx:Perl5/, /,:k)
                            ok 7 - split(rx:Perl5/, /,"comma, separated, values",:kv)
                            ok 8 - "comma, separated, values".split(rx:Perl5/, /,:kv)
                            ok 9 - split(rx:Perl5/, /,"comma, separated, values",:p)
                            ok 10 - "comma, separated, values".split(rx:Perl5/, /,:p)
                            ok 11 - split(rx:Perl5/, /,"comma, separated, values",:skip-empty)
                            ok 12 - "comma, separated, values".split(rx:Perl5/, /,:skip-empty)
                            ok 13 - split(rx:Perl5/, /,"comma, separated, values",:v,:skip-empty)
                            ok 14 - "comma, separated, values".split(rx:Perl5/, /,:v,:skip-empty)
                            ok 15 - split(rx:Perl5/, /,"comma, separated, values",:k,:skip-empty)
                            ok 16 - "comma, separated, values".split(rx:Perl5/, /,:k,:skip-empty)
                            ok 17 - split(rx:Perl5/, /,"comma, separated, values",:kv,:skip-empty)
                            ok 18 - "comma, separated, values".split(rx:Perl5/, /,:kv,:skip-empty)
                            ok 19 - split(rx:Perl5/, /,"comma, separated, values",:p,:skip-empty)
                            ok 20 - "comma, separated, values".split(rx:Perl5/, /,:p,:skip-empty)
                            ok 21 - split(rx:Perl5/, /,"comma, separated, values",2)
                            ok 22 - "comma, separated, values".split(rx:Perl5/, /,2)
                            ok 23 - split(rx:Perl5/, /,"comma, separated, values",2,:v)
                            ok 24 - "comma, separated, values".split(rx:Perl5/, /,2,:v)
                            ok 25 - split(rx:Perl5/, /,"comma, separated, values",2,:k)
                            ok 26 - "comma, separated, values".split(rx:Perl5/, /,2,:k)
                            ok 27 - split(rx:Perl5/, /,"comma, separated, values",2,:kv)
                            ok 28 - "comma, separated, values".split(rx:Perl5/, /,2,:kv)
                            ok 29 - split(rx:Perl5/, /,"comma, separated, values",2,:p)
                            ok 30 - "comma, separated, values".split(rx:Perl5/, /,2,:p)
                            ok 31 - split(rx:Perl5/, /,"comma, separated, values",2,:split-empty)
                            ok 32 - "comma, separated, values".split(rx:Perl5/, /,2,:split-empty)
                            ok 33 - split(rx:Perl5/, /,"comma, separated, values",2,:v,:skip-empty)
                            ok 34 - "comma, separated, values".split(rx:Perl5/, /,2,:v,:skip-empty)
                            ok 35 - split(rx:Perl5/, /,"comma, separated, values",2,:k,:skip-empty)
                            ok 36 - "comma, separated, values".split(rx:Perl5/, /,2,:k,:skip-empty)
                            ok 37 - split(rx:Perl5/, /,"comma, separated, values",2,:kv,:skip-empty)
                            ok 38 - "comma, separated, values".split(rx:Perl5/, /,2,:kv,:skip-empty)
                            ok 39 - split(rx:Perl5/, /,"comma, separated, values",2,:p,:skip-empty)
                            ok 40 - "comma, separated, values".split(rx:Perl5/, /,2,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 208 - tested "comma, separated, values" with rx:Perl5/, /
                            1..41
                            ok 1 - split(rx:Perl5/,\s/,"comma, separated, values")
                            ok 2 - "comma, separated, values".split(rx:Perl5/,\s/)
                            ok 3 - split(rx:Perl5/,\s/,"comma, separated, values",:v)
                            ok 4 - "comma, separated, values".split(rx:Perl5/,\s/,:v)
                            ok 5 - split(rx:Perl5/,\s/,"comma, separated, values",:k)
                            ok 6 - "comma, separated, values".split(rx:Perl5/,\s/,:k)
                            ok 7 - split(rx:Perl5/,\s/,"comma, separated, values",:kv)
                            ok 8 - "comma, separated, values".split(rx:Perl5/,\s/,:kv)
                            ok 9 - split(rx:Perl5/,\s/,"comma, separated, values",:p)
                            ok 10 - "comma, separated, values".split(rx:Perl5/,\s/,:p)
                            ok 11 - split(rx:Perl5/,\s/,"comma, separated, values",:skip-empty)
                            ok 12 - "comma, separated, values".split(rx:Perl5/,\s/,:skip-empty)
                            ok 13 - split(rx:Perl5/,\s/,"comma, separated, values",:v,:skip-empty)
                            ok 14 - "comma, separated, values".split(rx:Perl5/,\s/,:v,:skip-empty)
                            ok 15 - split(rx:Perl5/,\s/,"comma, separated, values",:k,:skip-empty)
                            ok 16 - "comma, separated, values".split(rx:Perl5/,\s/,:k,:skip-empty)
                            ok 17 - split(rx:Perl5/,\s/,"comma, separated, values",:kv,:skip-empty)
                            ok 18 - "comma, separated, values".split(rx:Perl5/,\s/,:kv,:skip-empty)
                            ok 19 - split(rx:Perl5/,\s/,"comma, separated, values",:p,:skip-empty)
                            ok 20 - "comma, separated, values".split(rx:Perl5/,\s/,:p,:skip-empty)
                            ok 21 - split(rx:Perl5/,\s/,"comma, separated, values",2)
                            ok 22 - "comma, separated, values".split(rx:Perl5/,\s/,2)
                            ok 23 - split(rx:Perl5/,\s/,"comma, separated, values",2,:v)
                            ok 24 - "comma, separated, values".split(rx:Perl5/,\s/,2,:v)
                            ok 25 - split(rx:Perl5/,\s/,"comma, separated, values",2,:k)
                            ok 26 - "comma, separated, values".split(rx:Perl5/,\s/,2,:k)
                            ok 27 - split(rx:Perl5/,\s/,"comma, separated, values",2,:kv)
                            ok 28 - "comma, separated, values".split(rx:Perl5/,\s/,2,:kv)
                            ok 29 - split(rx:Perl5/,\s/,"comma, separated, values",2,:p)
                            ok 30 - "comma, separated, values".split(rx:Perl5/,\s/,2,:p)
                            ok 31 - split(rx:Perl5/,\s/,"comma, separated, values",2,:split-empty)
                            ok 32 - "comma, separated, values".split(rx:Perl5/,\s/,2,:split-empty)
                            ok 33 - split(rx:Perl5/,\s/,"comma, separated, values",2,:v,:skip-empty)
                            ok 34 - "comma, separated, values".split(rx:Perl5/,\s/,2,:v,:skip-empty)
                            ok 35 - split(rx:Perl5/,\s/,"comma, separated, values",2,:k,:skip-empty)
                            ok 36 - "comma, separated, values".split(rx:Perl5/,\s/,2,:k,:skip-empty)
                            ok 37 - split(rx:Perl5/,\s/,"comma, separated, values",2,:kv,:skip-empty)
                            ok 38 - "comma, separated, values".split(rx:Perl5/,\s/,2,:kv,:skip-empty)
                            ok 39 - split(rx:Perl5/,\s/,"comma, separated, values",2,:p,:skip-empty)
                            ok 40 - "comma, separated, values".split(rx:Perl5/,\s/,2,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 209 - tested "comma, separated, values" with rx:Perl5/,\s/
                            1..41
                            ok 1 - split(rx:Perl5/,\s+/,"comma, separated, values")
                            ok 2 - "comma, separated, values".split(rx:Perl5/,\s+/)
                            ok 3 - split(rx:Perl5/,\s+/,"comma, separated, values",:v)
                            ok 4 - "comma, separated, values".split(rx:Perl5/,\s+/,:v)
                            ok 5 - split(rx:Perl5/,\s+/,"comma, separated, values",:k)
                            ok 6 - "comma, separated, values".split(rx:Perl5/,\s+/,:k)
                            ok 7 - split(rx:Perl5/,\s+/,"comma, separated, values",:kv)
                            ok 8 - "comma, separated, values".split(rx:Perl5/,\s+/,:kv)
                            ok 9 - split(rx:Perl5/,\s+/,"comma, separated, values",:p)
                            ok 10 - "comma, separated, values".split(rx:Perl5/,\s+/,:p)
                            ok 11 - split(rx:Perl5/,\s+/,"comma, separated, values",:skip-empty)
                            ok 12 - "comma, separated, values".split(rx:Perl5/,\s+/,:skip-empty)
                            ok 13 - split(rx:Perl5/,\s+/,"comma, separated, values",:v,:skip-empty)
                            ok 14 - "comma, separated, values".split(rx:Perl5/,\s+/,:v,:skip-empty)
                            ok 15 - split(rx:Perl5/,\s+/,"comma, separated, values",:k,:skip-empty)
                            ok 16 - "comma, separated, values".split(rx:Perl5/,\s+/,:k,:skip-empty)
                            ok 17 - split(rx:Perl5/,\s+/,"comma, separated, values",:kv,:skip-empty)
                            ok 18 - "comma, separated, values".split(rx:Perl5/,\s+/,:kv,:skip-empty)
                            ok 19 - split(rx:Perl5/,\s+/,"comma, separated, values",:p,:skip-empty)
                            ok 20 - "comma, separated, values".split(rx:Perl5/,\s+/,:p,:skip-empty)
                            ok 21 - split(rx:Perl5/,\s+/,"comma, separated, values",2)
                            ok 22 - "comma, separated, values".split(rx:Perl5/,\s+/,2)
                            ok 23 - split(rx:Perl5/,\s+/,"comma, separated, values",2,:v)
                            ok 24 - "comma, separated, values".split(rx:Perl5/,\s+/,2,:v)
                            ok 25 - split(rx:Perl5/,\s+/,"comma, separated, values",2,:k)
                            ok 26 - "comma, separated, values".split(rx:Perl5/,\s+/,2,:k)
                            ok 27 - split(rx:Perl5/,\s+/,"comma, separated, values",2,:kv)
                            ok 28 - "comma, separated, values".split(rx:Perl5/,\s+/,2,:kv)
                            ok 29 - split(rx:Perl5/,\s+/,"comma, separated, values",2,:p)
                            ok 30 - "comma, separated, values".split(rx:Perl5/,\s+/,2,:p)
                            ok 31 - split(rx:Perl5/,\s+/,"comma, separated, values",2,:split-empty)
                            ok 32 - "comma, separated, values".split(rx:Perl5/,\s+/,2,:split-empty)
                            ok 33 - split(rx:Perl5/,\s+/,"comma, separated, values",2,:v,:skip-empty)
                            ok 34 - "comma, separated, values".split(rx:Perl5/,\s+/,2,:v,:skip-empty)
                            ok 35 - split(rx:Perl5/,\s+/,"comma, separated, values",2,:k,:skip-empty)
                            ok 36 - "comma, separated, values".split(rx:Perl5/,\s+/,2,:k,:skip-empty)
                            ok 37 - split(rx:Perl5/,\s+/,"comma, separated, values",2,:kv,:skip-empty)
                            ok 38 - "comma, separated, values".split(rx:Perl5/,\s+/,2,:kv,:skip-empty)
                            ok 39 - split(rx:Perl5/,\s+/,"comma, separated, values",2,:p,:skip-empty)
                            ok 40 - "comma, separated, values".split(rx:Perl5/,\s+/,2,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 210 - tested "comma, separated, values" with rx:Perl5/,\s+/
                            1..41
                            ok 1 - split("a","")
                            ok 2 - "".split("a")
                            ok 3 - split("a","",:v)
                            ok 4 - "".split("a",:v)
                            ok 5 - split("a","",:k)
                            ok 6 - "".split("a",:k)
                            ok 7 - split("a","",:kv)
                            ok 8 - "".split("a",:kv)
                            ok 9 - split("a","",:p)
                            ok 10 - "".split("a",:p)
                            ok 11 - split("a","",:skip-empty)
                            ok 12 - "".split("a",:skip-empty)
                            ok 13 - split("a","",:v,:skip-empty)
                            ok 14 - "".split("a",:v,:skip-empty)
                            ok 15 - split("a","",:k,:skip-empty)
                            ok 16 - "".split("a",:k,:skip-empty)
                            ok 17 - split("a","",:kv,:skip-empty)
                            ok 18 - "".split("a",:kv,:skip-empty)
                            ok 19 - split("a","",:p,:skip-empty)
                            ok 20 - "".split("a",:p,:skip-empty)
                            ok 21 - split("a","",2)
                            ok 22 - "".split("a",2)
                            ok 23 - split("a","",2,:v)
                            ok 24 - "".split("a",2,:v)
                            ok 25 - split("a","",2,:k)
                            ok 26 - "".split("a",2,:k)
                            ok 27 - split("a","",2,:kv)
                            ok 28 - "".split("a",2,:kv)
                            ok 29 - split("a","",2,:p)
                            ok 30 - "".split("a",2,:p)
                            ok 31 - split("a","",2,:split-empty)
                            ok 32 - "".split("a",2,:split-empty)
                            ok 33 - split("a","",2,:v,:skip-empty)
                            ok 34 - "".split("a",2,:v,:skip-empty)
                            ok 35 - split("a","",2,:k,:skip-empty)
                            ok 36 - "".split("a",2,:k,:skip-empty)
                            ok 37 - split("a","",2,:kv,:skip-empty)
                            ok 38 - "".split("a",2,:kv,:skip-empty)
                            ok 39 - split("a","",2,:p,:skip-empty)
                            ok 40 - "".split("a",2,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 211 - tested "" with "a"
                            1..41
                            ok 1 - split(/a/,"")
                            ok 2 - "".split(/a/)
                            ok 3 - split(/a/,"",:v)
                            ok 4 - "".split(/a/,:v)
                            ok 5 - split(/a/,"",:k)
                            ok 6 - "".split(/a/,:k)
                            ok 7 - split(/a/,"",:kv)
                            ok 8 - "".split(/a/,:kv)
                            ok 9 - split(/a/,"",:p)
                            ok 10 - "".split(/a/,:p)
                            ok 11 - split(/a/,"",:skip-empty)
                            ok 12 - "".split(/a/,:skip-empty)
                            ok 13 - split(/a/,"",:v,:skip-empty)
                            ok 14 - "".split(/a/,:v,:skip-empty)
                            ok 15 - split(/a/,"",:k,:skip-empty)
                            ok 16 - "".split(/a/,:k,:skip-empty)
                            ok 17 - split(/a/,"",:kv,:skip-empty)
                            ok 18 - "".split(/a/,:kv,:skip-empty)
                            ok 19 - split(/a/,"",:p,:skip-empty)
                            ok 20 - "".split(/a/,:p,:skip-empty)
                            ok 21 - split(/a/,"",2)
                            ok 22 - "".split(/a/,2)
                            ok 23 - split(/a/,"",2,:v)
                            ok 24 - "".split(/a/,2,:v)
                            ok 25 - split(/a/,"",2,:k)
                            ok 26 - "".split(/a/,2,:k)
                            ok 27 - split(/a/,"",2,:kv)
                            ok 28 - "".split(/a/,2,:kv)
                            ok 29 - split(/a/,"",2,:p)
                            ok 30 - "".split(/a/,2,:p)
                            ok 31 - split(/a/,"",2,:split-empty)
                            ok 32 - "".split(/a/,2,:split-empty)
                            ok 33 - split(/a/,"",2,:v,:skip-empty)
                            ok 34 - "".split(/a/,2,:v,:skip-empty)
                            ok 35 - split(/a/,"",2,:k,:skip-empty)
                            ok 36 - "".split(/a/,2,:k,:skip-empty)
                            ok 37 - split(/a/,"",2,:kv,:skip-empty)
                            ok 38 - "".split(/a/,2,:kv,:skip-empty)
                            ok 39 - split(/a/,"",2,:p,:skip-empty)
                            ok 40 - "".split(/a/,2,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 212 - tested "" with /a/
                            1..41
                            ok 1 - split("ab","")
                            ok 2 - "".split("ab")
                            ok 3 - split("ab","",:v)
                            ok 4 - "".split("ab",:v)
                            ok 5 - split("ab","",:k)
                            ok 6 - "".split("ab",:k)
                            ok 7 - split("ab","",:kv)
                            ok 8 - "".split("ab",:kv)
                            ok 9 - split("ab","",:p)
                            ok 10 - "".split("ab",:p)
                            ok 11 - split("ab","",:skip-empty)
                            ok 12 - "".split("ab",:skip-empty)
                            ok 13 - split("ab","",:v,:skip-empty)
                            ok 14 - "".split("ab",:v,:skip-empty)
                            ok 15 - split("ab","",:k,:skip-empty)
                            ok 16 - "".split("ab",:k,:skip-empty)
                            ok 17 - split("ab","",:kv,:skip-empty)
                            ok 18 - "".split("ab",:kv,:skip-empty)
                            ok 19 - split("ab","",:p,:skip-empty)
                            ok 20 - "".split("ab",:p,:skip-empty)
                            ok 21 - split("ab","",2)
                            ok 22 - "".split("ab",2)
                            ok 23 - split("ab","",2,:v)
                            ok 24 - "".split("ab",2,:v)
                            ok 25 - split("ab","",2,:k)
                            ok 26 - "".split("ab",2,:k)
                            ok 27 - split("ab","",2,:kv)
                            ok 28 - "".split("ab",2,:kv)
                            ok 29 - split("ab","",2,:p)
                            ok 30 - "".split("ab",2,:p)
                            ok 31 - split("ab","",2,:split-empty)
                            ok 32 - "".split("ab",2,:split-empty)
                            ok 33 - split("ab","",2,:v,:skip-empty)
                            ok 34 - "".split("ab",2,:v,:skip-empty)
                            ok 35 - split("ab","",2,:k,:skip-empty)
                            ok 36 - "".split("ab",2,:k,:skip-empty)
                            ok 37 - split("ab","",2,:kv,:skip-empty)
                            ok 38 - "".split("ab",2,:kv,:skip-empty)
                            ok 39 - split("ab","",2,:p,:skip-empty)
                            ok 40 - "".split("ab",2,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 213 - tested "" with "ab"
                            1..41
                            ok 1 - split(/ab/,"")
                            ok 2 - "".split(/ab/)
                            ok 3 - split(/ab/,"",:v)
                            ok 4 - "".split(/ab/,:v)
                            ok 5 - split(/ab/,"",:k)
                            ok 6 - "".split(/ab/,:k)
                            ok 7 - split(/ab/,"",:kv)
                            ok 8 - "".split(/ab/,:kv)
                            ok 9 - split(/ab/,"",:p)
                            ok 10 - "".split(/ab/,:p)
                            ok 11 - split(/ab/,"",:skip-empty)
                            ok 12 - "".split(/ab/,:skip-empty)
                            ok 13 - split(/ab/,"",:v,:skip-empty)
                            ok 14 - "".split(/ab/,:v,:skip-empty)
                            ok 15 - split(/ab/,"",:k,:skip-empty)
                            ok 16 - "".split(/ab/,:k,:skip-empty)
                            ok 17 - split(/ab/,"",:kv,:skip-empty)
                            ok 18 - "".split(/ab/,:kv,:skip-empty)
                            ok 19 - split(/ab/,"",:p,:skip-empty)
                            ok 20 - "".split(/ab/,:p,:skip-empty)
                            ok 21 - split(/ab/,"",2)
                            ok 22 - "".split(/ab/,2)
                            ok 23 - split(/ab/,"",2,:v)
                            ok 24 - "".split(/ab/,2,:v)
                            ok 25 - split(/ab/,"",2,:k)
                            ok 26 - "".split(/ab/,2,:k)
                            ok 27 - split(/ab/,"",2,:kv)
                            ok 28 - "".split(/ab/,2,:kv)
                            ok 29 - split(/ab/,"",2,:p)
                            ok 30 - "".split(/ab/,2,:p)
                            ok 31 - split(/ab/,"",2,:split-empty)
                            ok 32 - "".split(/ab/,2,:split-empty)
                            ok 33 - split(/ab/,"",2,:v,:skip-empty)
                            ok 34 - "".split(/ab/,2,:v,:skip-empty)
                            ok 35 - split(/ab/,"",2,:k,:skip-empty)
                            ok 36 - "".split(/ab/,2,:k,:skip-empty)
                            ok 37 - split(/ab/,"",2,:kv,:skip-empty)
                            ok 38 - "".split(/ab/,2,:kv,:skip-empty)
                            ok 39 - split(/ab/,"",2,:p,:skip-empty)
                            ok 40 - "".split(/ab/,2,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 214 - tested "" with /ab/
                            1..41
                            ok 1 - split($("a", "b"),"")
                            ok 2 - "".split($("a", "b"))
                            ok 3 - split($("a", "b"),"",:v)
                            ok 4 - "".split($("a", "b"),:v)
                            ok 5 - split($("a", "b"),"",:k)
                            ok 6 - "".split($("a", "b"),:k)
                            ok 7 - split($("a", "b"),"",:kv)
                            ok 8 - "".split($("a", "b"),:kv)
                            ok 9 - split($("a", "b"),"",:p)
                            ok 10 - "".split($("a", "b"),:p)
                            ok 11 - split($("a", "b"),"",:skip-empty)
                            ok 12 - "".split($("a", "b"),:skip-empty)
                            ok 13 - split($("a", "b"),"",:v,:skip-empty)
                            ok 14 - "".split($("a", "b"),:v,:skip-empty)
                            ok 15 - split($("a", "b"),"",:k,:skip-empty)
                            ok 16 - "".split($("a", "b"),:k,:skip-empty)
                            ok 17 - split($("a", "b"),"",:kv,:skip-empty)
                            ok 18 - "".split($("a", "b"),:kv,:skip-empty)
                            ok 19 - split($("a", "b"),"",:p,:skip-empty)
                            ok 20 - "".split($("a", "b"),:p,:skip-empty)
                            ok 21 - split($("a", "b"),"",2)
                            ok 22 - "".split($("a", "b"),2)
                            ok 23 - split($("a", "b"),"",2,:v)
                            ok 24 - "".split($("a", "b"),2,:v)
                            ok 25 - split($("a", "b"),"",2,:k)
                            ok 26 - "".split($("a", "b"),2,:k)
                            ok 27 - split($("a", "b"),"",2,:kv)
                            ok 28 - "".split($("a", "b"),2,:kv)
                            ok 29 - split($("a", "b"),"",2,:p)
                            ok 30 - "".split($("a", "b"),2,:p)
                            ok 31 - split($("a", "b"),"",2,:split-empty)
                            ok 32 - "".split($("a", "b"),2,:split-empty)
                            ok 33 - split($("a", "b"),"",2,:v,:skip-empty)
                            ok 34 - "".split($("a", "b"),2,:v,:skip-empty)
                            ok 35 - split($("a", "b"),"",2,:k,:skip-empty)
                            ok 36 - "".split($("a", "b"),2,:k,:skip-empty)
                            ok 37 - split($("a", "b"),"",2,:kv,:skip-empty)
                            ok 38 - "".split($("a", "b"),2,:kv,:skip-empty)
                            ok 39 - split($("a", "b"),"",2,:p,:skip-empty)
                            ok 40 - "".split($("a", "b"),2,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 215 - tested "" with $("a", "b")
                            1..41
                            ok 1 - split(/a|b/,"")
                            ok 2 - "".split(/a|b/)
                            ok 3 - split(/a|b/,"",:v)
                            ok 4 - "".split(/a|b/,:v)
                            ok 5 - split(/a|b/,"",:k)
                            ok 6 - "".split(/a|b/,:k)
                            ok 7 - split(/a|b/,"",:kv)
                            ok 8 - "".split(/a|b/,:kv)
                            ok 9 - split(/a|b/,"",:p)
                            ok 10 - "".split(/a|b/,:p)
                            ok 11 - split(/a|b/,"",:skip-empty)
                            ok 12 - "".split(/a|b/,:skip-empty)
                            ok 13 - split(/a|b/,"",:v,:skip-empty)
                            ok 14 - "".split(/a|b/,:v,:skip-empty)
                            ok 15 - split(/a|b/,"",:k,:skip-empty)
                            ok 16 - "".split(/a|b/,:k,:skip-empty)
                            ok 17 - split(/a|b/,"",:kv,:skip-empty)
                            ok 18 - "".split(/a|b/,:kv,:skip-empty)
                            ok 19 - split(/a|b/,"",:p,:skip-empty)
                            ok 20 - "".split(/a|b/,:p,:skip-empty)
                            ok 21 - split(/a|b/,"",2)
                            ok 22 - "".split(/a|b/,2)
                            ok 23 - split(/a|b/,"",2,:v)
                            ok 24 - "".split(/a|b/,2,:v)
                            ok 25 - split(/a|b/,"",2,:k)
                            ok 26 - "".split(/a|b/,2,:k)
                            ok 27 - split(/a|b/,"",2,:kv)
                            ok 28 - "".split(/a|b/,2,:kv)
                            ok 29 - split(/a|b/,"",2,:p)
                            ok 30 - "".split(/a|b/,2,:p)
                            ok 31 - split(/a|b/,"",2,:split-empty)
                            ok 32 - "".split(/a|b/,2,:split-empty)
                            ok 33 - split(/a|b/,"",2,:v,:skip-empty)
                            ok 34 - "".split(/a|b/,2,:v,:skip-empty)
                            ok 35 - split(/a|b/,"",2,:k,:skip-empty)
                            ok 36 - "".split(/a|b/,2,:k,:skip-empty)
                            ok 37 - split(/a|b/,"",2,:kv,:skip-empty)
                            ok 38 - "".split(/a|b/,2,:kv,:skip-empty)
                            ok 39 - split(/a|b/,"",2,:p,:skip-empty)
                            ok 40 - "".split(/a|b/,2,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 216 - tested "" with /a|b/
                            1..41
                            ok 1 - split(/\s/,"")
                            ok 2 - "".split(/\s/)
                            ok 3 - split(/\s/,"",:v)
                            ok 4 - "".split(/\s/,:v)
                            ok 5 - split(/\s/,"",:k)
                            ok 6 - "".split(/\s/,:k)
                            ok 7 - split(/\s/,"",:kv)
                            ok 8 - "".split(/\s/,:kv)
                            ok 9 - split(/\s/,"",:p)
                            ok 10 - "".split(/\s/,:p)
                            ok 11 - split(/\s/,"",:skip-empty)
                            ok 12 - "".split(/\s/,:skip-empty)
                            ok 13 - split(/\s/,"",:v,:skip-empty)
                            ok 14 - "".split(/\s/,:v,:skip-empty)
                            ok 15 - split(/\s/,"",:k,:skip-empty)
                            ok 16 - "".split(/\s/,:k,:skip-empty)
                            ok 17 - split(/\s/,"",:kv,:skip-empty)
                            ok 18 - "".split(/\s/,:kv,:skip-empty)
                            ok 19 - split(/\s/,"",:p,:skip-empty)
                            ok 20 - "".split(/\s/,:p,:skip-empty)
                            ok 21 - split(/\s/,"",2)
                            ok 22 - "".split(/\s/,2)
                            ok 23 - split(/\s/,"",2,:v)
                            ok 24 - "".split(/\s/,2,:v)
                            ok 25 - split(/\s/,"",2,:k)
                            ok 26 - "".split(/\s/,2,:k)
                            ok 27 - split(/\s/,"",2,:kv)
                            ok 28 - "".split(/\s/,2,:kv)
                            ok 29 - split(/\s/,"",2,:p)
                            ok 30 - "".split(/\s/,2,:p)
                            ok 31 - split(/\s/,"",2,:split-empty)
                            ok 32 - "".split(/\s/,2,:split-empty)
                            ok 33 - split(/\s/,"",2,:v,:skip-empty)
                            ok 34 - "".split(/\s/,2,:v,:skip-empty)
                            ok 35 - split(/\s/,"",2,:k,:skip-empty)
                            ok 36 - "".split(/\s/,2,:k,:skip-empty)
                            ok 37 - split(/\s/,"",2,:kv,:skip-empty)
                            ok 38 - "".split(/\s/,2,:kv,:skip-empty)
                            ok 39 - split(/\s/,"",2,:p,:skip-empty)
                            ok 40 - "".split(/\s/,2,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 217 - tested "" with /\s/
                            1..41
                            ok 1 - split(rx:Perl5/\s/,"")
                            ok 2 - "".split(rx:Perl5/\s/)
                            ok 3 - split(rx:Perl5/\s/,"",:v)
                            ok 4 - "".split(rx:Perl5/\s/,:v)
                            ok 5 - split(rx:Perl5/\s/,"",:k)
                            ok 6 - "".split(rx:Perl5/\s/,:k)
                            ok 7 - split(rx:Perl5/\s/,"",:kv)
                            ok 8 - "".split(rx:Perl5/\s/,:kv)
                            ok 9 - split(rx:Perl5/\s/,"",:p)
                            ok 10 - "".split(rx:Perl5/\s/,:p)
                            ok 11 - split(rx:Perl5/\s/,"",:skip-empty)
                            ok 12 - "".split(rx:Perl5/\s/,:skip-empty)
                            ok 13 - split(rx:Perl5/\s/,"",:v,:skip-empty)
                            ok 14 - "".split(rx:Perl5/\s/,:v,:skip-empty)
                            ok 15 - split(rx:Perl5/\s/,"",:k,:skip-empty)
                            ok 16 - "".split(rx:Perl5/\s/,:k,:skip-empty)
                            ok 17 - split(rx:Perl5/\s/,"",:kv,:skip-empty)
                            ok 18 - "".split(rx:Perl5/\s/,:kv,:skip-empty)
                            ok 19 - split(rx:Perl5/\s/,"",:p,:skip-empty)
                            ok 20 - "".split(rx:Perl5/\s/,:p,:skip-empty)
                            ok 21 - split(rx:Perl5/\s/,"",2)
                            ok 22 - "".split(rx:Perl5/\s/,2)
                            ok 23 - split(rx:Perl5/\s/,"",2,:v)
                            ok 24 - "".split(rx:Perl5/\s/,2,:v)
                            ok 25 - split(rx:Perl5/\s/,"",2,:k)
                            ok 26 - "".split(rx:Perl5/\s/,2,:k)
                            ok 27 - split(rx:Perl5/\s/,"",2,:kv)
                            ok 28 - "".split(rx:Perl5/\s/,2,:kv)
                            ok 29 - split(rx:Perl5/\s/,"",2,:p)
                            ok 30 - "".split(rx:Perl5/\s/,2,:p)
                            ok 31 - split(rx:Perl5/\s/,"",2,:split-empty)
                            ok 32 - "".split(rx:Perl5/\s/,2,:split-empty)
                            ok 33 - split(rx:Perl5/\s/,"",2,:v,:skip-empty)
                            ok 34 - "".split(rx:Perl5/\s/,2,:v,:skip-empty)
                            ok 35 - split(rx:Perl5/\s/,"",2,:k,:skip-empty)
                            ok 36 - "".split(rx:Perl5/\s/,2,:k,:skip-empty)
                            ok 37 - split(rx:Perl5/\s/,"",2,:kv,:skip-empty)
                            ok 38 - "".split(rx:Perl5/\s/,2,:kv,:skip-empty)
                            ok 39 - split(rx:Perl5/\s/,"",2,:p,:skip-empty)
                            ok 40 - "".split(rx:Perl5/\s/,2,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 218 - tested "" with rx:Perl5/\s/
                            1..41
                            ok 1 - split("","")
                            ok 2 - "".split("")
                            ok 3 - split("","",:v)
                            ok 4 - "".split("",:v)
                            ok 5 - split("","",:k)
                            ok 6 - "".split("",:k)
                            ok 7 - split("","",:kv)
                            ok 8 - "".split("",:kv)
                            ok 9 - split("","",:p)
                            ok 10 - "".split("",:p)
                            ok 11 - split("","",:skip-empty)
                            ok 12 - "".split("",:skip-empty)
                            ok 13 - split("","",:v,:skip-empty)
                            ok 14 - "".split("",:v,:skip-empty)
                            ok 15 - split("","",:k,:skip-empty)
                            ok 16 - "".split("",:k,:skip-empty)
                            ok 17 - split("","",:kv,:skip-empty)
                            ok 18 - "".split("",:kv,:skip-empty)
                            ok 19 - split("","",:p,:skip-empty)
                            ok 20 - "".split("",:p,:skip-empty)
                            ok 21 - split("","",2)
                            ok 22 - "".split("",2)
                            ok 23 - split("","",2,:v)
                            ok 24 - "".split("",2,:v)
                            ok 25 - split("","",2,:k)
                            ok 26 - "".split("",2,:k)
                            ok 27 - split("","",2,:kv)
                            ok 28 - "".split("",2,:kv)
                            ok 29 - split("","",2,:p)
                            ok 30 - "".split("",2,:p)
                            ok 31 - split("","",2,:split-empty)
                            ok 32 - "".split("",2,:split-empty)
                            ok 33 - split("","",2,:v,:skip-empty)
                            ok 34 - "".split("",2,:v,:skip-empty)
                            ok 35 - split("","",2,:k,:skip-empty)
                            ok 36 - "".split("",2,:k,:skip-empty)
                            ok 37 - split("","",2,:kv,:skip-empty)
                            ok 38 - "".split("",2,:kv,:skip-empty)
                            ok 39 - split("","",2,:p,:skip-empty)
                            ok 40 - "".split("",2,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 219 - tested "" with "empty string"
                            1..41
                            ok 1 - split("foo","")
                            ok 2 - "".split("foo")
                            ok 3 - split("foo","",:v)
                            ok 4 - "".split("foo",:v)
                            ok 5 - split("foo","",:k)
                            ok 6 - "".split("foo",:k)
                            ok 7 - split("foo","",:kv)
                            ok 8 - "".split("foo",:kv)
                            ok 9 - split("foo","",:p)
                            ok 10 - "".split("foo",:p)
                            ok 11 - split("foo","",:skip-empty)
                            ok 12 - "".split("foo",:skip-empty)
                            ok 13 - split("foo","",:v,:skip-empty)
                            ok 14 - "".split("foo",:v,:skip-empty)
                            ok 15 - split("foo","",:k,:skip-empty)
                            ok 16 - "".split("foo",:k,:skip-empty)
                            ok 17 - split("foo","",:kv,:skip-empty)
                            ok 18 - "".split("foo",:kv,:skip-empty)
                            ok 19 - split("foo","",:p,:skip-empty)
                            ok 20 - "".split("foo",:p,:skip-empty)
                            ok 21 - split("foo","",2)
                            ok 22 - "".split("foo",2)
                            ok 23 - split("foo","",2,:v)
                            ok 24 - "".split("foo",2,:v)
                            ok 25 - split("foo","",2,:k)
                            ok 26 - "".split("foo",2,:k)
                            ok 27 - split("foo","",2,:kv)
                            ok 28 - "".split("foo",2,:kv)
                            ok 29 - split("foo","",2,:p)
                            ok 30 - "".split("foo",2,:p)
                            ok 31 - split("foo","",2,:split-empty)
                            ok 32 - "".split("foo",2,:split-empty)
                            ok 33 - split("foo","",2,:v,:skip-empty)
                            ok 34 - "".split("foo",2,:v,:skip-empty)
                            ok 35 - split("foo","",2,:k,:skip-empty)
                            ok 36 - "".split("foo",2,:k,:skip-empty)
                            ok 37 - split("foo","",2,:kv,:skip-empty)
                            ok 38 - "".split("foo",2,:kv,:skip-empty)
                            ok 39 - split("foo","",2,:p,:skip-empty)
                            ok 40 - "".split("foo",2,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 220 - tested "" with "empty string"
                            1..41
                            ok 1 - split("a","zzzzz")
                            ok 2 - "zzzzz".split("a")
                            ok 3 - split("a","zzzzz",:v)
                            ok 4 - "zzzzz".split("a",:v)
                            ok 5 - split("a","zzzzz",:k)
                            ok 6 - "zzzzz".split("a",:k)
                            ok 7 - split("a","zzzzz",:kv)
                            ok 8 - "zzzzz".split("a",:kv)
                            ok 9 - split("a","zzzzz",:p)
                            ok 10 - "zzzzz".split("a",:p)
                            ok 11 - split("a","zzzzz",:skip-empty)
                            ok 12 - "zzzzz".split("a",:skip-empty)
                            ok 13 - split("a","zzzzz",:v,:skip-empty)
                            ok 14 - "zzzzz".split("a",:v,:skip-empty)
                            ok 15 - split("a","zzzzz",:k,:skip-empty)
                            ok 16 - "zzzzz".split("a",:k,:skip-empty)
                            ok 17 - split("a","zzzzz",:kv,:skip-empty)
                            ok 18 - "zzzzz".split("a",:kv,:skip-empty)
                            ok 19 - split("a","zzzzz",:p,:skip-empty)
                            ok 20 - "zzzzz".split("a",:p,:skip-empty)
                            ok 21 - split("a","zzzzz",2)
                            ok 22 - "zzzzz".split("a",2)
                            ok 23 - split("a","zzzzz",2,:v)
                            ok 24 - "zzzzz".split("a",2,:v)
                            ok 25 - split("a","zzzzz",2,:k)
                            ok 26 - "zzzzz".split("a",2,:k)
                            ok 27 - split("a","zzzzz",2,:kv)
                            ok 28 - "zzzzz".split("a",2,:kv)
                            ok 29 - split("a","zzzzz",2,:p)
                            ok 30 - "zzzzz".split("a",2,:p)
                            ok 31 - split("a","zzzzz",2,:split-empty)
                            ok 32 - "zzzzz".split("a",2,:split-empty)
                            ok 33 - split("a","zzzzz",2,:v,:skip-empty)
                            ok 34 - "zzzzz".split("a",2,:v,:skip-empty)
                            ok 35 - split("a","zzzzz",2,:k,:skip-empty)
                            ok 36 - "zzzzz".split("a",2,:k,:skip-empty)
                            ok 37 - split("a","zzzzz",2,:kv,:skip-empty)
                            ok 38 - "zzzzz".split("a",2,:kv,:skip-empty)
                            ok 39 - split("a","zzzzz",2,:p,:skip-empty)
                            ok 40 - "zzzzz".split("a",2,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 221 - tested "zzzzz" with "no match"
                            1..41
                            ok 1 - split($("a", "e", "i", "o", "u"),"hello world")
                            ok 2 - "hello world".split($("a", "e", "i", "o", "u"))
                            ok 3 - split($("a", "e", "i", "o", "u"),"hello world",:v)
                            ok 4 - "hello world".split($("a", "e", "i", "o", "u"),:v)
                            ok 5 - split($("a", "e", "i", "o", "u"),"hello world",:k)
                            ok 6 - "hello world".split($("a", "e", "i", "o", "u"),:k)
                            ok 7 - split($("a", "e", "i", "o", "u"),"hello world",:kv)
                            ok 8 - "hello world".split($("a", "e", "i", "o", "u"),:kv)
                            ok 9 - split($("a", "e", "i", "o", "u"),"hello world",:p)
                            ok 10 - "hello world".split($("a", "e", "i", "o", "u"),:p)
                            ok 11 - split($("a", "e", "i", "o", "u"),"hello world",:skip-empty)
                            ok 12 - "hello world".split($("a", "e", "i", "o", "u"),:skip-empty)
                            ok 13 - split($("a", "e", "i", "o", "u"),"hello world",:v,:skip-empty)
                            ok 14 - "hello world".split($("a", "e", "i", "o", "u"),:v,:skip-empty)
                            ok 15 - split($("a", "e", "i", "o", "u"),"hello world",:k,:skip-empty)
                            ok 16 - "hello world".split($("a", "e", "i", "o", "u"),:k,:skip-empty)
                            ok 17 - split($("a", "e", "i", "o", "u"),"hello world",:kv,:skip-empty)
                            ok 18 - "hello world".split($("a", "e", "i", "o", "u"),:kv,:skip-empty)
                            ok 19 - split($("a", "e", "i", "o", "u"),"hello world",:p,:skip-empty)
                            ok 20 - "hello world".split($("a", "e", "i", "o", "u"),:p,:skip-empty)
                            ok 21 - split($("a", "e", "i", "o", "u"),"hello world",3)
                            ok 22 - "hello world".split($("a", "e", "i", "o", "u"),3)
                            ok 23 - split($("a", "e", "i", "o", "u"),"hello world",3,:v)
                            ok 24 - "hello world".split($("a", "e", "i", "o", "u"),3,:v)
                            ok 25 - split($("a", "e", "i", "o", "u"),"hello world",3,:k)
                            ok 26 - "hello world".split($("a", "e", "i", "o", "u"),3,:k)
                            ok 27 - split($("a", "e", "i", "o", "u"),"hello world",3,:kv)
                            ok 28 - "hello world".split($("a", "e", "i", "o", "u"),3,:kv)
                            ok 29 - split($("a", "e", "i", "o", "u"),"hello world",3,:p)
                            ok 30 - "hello world".split($("a", "e", "i", "o", "u"),3,:p)
                            ok 31 - split($("a", "e", "i", "o", "u"),"hello world",3,:split-empty)
                            ok 32 - "hello world".split($("a", "e", "i", "o", "u"),3,:split-empty)
                            ok 33 - split($("a", "e", "i", "o", "u"),"hello world",3,:v,:skip-empty)
                            ok 34 - "hello world".split($("a", "e", "i", "o", "u"),3,:v,:skip-empty)
                            ok 35 - split($("a", "e", "i", "o", "u"),"hello world",3,:k,:skip-empty)
                            ok 36 - "hello world".split($("a", "e", "i", "o", "u"),3,:k,:skip-empty)
                            ok 37 - split($("a", "e", "i", "o", "u"),"hello world",3,:kv,:skip-empty)
                            ok 38 - "hello world".split($("a", "e", "i", "o", "u"),3,:kv,:skip-empty)
                            ok 39 - split($("a", "e", "i", "o", "u"),"hello world",3,:p,:skip-empty)
                            ok 40 - "hello world".split($("a", "e", "i", "o", "u"),3,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 222 - tested "hello world" with $("a", "e", "i", "o", "u")
                            1..41
                            ok 1 - split(/<[aeiou]>/,"hello world")
                            ok 2 - "hello world".split(/<[aeiou]>/)
                            ok 3 - split(/<[aeiou]>/,"hello world",:v)
                            ok 4 - "hello world".split(/<[aeiou]>/,:v)
                            ok 5 - split(/<[aeiou]>/,"hello world",:k)
                            ok 6 - "hello world".split(/<[aeiou]>/,:k)
                            ok 7 - split(/<[aeiou]>/,"hello world",:kv)
                            ok 8 - "hello world".split(/<[aeiou]>/,:kv)
                            ok 9 - split(/<[aeiou]>/,"hello world",:p)
                            ok 10 - "hello world".split(/<[aeiou]>/,:p)
                            ok 11 - split(/<[aeiou]>/,"hello world",:skip-empty)
                            ok 12 - "hello world".split(/<[aeiou]>/,:skip-empty)
                            ok 13 - split(/<[aeiou]>/,"hello world",:v,:skip-empty)
                            ok 14 - "hello world".split(/<[aeiou]>/,:v,:skip-empty)
                            ok 15 - split(/<[aeiou]>/,"hello world",:k,:skip-empty)
                            ok 16 - "hello world".split(/<[aeiou]>/,:k,:skip-empty)
                            ok 17 - split(/<[aeiou]>/,"hello world",:kv,:skip-empty)
                            ok 18 - "hello world".split(/<[aeiou]>/,:kv,:skip-empty)
                            ok 19 - split(/<[aeiou]>/,"hello world",:p,:skip-empty)
                            ok 20 - "hello world".split(/<[aeiou]>/,:p,:skip-empty)
                            ok 21 - split(/<[aeiou]>/,"hello world",3)
                            ok 22 - "hello world".split(/<[aeiou]>/,3)
                            ok 23 - split(/<[aeiou]>/,"hello world",3,:v)
                            ok 24 - "hello world".split(/<[aeiou]>/,3,:v)
                            ok 25 - split(/<[aeiou]>/,"hello world",3,:k)
                            ok 26 - "hello world".split(/<[aeiou]>/,3,:k)
                            ok 27 - split(/<[aeiou]>/,"hello world",3,:kv)
                            ok 28 - "hello world".split(/<[aeiou]>/,3,:kv)
                            ok 29 - split(/<[aeiou]>/,"hello world",3,:p)
                            ok 30 - "hello world".split(/<[aeiou]>/,3,:p)
                            ok 31 - split(/<[aeiou]>/,"hello world",3,:split-empty)
                            ok 32 - "hello world".split(/<[aeiou]>/,3,:split-empty)
                            ok 33 - split(/<[aeiou]>/,"hello world",3,:v,:skip-empty)
                            ok 34 - "hello world".split(/<[aeiou]>/,3,:v,:skip-empty)
                            ok 35 - split(/<[aeiou]>/,"hello world",3,:k,:skip-empty)
                            ok 36 - "hello world".split(/<[aeiou]>/,3,:k,:skip-empty)
                            ok 37 - split(/<[aeiou]>/,"hello world",3,:kv,:skip-empty)
                            ok 38 - "hello world".split(/<[aeiou]>/,3,:kv,:skip-empty)
                            ok 39 - split(/<[aeiou]>/,"hello world",3,:p,:skip-empty)
                            ok 40 - "hello world".split(/<[aeiou]>/,3,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 223 - tested "hello world" with /<[aeiou]>/
                            1..41
                            ok 1 - split(rx:Perl5/[aeiou]/,"hello world")
                            ok 2 - "hello world".split(rx:Perl5/[aeiou]/)
                            ok 3 - split(rx:Perl5/[aeiou]/,"hello world",:v)
                            ok 4 - "hello world".split(rx:Perl5/[aeiou]/,:v)
                            ok 5 - split(rx:Perl5/[aeiou]/,"hello world",:k)
                            ok 6 - "hello world".split(rx:Perl5/[aeiou]/,:k)
                            ok 7 - split(rx:Perl5/[aeiou]/,"hello world",:kv)
                            ok 8 - "hello world".split(rx:Perl5/[aeiou]/,:kv)
                            ok 9 - split(rx:Perl5/[aeiou]/,"hello world",:p)
                            ok 10 - "hello world".split(rx:Perl5/[aeiou]/,:p)
                            ok 11 - split(rx:Perl5/[aeiou]/,"hello world",:skip-empty)
                            ok 12 - "hello world".split(rx:Perl5/[aeiou]/,:skip-empty)
                            ok 13 - split(rx:Perl5/[aeiou]/,"hello world",:v,:skip-empty)
                            ok 14 - "hello world".split(rx:Perl5/[aeiou]/,:v,:skip-empty)
                            ok 15 - split(rx:Perl5/[aeiou]/,"hello world",:k,:skip-empty)
                            ok 16 - "hello world".split(rx:Perl5/[aeiou]/,:k,:skip-empty)
                            ok 17 - split(rx:Perl5/[aeiou]/,"hello world",:kv,:skip-empty)
                            ok 18 - "hello world".split(rx:Perl5/[aeiou]/,:kv,:skip-empty)
                            ok 19 - split(rx:Perl5/[aeiou]/,"hello world",:p,:skip-empty)
                            ok 20 - "hello world".split(rx:Perl5/[aeiou]/,:p,:skip-empty)
                            ok 21 - split(rx:Perl5/[aeiou]/,"hello world",3)
                            ok 22 - "hello world".split(rx:Perl5/[aeiou]/,3)
                            ok 23 - split(rx:Perl5/[aeiou]/,"hello world",3,:v)
                            ok 24 - "hello world".split(rx:Perl5/[aeiou]/,3,:v)
                            ok 25 - split(rx:Perl5/[aeiou]/,"hello world",3,:k)
                            ok 26 - "hello world".split(rx:Perl5/[aeiou]/,3,:k)
                            ok 27 - split(rx:Perl5/[aeiou]/,"hello world",3,:kv)
                            ok 28 - "hello world".split(rx:Perl5/[aeiou]/,3,:kv)
                            ok 29 - split(rx:Perl5/[aeiou]/,"hello world",3,:p)
                            ok 30 - "hello world".split(rx:Perl5/[aeiou]/,3,:p)
                            ok 31 - split(rx:Perl5/[aeiou]/,"hello world",3,:split-empty)
                            ok 32 - "hello world".split(rx:Perl5/[aeiou]/,3,:split-empty)
                            ok 33 - split(rx:Perl5/[aeiou]/,"hello world",3,:v,:skip-empty)
                            ok 34 - "hello world".split(rx:Perl5/[aeiou]/,3,:v,:skip-empty)
                            ok 35 - split(rx:Perl5/[aeiou]/,"hello world",3,:k,:skip-empty)
                            ok 36 - "hello world".split(rx:Perl5/[aeiou]/,3,:k,:skip-empty)
                            ok 37 - split(rx:Perl5/[aeiou]/,"hello world",3,:kv,:skip-empty)
                            ok 38 - "hello world".split(rx:Perl5/[aeiou]/,3,:kv,:skip-empty)
                            ok 39 - split(rx:Perl5/[aeiou]/,"hello world",3,:p,:skip-empty)
                            ok 40 - "hello world".split(rx:Perl5/[aeiou]/,3,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 224 - tested "hello world" with rx:Perl5/[aeiou]/
                        ok 225 - split:v resulted in seven pieces
                        ok 226 - second is a Match object
                        ok 227 - fourth is a Match object
                        ok 228 - sixth is a Match object
                        ok 229 - split:v resulted in seven pieces
                        ok 230 - First capture worked
                        ok 231 - Second capture worked
                        ok 232 - Third capture worked
                        ok 233 - Fourth capture worked
                            1..41
                            ok 1 - split(/<.ws>/,"hello-world")
                            ok 2 - "hello-world".split(/<.ws>/)
                            ok 3 - split(/<.ws>/,"hello-world",:v)
                            ok 4 - "hello-world".split(/<.ws>/,:v)
                            ok 5 - split(/<.ws>/,"hello-world",:k)
                            ok 6 - "hello-world".split(/<.ws>/,:k)
                            ok 7 - split(/<.ws>/,"hello-world",:kv)
                            ok 8 - "hello-world".split(/<.ws>/,:kv)
                            ok 9 - split(/<.ws>/,"hello-world",:p)
                            ok 10 - "hello-world".split(/<.ws>/,:p)
                            ok 11 - split(/<.ws>/,"hello-world",:skip-empty)
                            ok 12 - "hello-world".split(/<.ws>/,:skip-empty)
                            ok 13 - split(/<.ws>/,"hello-world",:v,:skip-empty)
                            ok 14 - "hello-world".split(/<.ws>/,:v,:skip-empty)
                            ok 15 - split(/<.ws>/,"hello-world",:k,:skip-empty)
                            ok 16 - "hello-world".split(/<.ws>/,:k,:skip-empty)
                            ok 17 - split(/<.ws>/,"hello-world",:kv,:skip-empty)
                            ok 18 - "hello-world".split(/<.ws>/,:kv,:skip-empty)
                            ok 19 - split(/<.ws>/,"hello-world",:p,:skip-empty)
                            ok 20 - "hello-world".split(/<.ws>/,:p,:skip-empty)
                            ok 21 - split(/<.ws>/,"hello-world",3)
                            ok 22 - "hello-world".split(/<.ws>/,3)
                            ok 23 - split(/<.ws>/,"hello-world",3,:v)
                            ok 24 - "hello-world".split(/<.ws>/,3,:v)
                            ok 25 - split(/<.ws>/,"hello-world",3,:k)
                            ok 26 - "hello-world".split(/<.ws>/,3,:k)
                            ok 27 - split(/<.ws>/,"hello-world",3,:kv)
                            ok 28 - "hello-world".split(/<.ws>/,3,:kv)
                            ok 29 - split(/<.ws>/,"hello-world",3,:p)
                            ok 30 - "hello-world".split(/<.ws>/,3,:p)
                            ok 31 - split(/<.ws>/,"hello-world",3,:split-empty)
                            ok 32 - "hello-world".split(/<.ws>/,3,:split-empty)
                            ok 33 - split(/<.ws>/,"hello-world",3,:v,:skip-empty)
                            ok 34 - "hello-world".split(/<.ws>/,3,:v,:skip-empty)
                            ok 35 - split(/<.ws>/,"hello-world",3,:k,:skip-empty)
                            ok 36 - "hello-world".split(/<.ws>/,3,:k,:skip-empty)
                            ok 37 - split(/<.ws>/,"hello-world",3,:kv,:skip-empty)
                            ok 38 - "hello-world".split(/<.ws>/,3,:kv,:skip-empty)
                            ok 39 - split(/<.ws>/,"hello-world",3,:p,:skip-empty)
                            ok 40 - "hello-world".split(/<.ws>/,3,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 234 - tested "hello-world" with /<.ws>/
                            1..41
                            ok 1 - split(/<.wb>/,"hello-world")
                            ok 2 - "hello-world".split(/<.wb>/)
                            ok 3 - split(/<.wb>/,"hello-world",:v)
                            ok 4 - "hello-world".split(/<.wb>/,:v)
                            ok 5 - split(/<.wb>/,"hello-world",:k)
                            ok 6 - "hello-world".split(/<.wb>/,:k)
                            ok 7 - split(/<.wb>/,"hello-world",:kv)
                            ok 8 - "hello-world".split(/<.wb>/,:kv)
                            ok 9 - split(/<.wb>/,"hello-world",:p)
                            ok 10 - "hello-world".split(/<.wb>/,:p)
                            ok 11 - split(/<.wb>/,"hello-world",:skip-empty)
                            ok 12 - "hello-world".split(/<.wb>/,:skip-empty)
                            ok 13 - split(/<.wb>/,"hello-world",:v,:skip-empty)
                            ok 14 - "hello-world".split(/<.wb>/,:v,:skip-empty)
                            ok 15 - split(/<.wb>/,"hello-world",:k,:skip-empty)
                            ok 16 - "hello-world".split(/<.wb>/,:k,:skip-empty)
                            ok 17 - split(/<.wb>/,"hello-world",:kv,:skip-empty)
                            ok 18 - "hello-world".split(/<.wb>/,:kv,:skip-empty)
                            ok 19 - split(/<.wb>/,"hello-world",:p,:skip-empty)
                            ok 20 - "hello-world".split(/<.wb>/,:p,:skip-empty)
                            ok 21 - split(/<.wb>/,"hello-world",3)
                            ok 22 - "hello-world".split(/<.wb>/,3)
                            ok 23 - split(/<.wb>/,"hello-world",3,:v)
                            ok 24 - "hello-world".split(/<.wb>/,3,:v)
                            ok 25 - split(/<.wb>/,"hello-world",3,:k)
                            ok 26 - "hello-world".split(/<.wb>/,3,:k)
                            ok 27 - split(/<.wb>/,"hello-world",3,:kv)
                            ok 28 - "hello-world".split(/<.wb>/,3,:kv)
                            ok 29 - split(/<.wb>/,"hello-world",3,:p)
                            ok 30 - "hello-world".split(/<.wb>/,3,:p)
                            ok 31 - split(/<.wb>/,"hello-world",3,:split-empty)
                            ok 32 - "hello-world".split(/<.wb>/,3,:split-empty)
                            ok 33 - split(/<.wb>/,"hello-world",3,:v,:skip-empty)
                            ok 34 - "hello-world".split(/<.wb>/,3,:v,:skip-empty)
                            ok 35 - split(/<.wb>/,"hello-world",3,:k,:skip-empty)
                            ok 36 - "hello-world".split(/<.wb>/,3,:k,:skip-empty)
                            ok 37 - split(/<.wb>/,"hello-world",3,:kv,:skip-empty)
                            ok 38 - "hello-world".split(/<.wb>/,3,:kv,:skip-empty)
                            ok 39 - split(/<.wb>/,"hello-world",3,:p,:skip-empty)
                            ok 40 - "hello-world".split(/<.wb>/,3,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 235 - tested "hello-world" with /<.wb>/
                            1..41
                            ok 1 - split(/<.ws>/,"-a-b-c-")
                            ok 2 - "-a-b-c-".split(/<.ws>/)
                            ok 3 - split(/<.ws>/,"-a-b-c-",:v)
                            ok 4 - "-a-b-c-".split(/<.ws>/,:v)
                            ok 5 - split(/<.ws>/,"-a-b-c-",:k)
                            ok 6 - "-a-b-c-".split(/<.ws>/,:k)
                            ok 7 - split(/<.ws>/,"-a-b-c-",:kv)
                            ok 8 - "-a-b-c-".split(/<.ws>/,:kv)
                            ok 9 - split(/<.ws>/,"-a-b-c-",:p)
                            ok 10 - "-a-b-c-".split(/<.ws>/,:p)
                            ok 11 - split(/<.ws>/,"-a-b-c-",:skip-empty)
                            ok 12 - "-a-b-c-".split(/<.ws>/,:skip-empty)
                            ok 13 - split(/<.ws>/,"-a-b-c-",:v,:skip-empty)
                            ok 14 - "-a-b-c-".split(/<.ws>/,:v,:skip-empty)
                            ok 15 - split(/<.ws>/,"-a-b-c-",:k,:skip-empty)
                            ok 16 - "-a-b-c-".split(/<.ws>/,:k,:skip-empty)
                            ok 17 - split(/<.ws>/,"-a-b-c-",:kv,:skip-empty)
                            ok 18 - "-a-b-c-".split(/<.ws>/,:kv,:skip-empty)
                            ok 19 - split(/<.ws>/,"-a-b-c-",:p,:skip-empty)
                            ok 20 - "-a-b-c-".split(/<.ws>/,:p,:skip-empty)
                            ok 21 - split(/<.ws>/,"-a-b-c-",4)
                            ok 22 - "-a-b-c-".split(/<.ws>/,4)
                            ok 23 - split(/<.ws>/,"-a-b-c-",4,:v)
                            ok 24 - "-a-b-c-".split(/<.ws>/,4,:v)
                            ok 25 - split(/<.ws>/,"-a-b-c-",4,:k)
                            ok 26 - "-a-b-c-".split(/<.ws>/,4,:k)
                            ok 27 - split(/<.ws>/,"-a-b-c-",4,:kv)
                            ok 28 - "-a-b-c-".split(/<.ws>/,4,:kv)
                            ok 29 - split(/<.ws>/,"-a-b-c-",4,:p)
                            ok 30 - "-a-b-c-".split(/<.ws>/,4,:p)
                            ok 31 - split(/<.ws>/,"-a-b-c-",4,:split-empty)
                            ok 32 - "-a-b-c-".split(/<.ws>/,4,:split-empty)
                            ok 33 - split(/<.ws>/,"-a-b-c-",4,:v,:skip-empty)
                            ok 34 - "-a-b-c-".split(/<.ws>/,4,:v,:skip-empty)
                            ok 35 - split(/<.ws>/,"-a-b-c-",4,:k,:skip-empty)
                            ok 36 - "-a-b-c-".split(/<.ws>/,4,:k,:skip-empty)
                            ok 37 - split(/<.ws>/,"-a-b-c-",4,:kv,:skip-empty)
                            ok 38 - "-a-b-c-".split(/<.ws>/,4,:kv,:skip-empty)
                            ok 39 - split(/<.ws>/,"-a-b-c-",4,:p,:skip-empty)
                            ok 40 - "-a-b-c-".split(/<.ws>/,4,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 236 - tested "-a-b-c-" with /<.ws>/
                            1..41
                            ok 1 - split(/<.wb>/,"-a-b-c-")
                            ok 2 - "-a-b-c-".split(/<.wb>/)
                            ok 3 - split(/<.wb>/,"-a-b-c-",:v)
                            ok 4 - "-a-b-c-".split(/<.wb>/,:v)
                            ok 5 - split(/<.wb>/,"-a-b-c-",:k)
                            ok 6 - "-a-b-c-".split(/<.wb>/,:k)
                            ok 7 - split(/<.wb>/,"-a-b-c-",:kv)
                            ok 8 - "-a-b-c-".split(/<.wb>/,:kv)
                            ok 9 - split(/<.wb>/,"-a-b-c-",:p)
                            ok 10 - "-a-b-c-".split(/<.wb>/,:p)
                            ok 11 - split(/<.wb>/,"-a-b-c-",:skip-empty)
                            ok 12 - "-a-b-c-".split(/<.wb>/,:skip-empty)
                            ok 13 - split(/<.wb>/,"-a-b-c-",:v,:skip-empty)
                            ok 14 - "-a-b-c-".split(/<.wb>/,:v,:skip-empty)
                            ok 15 - split(/<.wb>/,"-a-b-c-",:k,:skip-empty)
                            ok 16 - "-a-b-c-".split(/<.wb>/,:k,:skip-empty)
                            ok 17 - split(/<.wb>/,"-a-b-c-",:kv,:skip-empty)
                            ok 18 - "-a-b-c-".split(/<.wb>/,:kv,:skip-empty)
                            ok 19 - split(/<.wb>/,"-a-b-c-",:p,:skip-empty)
                            ok 20 - "-a-b-c-".split(/<.wb>/,:p,:skip-empty)
                            ok 21 - split(/<.wb>/,"-a-b-c-",4)
                            ok 22 - "-a-b-c-".split(/<.wb>/,4)
                            ok 23 - split(/<.wb>/,"-a-b-c-",4,:v)
                            ok 24 - "-a-b-c-".split(/<.wb>/,4,:v)
                            ok 25 - split(/<.wb>/,"-a-b-c-",4,:k)
                            ok 26 - "-a-b-c-".split(/<.wb>/,4,:k)
                            ok 27 - split(/<.wb>/,"-a-b-c-",4,:kv)
                            ok 28 - "-a-b-c-".split(/<.wb>/,4,:kv)
                            ok 29 - split(/<.wb>/,"-a-b-c-",4,:p)
                            ok 30 - "-a-b-c-".split(/<.wb>/,4,:p)
                            ok 31 - split(/<.wb>/,"-a-b-c-",4,:split-empty)
                            ok 32 - "-a-b-c-".split(/<.wb>/,4,:split-empty)
                            ok 33 - split(/<.wb>/,"-a-b-c-",4,:v,:skip-empty)
                            ok 34 - "-a-b-c-".split(/<.wb>/,4,:v,:skip-empty)
                            ok 35 - split(/<.wb>/,"-a-b-c-",4,:k,:skip-empty)
                            ok 36 - "-a-b-c-".split(/<.wb>/,4,:k,:skip-empty)
                            ok 37 - split(/<.wb>/,"-a-b-c-",4,:kv,:skip-empty)
                            ok 38 - "-a-b-c-".split(/<.wb>/,4,:kv,:skip-empty)
                            ok 39 - split(/<.wb>/,"-a-b-c-",4,:p,:skip-empty)
                            ok 40 - "-a-b-c-".split(/<.wb>/,4,:p,:skip-empty)
                            ok 41 - string did not get changed
                        ok 237 - tested "-a-b-c-" with /<.wb>/
                        ok 238 - Str.split() disallowed
                        ok 239 - "a.b".split(/\./)
                        ok 240 - # SKIP No such method null for invocant of type Cursor RT  \#124685
Could not find symbol '&Adverb' in 'X'
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-str/split.rakudo line 499
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-str/split.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

                        1..25
                        ok 241 - $*TZ is defined
                        ok 242 - DateTime.now uses $*TZ
                        ok 243 - DateTime.local uses $*TZ
                        ok 244 - UTC -> local -> UTC (2003-08-01T02:22:00Z)
                        ok 245 - UTC -> local -> UTC (1984-02-29T05:55:22Z)
                        ok 246 - UTC -> local -> UTC (1998-12-31T23:59:60Z)
                        not ok 247 - DateTime.in-timezone($*TZ) (from UTC, outside of DST) # TODO 
                        # Failed test 'DateTime.in-timezone($*TZ) (from UTC, outside of DST)'
                        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-temporal/local.rakudo line 43
                        # expected: '2007-01-01T21:22:00-05:00'
                        #      got: '2007-01-01T22:22:00-04:00'
                        not ok 248 - DateTime.local (from UTC, outside of DST) # TODO 
                        # Failed test 'DateTime.local (from UTC, outside of DST)'
                        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-temporal/local.rakudo line 48
                        # expected: '2007-01-01T21:22:00-05:00'
                        #      got: '2007-01-01T22:22:00-04:00'
                        ok 249 - DateTime.local (from UTC, during DST)
                        not ok 250 - DateTime.local (from UTC, just before DST begins) # TODO 
                        # Failed test 'DateTime.local (from UTC, just before DST begins)'
                        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-temporal/local.rakudo line 54
                        # expected: '1984-04-29T01:55:00-05:00'
                        #      got: '1984-04-29T02:55:00-04:00'
                        ok 251 - DateTime.local (from UTC, just after DST begins)
                        ok 252 - DateTime.local (from UTC, just before DST ends)
                        ok 253 - DateTime.local (from UTC, just before DST ends, .raku)
                        not ok 254 - DateTime.local (from UTC, just after DST ends) # TODO 
                        # Failed test 'DateTime.local (from UTC, just after DST ends)'
                        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-temporal/local.rakudo line 63
                        # expected: '2008-11-02T01:55:00-05:00'
                        #      got: '2008-11-02T02:55:00-04:00'
                        not ok 255 - DateTime.local (from UTC, just after DST ends, .raku) # TODO 
                        # Failed test 'DateTime.local (from UTC, just after DST ends, .raku)'
                        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-temporal/local.rakudo line 66
                        # expected: '2008-11-02T01:55:00-05:00'
                        #      got: '2008-11-02T02:55:00-04:00'
                        ok 256 - DateTime.local (from +0303, just before DST ends)
                        not ok 257 - DateTime.local (from -1612, just after DST ends) # TODO 
                        # Failed test 'DateTime.local (from -1612, just after DST ends)'
                        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-temporal/local.rakudo line 72
                        # expected: '2008-11-02T01:55:00-05:00'
                        #      got: '2008-11-02T02:55:00-04:00'
                        not ok 258 - DateTime.utc (from local, outside of DST) # TODO 
                        # Failed test 'DateTime.utc (from local, outside of DST)'
                        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-temporal/local.rakudo line 79
                        # expected: '1995-01-02T02:22:00Z'
                        #      got: '1995-01-02T01:22:00Z'
                        ok 259 - DateTime.utc (from local, during DST)
                        not ok 260 - DateTime.utc (from local, just before DST starts) # TODO 
                        # Failed test 'DateTime.utc (from local, just before DST starts)'
                        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-temporal/local.rakudo line 85
                        # expected: '2007-03-11T06:55:00Z'
                        #      got: '2007-03-11T05:55:00Z'
                        ok 261 - DateTime.in-timezone (local to -1612, just after DST starts)
                        ok 262 - DateTime.utc (from local, ambiguous)
                        ok 263 - DateTime.utc (from local, with leap second)
                        ok 264 - Local time zone rejects bogus leap second
                        not ok 265 - DateTime.local (from UTC, with leap second) # TODO 
                        # Failed test 'DateTime.local (from UTC, with leap second)'
                        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/S32-temporal/local.rakudo line 99
                        # expected: '1998-12-31T18:59:60-05:00'
                        #      got: '1998-12-31T19:59:60-04:00'
# FUDGED!
                        1..4
Error while constructing error object:Could not locate compile-time value for symbol Comp::FailGoal
                        not ok 266 -  # TODO feed fails to parse
                        # Failed test at /Users/tobiuo/class/seminar/Abyss-Server/roast/integration/advent2010-day10.rakudo line 16
                        # Error while compiling, type X::Comp::FailGoal
                        #   goal: '>'
                        #   dba: quote words
                        #   line-real: 1
                        #  at line 2, near ""
                        not ok 267 - left feed # TODO feed fails to parse
                        # Failed test 'left feed'
                        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/integration/advent2010-day10.rakudo line 17
                        # expected: '1 9 25 49 81 121 169 225 289 361 441 529 625 729 841 961 1089 1225 1369 1521 1681 1849 2025 2209 2401 2601 2809 3025 3249 3481 3721 3969 4225 4489 4761 5041 5329 5625 5929 6241 6561 6889 7225 7569 7921 8281 8649 9025 9409 9801'
                        #      got: ''
                        ok 268 - left feed
                        ok 269 - right feed
# FUDGED!
                        1..8
                        ok 270 - fibonacci
                        ok 271 - largest prime factor
                        not ok 272 - Pascal's triangle # TODO failing during 2015.09 release...
                        # Failed test 'Pascal's triangle'
                        # at /Users/tobiuo/class/seminar/Abyss-Server/roast/integration/advent2012-day04.rakudo line 22
                        # expected: 4075
                        #      got: 0
                        ok 273 - Pythagorean triplet products (gathered)
                        ok 274 - Pythagorean triplet products (dataflow)
                        ok 275 - consecutive prime factors
                        ok 276 - distinct term count
                        ok 277 - distinct term count - optimized
# FUDGED!
                        1..7
                        ok 278 - do we have right number of elements
                        ok 279 - did we get the right string
                        ok 280 - # SKIP sometimes hangs, sometimes segfaults
                        ok 281 - do we have right number of elements
                        ok 282 - did we get the right string
                        ok 283 - do we have right number of elements
                        ok 284 - did we get the right string
# FUDGED!
                        1..10
                        ok 285 - Test class inherited from the same role caused infinite loop bug
                        ok 286 - did we see the Int private attribute from the role
                        ok 287 - did we update the Int private attribute from the role
                        ok 288 - # SKIP alas, no visibility of native private attributes yet
                        ok 289 - # SKIP alas, no visibility of native private attributes yet
                        ok 290 - did we see the Int private attribute from the embedded role
                        ok 291 - did we update the Int private attribute from the embedded role
                        ok 292 - # SKIP alas, no visibility of private attributes in other role
                        ok 293 - # SKIP alas, no visibility of private attributes in other role
Could not find symbol '&Undeclared' in 'X::Attribute'
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/integration/role-composition-vs-attribute.rakudo line 78
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/integration/role-composition-vs-attribute.rakudo line 1
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 20
  in block <unit> at other/startup.p6 line 7

                        1..35
Use of Nil in string context
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/roast/packages/Test-Helpers/lib/Test/Util.pm6 (Test::Util) line 233
No such method 'queue' for invocant of type 'CurrentThreadScheduler'
  in sub get_out at /Users/tobiuo/class/seminar/Abyss-Server/roast/packages/Test-Helpers/lib/Test/Util.pm6 (Test::Util) line 229
  in sub is_run at /Users/tobiuo/class/seminar/Abyss-Server/roast/packages/Test-Helpers/lib/Test/Util.pm6 (Test::Util) line 135
  in sub is_run at /Users/tobiuo/class/seminar/Abyss-Server/roast/packages/Test-Helpers/lib/Test/Util.pm6 (Test::Util) line 129
  in block <unit> at /Users/tobiuo/class/seminar/Abyss-Server/roast/integration/weird-errors.rakudo line 10
  in sub EVALASMOD at /Users/tobiuo/class/seminar/Abyss-Server2/lib/Abyss/EvalAsMod.pm6 (Abyss::EvalAsMod) line 6
  in block  at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 27
  in method readeval at /Users/tobiuo/class/seminar/Abyss-Server/lib/Abyss/Server.pm6 (Abyss::Server) line 17
  in block <unit> at other/startup.p6 line 7

